<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2025-07-24T09:39:36.400Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rabbit-mq初探</title>
    <link href="https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2025/07/21/rabbit-mq%E5%88%9D%E6%8E%A2/</id>
    <published>2025-07-21T12:36:01.000Z</published>
    <updated>2025-07-24T09:39:36.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB.<br><span id="more"></span></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><img data-src="https://s2.loli.net/2025/07/23/aSBLvYT564eHXyq.png" alt="image-20250723102231391"></p><p>消息队列:<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础</p><p>为什么使用消息队列?异步、解耦、削峰</p><p>引入消息队列带来的问题: 消息顺序消息  重复消费消息  分布式事务问题等</p><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p><p><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</p><p><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</p><p><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</p><p><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</p><p><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</p><p><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</p><p><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</p><p><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装Erlang和Rabbit-mq,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat status</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq-management</span><br></pre></td></tr></table></figure><p>然后访问15672端口可视化管理.</p><h2 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h2><p>RabbitMQ 提供了三种主要的队列类型，它们在数据存储、性能、特性和使用场景上有所不同：</p><h3 id="经典队列"><a href="#经典队列" class="headerlink" title="经典队列"></a>经典队列</h3><ul><li><strong>默认和最常见：</strong> 这是 RabbitMQ 最早支持的队列类型，也是如果你不显式指定队列类型时创建的默认类型。</li><li><strong>灵活的持久性：</strong> 可以配置为<strong>持久化 (durable)</strong> 或<strong>非持久化 (transient)</strong>。<ul><li><strong>持久化队列：</strong> 队列的元数据（队列名称、配置等）和消息都会被写入磁盘。即使 RabbitMQ 服务重启，队列及其消息也不会丢失。</li><li><strong>非持久化队列：</strong> 队列的元数据和消息只存在于内存中。RabbitMQ 服务重启后，队列及其消息会丢失。</li></ul></li><li><strong>支持镜像 (Mirrored Queues)：</strong> 经典队列可以通过配置<strong>镜像模式</strong>来提高可用性。这意味着队列的主副本存在于一个节点，同时在其他节点上也有同步的副本。当主节点故障时，一个镜像副本可以被提升为新的主副本。<ul><li><strong>优点：</strong> 提高了高可用性。</li><li><strong>缺点：</strong> 镜像队列在写入时需要进行同步复制，这会增加网络开销和延迟，影响吞吐量。消费者从主副本消费，如果主副本故障，需要选举新的主副本。</li></ul></li><li><strong>性能：</strong> 在单节点或非镜像模式下性能较高，但在高可用（镜像）模式下，由于同步复制开销，吞吐量可能会下降。</li><li><strong>内部实现：</strong> 消息通常存储在内存中，并根据需要（如持久化消息或内存不足时）溢出到磁盘。</li></ul><p><strong>使用场景：</strong></p><ul><li>大多数通用消息传递场景。</li><li>对消息持久性和可靠性有要求，但对吞吐量要求不是极致的场景（特别是在镜像模式下）。</li><li>需要简单高可用的应用。</li></ul><h3 id="仲裁队列-Quorum-Queue"><a href="#仲裁队列-Quorum-Queue" class="headerlink" title="仲裁队列(Quorum Queue)"></a>仲裁队列(Quorum Queue)</h3><p><strong>特点：</strong></p><ul><li><strong>Raft 共识算法：</strong> 仲裁队列是 RabbitMQ 3.8 版本引入的新队列类型，它基于 <strong>Raft 一致性算法</strong>实现。Raft 算法确保了分布式系统中的强一致性，比经典队列的镜像机制更健壮。</li><li><strong>自动高可用：</strong> 仲裁队列天生就是分布式的，不需要像经典队列那样手动配置镜像。它会自动在集群中的大多数节点上复制消息。</li><li><strong>多数派机制 (Quorum)：</strong> 任何操作（如消息的发布、消费确认）都需要集群中<strong>大多数节点</strong>的确认才能被视为成功。例如，一个有 3 个节点的仲裁队列，需要 2 个节点的确认。这保证了即使有节点故障，只要多数派存活，数据就不会丢失，并且服务可以继续。</li><li><strong>更好的数据安全性：</strong> Raft 算法确保了消息的强一致性，理论上比经典队列的镜像模式更能避免脑裂 (split-brain) 等问题，提供更高的数据安全性。</li><li><strong>写入性能：</strong> 由于需要多数派确认，写入性能通常会比非镜像的经典队列低，但比镜像的经典队列在某些情况下可能更好，因为它优化了复制过程。</li><li><strong>消费者行为：</strong> 消费者可以从任何副本消费消息，并且消费确认也会通过 Raft 算法进行同步，确保消费的顺序和一致性。</li><li><strong>只支持持久化：</strong> 仲裁队列的消息总是持久化的。</li></ul><p><strong>使用场景：</strong></p><ul><li>对数据一致性和高可用性有极高要求的场景。</li><li>需要避免数据丢失和脑裂问题的关键业务消息。</li><li>替代经典队列的镜像模式，提供更健壮的集群行为。</li></ul><h3 id="流式队列-Stream-Queue"><a href="#流式队列-Stream-Queue" class="headerlink" title="流式队列(Stream Queue)"></a>流式队列(Stream Queue)</h3><p><strong>特点：</strong></p><ul><li><strong>专为大数据流设计：</strong> 流式队列是 RabbitMQ 3.9 版本引入的最新队列类型，其设计目标是处理<strong>海量的、连续的、高吞吐量</strong>的消息流。</li><li><strong>类似 Kafka 的特性：</strong> 它吸收了 Kafka 等流处理系统的概念，例如：<ul><li><strong>追加日志 (Append-only Log)：</strong> 消息以追加的方式写入，像一个不可变的日志。</li><li><strong>多消费者并行消费：</strong> 多个消费者可以独立地追踪自己的消费进度（偏移量），从流的不同位置并行消费。</li><li><strong>消息保留策略：</strong> 消息可以被长期保留（例如，保留几天或直到达到某个大小限制），即使它们已经被消费者确认，也可以重新消费。这对于回溯、重放或处理慢速消费者非常有用。</li></ul></li><li><strong>高吞吐量：</strong> 通过优化内部存储和消费模型，流式队列可以提供比经典队列和仲裁队列更高的吞吐量，尤其是在大量消息的场景下。</li><li><strong>磁盘友好：</strong> 消息主要存储在磁盘上，但通过优化读写性能，依然能保持高吞吐。</li><li><strong>适用于历史数据回溯：</strong> 消费者可以从流的任意位置开始消费，或重新消费已处理过的消息。</li><li><strong>高可用：</strong> 流式队列也有其自身的复制机制来保证高可用性，但其细节与仲裁队列和经典镜像队列有所不同。</li></ul><p><strong>使用场景：</strong></p><ul><li>日志收集和分析。</li><li>IoT (物联网) 数据流处理。</li><li>事件溯源 (Event Sourcing)。</li><li>实时数据管道。</li><li>任何需要处理海量、连续、可回溯消息流的场景。</li></ul><p><strong>三种队列类型的比较总结</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>经典队列 (Classic Queues)</th><th>仲裁队列 (Quorum Queues)</th><th>流式队列 (Stream Queues)</th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>通用消息，灵活配置</td><td>强一致性，高可用</td><td>大数据流，高吞吐，可回溯</td></tr><tr><td><strong>高可用</strong></td><td>需手动配置镜像（同步复制）</td><td>基于 Raft 算法，自动高可用（多数派）</td><td>自身复制机制，高可用</td></tr><tr><td><strong>一致性</strong></td><td>最终一致性（镜像）</td><td>强一致性</td><td>强一致性（内部实现）</td></tr><tr><td><strong>消息持久性</strong></td><td>可选（持久化/非持久化）</td><td>总是持久化</td><td>总是持久化，支持长期保留</td></tr><tr><td><strong>吞吐量</strong></td><td>单节点高，镜像模式有开销</td><td>比非镜像经典低，比镜像经典好（某些场景）</td><td>极高，尤其适合大数据流</td></tr><tr><td><strong>消费模型</strong></td><td>传统消息队列模型，消息一旦消费即移除</td><td>传统模型，但消费确认更强一致</td><td>类似 Kafka，支持多消费者独立追踪偏移量，可回溯</td></tr><tr><td><strong>内部实现</strong></td><td>基于内存/磁盘混合，分段存储</td><td>基于 Raft 日志，强一致性日志</td><td>追加日志，磁盘优化</td></tr><tr><td><strong>版本</strong></td><td>早期版本支持，默认</td><td>RabbitMQ 3.8+</td><td>RabbitMQ 3.9+</td></tr></tbody></table></div><h3 id="队列设置"><a href="#队列设置" class="headerlink" title="队列设置"></a>队列设置</h3><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>设置队列属性max-priority,发送消息时设置priority属性排序.</p><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p><strong>交换机 (Exchange)</strong> 是消息路由的核心组件。生产者发送消息到交换机，而不是直接发送到队列。交换机接收到消息后，根据其类型和绑定的路由规则，将消息转发到一个或多个队列。</p><p>可以把交换机想象成一个邮局的分拣中心。当一封信（消息）到达邮局时，分拣中心（交换机）不会直接把它投递到某个邮箱（队列），而是会根据信封上的地址信息（路由键）和分拣规则（交换机类型及绑定），决定把这封信投递到哪些信箱。</p><p><strong>接收消息：</strong> 接收来自生产者的消息。</p><p><strong>路由消息：</strong> 根据自身类型和消息的<strong>路由键 (Routing Key)</strong>，以及与队列之间的<strong>绑定 (Binding)</strong> 规则，将消息转发到对应的队列。</p><p><strong>不存储消息：</strong> 交换机本身不存储消息，它只是一个消息转发器。如果一条消息到达交换机，但没有匹配到任何队列，那么这条消息就会被丢弃（除非配置了<strong>备份交换机</strong>）。</p><h3 id="直连交换机-Direct-Exchange"><a href="#直连交换机-Direct-Exchange" class="headerlink" title="直连交换机 (Direct Exchange)"></a>直连交换机 (Direct Exchange)</h3><p><strong>路由规则：</strong> 直连交换机根据消息的<strong>路由键（Routing Key)</strong>与<strong>队列和交换机之间的绑定键（Binding Key）</strong>进行精确匹配。</p><p><strong>工作方式：</strong> 只有当消息的路由键与队列的绑定键<strong>完全一致</strong>时，消息才会被转发到该队列。</p><p><strong>使用场景：</strong></p><ul><li><strong>点对点消息传递：</strong> 当你需要将消息发送到特定队列时。</li><li><strong>日志系统：</strong> 根据日志级别（如 <code>info</code>, <code>warning</code>, <code>error</code>）路由到不同的处理队列。</li></ul><p><strong>路由键</strong>和<strong>绑定键（Binding Key）\</strong>需要*<em>精确匹配*</em>。</p><p><strong>如何工作：</strong> 当一个队列与直连交换机绑定时，它会提供一个绑定键。如果消息的路由键与这个绑定键完全相同，交换机就会将消息转发到这个队列。</p><p><strong>示例：</strong></p><ul><li>队列 Q1 绑定到直连交换机 E1，绑定键是 <code>error</code>。</li><li>队列 Q2 绑定到直连交换机 E1，绑定键是 <code>info</code>。</li><li>生产者发送消息到 E1，路由键为 <code>error</code>。只有 Q1 会收到消息。</li><li>生产者发送消息到 E1，路由键为 <code>warning</code>。没有队列会收到消息（除非有备份交换机）。</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/uvOSniRI79KlHjZ.png" alt="image-20250723152920972"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">directQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String exchangeName = <span class="string">&quot;amq.direct&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;hello,this is direct1 exhange&quot;</span>);</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue2&quot;</span>, <span class="string">&quot;hello,this is direct2 exhange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主题交换机-Topic-Exchange"><a href="#主题交换机-Topic-Exchange" class="headerlink" title="主题交换机 (Topic Exchange)"></a>主题交换机 (Topic Exchange)</h3><p><strong>路由规则：</strong> 主题交换机通过<strong>模式匹配</strong>的方式来路由消息，它也依赖于消息的路由键和绑定键。绑定键可以使用通配符：</p><ul><li><code>*</code> (星号)：匹配一个单词。</li><li><code>#</code> (井号)：匹配零个或多个单词。</li></ul><p><strong>示例：</strong></p><ul><li>队列 Q1 绑定到主题交换机 E2，绑定键是 <code>*.critical</code>。</li><li>队列 Q2 绑定到主题交换机 E2，绑定键是 <code>audit.#</code>。</li><li>生产者发送消息到 E2，路由键为 <code>log.critical</code>。Q1 会收到。</li><li>生产者发送消息到 E2，路由键为 <code>audit.user.login</code>。Q2 会收到。</li><li>生产者发送消息到 E2，路由键为 <code>report.summary</code>。都没有收到。</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/Vi4tCgzQxNeEsGl.png" alt="image-20250723154158270"></p><p><strong>工作方式：</strong></p><ul><li>路由键和绑定键都是由句点 <code>.</code> 分隔的字符串（例如 <code>stock.usd.ny</code>）。</li><li>当消息的路由键与绑定键的模式匹配时，消息会被转发到对应的队列。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>日志订阅：</strong> 灵活地订阅不同来源、不同级别的日志。</li><li><strong>股票行情：</strong> 根据股票代码、货币类型等进行多维度的消息订阅。</li><li><strong>复杂事件处理：</strong> 需要根据事件类型或来源的层级结构进行路由</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topicQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String exchangeName = <span class="string">&quot;amq.topic&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;china.weather&quot;</span>, <span class="string">&quot;hello,this is topic exhange&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;china.news&quot;</span>, <span class="string">&quot;hello,this is topic exhange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广播-扇形交换机-Fanout-Exchange"><a href="#广播-扇形交换机-Fanout-Exchange" class="headerlink" title="广播/扇形交换机 (Fanout Exchange)"></a>广播/扇形交换机 (Fanout Exchange)</h3><p>将接收到的消息广播到每一个跟其绑定的队列</p><p><strong>路由规则：</strong> 扇形交换机最简单，它会<strong>忽略</strong>消息的路由键。</p><p><strong>工作方式：</strong> 它会将接收到的所有消息广播到<strong>所有与它绑定的队列</strong>。</p><p><strong>关系：</strong> 扇形交换机<strong>完全忽略路由键</strong>, 无论消息的路由键是什么，扇形交换机都会将所有收到的消息广播到所有与它绑定的队列。路由键的存在只是为了符合协议要求，但其值没有任何路由意义。</p><p><strong>示例：</strong></p><ul><li>队列 Q1、Q2、Q3 都绑定到扇形交换机 E3。</li><li>生产者发送消息到 E3，路由键为任何值（例如 <code>my.key</code> 或 <code>whatever</code>）。Q1、Q2、Q3 都会收到消息。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>广播消息：</strong> 例如，通知所有在线用户某个系统维护消息。</li><li><strong>多任务处理：</strong> 一个任务触发后，需要多个不同的服务并行处理该任务的不同方面。</li><li><strong>缓存更新：</strong> 当数据更新时，通知所有需要更新缓存的服务。</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/V12oSsUWA6M47c3.png" alt="image-20250723141958629"></p><p><img data-src="https://s2.loli.net/2025/07/23/y1GN8qE5B9toWRc.png" alt="image-20250723151942617"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fanoutQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String exchangeName = <span class="string">&quot;amq.fanout&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="keyword">null</span>, <span class="string">&quot;hello,this is fanout exhange&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="头交换机-Headers-Exchange"><a href="#头交换机-Headers-Exchange" class="headerlink" title="头交换机 (Headers Exchange)"></a>头交换机 (Headers Exchange)</h3><p><strong>路由规则：</strong> 头交换机是<strong>最不常用</strong>的一种。它根据消息的<strong>头部属性（Headers）</strong>而不是路由键来路由消息。</p><p><strong>工作方式：</strong> 绑定时，你可以指定一系列的键值对（<code>x-match</code> 参数决定匹配规则：<code>any</code> 匹配任一，<code>all</code> 匹配所有）。消息的头部如果包含匹配的键值对，则会被转发。</p><p><strong>使用场景：</strong></p><ul><li>非常特殊的、基于复杂消息元数据的路由需求。</li><li>当路由键不足以表达所有路由逻辑时。</li></ul><p><strong>交换机的核心作用：</strong></p><ul><li>它是消息路由的<strong>第一站</strong>，解耦了生产者和队列。</li><li>不存储消息，只负责转发。</li></ul><p><strong>四种交换机类型及其路由规则：</strong></p><ul><li><strong>Direct (直连)：</strong> 精确匹配路由键。</li><li><strong>Topic (主题)：</strong> 模式匹配（<code>*</code>, <code>#</code> 通配符）。</li><li><strong>Fanout (扇形)：</strong> 广播到所有绑定队列，忽略路由键。</li><li><strong>Headers (头)：</strong> 根据消息头属性匹配（较少用）。</li><li><strong>面试时，能够清晰地解释每种类型的路由机制和适用场景是关键。</strong></li></ul><p><strong>路由键 (Routing Key) 和绑定键 (Binding Key) 的区别和联系：</strong></p><ul><li><strong>Routing Key：</strong> 生产者发送消息时附带的，描述消息的属性。</li><li><strong>Binding Key：</strong> 队列与交换机绑定时定义的，描述队列希望接收哪类消息。</li><li><strong>关系：</strong> 交换机根据这两者进行匹配，将消息路由到队列。它们的匹配规则取决于交换机的类型。</li></ul><h3 id="交换机设置"><a href="#交换机设置" class="headerlink" title="交换机设置"></a>交换机设置</h3><h4 id="持久化交换机"><a href="#持久化交换机" class="headerlink" title="持久化交换机"></a>持久化交换机</h4><p><strong>保证交换机本身的元数据不会因为 RabbitMQ 服务重启而丢失。</strong></p><p>持久化交换机的作用和重要性</p><p>当你声明一个交换机时，你可以将其设置为<strong>持久化（<code>durable = true</code>）\</strong>或*<em>非持久化（<code>durable = false</code>）*</em>。</p><ol><li><strong>保证交换机定义不丢失：</strong><ul><li><strong>作用：</strong> 当一个交换机被声明为持久化时，它的配置信息（名称、类型、是否是持久化等）会被 RabbitMQ 写入磁盘。</li><li><strong>重要性：</strong> 这意味着即使 RabbitMQ 服务器崩溃或被意外关闭，当它重新启动时，这个持久化交换机依然会自动被创建并恢复，无需应用程序重新声明它。这对于系统的稳定性和自恢复能力至关重要。</li></ul></li><li><strong>配合持久化队列和持久化消息，实现端到端的可靠性：</strong><ul><li><strong>作用：</strong> 持久化交换机本身并不能保证消息的持久性。它只是保证了“通道”的存在。要实现消息在 Broker 重启后不丢失，需要<strong>三者协同工作</strong>：<ol><li><strong>持久化交换机：</strong> 确保交换机定义不丢失。</li><li><strong>持久化队列：</strong> 确保队列定义及其内部存储的消息不丢失。</li><li><strong>持久化消息：</strong> 生产者发送消息时，将 <code>delivery_mode</code> 设置为 <code>2</code> (Persistent)，这样消息内容本身才会被写入磁盘。</li></ol></li><li><strong>重要性：</strong> 只有这三者都配置为持久化，才能在 RabbitMQ 服务器重启后，确保消息从生产者到达消费者前的整个传递路径上的数据都不会丢失，从而实现端到端的消息可靠性。</li></ul></li></ol><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p><strong>死信机制</strong>是 RabbitMQ 提供的一种处理无法被正常投递或消费的消息的机制，是消息可靠性设计的重要组成部分。</p><p>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：</p><ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息 TTL (Time-To-Live) 过期。</li><li>队列达到最大长度 (max-length)。</li></ul><h2 id="消息属性与投递属性"><a href="#消息属性与投递属性" class="headerlink" title="消息属性与投递属性"></a>消息属性与投递属性</h2><p>消息属性是<strong>生产者在发布消息时设置的</strong>元数据，随消息一起传递。它们通常用于描述消息的特性或提供额外的处理信息。 常见的消息属性包括：</p><ul><li><strong><code>content_type</code>：</strong> 消息体的数据类型（例如 <code>application/json</code>）。</li><li><strong><code>content_encoding</code>：</strong> 消息体的编码方式（例如 <code>gzip</code>）。</li><li><strong><code>headers</code>：</strong> 一个自定义的键值对映射，可以包含应用程序定义的任意元数据。</li><li><strong><code>delivery_mode</code>：</strong> 消息的持久性。<ul><li><code>1</code> (Non-persistent): 消息不会写入磁盘，Broker 重启后会丢失。</li><li><code>2</code> (Persistent): 消息会写入磁盘，Broker 重启后会保留（但还需要队列是持久化的）。</li></ul></li><li><strong><code>priority</code>：</strong> 消息的优先级（如果队列支持优先级）。</li><li><strong><code>correlation_id</code>：</strong> 用于关联请求和响应消息，常用于 RPC 模式。</li><li><strong><code>reply_to</code>：</strong> 用于指定响应消息应该发送到哪个队列，常用于 RPC 模式。</li><li><strong><code>expiration</code>：</strong> 消息的过期时间（TTL），过期后消息会成为死信。</li><li><strong><code>message_id</code>：</strong> 消息的唯一标识符，由生产者设置。</li><li><strong><code>timestamp</code>：</strong> 消息发布时的时间戳。</li><li><strong><code>type</code>：</strong> 消息类型（应用程序定义）。</li><li><strong><code>user_id</code>：</strong> 发布消息的用户 ID。</li><li><strong><code>app_id</code>：</strong> 发布消息的应用程序 ID。</li></ul><p>投递属性是 RabbitMQ <strong>在将消息投递给消费者时添加的</strong>元数据，它们不属于原始消息本身，而是描述了消息的投递状态。</p><p> <code>requeue</code> 和 <code>redelivered</code> 并不是消息本身的属性，而是与<strong>消息处理和确认机制</strong>相关的<strong>行为参数或状态标志</strong>。</p><ul><li><strong><code>requeue</code> (行为参数)</strong><ul><li><code>requeue</code> 是在消费者向 RabbitMQ 发送<strong>否定确认 (Negative Acknowledgment - <code>basic.reject</code> 或 <code>basic.nack</code>)</strong> 时使用的一个<strong>布尔参数</strong>。</li><li>当 <code>requeue</code> 设置为 <code>true</code> 时，表示消费者要求 RabbitMQ 将此消息<strong>重新放回队列</strong>。消息会通常被放回队列的头部或按优先级排序。</li><li>当 <code>requeue</code> 设置为 <code>false</code> 时，表示消费者拒绝此消息，并且<strong>不希望它重新入队</strong>。此时，如果队列配置了死信交换机（DLX），消息就会被路由到 DLX；否则，消息会被直接丢弃。</li></ul></li><li><strong><code>redelivered</code> (状态标志)</strong><ul><li><code>redelivered</code> 是一个<strong>布尔型的投递属性</strong>。</li><li>当 RabbitMQ 第一次将消息投递给某个消费者时，<code>redelivered</code> 标志为 <code>false</code>。</li><li>如果消息被<strong>重新入队</strong>（例如，消费者 <code>nack</code> 并 <code>requeue=true</code>，或者连接断开导致消息自动重新入队），那么当这条消息<strong>再次</strong>被投递给任何消费者时，它的 <code>redelivered</code> 标志就会被设置为 <code>true</code>。</li><li><strong>作用：</strong> 这个标志告诉消费者：“这条消息不是第一次被投递了，你可能已经处理过它或者它之前未能成功处理。”消费者可以根据这个标志来识别重复投递的消息，并采取相应的处理策略（例如，幂等处理、记录警告、发送到死信队列等）。</li></ul></li></ul><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><hr><p>消息可靠性在分布式系统中是一个至关重要的概念，它指的是<strong>确保消息在从生产者到消费者的整个生命周期中不会丢失、不被重复处理，并且能够按照预期的顺序被处理</strong>。消息不丢失,消息不重复,消息有序性</p><h3 id="生产者可靠性"><a href="#生产者可靠性" class="headerlink" title="生产者可靠性"></a>生产者可靠性</h3><h4 id="生产者重连"><a href="#生产者重连" class="headerlink" title="生产者重连"></a>生产者重连</h4><p>由于网络波动,生产者可能出现连接mq失败的情况,可以设置连接超时和重试时间.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者超时重连</span></span><br><span class="line"><span class="meta">spring.rabbitmq.connection-timeout</span>= <span class="string">1s</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">1000ms</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.max-attempts</span>=<span class="string">3</span></span><br></pre></td></tr></table></figure><h4 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h4><p>如果路由失败,通过PublisherReturen返回路由异常原因,返回ACK.告知投递成功.</p><p>如果消息投递到了MQ并且入队成功,返回ACK,告知投递成功,其他情况发送nack.</p><p>RabbitMQ 提供了两种主要的生产者确认机制：</p><ol><li><strong>事务 (Transactions)</strong></li><li><strong>发布者确认 (Publisher Confirms)</strong></li></ol><p>RabbitMQ 的事务机制允许将一组消息的发送操作包装成一个原子单元。在事务中，要么所有消息都被 Broker 接收并处理，要么所有消息的操作都被回滚。</p><p>它涉及三个基本的 AMQP 命令：</p><ul><li><strong><code>Tx.Select</code></strong>: 声明当前通道进入事务模式。</li><li><strong><code>Tx.Commit</code></strong>: 提交事务。一旦提交，所有在事务期间发送的消息都被 Broker 确认接收。</li><li><strong><code>Tx.Rollback</code></strong>: 回滚事务。事务期间发送的所有消息都会被丢弃。</li></ul><p>优点</p><ul><li><strong>强一致性保证：</strong> 提供了严格的原子性，确保事务内的所有消息要么都成功，要么都失败。</li></ul><p>缺点</p><ul><li><strong>性能开销大：</strong> 每个 <code>Tx.Commit</code> 命令都会阻塞生产者，直到 Broker 响应。这意味着 Broker 需要对每个事务进行磁盘同步（如果消息是持久化的），这会大大<strong>降低消息的吞吐量</strong>。</li><li><strong>不适合高并发场景：</strong> 由于其阻塞特性，事务机制不适用于需要高吞吐量或低延迟的场景。</li></ul><p>发布者确认是 RabbitMQ 推荐的、更高效的生产者确认机制。它允许生产者异步地接收 Broker 的确认，而无需阻塞发送线程。</p><p>启用发布者确认后，Broker 会在以下两种情况下向生产者发送确认：</p><ul><li><strong><code>basic.ack</code> (肯定确认)：</strong><ul><li>表示消息已成功接收并<strong>持久化到磁盘</strong>（如果消息和队列都是持久化的），或者已成功<strong>路由到至少一个队列</strong>（如果消息是非持久化的）。</li><li>每个 <code>basic.ack</code> 都带有一个 <code>deliveryTag</code>（通道内递增的唯一标识符），可以确认单条消息或一批消息。</li></ul></li><li><strong><code>basic.nack</code> (否定确认)：</strong><ul><li>表示消息已被 Broker 接收，但由于某种原因<strong>未能被处理</strong>（例如，Broker 内部错误）。</li><li>这并不意味着消息丢失，而是 Broker 告诉生产者消息可能需要重新发送或进行其他处理</li></ul></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者确认机制</span></span><br><span class="line"><span class="comment"># 异步回调方式并且会返回deliveryId</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated </span></span><br><span class="line"><span class="comment"># simple 同步阻塞等待broker回执消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 开启publisher return 机制 返回路由失败消息</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true  </span></span><br></pre></td></tr></table></figure><p><strong>退回机制</strong></p><p>当publisher-returns属性设置为 <code>true</code> 时，如果生产者发送的消息<strong>无法被路由到任何队列</strong>（例如，因为路由键不匹配任何绑定，或者队列不存在），RabbitMQ Broker 会将这条消息”退回”给生产者</p><p>需要为 <code>RabbitTemplate</code> 设置一个 <code>ReturnsCallback</code>。</p><p>当消息被退回时，<code>ReturnsCallback</code> 会被异步调用，并接收一个 <code>ReturnedMessage</code> 对象作为参数。</p><p><code>ReturnedMessage</code> 对象包含了被退回的<strong>原始消息</strong>、<strong>退回的原因</strong>（<code>replyCode</code> 和 <code>replyText</code>，例如 <code>312 NO_ROUTE</code> 表示无路由）、<strong>发送时使用的交换机</strong>和<strong>路由键</strong>等信息。</p><p>退回回调是rabbitTemplate在初始化后设置的,因此可以在postConstrcut中,以及aware接口,BeanPostProcessor接口等实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> RabbitTemplate.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">                Message message = returnedMessage.getMessage();</span><br><span class="line">                String exchange = returnedMessage.getExchange();<span class="comment">//发送的交换机</span></span><br><span class="line">                <span class="keyword">int</span> replyCode = returnedMessage.getReplyCode();</span><br><span class="line">                String replyText = returnedMessage.getReplyText();</span><br><span class="line">                log.info(<span class="string">&quot;message:&#123;&#125;,exchange:&#123;&#125;,replyCode:&#123;&#125;,replyText:&#123;&#125;&quot;</span>,message,exchange,replyCode,replyText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>确认机制</strong></p><p>当设置为 <code>CORRELATED</code> 时，Spring AMQP 启用了发布者确认机制，并提供了<strong>更细粒度、更强大的确认方式</strong>。这是<strong>推荐</strong>用于生产环境的配置。</p><ul><li><strong>确认方式：</strong> 允许你为每条发送的消息提供一个<strong>唯一的 <code>CorrelationData</code> 对象</strong>（通常包含一个消息 ID）。当 Broker 返回确认（<code>basic.ack</code> 或 <code>basic.nack</code>）时，这个 <code>CorrelationData</code> 对象会作为参数传递给 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。</li><li><strong>关联性：</strong> 这是核心优势。通过 <code>CorrelationData</code>，你可以<strong>精确地将 Broker 返回的确认与你发送的特定消息关联起来</strong>。这对于跟踪消息状态、实现重试逻辑、确保幂等性等非常关键。</li><li><strong>回调：</strong> 你必须设置 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。当 Broker 返回确认时，该回调会被异步调用。<code>ConfirmCallback</code> 会接收 <code>CorrelationData</code>、<code>ack</code>（是否成功确认）和 <code>cause</code>（如果 <code>ack</code> 为 <code>false</code>，表示原因）作为参数。</li><li><strong>异步性：</strong> 生产者可以持续发送消息，而无需等待 Broker 的确认。确认的回调是异步发生的，大大提高了吞吐量。</li></ul><p>必须设置 <code>RabbitTemplate</code> 的 <code>ConfirmCallback</code>。当 Broker 返回确认时，该回调会被异步调用。<code>ConfirmCallback</code> 会接收 <code>CorrelationData</code>、<code>ack</code>（是否成功确认）和 <code>cause</code>（如果 <code>ack</code> 为 <code>false</code>，表示原因）作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testPublisherConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        correlationData.getFuture().toCompletableFuture().thenAccept(<span class="keyword">new</span> Consumer&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(CorrelationData.Confirm confirm)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (confirm.isAck()) &#123;</span><br><span class="line"><span class="comment">//                    ack成功,接收到ack</span></span><br><span class="line">                    log.info(<span class="string">&quot;消息成功,收到broker ack&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    发送者确认机制,如果没有收到ack</span></span><br><span class="line">                    log.info(<span class="string">&quot;消息失败,收到broker nack,发送者没有收到ack:&#123;&#125;&quot;</span>,confirm.getReason());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                log.error(throwable.getMessage(),throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;amq.direct&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;hello,this is topic exhange&quot;</span>,correlationData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/23/HCNPY9af2AxcIi4.png" alt="image-20250723215959341"></p><h3 id="消息队列可靠性"><a href="#消息队列可靠性" class="headerlink" title="消息队列可靠性"></a>消息队列可靠性</h3><p>默认情况下,会将接收到的消息保存在内存中,但:</p><ol><li>如果mq宕机,内存中的消息会丢失</li><li>内存空间有限,如果消费者故障或者处理过慢会导致消息堆积,引发mq阻塞</li></ol><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>RabbitMQ实现数据持久化包括三个方面:</p><p>消息队列设置durable,发送消息设置delivery_mode为持久化(2)),交换机设置为持久.</p><p>持久化使得存储在磁盘避免崩溃数据丢失,同时当消息堆积过多时避免page out(也就是当 Broker 中的消息堆积过多，导致内存压力过大时，RabbitMQ 会将内存中一部分<strong>非活跃</strong>（未被消费者拉取）的消息<strong>暂时从内存中移除并写入到磁盘上</strong>，以释放内存资源)</p><p>注意在RabbitTemplate中(来自spring-boot-starter-amqp),消息的delivery_mode是2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span><br><span class="line">    DEFAULT_PRIORITY = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExchangeBuilder</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">BaseExchangeBuilder</span>&lt;<span class="title">B</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String type;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> autoDelete;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> internal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> delayed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreDeclarationExceptions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> declare = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] declaringAdmins;&#125;</span><br></pre></td></tr></table></figure><h4 id="Lazy-Queue"><a href="#Lazy-Queue" class="headerlink" title="Lazy Queue"></a>Lazy Queue</h4><p>惰性队列收到消息后直接存入磁盘而非内存,内存只保留最近消息.</p><p>消费者要消费消息时才会从磁盘中读取并加载到内存,支持数百万跳的消息存储.</p><p><strong>新版本都是惰性队列</strong></p><p>标准队列（非惰性队列）在消息堆积时的行为：</p><ul><li><strong>内存优先：</strong> 默认情况下，标准队列会尽可能地将消息保留在内存中，以提高消息的投递速度。只有当 Broker 的内存达到高水位线时，才会将消息 Page-out (从内存交换到磁盘)。</li><li><strong>内存峰值：</strong> 当消息生产者发送速度远超消费者，导致大量消息在队列中堆积时，这些消息会全部加载到内存中。这可能导致 Broker 内存急剧增长，甚至达到内存限制，触发流控或崩溃。</li><li><strong>频繁 Page-out/Page-in：</strong> 如果消息持续堆积，Broker 会频繁地进行 Page-out 和 Page-in 操作，这会导致大量的磁盘 I/O，严重影响系统性能和消息延迟。</li></ul><p>惰性队列的核心思想是<strong>“消息总是尽可能地写入磁盘，只有在需要投递时才加载到内存”</strong>。</p><p>它通过调整消息在队列中的存储策略来达到减少内存占用的目的：</p><ol><li><strong>主动写入磁盘：</strong> 与标准队列不同，惰性队列在接收到消息后，会<strong>立即或很快地将消息内容写入到磁盘</strong>，只在内存中保留少量消息元数据（如消息索引）。</li><li><strong>延迟加载：</strong> 只有当消息即将被消费者拉取时（例如，消费者连接并准备接收消息），惰性队列才会将这些消息从磁盘读取到内存中进行投递。</li><li><strong>内存占用低：</strong> 即使有大量消息堆积，内存中的实际消息内容非常少，从而大大降低了 Broker 的内存使用。</li></ol><p><img data-src="https://s2.loli.net/2025/07/23/fvJXcjB8t7Y1QIN.png" alt="image-20250723230903068"></p><h3 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h3><p>如果没有确认机制，当消息被投递给消费者后，即使消费者未能成功处理（例如，程序崩溃、网络中断、业务逻辑出错），Broker 也会认为消息已经发送，并将其从队列中删除。这就会导致<strong>消息丢失</strong>。</p><p>消费者确认机制正是为了解决这个问题，它在消费者和 Broker 之间建立了一种“消息处理状态”的反馈机制</p><h4 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h4><p>当消费者处理消息结束后,应该向RabbitMQ发送一个回执,告知MQ消息处理状态. </p><p>消费者处理结束后可以向MQ发送一个回执,告知自己消息的处理状态.</p><ul><li>ack:成功处理消息,MQ从队列中删除消息</li><li>nack:消息处理失败,MQ需要再次投递消息</li><li>reject:消息处理失败并拒绝该消息,从队列中删除.</li></ul><p><img data-src="https://s2.loli.net/2025/07/23/V6L9IWvfeUYTdrN.png" alt="image-20250723231753038"></p><p>SpringAMQP已经实现了消息确认功能,可以通过配置文件选择ACK处理方式.</p><p>none,manual,auto</p><p><img data-src="https://s2.loli.net/2025/07/23/XGb3OVvExu6Jmt8.png" alt="image-20250723232046254"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者确认机制</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">auto</span></span><br></pre></td></tr></table></figure><h4 id="消息失败"><a href="#消息失败" class="headerlink" title="消息失败"></a>消息失败</h4><p>当消费者出现异常后,消息会不断requeue到队列,再重新发送给消费者,然后再次异常,再次requeue,无限循环,导致mq消息处理飙升.</p><p>配置retry机制,设置最大尝试次数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">auto</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class="string">1000ms</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">3</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">2</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>当重试次数达到后直接抛弃消息,可以通过MessageRecoverer接口来处理,包括三种实现,可以直接reject并丢弃消息,也可以返回nack,重新入队,也可以将失败消息投递到指定的交换机.</p><p><img data-src="https://s2.loli.net/2025/07/23/GEYShOIwDZ9KnCQ.png" alt="image-20250723234838816"></p><p><img data-src="https://s2.loli.net/2025/07/24/KHnvIaoRCrUVsYz.png" alt="image-20250724003504963"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRecoverer <span class="title">messageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RepublishMessageRecoverer(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h4><p>同一个业务执行一次或多次对业务状态的影响是一致的.</p><p>设置唯一消息id,可以直接设置消息属性,然后在消费者处将处理后的消息保存到数据库,当新消息</p><p><img data-src="https://s2.loli.net/2025/07/24/GHoW2eD1jNFbUQ4.png" alt="image-20250724104054206"></p><p>或者基于业务判断,例如在支付后修改订单状态,可以在修改订单状态后先查询订单状态判断状态是否是未支付,未支付才需要修改.</p><p><img data-src="https://s2.loli.net/2025/07/24/OJGYiMmEP45eaXA.png" alt="image-20250724105630177"></p><h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>生产者发送消息时指定一个时间,消费者不会立刻收到消息,而是在指定时刻之后才收到消息.</p><p>假设在交易之后还未付费,需要发送一个延时消息,在指定时间之后收到检查用户是否已经付费,如果付费则修改订单状态,如果没有付费,商品数量和订单状态都修改.</p><p><img data-src="https://s2.loli.net/2025/07/24/d1XV3agFZuc2EpU.png" alt="image-20250724110445201"></p><h4 id="死信交换机-1"><a href="#死信交换机-1" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列的消息满足以下情况之一时,就会成为死信:</p><ol><li>消费者使用basic.reject或者basic.nack,并且消息requeue参数为false.</li><li>消息达到了设置的expiration或者队列的x-max-ttl过期时间但无人消费.</li><li>队列消息堆积满了,最早的消息成为死信</li></ol><p>如果队列通过x-dead-letter-exchange指定交换了交换机,该队列中的死信就会投递到这个交换机.这个交换机就是DLX.</p><p><img data-src="https://s2.loli.net/2025/07/24/QqeEXnDsPTHOYrk.png" alt="image-20250724112010554"></p><p>也就是给一个交换机发送消息,然后一个队列接受,给这个队列设置超时时间和死信队列,当超时后到指定的队列中,消费者监听这个队列并进行处理.</p><h4 id="延迟消息插件"><a href="#延迟消息插件" class="headerlink" title="延迟消息插件"></a>延迟消息插件</h4><p>官方提供插件原生支持延迟消息功能. 插件的原理是设计一种支持延迟消息功能的交换机,当消息投递到交换机后可以延迟一段时间然后再投递到队列.</p><p>安装并启用插件,使用delayed交换机,同时设置消息头<code>x-delay</code>设置过期时间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;direct.delayExchange&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;direct.delayQueue&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listenMessage15</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;direct2, Spring接收到消费消息&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;hihihi&quot;</span>,(msg)-&gt;&#123;</span><br><span class="line">    msg.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//   msg.getMessageProperties().setDelayLong(1000L);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实现原理是,有一个时钟,当达到超时时间进行任务,因此对cpu压力较大. 适合延时时间较短的场景.</p><p>应用:取消超时订单</p><p><img data-src="https://s2.loli.net/2025/07/24/q4FaG2AV5BWoXxD.png" alt="image-20250724154804554"></p><p>订单完成后,发送延迟消息,进行延迟消息处理,监听对应的延迟消息队列,接收到消息id,查看订单是否已支付,如果支付,则return. 否则继续向延迟交换机发送消息,延迟时间可以设置更长一点.当延迟时间达到最大时间后,取消该订单并恢复库存(事务).</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>最简单的消息发送,直接根据队列名字发送,不通过交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String queueName = <span class="string">&quot;hello.queue1&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(queueName, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接受消息上,spring-amqp提供声明式的消息监听,通过注解在方法上声明要监听的队列名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.queue1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listenMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Spring接收到消费消息&quot;</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个消费者绑定到同一个队列时,同一个消息只能被一个消费者消费,默认情况下将消息一次轮询投递给绑定在队列上的每一个消费者,没有考虑消费者是否已经处理完消息(消费者处理能力),可能出现消息堆积.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次只能获取一条消息,处理完后再取</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/23/3ANVlJm2jqtbDvh.png" alt="image-20250723141413063"></p><p>创建队列,交换机以及绑定关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanOutConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange  <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;exchange&quot;</span>).build();</span><br><span class="line"><span class="comment">//        return new FanoutExchange(&quot;exchange&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return QueueBuilder.durable(&quot;queue&quot;).build();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了创建@Bean的方式,还可以通过注解方式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;queue1&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;exchange1&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;test1&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/23/qDZUVliadH42pku.png" alt="image-20250723165130608"></p><div class="table-container"><table><thead><tr><th>元素</th><th>默认持久化属性 (<code>durable</code>)</th><th>默认 <code>delivery_mode</code></th><th>行为解释</th></tr></thead><tbody><tr><td><strong>消息</strong></td><td><strong>否</strong> (<code>delivery_mode=1</code>)</td><td><code>1</code> (非持久化)</td><td>Broker 重启会丢失，即使队列持久化。</td></tr><tr><td><strong>队列</strong></td><td><strong>是</strong> (<code>durable=true</code>)</td><td>N/A</td><td>Broker 重启后队列元数据不会丢失。</td></tr><tr><td><strong>交换机</strong></td><td><strong>是</strong> (<code>durable=true</code>)</td><td>N/A</td><td>Broker 重启后交换机元数据不会丢失。</td></tr></tbody></table></div><p>导出到 Google 表格</p><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>如果发送的不是提供的Message对象或者字符串等,而是直接的pojo或者map,会通过消息转换器进行转换.  对消息对象的处理默认实现是SimpleMessageConverter,基于JDK的ObjectOutputStream完成序列化. 存在问题:JDK序列化消息可读性差,消息太大,有安全风险.</p><p>采用json序列化替代默认的JDK序列化</p><h2 id="面试重点"><a href="#面试重点" class="headerlink" title="面试重点"></a>面试重点</h2><h3 id="交换机（Exchange）的面试重点"><a href="#交换机（Exchange）的面试重点" class="headerlink" title="交换机（Exchange）的面试重点"></a>交换机（Exchange）的面试重点</h3><ol><li><p><strong>交换机的核心作用：</strong></p><ul><li>它是消息路由的<strong>第一站</strong>，解耦了生产者和队列。</li><li>不存储消息，只负责转发。</li></ul></li><li><p><strong>四种交换机类型及其路由规则：</strong></p><ul><li><strong>Direct (直连)：</strong> 精确匹配路由键。</li><li><strong>Topic (主题)：</strong> 模式匹配（<code>*</code>, <code>#</code> 通配符）。</li><li><strong>Fanout (扇形)：</strong> 广播到所有绑定队列，忽略路由键。</li><li><strong>Headers (头)：</strong> 根据消息头属性匹配（较少用）。</li><li><strong>面试时，能够清晰地解释每种类型的路由机制和适用场景是关键。</strong></li></ul></li><li><p><strong>路由键 (Routing Key) 和绑定键 (Binding Key) 的区别和联系：</strong></p><ul><li><strong>Routing Key：</strong> 生产者发送消息时附带的，描述消息的属性。</li><li><strong>Binding Key：</strong> 队列与交换机绑定时定义的，描述队列希望接收哪类消息。</li><li><strong>关系：</strong> 交换机根据这两者进行匹配，将消息路由到队列。它们的匹配规则取决于交换机的类型。</li></ul></li><li><p><strong>绑定 (Binding) 的概念：</strong></p><ul><li>它是交换机和队列之间的<strong>关联关系</strong>，定义了消息如何从交换机流向队列。</li></ul></li><li><p><strong>死信交换机 (Dead Letter Exchange, DLX) 和死信队列 (Dead Letter Queue, DLQ)：</strong></p><ul><li>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息 TTL (Time-To-Live) 过期。</li><li>队列达到最大长度 (max-length)。</li></ul></li><li>面试中常与消息可靠性、异常处理等话题结合考察。</li></ul></li><li><p><strong>持久化 (Durable) 交换机：</strong></p><ul><li>和队列一样，交换机也可以被声明为持久化的。这意味着即使 RabbitMQ 服务重启，交换机本身（及其类型、名称、配置）也不会丢失。</li><li><strong>注意：</strong> 持久化交换机只保证交换机的元数据不丢失，不保证消息本身。消息的持久化取决于消息的 <code>delivery_mode</code> 和队列的持久化配置。</li></ul></li><li><p><strong>消息丢失场景：</strong></p><ul><li>消息到达交换机，但没有匹配到任何队列（除非有备份交换机）。</li><li>消息被发送到非持久化交换机，且 RabbitMQ 服务重启。</li></ul></li><li><p><strong>备份交换机 (Alternate Exchange, AE)：</strong></p><p>当消息无法被路由到任何队列时，交换机可以将这些消息发送到预先配置的备份交换机。这对于捕获和处理那些未能成功路由的消息非常有用，防止消息静默丢失。</p><p>如果交换机收到的消息路由键没有匹配到任何队列，消息默认会被丢弃。这会引出<strong>备份交换机 (Alternate Exchange)</strong> 的概念，它可以在消息无法被路由时捕获这些消息。</p></li></ol><p><strong>死信交换机 (Dead Letter Exchange, DLX) 和死信队列 (Dead Letter Queue, DLQ)：</strong></p><ul><li>虽然 DLX/DLQ 不是交换机类型，但它是一个非常重要的概念，涉及到消息无法被消费时的处理。当消息出现以下情况时，会被转发到死信交换机：<ul><li>消息被消费者拒收 (rejected)，并且 <code>requeue</code> 参数设置为 <code>false</code>。</li><li>消息 TTL (Time-To-Live) 过期。</li><li>队列达到最大长度 (max-length)。</li></ul></li><li>面试中常与消息可靠性、异常处理等话题结合考察。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="使用Jackson2json转化器报错"><a href="#使用Jackson2json转化器报错" class="headerlink" title="使用Jackson2json转化器报错"></a>使用Jackson2json转化器报错</h3><p>如果在使用convertAndSend发送消息时可以发现,如果传输的本身就是Message,会直接传输,不做特别处理.但如果在RabbitListener中参数设置为Message,会报conversion异常,这是为什么呢. 核心原因是,在接受消息时,MessagingMessageConverter会调用Jackson2jsonConverter的fromMessage方法,它会根据消息的属性和头部进行推断类型,如果是没有,则会默认将Message的body二进制数据json反序列化为Object,如果转化失败就报错(比如是string的二进制数据).</p><p>下面是具体分析:</p><p>使用jacksonmessageconverter消息序列化机制</p><p>如果是传入对象,首先是Message直接返回,否则进行转换,调用这个converter的toMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Message <span class="title">convertMessageIfNecessary</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Message msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getRequiredMessageConverter().toMessage(object, <span class="keyword">new</span> MessageProperties());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// RabbitTemplate类中</span></span><br></pre></td></tr></table></figure><p>然后会在AbstactMessageConverter中调用toMessage方法,jackson2json本身没有toMessage方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">toMessage</span><span class="params">(Object object, <span class="meta">@Nullable</span> MessageProperties messagePropertiesArg, <span class="meta">@Nullable</span> Type genericType)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">    MessageProperties messageProperties = messagePropertiesArg;</span><br><span class="line">    <span class="keyword">if</span> (messagePropertiesArg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">this</span>.createMessage(object, messageProperties, genericType);</span><br><span class="line">    messageProperties = message.getMessageProperties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.createMessageIds &amp;&amp; messageProperties.getMessageId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties.setMessageId(UUID.randomUUID().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意new MessageProperties得到的消息content-type默认是<code>application/octet-stream</code>,然后通过AbstractJackson2MessageConverter的createMessage创建消息,这里就是关键了,这个converter的this.supportedContentType只有<code>application/json</code>,所以这里创建消息,并根据数据设置了长度的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">messageProperties.setContentType(<span class="keyword">this</span>.supportedContentType.toString());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.supportedCTCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line">    messageProperties.setContentEncoding(<span class="keyword">this</span>.getDefaultCharset());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">messageProperties.setContentLength((<span class="keyword">long</span>)bytes.length);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    JavaType type = <span class="keyword">this</span>.objectMapper.constructType((Type)(genericType == <span class="keyword">null</span> ? objectToConvert.getClass() : genericType));</span><br><span class="line">    <span class="keyword">if</span> (genericType != <span class="keyword">null</span> &amp;&amp; !type.isContainerType() &amp;&amp; Modifier.isAbstract(type.getRawClass().getModifiers())) &#123;</span><br><span class="line">        type = <span class="keyword">this</span>.objectMapper.constructType(objectToConvert.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getJavaTypeMapper().fromJavaType(type, messageProperties);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getClassMapper().fromClass(objectToConvert.getClass(), messageProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Message(bytes, messageProperties);</span><br></pre></td></tr></table></figure><p>到此,toMessage结束.</p><p>而在接受消息时,在AbstactMessageListenerContainer中,接收到消息后调用onMessage方法,它会调用messagingMessageListenerAdapter中的toMessage方法,在这个方法中又调用toMessagingMessage方法,然后在其中调用fromMessage方法,在这里就是MessagingMessageConverter的fromMessage方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Message&lt;?&gt; toMessagingMessage(org.springframework.amqp.core.Message amqpMessage) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Message)<span class="keyword">this</span>.getMessagingMessageConverter().fromMessage(amqpMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个extractPayload调用了extractMessage方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">extractPayload</span><span class="params">(org.springframework.amqp.core.Message message)</span> </span>&#123;</span><br><span class="line">    MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties.setTargetBean(<span class="keyword">this</span>.bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageProperties.setTargetMethod(<span class="keyword">this</span>.method);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.inferredArgumentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageProperties.setInferredArgumentType(<span class="keyword">this</span>.inferredArgumentType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MessagingMessageListenerAdapter.<span class="keyword">this</span>.extractMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在extractMessage中获取了jackson2jsonMessageConverter,然后调用其fromMessage方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">extractMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    MessageConverter converter = <span class="keyword">this</span>.getMessageConverter();</span><br><span class="line">    <span class="keyword">return</span> converter != <span class="keyword">null</span> ? converter.fromMessage(message) : message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会进行判断,如果不是octet-stream或者application/json以及null等,会报不支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message, <span class="meta">@Nullable</span> Object conversionHint)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">    Object content = <span class="keyword">null</span>;</span><br><span class="line">    MessageProperties properties = message.getMessageProperties();</span><br><span class="line">    <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String contentType = properties.getContentType();</span><br><span class="line">        <span class="keyword">if</span> ((!<span class="keyword">this</span>.assumeSupportedContentType || contentType != <span class="keyword">null</span> &amp;&amp; !contentType.equals(<span class="string">&quot;application/octet-stream&quot;</span>)) &amp;&amp; (contentType == <span class="keyword">null</span> || !contentType.contains(<span class="keyword">this</span>.supportedContentType.getSubtype()))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.log.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.log.warn(<span class="string">&quot;Could not convert incoming message with content-type [&quot;</span> + contentType + <span class="string">&quot;], &#x27;&quot;</span> + <span class="keyword">this</span>.supportedContentType.getSubtype() + <span class="string">&quot;&#x27; keyword missing.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String encoding = <span class="keyword">this</span>.determineEncoding(properties, contentType);</span><br><span class="line">            content = <span class="keyword">this</span>.doFromMessage(message, conversionHint, properties, encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nullAsOptionalEmpty) &#123;</span><br><span class="line">            content = Optional.empty();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            content = message.getBody();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会在convertContent中进行转换得到目标对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doFromMessage</span><span class="params">(Message message, Object conversionHint, MessageProperties properties, String encoding)</span> </span>&#123;</span><br><span class="line">    Object content = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        content = <span class="keyword">this</span>.convertContent(message, conversionHint, properties, encoding);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">&quot;Failed to convert Message content&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">convertContent</span><span class="params">(Message message, Object conversionHint, MessageProperties properties, String encoding)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object content = <span class="keyword">null</span>;</span><br><span class="line">    JavaType inferredType = <span class="keyword">this</span>.javaTypeMapper.getInferredType(properties);</span><br><span class="line">    <span class="keyword">if</span> (inferredType != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.useProjectionForInterfaces &amp;&amp; inferredType.isInterface() &amp;&amp; !inferredType.getRawClass().getPackage().getName().startsWith(<span class="string">&quot;java.util&quot;</span>)) &#123;</span><br><span class="line">        content = <span class="keyword">this</span>.projectingConverter.convert(message, inferredType.getRawClass());</span><br><span class="line">        properties.setProjectionUsed(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inferredType != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.alwaysConvertToInferredType) &#123;</span><br><span class="line">        content = <span class="keyword">this</span>.tryConverType(message, encoding, inferredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conversionHint <span class="keyword">instanceof</span> ParameterizedTypeReference) &#123;</span><br><span class="line">            ParameterizedTypeReference&lt;?&gt; parameterizedTypeReference = (ParameterizedTypeReference)conversionHint;</span><br><span class="line">            content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, <span class="keyword">this</span>.objectMapper.getTypeFactory().constructType(parameterizedTypeReference.getType()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            JavaType targetJavaType = <span class="keyword">this</span>.getJavaTypeMapper().toJavaType(message.getMessageProperties());</span><br><span class="line">            content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, targetJavaType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getClassMapper().toClass(message.getMessageProperties());</span><br><span class="line">            content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到content,如果为null,则取message.body,然后将该对象包装为message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nullAsOptionalEmpty) &#123;</span><br><span class="line">        content = Optional.empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        content = message.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object convertedObject = <span class="keyword">this</span>.extractPayload(message);</span><br><span class="line"><span class="keyword">if</span> (convertedObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">&quot;Message converter returned null&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MessageBuilder&lt;Object&gt; builder = convertedObject <span class="keyword">instanceof</span> Message ? MessageBuilder.fromMessage((Message)convertedObject) : MessageBuilder.withPayload(convertedObject);</span><br><span class="line">    <span class="keyword">return</span> builder.copyHeadersIfAbsent(mappedHeaders).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现的问题是,如果send发送Message,在convertMessageIfNecessary会直接返回Message,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message build = MessageBuilder.withBody(<span class="string">&quot;Helloaa aa &quot;</span>.getBytes(StandardCharsets.UTF_8)).build();</span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;queue1&quot;</span>, build);</span><br></pre></td></tr></table></figure><p>其content-type默认是octet-stream,其中的关键就是,这里根据消息属性判断targetJavaType是Object,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">/// ....</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        JavaType targetJavaType = <span class="keyword">this</span>.getJavaTypeMapper().toJavaType(message.getMessageProperties());</span><br><span class="line">        content = <span class="keyword">this</span>.convertBytesToObject(message.getBody(), encoding, targetJavaType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体判断如下,首先根据属性判断,如果为空再根据”_<em>TypeId_</em>“头判断,如果还为空,就默认object了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JavaType <span class="title">toJavaType</span><span class="params">(MessageProperties properties)</span> </span>&#123;</span><br><span class="line">    JavaType inferredType = <span class="keyword">this</span>.getInferredType(properties);</span><br><span class="line">    <span class="keyword">if</span> (inferredType != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.canConvert(inferredType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> inferredType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String typeIdHeader = <span class="keyword">this</span>.retrieveHeaderAsString(properties, <span class="keyword">this</span>.getClassIdFieldName());</span><br><span class="line">        <span class="keyword">if</span> (typeIdHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fromTypeHeader(properties, typeIdHeader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.hasInferredTypeHeader(properties) ? <span class="keyword">this</span>.fromInferredTypeHeader(properties) : TypeFactory.defaultInstance().constructType(Object.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>content在进行convertBytesToObject转化过程中报异常,因为byte[]内容是字符串,但转为了Object,而且是通过jackson反序列化转的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String content, JavaType valueType)</span> <span class="keyword">throws</span> JsonProcessingException, JsonMappingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._assertNotNull(<span class="string">&quot;content&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)<span class="keyword">this</span>._readMapAndClose(<span class="keyword">this</span>._jsonFactory.createParser(content), valueType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> JsonMappingException.fromUnexpectedIOE(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>return (T)this._readMapAndClose(this._jsonFactory.createParser(content), valueType);</code>出错. 所以核心原因还是类型设置为octet-stream会被认为是可以json反序列化的对象.如果直接传字符串,jackon会帮我们序列化为字符串,并在消息属性的头部headers设置<code>__TypeId__</code>类型为String. 但我们自己 手动序列化的数据并填充到Message显然不会有这些机制.</p><p><img data-src="https://s2.loli.net/2025/07/24/fde7GAnb34KDgUp.png" alt="image-20250724144930607"></p><p>这时什么时候设置的呢? 其实就是在AbstractJackson2MessageConverter的createMessage时,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getClassMapper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    JavaType type = <span class="keyword">this</span>.objectMapper.constructType((Type)(genericType == <span class="keyword">null</span> ? objectToConvert.getClass() : genericType));</span><br><span class="line">    <span class="keyword">if</span> (genericType != <span class="keyword">null</span> &amp;&amp; !type.isContainerType() &amp;&amp; Modifier.isAbstract(type.getRawClass().getModifiers())) &#123;</span><br><span class="line">        type = <span class="keyword">this</span>.objectMapper.constructType(objectToConvert.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getJavaTypeMapper().fromJavaType(type, messageProperties);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getClassMapper().fromClass(objectToConvert.getClass(), messageProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将对应的类型写入头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromJavaType</span><span class="params">(JavaType javaType, MessageProperties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addHeader(properties, <span class="keyword">this</span>.getClassIdFieldName(), javaType.getRawClass());</span><br><span class="line">    <span class="keyword">if</span> (javaType.isContainerType() &amp;&amp; !javaType.isArrayType()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addHeader(properties, <span class="keyword">this</span>.getContentClassIdFieldName(), javaType.getContentType().getRawClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (javaType.getKeyType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addHeader(properties, <span class="keyword">this</span>.getKeyClassIdFieldName(), javaType.getKeyType().getRawClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Netty 是一个高性能、事件驱动的异步网络应用框架，广泛用于构建可扩展的服务器和客户端程序.</p><p>基于 Java NIO(同步非阻塞IO)，但对其进行了封装和增强，使其更易于使用和性能更优。</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO是Netty 的基石。传统的 I/O（BIO）是阻塞的，每个连接都需要一个线程处理。NIO 允许单个线程处理多个 I/O 操作，通过 <strong>Selector</strong> 机制监听多个 Channel 上的事件，从而实现高并发。Netty 在 NIO 之上进行了抽象和优化，使其使用起来更加简单和高效。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><div class="table-container"><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td><strong>FD 数量限制</strong></td><td>默认 1024/2048 (固定位图)</td><td>无限制 (受限于内存)</td><td>无限制 (受限于内存)</td></tr><tr><td><strong>FD 传递</strong></td><td>每次调用完整复制 (<code>fd_set</code>)</td><td>每次调用完整复制 (<code>pollfd[]</code>)</td><td>一次注册，之后只返回就绪 FD</td></tr><tr><td><strong>效率</strong></td><td>O(N) (遍历所有 FD)</td><td>O(N) (遍历所有 FD)</td><td>O(K) (只遍历就绪 FD, K &lt;&lt; N)</td></tr><tr><td><strong>通知机制</strong></td><td>遍历查找</td><td>遍历查找</td><td>回调机制，内核通知就绪</td></tr><tr><td><strong>工作模式</strong></td><td>水平触发 (LT)</td><td>水平触发 (LT)</td><td>水平触发 (LT) / 边缘触发 (ET)</td></tr><tr><td><strong>“惊群”问题</strong></td><td>存在</td><td>存在</td><td>已优化，通常避免</td></tr><tr><td><strong>API 使用</strong></td><td>相对复杂</td><td>相对简单 (比 <code>select</code>)</td><td>需要三个系统调用 (<code>create</code>, <code>ctl</code>, <code>wait</code>)</td></tr><tr><td><strong>出现时间</strong></td><td>最早</td><td>较早</td><td>Linux 2.5.44+ (最新)</td></tr></tbody></table></div><p>“惊群”问题：<strong>当一个事件发生时，所有等待该事件的进程或线程都被唤醒，但实际上只有其中一个能够处理该事件，导致其他被唤醒的进程/线程做了无用功，并产生不必要的上下文切换开销，从而降低了系统效率和性能。</strong></p><p>FD传递指的是用户空间每次调用<code>select</code>或 <code>poll</code> 时，需要将 <code>fd_set</code>或<code>pollfd</code> 数组从用户空间<strong>完整地复制到内核空间</strong>, FD 就绪时，内核会修改对应 <code>pollfd</code> 结构体中的 <code>revents</code> 字段，并将其<strong>完整地复制回用户空间</strong>。</p><p>而在epoll中用户程序通过 <code>epoll_create()</code> 创建一个 <code>epoll</code> 实例。然后通过 <code>epoll_ctl()</code> <strong>一次性地将所有要监控的 FD 注册到内核的 <code>epoll</code> 事件表中</strong>，并指定感兴趣的事件。这个过程只需要将 FD 及其事件类型从用户空间复制到内核空间一次.</p><p><code>epoll_wait()</code> 调用时，内核<strong>只将就绪列表中的 FD 复制到用户空间</strong>。用户程序只需要遍历这些就绪的 FD 即可。</p><p>通知机制指的是内核修改了fd_set位图的值并完整返回,<code>fd_set</code> 仍然是一个<strong>位图 (bitmap)</strong>。它不像一个列表或数组那样直接给出就绪的 FD 列表。它只是在对应 FD 的位上设置为 1，而其他未就绪的 FD 的位仍为 0。为了知道具体是哪个文件描述符就绪了，用户程序必须遍历逐个检查,poll<code>也是类似的，它返回一个</code>pollfd<code>数组，你需要遍历这个数组来检查每个元素的</code>revents` 字段，找出就绪的 FD。</p><p>而 <code>epoll</code> 则不同，<code>epoll_wait</code> 会直接返回一个<strong>已就绪文件描述符的列表或数组</strong>，用户程序只需要遍历这个较小的就绪列表即可，因此效率更高，时间复杂度是 O(K)。</p><h3 id="Netty相比NIO改进"><a href="#Netty相比NIO改进" class="headerlink" title="Netty相比NIO改进"></a>Netty相比NIO改进</h3><p>Channel-&gt;NioSocketChannel/NioServerSocketChannel</p><p>Selector-&gt;EventLoop/EventLoppGroup</p><p>Buffer-&gt;ByteBuf</p><p>此外通过ChannelPipeline和ChannelHanlder来处理自定义事件.</p><h3 id="EventLoop-amp-EventLoopGroup-事件循环与事件循环组"><a href="#EventLoop-amp-EventLoopGroup-事件循环与事件循环组" class="headerlink" title="EventLoop &amp; EventLoopGroup 事件循环与事件循环组"></a>EventLoop &amp; EventLoopGroup 事件循环与事件循环组</h3><ul><li><strong>EventLoop:</strong> Netty 的核心线程模型。每个 <code>EventLoop</code> 是一个单线程，负责处理一个或多个 <strong>Channel</strong> 上的所有 I/O 事件（如连接建立、数据读写、断开连接），并执行关联的 <strong>ChannelHandler</strong>。它以事件驱动的方式运行，通过一个循环不断地从任务队列中获取事件并执行。</li><li><strong>EventLoopGroup:</strong> 包含一个或多个 <code>EventLoop</code> 的组。通常有两个 <code>EventLoopGroup</code>：<ul><li><strong>BossGroup (或 AcceptorGroup):</strong> 负责处理客户端的连接请求。一旦接受到连接，就会将连接注册到 WorkerGroup 中的某个 <code>EventLoop</code> 上。通常只有一个 <code>EventLoop</code> 或少量 <code>EventLoop</code>。</li><li><strong>WorkerGroup:</strong> 负责处理已建立连接的 I/O 读写事件和业务逻辑。包含多个 <code>EventLoop</code>，以实现并发处理。</li></ul></li></ul><p><strong>Channel 通道</strong> Netty 对网络连接的抽象。可以看作是连接双方进行数据传输的“通道”。所有的 I/O 操作都在 Channel 上进行。不同类型的 Channel 对应不同的传输协议（如 <code>NioSocketChannel</code> 用于 TCP/IP，<code>NioDatagramChannel</code> 用于 UDP）。</p><h3 id="ChannelHandler-amp-ChannelPipeline-处理器与处理器链"><a href="#ChannelHandler-amp-ChannelPipeline-处理器与处理器链" class="headerlink" title="ChannelHandler &amp; ChannelPipeline 处理器与处理器链"></a>ChannelHandler &amp; ChannelPipeline 处理器与处理器链</h3><ul><li><strong>ChannelHandler:</strong> 消息处理的核心组件。它是一个接口，定义了处理入站 (Inbound) 或出站 (Outbound) 事件的方法。<ul><li><strong>ChannelInboundHandler:</strong> 处理从网络读入的数据（入站事件），例如接收到连接、读取数据、处理异常等。</li><li><strong>ChannelOutboundHandler:</strong> 处理向网络写入的数据（出站事件），例如发送数据、连接断开等。</li><li>你可以自定义 <code>ChannelHandler</code> 来实现协议编解码、业务逻辑处理、日志记录、流量控制等功能。</li></ul></li><li><strong>ChannelPipeline:</strong> <code>ChannelHandler</code> 的链表。每个 <code>Channel</code> 都有一个 <code>ChannelPipeline</code>。当 I/O 事件发生时，数据会沿着 <code>ChannelPipeline</code> 在不同的 <code>ChannelHandler</code> 之间流动，形成一个责任链模式。<ul><li><strong>入站事件 (Inbound Event):</strong> 数据从网络流入，从 <code>ChannelPipeline</code> 的头部（第一个 <code>ChannelHandler</code>）开始，依次向后传递，直到链的尾部。</li><li><strong>出站事件 (Outbound Event):</strong> 数据从应用程序流出到网络，从 <code>ChannelPipeline</code> 的尾部（通常是触发写入操作的地方）开始，依次向前传递，直到链的头部。</li></ul></li></ul><h3 id="ByteBuf-字节缓冲区"><a href="#ByteBuf-字节缓冲区" class="headerlink" title="ByteBuf 字节缓冲区"></a>ByteBuf 字节缓冲区</h3><p> Netty 自己的高性能字节缓冲区，用于替换 Java NIO 的 <code>ByteBuffer</code>。<code>ByteBuf</code> 提供了许多优化和改进，使其更易于使用，例如：</p><ul><li><strong>读写指针分离：</strong> 独立的 <code>readerIndex</code> 和 <code>writerIndex</code>，避免了 <code>ByteBuffer</code> 复杂的 <code>flip()</code> 操作。</li><li><strong>动态扩容：</strong> 当容量不足时，可以自动扩容。</li><li><strong>零拷贝 (Zero-Copy)：</strong> 通过复合缓冲区（CompositeByteBuf）和切片（Slice）等机制，尽量减少数据在内存中的拷贝，提高性能。</li><li><strong>引用计数：</strong> 自动管理内存，防止内存泄漏。</li></ul><h3 id="Future-amp-Promise-异步结果与承诺"><a href="#Future-amp-Promise-异步结果与承诺" class="headerlink" title="Future &amp; Promise 异步结果与承诺"></a>Future &amp; Promise 异步结果与承诺</h3><ul><li><strong>Future:</strong> Java 并发包中的 <code>Future</code> 增强版。在 Netty 中，所有的 I/O 操作都是异步的，它们会立即返回一个 <code>ChannelFuture</code> 对象。你可以通过监听 <code>ChannelFuture</code> 来获取操作的最终结果（成功、失败或取消）。</li><li><strong>Promise:</strong> <code>Future</code> 的子接口，允许在某个点设置 <code>Future</code> 的结果，从而完成异步操作。</li></ul><h3 id="编解码器-Encoders-amp-Decoders"><a href="#编解码器-Encoders-amp-Decoders" class="headerlink" title="编解码器 (Encoders &amp; Decoders)"></a>编解码器 (Encoders &amp; Decoders)</h3><p><code>ChannelHandler</code> 的特殊形式，用于将原始字节数据转换为特定协议的消息对象，以及将消息对象转换回字节数据。</p><ul><li><strong>Decoder (入站):</strong> 将字节流解码成 Java 对象。</li><li><strong>Encoder (出站):</strong> 将 Java 对象编码成字节流。</li><li>Netty 提供了许多内置的编解码器（如 <code>StringEncoder</code>/<code>StringDecoder</code>、HTTP 编解码器），也支持自定义协议编解码。</li></ul><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>关于 Netty 的问题通常会围绕其高性能、异步特性和核心组件展开。</p><p><strong>Netty 的优势和使用场景</strong></p><ul><li><strong>为什么用 Netty？</strong> 高性能、高并发、异步非阻塞、易于开发、稳定可靠、社区活跃。</li><li><strong>能用来做什么？</strong> RPC 框架（Dubbo、gRPC）、IM 系统、游戏服务器、大数据传输、消息中间件、HTTP 服务器、WebSocket 服务器、代理服务器等。</li></ul><ol><li><p><strong>Netty 的线程模型</strong></p><ul><li><strong>EventLoopGroup (Boss/Worker) 的作用？</strong> </li><li><strong>BossGroup (或 AcceptorGroup)</strong>：主要负责<strong>处理客户端的连接请求</strong>。当有新的客户端连接到来时，BossGroup 中的一个 <code>EventLoop</code> 会接受这个连接，并将其注册到 WorkerGroup 中的一个 <code>EventLoop</code> 上。BossGroup 通常只需要一个或少数 <code>EventLoop</code>。</li><li><strong>WorkerGroup</strong>：负责处理<strong>已建立连接的 I/O 读写事件和业务逻辑</strong>。WorkerGroup 包含多个 <code>EventLoop</code>，每个 <code>EventLoop</code> 都可以处理多个 <code>Channel</code>（连接）上的事件。</li></ul><p><strong>Channel 分配机制：</strong> 当 BossGroup 接受一个新连接后，它会使用一个<strong>轮询（Round-Robin）或其他策略，将这个新连接（<code>Channel</code>）注册到 WorkerGroup 中一个特定的 EventLoop</strong> 上。一旦一个 <code>Channel</code> 被分配给某个 <code>EventLoop</code>，该 <code>Channel</code> 的所有后续 I/O 事件（读、写、关闭等）都将由这个 <code>EventLoop</code> 线程负责处理，从而保证了单个 <code>Channel</code> 的事件处理是<strong>线程安全的和有序的</strong></p><ul><li><p><strong>为什么是单线程 EventLoop？</strong></p><p> 避免了多线程并发访问 <code>Channel</code> 带来的同步开销和复杂性，简化了并发编程模型。一个 <code>Channel</code> 上的所有事件都由同一个 <code>EventLoop</code> 线程顺序处理，保证了事件的顺序性。</p></li><li><p><strong>I/O 线程和业务线程分离：</strong> 业务逻辑如果在 <code>ChannelHandler</code> 中耗时过长，会阻塞 <code>EventLoop</code> 线程，影响其他 Channel 的 I/O 处理。如何解决？（使用 <code>EventLoop.execute()</code> 提交任务到 EventLoop 线程，或使用 <code>EventLoopGroup</code> 的 <code>next().submit()</code> 提交到另一个线程池）。</p></li></ul><p>如果 <code>ChannelHandler</code> 中的业务逻辑执行时间过长，确实会阻塞 <code>EventLoop</code> 线程，导致该 <code>EventLoop</code> 负责的其他 <code>Channel</code> 的 I/O 事件无法及时处理，影响系统的响应性和吞吐量。解决这个问题通常有两种方法：</p><ol><li><strong>提交任务到 EventLoop 线程：</strong> 对于一些轻量级但又不希望立即执行的任务，可以通过 <code>EventLoop.execute(Runnable task)</code> 或 <code>EventLoop.submit(Callable&lt;T&gt; task)</code> 将任务提交到 <code>EventLoop</code> 自身维护的任务队列中。这些任务会在 I/O 操作空闲时被 <code>EventLoop</code> 线程顺序执行，但如果任务依然耗时，仍可能阻塞。</li><li><strong>使用独立的业务线程池：</strong> 这是更常用的方法，适用于耗时长的业务逻辑。在 <code>ChannelHandler</code> 中，当接收到消息并需要进行耗时操作时，不直接在 <code>EventLoop</code> 线程中执行，而是将该业务逻辑<strong>提交到一个独立的业务线程池（例如 <code>ThreadPoolExecutor</code>）</strong>中执行。当业务逻辑处理完成后，再将结果通过 <code>ChannelHandlerContext</code> 写回 <code>Channel</code>。</li></ol></li><li><p><strong>ChannelPipeline 和 ChannelHandler</strong></p><ul><li><strong>ChannelPipeline 是什么？</strong> </li></ul><p><strong>ChannelPipeline</strong> 是一个 <code>ChannelHandler</code> 的有序链表。每个 <code>Channel</code> 都有且只有一个 <code>ChannelPipeline</code>。它扮演着事件处理的<strong>责任链</strong>角色，负责协调和管理 <code>ChannelHandler</code> 的执行顺序。</p><p>双向链表的设计是为了支持消息流的<strong>双向性</strong>：</p><ul><li><strong>入站事件 (Inbound Event)</strong>：数据从网络流入应用程序（例如客户端发送数据到服务器），事件从 <code>ChannelPipeline</code> 的<strong>头部</strong>（第一个 <code>ChannelHandler</code>）开始，依次向后传递。</li><li><p><strong>出站事件 (Outbound Event)</strong>：数据从应用程序流出到网络（例如服务器向客户端发送响应），事件从 <code>ChannelPipeline</code> 的<strong>尾部</strong>（通常是业务逻辑触发 <code>write</code> 操作）开始，依次向前传递</p></li><li><p><strong><code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 的区别？</strong> </p></li></ul><p><strong><code>ChannelInboundHandler</code> (入站处理器)：</strong></p><ul><li><strong>职责：</strong> 主要处理从网络端流入到应用程序的事件，例如：连接激活 (<code>channelActive()</code>)、读取数据 (<code>channelRead()</code>)、连接断开 (<code>channelInactive()</code>)、处理异常 (<code>exceptionCaught()</code>) 等。</li><li><strong>处理顺序：</strong> 在 <code>ChannelPipeline</code> 中，入站事件从<strong>头部向尾部</strong>流动，依次经过每个 <code>ChannelInboundHandler</code>。</li></ul><p><strong><code>ChannelOutboundHandler</code> (出站处理器)：</strong></p><ul><li><strong>职责：</strong> 主要处理从应用程序流出到网络端的事件，例如：写入数据 (<code>write()</code>)、连接 (<code>connect()</code>)、绑定 (<code>bind()</code>)、关闭 (<code>close()</code>) 等。</li><li><p><strong>处理顺序：</strong> 在 <code>ChannelPipeline</code> 中，出站事件从<strong>尾部向头部</strong>流动，依次经过每个 <code>ChannelOutboundHandler</code>。</p></li><li><p><strong>如何自定义 Handler？</strong> 常见的 <code>SimpleChannelInboundHandler</code> 和 <code>ChannelDuplexHandler</code>。</p></li><li><strong><code>ChannelHandlerContext</code> 的作用？</strong> 用于与 Pipeline 中的其他 Handler 交互，以及触发事件。</li></ul><p><strong>ChannelHandlerContext</strong> 是 <code>ChannelHandler</code> 与 <code>ChannelPipeline</code> 以及其他 <code>ChannelHandler</code> 之间交互的桥梁。每个 <code>ChannelHandler</code> 被添加到 <code>ChannelPipeline</code> 时，都会创建一个对应的 <code>ChannelHandlerContext</code> 实例。</p><ul><li><strong>消息在 Pipeline 中传递的机制？</strong> <code>fireChannelRead()</code>、<code>write()</code> 等方法。</li></ul></li><li><p><strong>ByteBuf 内存管理</strong></p><ul><li><strong>为什么不用 <code>ByteBuffer</code> 而用 <code>ByteBuf</code>？</strong> 读写指针分离、动态扩容、引用计数、零拷贝。</li><li><strong><code>readerIndex</code> 和 <code>writerIndex</code>？</strong> 如何操作数据？</li><li><strong><code>ByteBuf</code> 的引用计数？</strong> 为什么重要？如何避免内存泄漏？（<code>retain()</code> 和 <code>release()</code>）</li><li><strong>堆内存 (Heap ByteBuf) 和直接内存 (Direct ByteBuf) 的区别？</strong> 优缺点？什么时候用哪个？（Direct ByteBuf 减少一次拷贝，适用于大文件传输；Heap ByteBuf 更易于 GC）。</li></ul></li><li><p><strong>零拷贝 (Zero-Copy)</strong></p><ul><li><strong>Netty 如何实现零拷贝？</strong> 概念、<code>FileRegion</code>、<code>CompositeByteBuf</code>、<code>ByteBuf.slice()</code>。</li><li><strong>零拷贝的优势？</strong> 减少 CPU 拷贝，提高 I/O 性能。</li></ul><h4 id="什么是-TCP-粘包-拆包？Netty-是如何解决的？"><a href="#什么是-TCP-粘包-拆包？Netty-是如何解决的？" class="headerlink" title="什么是 TCP 粘包/拆包？Netty 是如何解决的？"></a>什么是 TCP 粘包/拆包？Netty 是如何解决的？</h4><p><strong>回答要点：</strong></p><ul><li><strong>什么是粘包/拆包？</strong><ul><li>TCP 是一个<strong>流式协议</strong>，它不保证每次 <code>read()</code> 或 <code>write()</code> 系统调用对应一个完整的应用层消息。它会把应用层发送的数据看作一个字节流，可能会将小的消息合并（<strong>粘包</strong>）成一个大的 TCP 包发送，也可能将一个大的应用层消息拆分成多个小的 TCP 包（<strong>拆包</strong>）发送。</li><li><strong>粘包：</strong> 发送方发送了两个独立的小消息 A 和 B，TCP 层可能将它们合并成一个数据包发送，接收方一次性收到 A+B。</li><li><strong>拆包：</strong> 发送方发送一个大的消息 C，TCP 层可能将其拆分成多个数据包发送，接收方需要多次读取才能得到完整的 C。</li></ul></li><li><strong>为什么会发生？</strong><ul><li>TCP 缓冲区机制。</li><li>Nagle 算法（小数据包合并）。</li><li>发送方每次发送的数据量与接收方每次读取的数据量不一致。</li></ul></li><li><strong>Netty 如何解决？</strong><ul><li>Netty 不直接在 TCP 层解决，而是在<strong>应用层</strong>通过<strong>编解码器（Decoder）</strong>来解决。它提供了多种开箱即用的 <code>ChannelInboundHandler</code>（解码器），用于根据特定的应用层协议规则来解析字节流，将原始字节数据正确地分割成完整的、逻辑上的消息帧：<ul><li><strong><code>FixedLengthFrameDecoder</code>：</strong> 固定长度帧解码器，按照预设的固定长度切分消息。</li><li><strong><code>LineBasedFrameDecoder</code>：</strong> 行解码器，根据换行符（<code>\n</code> 或 <code>\r\n</code>）切分消息。</li><li><strong><code>DelimiterBasedFrameDecoder</code>：</strong> 分隔符解码器，根据用户指定的特殊分隔符切分消息。</li><li><strong><code>LengthFieldBasedFrameDecoder</code>：</strong> <strong>基于长度字段的帧解码器</strong>（最常用和推荐），在消息的头部包含一个表示消息体长度的字段。解码器会先读取这个长度字段，然后等待足够的数据到达，再截取对应长度的消息体。</li></ul></li></ul></li></ul></li><li><p><strong>编解码器 (Encoders/Decoders)</strong></p><ul><li><strong>编解码器的作用？</strong> 为什么需要它们？</li><li><strong>与 <code>ChannelHandler</code> 的关系？</strong></li></ul></li><li><p><strong>Netty 的异步特性</strong></p><ul><li><strong>I/O 操作都是异步的，如何获取结果？</strong> <code>ChannelFuture</code> 和 <code>ChannelFutureListener</code>。</li><li><strong><code>Promise</code> 和 <code>Future</code> 的区别？</strong></li></ul></li><li><p><strong>与 Java NIO 的关系和区别</strong></p><ul><li><strong>Netty 是对 Java NIO 的封装和增强，解决了哪些 NIO 的痛点？</strong> (API 复杂、Selector Bug、缓冲区管理困难、多线程处理等)。</li></ul></li><li><p><strong>Netty 的连接管理和心跳机制</strong></p><ul><li><strong>IdleStateHandler：</strong> 如何检测连接空闲？</li><li><strong>心跳消息：</strong> 如何实现客户端和服务端的心跳？</li></ul><p><strong><code>IdleStateHandler</code></strong> 是 Netty 提供的一个 <code>ChannelHandler</code>，用于检测连接的空闲状态（即在指定时间内没有读或写操作发生）。</p><ul><li><strong>原理：</strong> <code>IdleStateHandler</code> 会在 <code>ChannelPipeline</code> 中维护一个定时任务。当连接在指定的 <code>readerIdleTime</code>（读空闲时间）、<code>writerIdleTime</code>（写空闲时间）或 <code>allIdleTime</code>（总空闲时间）内没有相应的 I/O 操作时，它会触发一个 <strong><code>IdleStateEvent</code></strong> 事件，并将其传递到 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code>。</li><li><strong>使用方式：</strong> 通常，你需要在 <code>IdleStateHandler</code> 之后再添加一个自定义的 <code>ChannelInboundHandler</code>（例如继承 <code>ChannelInboundHandlerAdapter</code>），并重写其 <code>userEventTriggered(ChannelHandlerContext ctx, Object evt)</code> 方法来捕获并处理 <code>IdleStateEvent</code>。</li></ul><p>心跳消息是利用 <code>IdleStateHandler</code> 检测到的空闲状态，在客户端或服务端发送的周期性短消息，用于维持连接的活性、检测连接的可用性以及防止因长时间空闲而被防火墙或路由器关闭。</p><p><strong>实现步骤：</strong></p><ol><li><strong>添加 <code>IdleStateHandler</code>：</strong> 在客户端和服务器端的 <code>ChannelPipeline</code> 中都添加 <code>IdleStateHandler</code>，配置合适的读/写/总空闲时间。</li><li><strong>自定义 <code>HeartbeatHandler</code>：</strong> 在 <code>IdleStateHandler</code> 之后添加一个自定义的 <code>ChannelInboundHandler</code>。</li><li><strong>处理 <code>IdleStateEvent</code>：</strong><ul><li><strong>客户端：</strong> 当检测到<strong>写空闲（<code>IdleState.WRITER_IDLE</code>）</strong>时，客户端发送一个心跳请求消息给服务器。</li><li><strong>服务端：</strong> 当检测到<strong>读空闲（<code>IdleState.READER_IDLE</code>）</strong>时，表示客户端可能已经断开或处于异常状态。此时，服务器可以发送一个心跳响应消息，或直接关闭连接。如果服务器也发送了心跳请求，它会期望客户端在指定时间内返回响应。</li></ul></li><li><strong>心跳消息的响应：</strong><ul><li>服务端收到心跳请求后，应该立即回复一个心跳响应消息。</li><li>客户端收到心跳响应后，确认连接正常。</li></ul></li><li><strong>超时处理：</strong><ul><li>如果在发送心跳请求后，在规定时间内没有收到心跳响应，则认为连接已断开，可以主动关闭连接。这通常在 <code>HeartbeatHandler</code> 中通过计数器实现。</li></ul></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组 boosGroup、workerGroup</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动对象，设置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//设置两个线程组boosGroup和workerGroup</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">//设置服务端通道实现类型    </span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//设置线程队列得到连接个数    </span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//设置保持活动连接状态    </span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//使用匿名内部类的形式初始化通道对象    </span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//给pipeline管道设置处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);<span class="comment">//给workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">6666</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>MongoDB 是一款流行的<strong>NoSQL 文档型数据库</strong>，以其<strong>灵活的数据模型、可伸缩性和高性能</strong>而闻名。它广泛应用于需要处理大量非结构化或半结构化数据、以及需要快速迭代的应用场景。在面试中，MongoDB 经常作为后端数据存储、大数据或微服务架构中的组件被提及。</p><h2 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a>关键概念</h2><p><strong>Document (文档)</strong></p><ul><li><strong>核心单位：</strong> 文档是 MongoDB 中数据的基本单位，类似于关系型数据库中的<strong>行 (row)</strong>。</li><li><strong>JSON-like 格式：</strong> 文档以类似 JSON 的 BSON (Binary JSON) 格式存储。BSON 支持更多的数据类型（如日期、二进制数据）并且是二进制编码，这使得存储和传输更高效。</li><li><strong>无模式 (Schemaless/Schema-less)：</strong> 这是 MongoDB 最重要的特性之一。同一个集合中的文档可以拥有不同的字段，字段的类型也可以不同。这提供了极大的灵活性，方便快速迭代和适应变化的需求。</li><li><strong>面试点：</strong> 理解文档是 MongoDB 的核心，其无模式特性提供了灵活性</li></ul><p><strong>Collection (集合)</strong></p><ul><li><strong>逻辑分组：</strong> 集合是文档的逻辑分组，类似于关系型数据库中的<strong>表 (table)</strong>。</li><li><strong>无固定结构：</strong> 集合不强制文档的结构，但通常同一集合中的文档会包含类似或相关的数据。</li><li><strong>面试点：</strong> 知道集合是文档的容器，其无模式特性与集合的关系。</li></ul><p><strong>Database (数据库)</strong></p><ul><li><strong>容器：</strong> 数据库是集合的物理容器，类似于关系型数据库中的<strong>数据库 (database)</strong>。</li><li><strong>多数据库：</strong> 一个 MongoDB 实例可以承载多个数据库。</li><li><strong>面试点：</strong> 数据库是组织集合的单元。</li></ul><p><strong>_id 字段</strong></p><ul><li><strong>主键：</strong> 每个文档在创建时都会自动生成一个唯一的 <code>_id</code> 字段作为其主键，除非你手动指定。</li><li><strong>ObjectID：</strong> 默认情况下，<code>_id</code> 的类型是 <code>ObjectID</code>，它是一个 12 字节的 BSON 类型，结合了时间戳、机器标识符、进程 ID 和计数器，以确保全局唯一性。</li><li><strong>面试点：</strong> 了解 <code>_id</code> 的作用和 <code>ObjectID</code> 的组成。</li></ul><p><strong>Index (索引)</strong></p><ul><li><strong>提高查询效率：</strong> 索引是 MongoDB 提高查询性能的关键。它允许数据库快速定位数据，而无需扫描整个集合。</li><li><strong>种类：</strong> 支持单字段索引、复合索引、多键索引（用于数组字段）、文本索引（用于全文搜索）、地理空间索引等。</li><li><strong>面试点：</strong> 索引的重要性，以及不同类型索引的适用场景。<strong>复合索引</strong>和<strong>多键索引</strong>是常考点。</li></ul><p><strong>Aggregation (聚合)</strong></p><ul><li><strong>数据处理：</strong> 聚合操作允许你对数据进行复杂的处理，如分组、筛选、转换、计算等，以生成汇总报告或分析结果。</li><li><strong>聚合管道 (Aggregation Pipeline)：</strong> 这是 MongoDB 最强大的聚合工具。它由一系列阶段 (stages) 组成，数据在这些阶段中依次处理，每个阶段的输出作为下一个阶段的输入。</li><li><strong>面试点：</strong> 理解聚合管道的工作原理，常用阶段（<code>$match</code>, <code>$group</code>, <code>$project</code>, <code>$sort</code>, <code>$limit</code>, <code>$unwind</code>）及其用途。</li></ul><p><strong>Replication (副本集)</strong></p><ul><li><strong>高可用性与数据冗余：</strong> 副本集是 MongoDB 提供<strong>高可用性</strong>和<strong>数据冗余</strong>的机制。它是一组维护相同数据集的 MongoDB 实例。</li><li><strong>Primary-Secondary 架构：</strong> 副本集中有一个主节点 (Primary)，负责处理所有写入操作和读操作。其他是从节点 (Secondary)，它们复制主节点的数据，并可以处理读操作（如果配置允许）。</li><li><strong>自动故障转移：</strong> 当主节点发生故障时，副本集会自动选举一个从节点成为新的主节点，从而保证服务持续可用。</li><li><strong>面试点：</strong> <strong>高频考点。</strong> 理解副本集的工作原理，主从节点的作用，以及自动故障转移过程。</li></ul><p><strong>Sharding (分片)</strong></p><ul><li><strong>水平扩展：</strong> 分片是 MongoDB 提供<strong>水平扩展</strong>的方式，用于处理大量数据和高吞吐量操作。它将数据分布在多个独立的服务器（称为分片或 Shard）上。</li><li><strong>组成：</strong><ul><li><strong>Shard (分片)：</strong> 存储部分数据的独立副本集。</li><li><strong>Config Server (配置服务器)：</strong> 存储集群的元数据（分片信息、数据分布规则）。</li><li><strong>Mongos (路由进程)：</strong> 负责处理客户端请求，将请求路由到正确的分片，并聚合结果。</li></ul></li><li><strong>面试点：</strong> <strong>高频考点。</strong> 理解分片解决的问题（海量数据存储和高并发），以及分片集群的各个组件及其职责。</li></ul><p><strong>CRUD 操作 (Create, Read, Update, Delete)</strong></p><ul><li>MongoDB 提供了丰富的操作来对文档进行增删改查。</li><li><strong><code>insertOne()</code>, <code>insertMany()</code></strong>: 插入文档。</li><li><strong><code>find()</code>, <code>findOne()</code></strong>: 查询文档（支持强大的查询语言，包括嵌套文档查询、数组查询、聚合查询等）。</li><li><strong><code>updateOne()</code>, <code>updateMany()</code>, <code>replaceOne()</code></strong>: 更新文档。</li><li><strong><code>deleteOne()</code>, <code>deleteMany()</code></strong>: 删除文档。</li><li><strong>面试点：</strong> 熟悉基本的 CRUD 操作语法和常用查询方法。</li></ul><h2 id="关键问题-1"><a href="#关键问题-1" class="headerlink" title="关键问题"></a>关键问题</h2><h3 id="什么是-NoSQL-数据库？MongoDB-属于哪种-NoSQL-类型？"><a href="#什么是-NoSQL-数据库？MongoDB-属于哪种-NoSQL-类型？" class="headerlink" title="什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？"></a>什么是 NoSQL 数据库？MongoDB 属于哪种 NoSQL 类型？</h3><ul><li><p><strong>NoSQL 定义：</strong> Not Only SQL。它是一类不使用传统关系型数据库的表格模型存储数据的数据存储系统。NoSQL 数据库通常为了特定的数据模型和访问模式而优化，牺牲了部分关系型数据库的特性（如强 ACID 事务和 JOIN 操作）来换取更高的可伸缩性、灵活性和性能。</p></li><li><p><strong>MongoDB 类型：</strong> <strong>文档型数据库</strong>。数据以类似 JSON 的 BSON（Binary JSON）格式的文档形式存储</p><h3 id="MongoDB-的核心特点是什么？"><a href="#MongoDB-的核心特点是什么？" class="headerlink" title="MongoDB 的核心特点是什么？"></a>MongoDB 的核心特点是什么？</h3><ul><li><strong>文档模型：</strong> 数据以 BSON 格式的文档存储，结构灵活，无模式 (Schema-less)，易于开发迭代。</li><li><strong>高可用性：</strong> 通过<strong>副本集（Replica Set）</strong>实现自动故障转移和数据冗余。</li><li><strong>水平扩展：</strong> 通过<strong>分片（Sharding）</strong>技术将数据分布到多个服务器，处理海量数据和高并发。</li><li><strong>高性能：</strong> 文档模型、索引、内存映射文件等优化手段提供了出色的读写性能。</li><li><strong>丰富的查询语言：</strong> 支持强大的查询语言，包括嵌套文档查询、聚合框架等。</li></ul></li></ul><h3 id="MongoDB-的-id-字段有什么特殊之处？"><a href="#MongoDB-的-id-字段有什么特殊之处？" class="headerlink" title="MongoDB 的 _id 字段有什么特殊之处？"></a>MongoDB 的 <code>_id</code> 字段有什么特殊之处？</h3><ul><li><strong>主键：</strong> 每个 MongoDB 文档都必须包含一个 <code>_id</code> 字段，作为其在集合中的<strong>唯一主键</strong>。</li><li><strong>自动生成：</strong> 如果插入文档时未指定 <code>_id</code>，MongoDB 会自动生成一个 <code>ObjectID</code> 作为其值。</li><li><strong>ObjectID 组成：</strong> <code>ObjectID</code> 是一个 12 字节的 BSON 类型，它包含时间戳、机器标识符、进程 ID 和一个计数器，确保了全局唯一性。</li><li><strong>不可变性：</strong> <code>_id</code> 字段的值一旦创建就不可更改。</li></ul><h3 id="什么是副本集（Replica-Set）？它有什么作用？"><a href="#什么是副本集（Replica-Set）？它有什么作用？" class="headerlink" title="什么是副本集（Replica Set）？它有什么作用？"></a>什么是副本集（Replica Set）？它有什么作用？</h3><ul><li><strong>定义：</strong> 副本集是一组维护相同数据集的 MongoDB 实例。它由一个<strong>主节点 (Primary)</strong> 和一个或多个<strong>从节点 (Secondary)</strong> 组成。</li><li><strong>作用：</strong><ul><li><strong>高可用性：</strong> 当主节点发生故障时，副本集会自动选举一个健康的从节点成为新的主节点，确保服务持续可用，避免单点故障。</li><li><strong>数据冗余：</strong> 从节点复制主节点的数据，提供数据的多份副本，防止数据丢失。</li><li><strong>读扩展：</strong> 可以配置从节点处理读请求（但要注意读的最终一致性），从而分散主节点的读负载。</li></ul></li><li><strong>工作原理简述：</strong> 所有写入操作都在主节点上进行，然后通过<strong>操作日志 (Oplog)</strong> 异步复制到所有从节点。</li></ul><h3 id="什么是分片（Sharding）？为什么要使用分片？"><a href="#什么是分片（Sharding）？为什么要使用分片？" class="headerlink" title="什么是分片（Sharding）？为什么要使用分片？"></a>什么是分片（Sharding）？为什么要使用分片？</h3><ul><li><strong>定义：</strong> 分片是一种<strong>水平扩展（Horizontal Scaling）\</strong>的技术。它将大型数据集分布存储到多个独立的数据库实例（即*<em>分片/Shard*</em>）上。</li><li><strong>为什么要用：</strong><ul><li><strong>处理海量数据：</strong> 单个服务器的存储容量和内存有限，分片可以突破这些限制。</li><li><strong>高并发和吞吐量：</strong> 将查询和写入负载分散到多个分片上，提高系统的整体吞吐量。</li><li><strong>降低成本：</strong> 可以使用更多的廉价服务器替代少数昂贵的高配服务器。</li></ul></li><li><strong>分片集群的组成：</strong><ul><li><strong>Shards (分片)：</strong> 存储部分数据的独立副本集。</li><li><strong>Config Servers (配置服务器)：</strong> 存储集群的元数据（分片信息、数据分布规则）。</li><li><strong>Mongos (路由进程)：</strong> 处理客户端请求，将请求路由到正确的分片，并聚合结果。</li></ul></li></ul><h3 id="解释-MongoDB-的数据模型设计：嵌入式文档（Embedded-Documents）与引用（References）的区别和选择。"><a href="#解释-MongoDB-的数据模型设计：嵌入式文档（Embedded-Documents）与引用（References）的区别和选择。" class="headerlink" title="解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。"></a>解释 MongoDB 的数据模型设计：嵌入式文档（Embedded Documents）与引用（References）的区别和选择。</h3><ul><li><strong>嵌入式文档：</strong> 将相关数据直接嵌套存储在同一个文档中。<ul><li><strong>优点：</strong> 单次查询即可获取所有数据，读性能好；原子性操作（对单个文档的更新）。</li><li><strong>缺点：</strong> 单文档大小限制（16MB）；数据冗余（如果子文档被多处引用）；更新复杂性（大文档更新或增长）。</li><li><strong>适用场景：</strong> 一对一、一对多关系（子文档数量有限且不常变），数据紧密耦合且经常一起查询。</li></ul></li><li><strong>引用：</strong> 通过存储另一个文档的 <code>_id</code> 来建立文档间的关联，类似关系型数据库的外键。需要使用 <code>$lookup</code> 或在应用层进行多次查询来获取关联数据。<ul><li><strong>优点：</strong> 减少数据冗余；突破文档大小限制；灵活处理多对多关系。</li><li><strong>缺点：</strong> 需要多次查询或使用 <code>$lookup</code>，性能可能不如嵌入式文档；查询逻辑可能更复杂。</li><li><strong>适用场景：</strong> 多对多关系；一对多关系（子文档数量多且动态增长）；数据独立性强，不总是与父文档一起查询。</li></ul></li><li><strong>选择策略：</strong> 核心原则是<strong>“应用程序如何使用数据”</strong>。优先考虑将那些原子性高、总是被一起查询的数据<strong>嵌入</strong>到文档中。对于那些独立存在、会被大量引用或可能变得很大的数据，使用<strong>引用</strong>。</li></ul><h3 id="什么是-MongoDB-的索引？有哪些常用的索引类型？"><a href="#什么是-MongoDB-的索引？有哪些常用的索引类型？" class="headerlink" title="什么是 MongoDB 的索引？有哪些常用的索引类型？"></a>什么是 MongoDB 的索引？有哪些常用的索引类型？</h3><ul><li><strong>作用：</strong> 索引是提高查询性能的关键。它允许数据库快速定位到匹配查询条件的文档，而无需扫描整个集合。</li><li><strong>常用类型：</strong><ul><li><strong>单字段索引：</strong> 在单个字段上创建。</li><li><strong>复合索引 (Compound Index)：</strong> 在多个字段上创建，字段顺序很重要（最左前缀原则），支持多字段查询和排序。</li><li><strong>多键索引 (Multikey Index)：</strong> 自动为包含<strong>数组</strong>的字段创建，为数组中每个元素创建索引条目，支持对数组内容的查询。</li><li><strong>文本索引 (Text Index)：</strong> 支持对字符串内容进行全文搜索。</li><li><strong>地理空间索引 (Geospatial Index)：</strong> 支持地理位置数据（如点、线、多边形）的查询。</li><li><strong>TTL 索引 (Time-to-Live Index)：</strong> 自动删除特定时间后过期的文档。</li></ul></li></ul><h3 id="什么是聚合框架（Aggregation-Framework）？常用的聚合阶段有哪些？"><a href="#什么是聚合框架（Aggregation-Framework）？常用的聚合阶段有哪些？" class="headerlink" title="什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？"></a>什么是聚合框架（Aggregation Framework）？常用的聚合阶段有哪些？</h3><ul><li><strong>定义：</strong> 聚合框架是 MongoDB 中进行数据处理和分析的强大工具。它允许你通过一系列的<strong>管道阶段 (Pipeline Stages)</strong> 来转换和组合文档，生成聚合结果。</li><li><strong>常用阶段：</strong><ul><li><strong><code>$match</code>：</strong> 过滤文档，只将符合条件的文档传递到下一个阶段。</li><li><strong><code>$group</code>：</strong> 按指定字段对文档进行分组，并对每个组执行聚合操作（如 <code>$sum</code>, <code>$avg</code>, <code>$count</code>）。</li><li><strong><code>$project</code>：</strong> 重构文档的形状，可以选择、排除或添加新字段。</li><li><strong><code>$sort</code>：</strong> 对文档进行排序。</li><li><strong><code>$limit</code>：</strong> 限制通过管道的文档数量。</li><li><strong><code>$skip</code>：</strong> 跳过指定数量的文档。</li><li><strong><code>$unwind</code>：</strong> 将文档中的数组字段“解构”，为数组中的每个元素生成一个单独的文档。</li><li><strong><code>$lookup</code>：</strong> 执行左外连接，从另一个集合中获取关联文档。</li></ul></li></ul><h3 id="MongoDB-如何保证数据一致性（特别是事务）？"><a href="#MongoDB-如何保证数据一致性（特别是事务）？" class="headerlink" title="MongoDB 如何保证数据一致性（特别是事务）？"></a>MongoDB 如何保证数据一致性（特别是事务）？</h3><ul><li><strong>原子性：</strong> MongoDB 的写入操作（如 <code>insertOne()</code>, <code>updateOne()</code>）在<strong>单个文档级别</strong>是原子性的。</li><li><strong>事务（MongoDB 4.0+）：</strong> 从 MongoDB 4.0 开始，引入了<strong>多文档事务（Multi-Document Transactions）</strong>。这意味着你可以在多个文档、多个集合乃至多个分片上执行符合 ACID 的事务。<ul><li><strong>隔离级别：</strong> 通常提供快照隔离，确保事务期间的数据一致性。</li><li><strong>限制：</strong> 相较于关系型数据库的事务，仍有一些限制（如性能开销、超时）。</li></ul></li><li><strong>副本集的一致性：</strong> 副本集通过 Oplog 复制实现最终一致性。你可以通过<strong>读偏好（Read Preference）</strong>和<strong>写关注（Write Concern）</strong>来调整一致性级别。<ul><li><strong>读偏好：</strong> 决定从主节点还是从节点读取数据（如 <code>primary</code>, <code>primaryPreferred</code>, <code>secondary</code>, <code>secondaryPreferred</code>, <code>nearest</code>）。</li><li><strong>写关注：</strong> 决定写入操作成功需要多少个节点的确认（如 <code>w:1</code> 写入主节点，<code>w:majority</code> 写入多数节点）。</li></ul></li></ul><h3 id="MongoDB-的缺点或局限性是什么？"><a href="#MongoDB-的缺点或局限性是什么？" class="headerlink" title="MongoDB 的缺点或局限性是什么？"></a>MongoDB 的缺点或局限性是什么？</h3><ul><li><strong>Join 操作：</strong> 虽然有 <code>$lookup</code>，但其功能和性能不如关系型数据库的 JOIN 强大和灵活。复杂的跨集合查询可能需要多次 <code>$lookup</code> 或在应用层处理。</li><li><strong>事务复杂性：</strong> 4.0+ 虽引入了多文档事务，但相较于关系型数据库，仍有学习成本和性能考量。</li><li><strong>模式缺失：</strong> 虽然是优势，但有时也可能导致数据混乱，需要应用层严格管理数据结构。</li><li><strong>数据冗余：</strong> 为了查询性能，可能需要牺牲范式化，导致数据冗余。</li><li><strong>内存使用：</strong> 有些操作（如排序、聚合）可能需要大量内存。</li></ul><h3 id="什么时候会选择-MongoDB-而不是关系型数据库？什么时候不选择？"><a href="#什么时候会选择-MongoDB-而不是关系型数据库？什么时候不选择？" class="headerlink" title="什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？"></a>什么时候会选择 MongoDB 而不是关系型数据库？什么时候不选择？</h3><ul><li><strong>选择 MongoDB 的场景：</strong><ul><li>数据结构不固定，需要灵活的模式（Schema-less）。</li><li>高并发写入和大数据量存储。</li><li>需要水平扩展来应对业务增长。</li><li>对读性能要求高，且数据关联性不复杂。</li><li>需要存储非结构化或半结构化数据（如日志、用户画像、IoT 数据）。</li></ul></li><li><strong>不选择 MongoDB 的场景：</strong><ul><li>需要复杂的、跨多表的 JOIN 查询。</li><li>需要强事务一致性，尤其是有复杂的、跨多文档的 ACID 事务。</li><li>严格的范式化数据结构。</li><li>传统的 OLTP 业务，数据模型稳定且关联复杂。</li></ul></li></ul><h3 id="如何进行-MongoDB-的性能优化？"><a href="#如何进行-MongoDB-的性能优化？" class="headerlink" title="如何进行 MongoDB 的性能优化？"></a>如何进行 MongoDB 的性能优化？</h3><ul><li><strong>创建合适的索引：</strong> 根据查询模式创建单字段、复合、多键、文本等索引。</li><li><strong>优化查询：</strong> 避免全表扫描，使用 <code>$explain</code> 分析查询性能。</li><li><strong>数据模型设计：</strong> 合理选择嵌入式文档或引用，避免深层嵌套。</li><li><strong>读写分离：</strong> 利用副本集实现读写分离。</li><li><strong>分片：</strong> 针对大规模数据和高并发场景。</li><li><strong>硬件优化：</strong> 足够的内存（MongoDB 尽可能将数据放在内存中）、SSD 硬盘。</li><li><strong>聚合管道优化：</strong> 将 <code>$match</code> 放在管道前面尽可能过滤数据。</li></ul><h3 id="嵌入式文档与lookup操作"><a href="#嵌入式文档与lookup操作" class="headerlink" title="嵌入式文档与lookup操作"></a>嵌入式文档与lookup操作</h3><p>嵌入式文档是指一个文档内部包含另一个文档（或多个文档）。这意味着相关的子数据直接存储在父文档中，而不是作为单独的文档存储在另一个集合中并通过引用关联。</p><p><code>$lookup</code> 是 MongoDB 聚合管道（Aggregation Pipeline）中的一个阶段，它允许你执行<strong>左外连接（Left Outer Join）</strong>，从一个集合中的文档获取相关数据，并将其合并到另一个集合的文档中。</p><p>面试时，面试官通常会考察你如何根据业务场景和数据访问模式来选择嵌入式文档或引用加 <code>$lookup</code>。</p><ol><li><strong>数据的关联性/紧密性：</strong><ul><li>如果数据是<strong>强关联且总是被一起访问</strong>（例如，用户的地址和用户一起读取），优先考虑<strong>嵌入式文档</strong>。</li><li>如果数据是<strong>弱关联，或者不总是被一起访问</strong>（例如，订单中的商品详情，用户可能只看订单列表不看详情），考虑<strong>引用 + <code>$lookup</code></strong>。</li></ul></li><li><strong>读写模式：</strong><ul><li><strong>读多写少，且一起读：</strong> <strong>嵌入式文档</strong>通常性能更优。</li><li><strong>写入频繁，且子文档会被重复引用：</strong> <strong>引用 + <code>$lookup</code></strong> 可以减少数据冗余和更新复杂性。</li></ul></li><li><strong>数据大小和增长：</strong><ul><li>如果嵌入的子文档会<strong>变得非常大</strong>或者<strong>数量无限增长</strong>（接近 16MB 限制），使用<strong>引用 + <code>$lookup</code></strong>。</li><li>如果子文档<strong>相对较小且数量有限</strong>，可以考虑<strong>嵌入式文档</strong>。</li></ul></li><li><strong>一致性和原子性要求：</strong><ul><li>对<strong>强一致性要求高且需要原子操作</strong>的内部数据，<strong>嵌入式文档</strong>更安全。</li><li>涉及到<strong>多个集合的关联数据</strong>，通常需要应用层或 MongoDB 4.0+ 的多文档事务来保证一致性（如果使用引用）。</li></ul></li><li><strong>业务逻辑复杂性：</strong><ul><li>简单的聚合或联接，<code>$lookup</code> 也可以接受。</li><li>非常复杂的联接或需要跨集合的多次查询，可能需要重新评估数据模型或考虑将部分处理逻辑放到应用层。</li></ul></li></ol><h1 id="Elastic-Search"><a href="#Elastic-Search" class="headerlink" title="Elastic Search"></a>Elastic Search</h1><p>Elasticsearch 是一个基于 Apache Lucene 的分布式、RESTful 风格的搜索和分析引擎。它以其<strong>速度快、可伸缩性强</strong>以及能够处理<strong>海量数据</strong>而闻名。在面试中，Elasticsearch 经常作为大数据、搜索或微服务架构中的关键组件被问到。</p><p>ELK Stack (Elasticsearch, Logstash, Kibana) 技术栈核心</p><h2 id="关键概念-2"><a href="#关键概念-2" class="headerlink" title="关键概念"></a>关键概念</h2><p><img data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-ad2b2f8c-5a19-4c5e-9bc7-cf7ba17830bf.jpg" alt="img"></p><p><strong>节点</strong></p><p>一个 Elasticsearch 实例就是一个节点。每个节点都有一个名称。</p><p>主要节点类型：</p><ul><li><strong>Master Node (主节点)</strong>：负责集群的管理任务，如创建/删除索引、跟踪节点状态、分片分配等。一个集群中只能有一个主节点，但可以有多个符合主节点条件的节点（master-eligible node）。</li><li><strong>Data Node (数据节点)</strong>：存储数据（分片）并执行数据相关操作（CRUD、搜索、聚合）。</li><li><strong>Ingest Node (摄入节点)</strong>：执行预处理管道，转换文档。</li><li><strong>Coordinating Node (协调节点)</strong>：默认所有节点都是协调节点，负责接收客户端请求，将请求路由到正确的数据节点，并汇集各数据节点的结果返回给客户端。</li></ul><p><strong>Cluster (集群)</strong></p><ul><li>一个集群由一个或多个<strong>节点 (Node)</strong> 组成，它们共同存储数据并提供索引和搜索能力。</li><li><strong>目的：</strong> 提供高可用性、可伸缩性和容错性。</li><li><strong>面试点：</strong> 知道集群如何协同工作，以及其分布式特性。</li></ul><p><strong>Document (文档)</strong></p><ul><li>类似关系数据库中的<strong>行 (row)</strong>。它是可被索引的最小单位。</li><li><strong>JSON 格式：</strong> 文档以 JSON (JavaScript Object Notation) 格式表示。</li><li><strong>唯一 ID：</strong> 每个文档在它所属的索引中都有一个唯一的 ID。</li><li><strong>面试点：</strong> 理解文档是 Elasticsearch 存储和搜索的原子单元。</li></ul><p><strong>Index (索引)</strong></p><ul><li>类似关系数据库中的<strong>数据库 (database)</strong>。它是拥有相似特性的文档的集合。</li><li><strong>逻辑概念：</strong> 一个索引实际上在物理上分布在多个<strong>分片 (Shard)</strong> 上。</li><li><strong>面试点：</strong> 理解索引是逻辑上的分组，是可搜索的最高层级。</li></ul><p><strong>Type (类型)</strong> - <strong>在 Elasticsearch 7.x 及更高版本中已废弃！</strong></p><ul><li>在 6.x 及以前版本中，一个索引可以包含多个类型，类似关系数据库中的<strong>表 (table)</strong>。</li><li><strong>面试点：</strong> <strong>强调它已被废弃，并解释原因</strong>（Mapping 冲突、性能问题）。对于 7.x+ 版本，一个索引通常只对应一个类型或根本没有显式类型。</li></ul><p><strong>Field (字段)</strong></p><ul><li>类似关系数据库中的<strong>列 (column)</strong>。文档由多个字段组成。</li><li><strong>面试点：</strong> 字段是文档中的基本数据单元</li></ul><p><strong>Mapping (映射)</strong></p><ul><li>类似关系数据库中的<strong>表结构 (schema)</strong>。它定义了文档及其字段的类型、如何存储以及如何被索引。</li><li><strong>动态映射：</strong> Elasticsearch 默认支持动态映射，即当你索引一个新文档时，如果其中包含新的字段，Elasticsearch 会尝试猜测其数据类型并自动创建映射。</li><li><strong>显式映射：</strong> 最佳实践是显式定义映射，特别是对于文本字段，以控制它们的分析方式。</li><li><strong>面试点：</strong> 理解 Mapping 的作用，以及动态映射和显式映射的区别。<code>keyword</code> 和 <code>text</code> 类型字段的区别是高频考点。<ul><li><strong><code>text</code> 类型：</strong> 用于全文本字段，会被分词器处理（例如，”Hello World” 可能被分成 “hello” 和 “world”）。可用于全文搜索。</li><li><strong><code>keyword</code> 类型：</strong> 用于结构化数据（如 ID、标签、国家代码），不会被分词。适用于过滤、聚合、排序。</li></ul></li></ul><p><strong>Shard (分片)</strong></p><ul><li><strong>物理存储单元：</strong> 一个索引的数据被分成多个分片。每个分片都是一个独立的 Lucene 索引。</li><li><strong>目的：</strong><ul><li><strong>横向扩展：</strong> 允许你水平扩展存储容量和吞吐量。</li><li><strong>并行处理：</strong> 允许在多个节点上并行执行搜索和聚合操作，提高性能。</li></ul></li><li><strong>主分片 (Primary Shard)：</strong> 存储原始数据。</li><li><strong>副本分片 (Replica Shard)：</strong> 主分片的副本，用于提供高可用性（当主分片失效时可以提升为新主分片）和提升搜索吞吐量。</li><li><strong>面试点：</strong> <strong>高频考点</strong>。理解分片是 Elasticsearch 可伸缩和高可用的基石。区分主分片和副本分片的作用，以及它们如何分布在集群中</li></ul><p><strong>Replicas (副本)</strong></p><ul><li><strong>作用：</strong> 副本分片是主分片的精确拷贝。</li><li><strong>目的：</strong><ul><li><strong>高可用性：</strong> 当某个节点上的主分片失败时，副本可以立即提升为新的主分片，确保数据不丢失和服务的连续性。</li><li><strong>提高查询性能：</strong> 搜索请求可以同时在主分片和其副本分片上执行，分散负载，提高吞吐量。</li></ul></li><li><strong>面试点：</strong> 理解副本如何保障高可用和提升查询性能，以及副本数量的设置对存储和查询性能的影响。</li></ul><p><strong>Analysers (分析器)</strong></p><ul><li><strong>作用：</strong> 在索引文本数据时，将原始文本转换为可搜索的<strong>词项 (terms)</strong> 的过程。</li><li><strong>组成：</strong> 由一个<strong>字符过滤器 (character filters)</strong>、一个<strong>分词器 (tokenizer)</strong> 和零个或多个<strong>词项过滤器 (token filters)</strong> 组成。</li><li><strong>面试点：</strong> 理解分析器在全文搜索中的重要性。常见的分析器如 <code>standard</code> 分析器。能解释分词（tokenization）和词项过滤（如小写转换、停用词移除、同义词处理）的概念。</li></ul><p><strong>Query DSL (查询领域特定语言)</strong></p><ul><li>Elasticsearch 强大的查询语言，基于 JSON。</li><li><strong>面试点：</strong> 知道如何使用 Query DSL 进行各种复杂的搜索，如全文搜索、词语匹配、范围查询、布尔组合查询等。</li></ul><p><strong>Aggregations (聚合)</strong></p><ul><li>Elasticsearch 强大的统计分析功能。允许你从数据中提取和计算出复杂的统计信息，例如分组、求和、平均值、最大/最小值等。</li><li><strong>面试点：</strong> 了解聚合的用途，例如用于仪表盘、统计报表等。</li></ul><h2 id="关键问题-2"><a href="#关键问题-2" class="headerlink" title="关键问题"></a>关键问题</h2><h3 id="什么是-Elasticsearch？它的核心特点是什么？"><a href="#什么是-Elasticsearch？它的核心特点是什么？" class="headerlink" title="什么是 Elasticsearch？它的核心特点是什么？"></a>什么是 Elasticsearch？它的核心特点是什么？</h3><ul><li><strong>定义：</strong> Elasticsearch 是一个基于 Apache Lucene 的<strong>分布式、RESTful 风格的搜索和分析引擎</strong>。</li><li><strong>核心特点：</strong><ul><li><strong>分布式：</strong> 能够横向扩展，处理海量数据。</li><li><strong>近实时（Near Real-time）：</strong> 数据从索引到可搜索只有毫秒级的延迟。</li><li><strong>高可用和可伸缩：</strong> 通过集群、分片和副本机制提供。</li><li><strong>RESTful API：</strong> 通过 HTTP 和 JSON 进行交互，易于使用。</li><li><strong>全文搜索：</strong> 强大的全文搜索能力，支持复杂查询。</li><li><strong>聚合分析：</strong> 强大的聚合功能，用于数据分析和报表。</li></ul></li></ul><h3 id="请解释-Elasticsearch-中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type-已废弃）、文档（Document）和字段（Field）之间的关系和作用。"><a href="#请解释-Elasticsearch-中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type-已废弃）、文档（Document）和字段（Field）之间的关系和作用。" class="headerlink" title="请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。"></a>请解释 Elasticsearch 中的集群（Cluster）、节点（Node）、索引（Index）、类型（Type - 已废弃）、文档（Document）和字段（Field）之间的关系和作用。</h3><ul><li><strong>集群 (Cluster)：</strong> 一个或多个节点的集合，共同存储数据并提供搜索和分析功能。是 Elasticsearch 的最高逻辑单位。</li><li><strong>节点 (Node)：</strong> 一个 Elasticsearch 实例。每个节点在集群中扮演不同角色（如 Master 节点、Data 节点、Ingest 节点、Coordinating 节点）。</li><li><strong>索引 (Index)：</strong> 逻辑上相关文档的集合，类似关系型数据库的<strong>数据库</strong>。物理上，一个索引由一个或多个<strong>分片 (Shard)</strong> 组成。</li><li><strong>类型 (Type)：</strong> <strong>在 Elasticsearch 7.x 及更高版本中已废弃！</strong> 在 6.x 及以前版本中，类型是索引下的逻辑分组，类似关系型数据库的<strong>表</strong>。面试时务必强调其已废弃。</li><li><strong>文档 (Document)：</strong> 可被索引的最小数据单元，以 JSON 格式表示，类似关系型数据库的<strong>行</strong>。每个文档都有一个唯一的 ID。</li><li><strong>字段 (Field)：</strong> 文档中的数据单元，类似关系型数据库的<strong>列</strong>。</li></ul><h3 id="Elasticsearch-中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？"><a href="#Elasticsearch-中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？" class="headerlink" title="Elasticsearch 中的分片（Shard）和副本（Replica）有什么作用？它们如何实现高可用和可伸缩？"></a>Elasticsearch 中的<strong>分片（Shard）</strong>和<strong>副本（Replica）</strong>有什么作用？它们如何实现高可用和可伸缩？</h3><ul><li><strong>分片 (Shard)：</strong><ul><li><strong>作用：</strong> 是一个索引的<strong>物理存储单元</strong>，一个 Lucene 索引。一个索引被分成多个分片，这些分片可以分布在集群的不同节点上。</li><li><strong>目的：</strong> 实现<strong>横向扩展</strong>（存储容量和吞吐量），并支持<strong>并行处理</strong>查询。</li></ul></li><li><strong>副本 (Replica)：</strong><ul><li><strong>作用：</strong> 是主分片的一个<strong>完整副本</strong>。</li><li><strong>目的：</strong> 实现<strong>高可用性</strong>（当主分片所在的节点故障时，副本可以提升为新的主分片，防止数据丢失和中断服务）和<strong>提高查询吞吐量</strong>（搜索请求可以在主分片和副本上并行执行，分摊负载）。</li></ul></li><li><strong>高可用和可伸缩：</strong><ul><li><strong>高可用：</strong> 通过副本机制，即使部分节点或分片失效，数据仍然可用，服务不会中断。</li><li><strong>可伸缩性：</strong> 通过增加分片数量和节点数量，可以将数据和查询负载分布到更多机器上，实现线性扩展。</li></ul></li></ul><h3 id="什么是倒排索引（Inverted-Index）？Elasticsearch-为什么用它？"><a href="#什么是倒排索引（Inverted-Index）？Elasticsearch-为什么用它？" class="headerlink" title="什么是倒排索引（Inverted Index）？Elasticsearch 为什么用它？"></a>什么是<strong>倒排索引（Inverted Index）</strong>？Elasticsearch 为什么用它？</h3><ul><li><strong>定义：</strong> 倒排索引是 Elasticsearch 实现<strong>快速全文搜索</strong>的核心数据结构。<ul><li>传统数据库的“正向索引”是从文档（行）到关键词（列）。</li><li>倒排索引则是从<strong>关键词 (Term)</strong> 到包含该关键词的<strong>文档 ID 列表</strong>。</li></ul></li><li><strong>示例：</strong><ul><li>文档1: “The quick brown fox”</li><li>文档2: “Quick foxes are quick”</li><li><strong>倒排索引：</strong><ul><li><code>the</code>: [文档1]</li><li><code>quick</code>: [文档1, 文档2]</li><li><code>brown</code>: [文档1]</li><li><code>fox</code>: [文档1]</li><li><code>foxes</code>: [文档2]</li><li><code>are</code>: [文档2]</li></ul></li></ul></li><li><strong>为什么用它：</strong><ul><li><strong>极快的全文搜索：</strong> 当你搜索一个或多个关键词时，可以直接在倒排索引中找到包含这些关键词的所有文档 ID，而无需扫描所有文档。</li><li><strong>高效过滤和聚合：</strong> 也是实现高效过滤和聚合的基础。</li></ul></li></ul><h3 id="Elasticsearch-中的-Mapping（映射）是什么？text-类型和-keyword-类型有什么区别？"><a href="#Elasticsearch-中的-Mapping（映射）是什么？text-类型和-keyword-类型有什么区别？" class="headerlink" title="Elasticsearch 中的 Mapping（映射）是什么？text 类型和 keyword 类型有什么区别？"></a>Elasticsearch 中的 <strong>Mapping（映射）</strong>是什么？<code>text</code> 类型和 <code>keyword</code> 类型有什么区别？</h3><ul><li><strong>Mapping 定义：</strong> Mapping 类似于关系型数据库中的<strong>表结构（Schema）</strong>。它定义了文档及其字段的数据类型、如何存储以及如何被索引和查询。</li><li><strong>作用：</strong> 控制字段如何被分析（分词）、如何被索引以及是否可以被搜索、聚合和排序。</li><li><strong><code>text</code> 类型 vs <code>keyword</code> 类型：</strong> 这是最常考的区别！<ul><li><strong><code>text</code> 类型：</strong><ul><li>用于<strong>全文文本</strong>字段，例如文章内容、产品描述。</li><li>在索引时会被<strong>分词器 (Analyzer)</strong> 处理，将文本分解为独立的<strong>词项 (Terms)</strong>。</li><li>适用于<strong>全文搜索</strong>（例如，搜索 “quick brown fox”，即使只搜 “quick” 也能找到）。</li><li><strong>不适用于精确匹配、排序或聚合</strong>（因为已经被分词）。</li></ul></li><li><strong><code>keyword</code> 类型：</strong><ul><li>用于<strong>精确值</strong>的字段，例如 ID、邮箱地址、标签、国家代码。</li><li><strong>不会被分词器处理</strong>，整个值被视为一个单一的词项。</li><li>适用于<strong>精确匹配、过滤、排序和聚合</strong>。</li><li><strong>不适用于全文搜索</strong>。</li></ul></li></ul></li><li><strong>面试重点：</strong> 能够清晰解释这两种类型的区别和适用场景。例如，一个商品标题字段，可能同时需要 <code>text</code> 类型用于搜索，<code>keyword</code> 类型用于精确过滤或聚合。</li></ul><h3 id="什么是分析器（Analyzer）？它由哪些部分组成？"><a href="#什么是分析器（Analyzer）？它由哪些部分组成？" class="headerlink" title="什么是分析器（Analyzer）？它由哪些部分组成？"></a>什么是<strong>分析器（Analyzer）</strong>？它由哪些部分组成？</h3><ul><li><strong>定义：</strong> 分析器是 Elasticsearch 在索引和搜索<strong>文本数据</strong>时，将原始文本转换为可搜索的<strong>词项 (Terms)</strong> 的过程。</li><li><strong>组成：</strong> 一个分析器由以下三部分组成：<ol><li><strong>字符过滤器 (Character Filters)：</strong> 在文本被分词前，进行预处理，例如移除 HTML 标签、替换特殊字符。</li><li><strong>分词器 (Tokenizer)：</strong> 将文本分解为独立的词项（tokens）。例如，<code>standard</code> 分词器按空格和标点符号分词。</li><li><strong>词项过滤器 (Token Filters)：</strong> 对分词器生成的词项进行进一步处理，例如转换为小写、移除停用词 (stop words)、添加同义词、词干提取等。</li></ol></li><li><strong>面试重点：</strong> 理解分析器在全文搜索中的核心作用，以及其三部分的职能。例如，搜索“Running Shoes”，分析器可能将其处理成“run”、“shoe”，这样搜索“run”也能找到。</li></ul><h3 id="Elasticsearch-的写入（索引）流程是怎样的？"><a href="#Elasticsearch-的写入（索引）流程是怎样的？" class="headerlink" title="Elasticsearch 的写入（索引）流程是怎样的？"></a>Elasticsearch 的写入（索引）流程是怎样的？</h3><ol><li>客户端发送写入请求（<code>PUT</code> 或 <code>POST</code> 文档）到集群中的<strong>任一节点</strong>（通常是协调节点）。</li><li>协调节点根据文档的 ID 和索引的路由规则计算出该文档应属于的<strong>主分片</strong>。</li><li>协调节点将请求转发到<strong>主分片所在的 Data 节点</strong>。</li><li>主分片所在节点将文档写入主分片，并将其写入<strong>事务日志 (Translog)</strong>。</li><li>主分片将请求并行转发到所有<strong>副本分片所在的 Data 节点</strong>。</li><li>副本分片所在节点将文档写入副本分片，并写入其自己的 Translog。</li><li>所有副本分片成功写入后，向主分片返回确认。</li><li>主分片收到所有副本确认后，向协调节点返回确认。</li><li>协调节点向客户端返回成功响应。</li></ol><p><strong>面试重点：</strong> 强调写入操作首先在主分片上进行，然后同步到副本分片，并涉及 Translog 的持久化来保证数据安全性。</p><h3 id="Elasticsearch-的查询（搜索）流程是怎样的？"><a href="#Elasticsearch-的查询（搜索）流程是怎样的？" class="headerlink" title="Elasticsearch 的查询（搜索）流程是怎样的？"></a>Elasticsearch 的查询（搜索）流程是怎样的？</h3><ol><li>客户端发送搜索请求到集群中的<strong>任一节点</strong>（协调节点）。</li><li>协调节点将请求广播到<strong>索引的所有主分片和副本分片</strong>（协调节点会随机选择一个分片来处理请求，通常是主分片或其一个副本）。</li><li>每个分片执行搜索请求的两个阶段：<ul><li><strong>Query Phase (查询阶段 / Scatter)：</strong> 每个分片执行查询，找到匹配的文档，并返回文档 ID 和得分（Score）到协调节点。</li><li><strong>Fetch Phase (取回阶段 / Gather)：</strong> 协调节点将所有分片返回的文档 ID 和得分进行合并、排序，选出最终需要的文档 ID。然后，协调节点再次向相应分片请求这些完整文档的内容。</li></ul></li><li>协调节点收集所有完整文档，并根据排序要求返回给客户端。</li></ol><p><strong>面试重点：</strong> 强调查询是“分而治之”的思想，分为查询和取回两个阶段，涉及协调节点的分发和结果聚合。</p><h3 id="如何保证-Elasticsearch-的数据一致性？"><a href="#如何保证-Elasticsearch-的数据一致性？" class="headerlink" title="如何保证 Elasticsearch 的数据一致性？"></a>如何保证 Elasticsearch 的数据一致性？</h3><ul><li><strong>写关注 (Write Consistency)：</strong> 在写入操作时，可以通过 <code>replication</code> 参数设置写关注：<ul><li><code>quorum</code> (默认)：需要主分片和大多数副本分片写入成功才返回。</li><li><code>one</code>：只需主分片写入成功。</li><li><code>all</code>：所有分片（主分片和所有副本分片）写入成功。</li><li><strong>面试重点：</strong> 了解不同的写关注级别对写入性能和数据安全性的影响。</li></ul></li><li><strong>Translog (事务日志)：</strong> 每个分片都有一个 Translog，所有操作在被 Lucene 写入磁盘前都会先写入 Translog，确保即使发生宕机，也能从 Translog 恢复未持久化的操作。</li><li><strong>刷新 (Refresh) 和提交 (Commit)：</strong><ul><li><strong>Refresh (刷新)：</strong> Translog 中的数据会定期刷新到 Lucene 的文件系统缓存中，此时数据变得<strong>可搜索</strong>（默认 1 秒刷新一次）。</li><li><strong>Commit (提交)：</strong> Lucene 会定期进行 fsync 操作，将数据<strong>持久化</strong>到磁盘。</li></ul></li><li><strong>最终一致性：</strong> Elasticsearch 追求的是<strong>最终一致性</strong>。这意味着写入数据后，可能在极短的时间内（通常是 Refresh 间隔）无法立即被搜索到，但最终会达到一致状态。</li></ul><h3 id="常见的-Elasticsearch-性能优化策略有哪些？"><a href="#常见的-Elasticsearch-性能优化策略有哪些？" class="headerlink" title="常见的 Elasticsearch 性能优化策略有哪些？"></a>常见的 Elasticsearch 性能优化策略有哪些？</h3><ul><li><strong>索引优化：</strong><ul><li><strong>合理设计 Mapping：</strong> 选择正确的数据类型（尤其是 <code>text</code> vs <code>keyword</code>），避免不必要的字段索引（<code>&quot;index&quot;: false</code>）。</li><li><strong>分片数量：</strong> 合理设置主分片数量，通常建议一个分片大小在 20GB-50GB 左右。过多的分片会增加管理开销，过少则限制扩展性。</li><li><strong>副本数量：</strong> 增加副本可以提高读吞吐量和高可用性，但会增加写入开销和存储成本。</li></ul></li><li><strong>查询优化：</strong><ul><li><strong>使用合适的查询类型：</strong> 优先使用 <code>term</code>、<code>match</code> 等简单查询，避免复杂的正则或通配符查询。</li><li><strong>避免深分页：</strong> 使用 <code>search_after</code> 或 <code>scroll</code> API 代替 <code>from</code>/<code>size</code> 进行深分页。</li><li><strong>缓存：</strong> 利用 Elasticsearch 的查询缓存和字段数据缓存。</li><li><strong>聚合优化：</strong> 将 <code>_source</code> 字段设置为 <code>false</code>（如果不需要返回原始文档），只返回聚合结果。</li></ul></li><li><strong>硬件优化：</strong><ul><li><strong>内存：</strong> 分配足够的 JVM 堆内存（通常是物理内存的一半，不超过 32GB）。</li><li><strong>SSD 硬盘：</strong> 对于 I/O 密集型操作至关重要。</li><li><strong>CPU：</strong> 足够的核数来处理查询和索引操作。</li></ul></li><li><strong>JVM 优化：</strong> 合理配置 JVM 堆内存大小和垃圾回收器。</li><li><strong>慢查询日志：</strong> 开启并分析慢查询日志，找出性能瓶颈。</li></ul><h3 id="Elasticsearch-集群可能遇到哪些问题？如何解决？"><a href="#Elasticsearch-集群可能遇到哪些问题？如何解决？" class="headerlink" title="Elasticsearch 集群可能遇到哪些问题？如何解决？"></a>Elasticsearch 集群可能遇到哪些问题？如何解决？</h3><ul><li><strong>脑裂 (Split-Brain)：</strong> 当网络分区时，集群可能分裂成多个子集群，每个子集群都选举出自己的 Master 节点，导致数据不一致。<ul><li><strong>解决方案：</strong> 配置 <code>discovery.zen.minimum_master_nodes</code> 参数（投票节点数的一半加一），确保只有多数节点存活的子集群才能选举出 Master。</li></ul></li><li><strong>集群健康状态 (Cluster Health)：</strong><ul><li><strong>Red (红色)：</strong> 至少一个主分片不可用，数据丢失或部分索引不可用，集群处于危险状态。</li><li><strong>Yellow (黄色)：</strong> 所有主分片可用，但至少一个副本分片不可用。数据仍然完整，但冗余性降低，高可用性受损。</li><li><strong>Green (绿色)：</strong> 所有主分片和副本分片都可用，集群健康。</li><li><strong>面试重点：</strong> 能够解释不同颜色的含义和应对措施。</li></ul></li><li><strong>磁盘空间不足：</strong> 索引拒绝写入，集群可能变红。<ul><li><strong>解决方案：</strong> 增加磁盘空间、删除旧数据、使用索引生命周期管理 (ILM)。</li></ul></li><li><strong>内存溢出 / JVM 垃圾回收频繁：</strong> 导致节点无响应或重启。<ul><li><strong>解决方案：</strong> 合理配置 JVM 堆内存，优化查询和索引操作。</li></ul></li></ul><h1 id="PostgreSql"><a href="#PostgreSql" class="headerlink" title="PostgreSql"></a>PostgreSql</h1><p>PostgreSQL 是一款功能强大、高度稳定且遵循 SQL 标准的<strong>开源对象关系型数据库管理系统 (ORDBMS)</strong>。它以其高级特性、严格的 ACID 兼容性和出色的可扩展性而闻名，常被认为是比 MySQL 更适合处理复杂业务逻辑和数据一致性要求高的场景。</p><h2 id="关键概念-3"><a href="#关键概念-3" class="headerlink" title="关键概念"></a>关键概念</h2><p>以下是 PostgreSQL 的一些核心概念，理解它们是掌握 PostgreSQL 的基础：</p><p>对象关系型数据库 (ORDBMS)</p><ul><li><strong>定义：</strong> PostgreSQL 不仅仅是一个传统的关系型数据库 (RDBMS)，它还是一个<strong>对象关系型数据库 (ORDBMS)</strong>。这意味着它融合了关系型数据库的优点和面向对象数据库的一些特性。</li><li><strong>特点：</strong><ul><li><strong>支持对象概念：</strong> 允许定义复杂的数据类型、函数重载和继承。</li><li><strong>丰富的内置数据类型：</strong> 除了标准的关系型数据类型（如整数、字符串、日期）外，PostgreSQL 还原生支持许多高级数据类型，如 <strong>JSONB</strong> (二进制 JSON)、<strong>数组 (Arrays)</strong>、<strong>XML</strong>、<strong>几何数据类型</strong>、<strong>范围类型</strong>、<strong>网络地址</strong>等。</li><li><strong>用户自定义类型：</strong> 你可以定义自己的数据类型和操作符，极大地扩展了数据库的功能。</li></ul></li><li><strong>重要性：</strong> 这是 PostgreSQL 与 MySQL 等纯 RDBMS 的一个显著区别，使其在处理半结构化数据、复杂业务逻辑和需要高度自定义的场景中更具优势。</li></ul><p>索引 (Index)</p><ul><li><strong>作用：</strong> 索引是提高数据检索效率的数据库对象。通过创建索引，数据库可以快速定位到满足查询条件的行，而无需扫描整个表。</li><li><strong>类型丰富：</strong> PostgreSQL 支持多种索引类型，包括：<ul><li><strong>B-tree：</strong> 最常用，适用于各种等值查询和范围查询。</li><li><strong>Hash：</strong> 适用于等值查询（较少用，因为不能保证 Crash-safe）。</li><li><strong>GIN (Generalized Inverted Index)：</strong> 适用于处理多值数据类型（如数组、JSONB）的包含查询。</li><li><strong>GiST (Generalized Search Tree)：</strong> 适用于复杂数据类型（如几何数据、全文搜索）和范围查询。</li><li><strong>BRIN (Block Range Index)：</strong> 适用于大型表，数据自然排序的场景，非常紧凑。</li></ul></li><li><strong>重要性：</strong> 合理地设计和使用索引是优化 PostgreSQL 查询性能的关键。</li></ul><p>事务 (Transaction) 和 ACID</p><ul><li><strong>事务：</strong> 事务是一组逻辑上相关的数据库操作，它们被视为一个单一的、不可分割的工作单元。</li><li><strong>ACID 特性：</strong> PostgreSQL 严格遵守 <strong>ACID</strong> (Atomicity, Consistency, Isolation, Durability) 原则。<ul><li><strong>原子性 (Atomicity)：</strong> 事务中的所有操作要么全部成功，要么全部失败回滚。</li><li><strong>一致性 (Consistency)：</strong> 事务完成后，数据库必须从一个一致状态转换到另一个一致状态。</li><li><strong>隔离性 (Isolation)：</strong> 并发执行的事务彼此独立，互不影响。</li><li><strong>持久性 (Durability)：</strong> 一旦事务提交，其所做的修改是永久性的，即使系统崩溃也不会丢失。</li></ul></li><li><strong>重要性：</strong> 严格的 ACID 兼容性是 PostgreSQL 可靠性和数据完整性的基石，尤其适用于金融、电商等对数据一致性要求极高的应用。</li></ul><p>多版本并发控制 (MVCC)</p><ul><li><strong>定义：</strong> PostgreSQL 实现并发控制的关键机制是 <strong>MVCC (Multi-Version Concurrency Control)</strong>。</li><li><strong>工作原理：</strong> 当一个事务修改数据时，PostgreSQL 不会直接覆盖旧数据，而是创建一个新的数据版本。读操作总是读取数据的旧版本，写操作则创建新版本。</li><li><strong>优势：</strong><ul><li><strong>读写不阻塞：</strong> 读操作和写操作通常不会相互阻塞，大大提高了并发性能。</li><li><strong>快照隔离：</strong> 每个事务都有一个“快照”，看到的是事务开始时的数据状态，避免了脏读、不可重复读和幻读（取决于隔离级别）。</li></ul></li><li><strong>重要性：</strong> MVCC 是 PostgreSQL 在高并发读写场景下表现出色的核心原因之一，也是其与 MySQL 等数据库在并发处理上差异较大的地方。</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ol><li><a href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html</a></li><li><a href="https://javabetter.cn/netty/rumen.html">https://javabetter.cn/netty/rumen.html</a></li><li><a href="https://javabetter.cn/mq/rabbitmq-rumen.html">https://javabetter.cn/mq/rabbitmq-rumen.html</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;消息队列功能很强大,它能使业务降低耦合,异步调用无需等待,下游服务故障不影响上游业务,缓存消息起到流量削峰填谷的作用. 这里介绍其中的RabbitMQ,此外在说一下Elastic Search和MongoDB.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>redis核心技术</title>
    <link href="https://www.sekyoro.top/2025/07/10/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.sekyoro.top/2025/07/10/redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</id>
    <published>2025-07-10T05:47:30.000Z</published>
    <updated>2025-07-23T12:19:50.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为redis与mysql经常搭配使用,也是面试常问,这里记录一些常见基础题.<br><span id="more"></span></p><h2 id="相比Memcached区别"><a href="#相比Memcached区别" class="headerlink" title="相比Memcached区别"></a>相比Memcached区别</h2><h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><p>String 常规计数、分布式锁、共享session信息</p><p>实现:简单动态字符串</p><p>不仅可以存文本数据还可以存二进制数据</p><p>获取长度时间复杂度O(1)</p><p>拼接字符串不会造成缓冲区溢出</p><p>List </p><p>SDS ziplist dict intset quicklist skiplist</p><p>消息队列(但存在问题1.生产者需要自行实现全局唯一ID 2.不能通过消费者组方式读取数据)</p><p>quicklist,</p><p>Hash</p><p>Set</p><p>ZSet</p><p>新增数据类型</p><p>BitMap</p><p>Hyperloglog</p><p>geo</p><p>stream</p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h1 id="备份机制"><a href="#备份机制" class="headerlink" title="备份机制"></a>备份机制</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h1 id="Redis在项目中应用"><a href="#Redis在项目中应用" class="headerlink" title="Redis在项目中应用"></a>Redis在项目中应用</h1><h2 id="不同数据类型的使用"><a href="#不同数据类型的使用" class="headerlink" title="不同数据类型的使用"></a>不同数据类型的使用</h2><h2 id="实现分布锁"><a href="#实现分布锁" class="headerlink" title="实现分布锁"></a>实现分布锁</h2><h2 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h2><h2 id="stream实现消息队列"><a href="#stream实现消息队列" class="headerlink" title="stream实现消息队列"></a>stream实现消息队列</h2><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://xiaolincoding.com/redis/base/redis_interview.html">Redis 常见面试题 | 小林coding</a></li><li><a href="https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目_哔哩哔哩_bilibili</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为redis与mysql经常搭配使用,也是面试常问,这里记录一些常见基础题.&lt;br&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://www.sekyoro.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>coding agent in real world</title>
    <link href="https://www.sekyoro.top/2025/07/01/coding-agent-in-real-world/"/>
    <id>https://www.sekyoro.top/2025/07/01/coding-agent-in-real-world/</id>
    <published>2025-07-01T07:09:55.000Z</published>
    <updated>2025-07-01T09:41:55.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近AI辅助编程特别火,主要是从llm时代,比如gpt4,llama4,claude,gemini等大模型出来后,再到cursor的vibe coding,最后到现在的<a href="https://openai.com/index/openai-codex/">OpenAI Codex | OpenAI</a>,<a href="https://ai-claude.net/code/">Claude Code</a>以及<a href="https://github.com/google-gemini/gemini-cli">google-gemini.</a>anthropic提出了MCP与cli工具,旗下的模型评测效果也很不错,在这些方面,似乎anthropic,openai是领跑者,而meta和google都紧随其后,微软主要是资助openai,而在国内主要是字节Coze,豆包等工具. </p><p>之前一段时间流行过的文生图/文生视频等模型或应用热度也在明显降低,比如<a href="https://openai.com/sora/">Sora | OpenAI</a>,<a href="https://jimeng.jianying.com/">即梦AI - 即刻造梦</a>,<a href="https://app.klingai.com/cn/">可灵 </a>,<a href="https://hailuoai.com/">海螺视频</a>,<a href="https://www.heygen.com/">HeyGen</a>,.但是在视频创作领域,这些工具已经逐渐成了基本功能了. 国内主要是字节和minimax,快手等公司持续发力.</p><span id="more"></span><p>在AI IDE上,主要有Cursor,vscode,trae,cline,windsurf等本地工具,主要特点是通过tab不断vibe coding以及agent模式的利用上下文编辑代码. 个人感觉这类工具本身差别不大. 还有web版的<a href="https://bolt.new/">bolt.new</a>,<a href="https://v0.dev/">v0 by Vercel</a>以及<a href="https://lovable.dev/">Lovable</a>.</p><p>而现在,在google开源了gemini cli后,似乎出现了新的范式,其主要优点就是免费+开源.</p><p>类似的AI工具还有<a href="https://jules.google.com/task">Jules</a>,<a href="https://agent.minimax.io/">MiniMax Agent</a>,<a href="https://aws.amazon.com/cn/q/developer/"> Amazon Q 开发者版 – AWS</a>,<a href="https://www.manusai.io/">Manus AI - The World’s First General-Purpose AI Assistant Launching in 2025</a>等等.但大多需要收费(一般除了google和meta,这两家公司还是够给力的),一般都是给一定的credit,用完了就需要给钱了.</p><p>作为成熟的开发者,价格比较高的产品我们就不使用了. 挑选下来还不错的工具有google jules,amazon q,gemini cli,此外国内还有<a href="https://github.com/bytedance/UI-TARS-desktop">bytedance/UI-TARS-desktop</a></p><p>这种工具一般都集成了许多功能,包括联网搜索等,而也有一些工具可以让我们更好阅读代码,比如<a href="https://deepwiki.com/">DeepWiki</a>.</p><p>最后还有cogni<a href="https://devin.ai/">Devin | The AI Software Engineer</a>，<a href="https://swe-agent.com/latest/"> SWE-agent </a>,<a href="https://github.com/stitionai/devika">devika</a>这类大杀器,比较早研究AI辅助编程的工具.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近AI辅助编程特别火,主要是从llm时代,比如gpt4,llama4,claude,gemini等大模型出来后,再到cursor的vibe coding,最后到现在的&lt;a href=&quot;https://openai.com/index/openai-codex/&quot;&gt;OpenAI Codex | OpenAI&lt;/a&gt;,&lt;a href=&quot;https://ai-claude.net/code/&quot;&gt;Claude Code&lt;/a&gt;以及&lt;a href=&quot;https://github.com/google-gemini/gemini-cli&quot;&gt;google-gemini.&lt;/a&gt;anthropic提出了MCP与cli工具,旗下的模型评测效果也很不错,在这些方面,似乎anthropic,openai是领跑者,而meta和google都紧随其后,微软主要是资助openai,而在国内主要是字节Coze,豆包等工具. &lt;/p&gt;
&lt;p&gt;之前一段时间流行过的文生图/文生视频等模型或应用热度也在明显降低,比如&lt;a href=&quot;https://openai.com/sora/&quot;&gt;Sora | OpenAI&lt;/a&gt;,&lt;a href=&quot;https://jimeng.jianying.com/&quot;&gt;即梦AI - 即刻造梦&lt;/a&gt;,&lt;a href=&quot;https://app.klingai.com/cn/&quot;&gt;可灵 &lt;/a&gt;,&lt;a href=&quot;https://hailuoai.com/&quot;&gt;海螺视频&lt;/a&gt;,&lt;a href=&quot;https://www.heygen.com/&quot;&gt;HeyGen&lt;/a&gt;,.但是在视频创作领域,这些工具已经逐渐成了基本功能了. 国内主要是字节和minimax,快手等公司持续发力.&lt;/p&gt;</summary>
    
    
    
    
    <category term="coding agent" scheme="https://www.sekyoro.top/tags/coding-agent/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习:基于mysql实战45讲</title>
    <link href="https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    <id>https://www.sekyoro.top/2025/07/01/mysql%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E6%88%9845%E8%AE%B2/</id>
    <published>2025-07-01T04:12:54.000Z</published>
    <updated>2025-07-03T05:24:08.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基于极客时间中的MySQL实战45讲,可以查看<a href="https://uaxe.github.io/geektime-docs/">极客时间文档</a>,相关github仓库<a href="https://github.com/it-ebooks-0/geektime-books">it-ebooks-0/geektime-books: :books: 极客时间电子书</a>和<a href="https://github.com/zkep/my-geektime">zkep/my-geektime: 👏 极客时间下载器 &amp; 在线文档</a></p><span id="more"></span><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img data-src="https://s2.loli.net/2025/07/01/UnhSHTDM9sx8F3W.png" alt="image-20250701121849232"></p><p>目前mysql版本基本大于8.0,而经典老版本5.7一些功能在新版本中已经移除(比如查询缓存).</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器用于客户端建立连接,获取权限,维持和管理连接. </p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>数据库里面，<strong>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</strong>。<strong>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</strong>。</p><p>建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，<strong>这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM）</strong>，从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>连接建立完成后,就可以执行语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端</p><blockquote><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p></blockquote><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>进行词法分析,语法、语义解析</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><h2 id="执行查询语句流程"><a href="#执行查询语句流程" class="headerlink" title="执行查询语句流程"></a>执行查询语句流程</h2><h2 id="执行更新语句流程"><a href="#执行更新语句流程" class="headerlink" title="执行更新语句流程"></a>执行更新语句流程</h2><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="全局锁和表锁"><a href="#全局锁和表锁" class="headerlink" title="全局锁和表锁"></a>全局锁和表锁</h2><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><h2 id="事务隔离-1"><a href="#事务隔离-1" class="headerlink" title="事务隔离"></a>事务隔离</h2><h2 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h2><p>唯一索引相比普通索引: 都是在B+树上,唯一索引有唯一约束条件.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于极客时间中的MySQL实战45讲,可以查看&lt;a href=&quot;https://uaxe.github.io/geektime-docs/&quot;&gt;极客时间文档&lt;/a&gt;,相关github仓库&lt;a href=&quot;https://github.com/it-ebooks-0/geektime-books&quot;&gt;it-ebooks-0/geektime-books: :books: 极客时间电子书&lt;/a&gt;和&lt;a href=&quot;https://github.com/zkep/my-geektime&quot;&gt;zkep/my-geektime: 👏 极客时间下载器 &amp;amp; 在线文档&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="https://www.sekyoro.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>文件分片上传分析</title>
    <link href="https://www.sekyoro.top/2025/05/12/%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90/"/>
    <id>https://www.sekyoro.top/2025/05/12/%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90/</id>
    <published>2025-05-12T12:26:12.000Z</published>
    <updated>2025-05-13T16:02:04.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在实现文件上传时,通常会去讨论文件分片上传、秒传以及断点续传等问题,这里整理一下解决方法.<br><span id="more"></span></p><div class="table-container"><table><thead><tr><th>问题</th><th>分片上传的好处</th></tr></thead><tbody><tr><td>大文件上传超时 / 失败</td><td>分片失败可重传，避免全部重传</td></tr><tr><td>网络不稳定</td><td>分片可以断点续传</td></tr><tr><td>并发能力弱</td><td>分片可并发上传提高速度</td></tr><tr><td>浏览器限制（如 body 大小）</td><td>避免单次请求过大被限制</td></tr><tr><td>支持上传进度显示</td><td>每片进度可追踪</td></tr></tbody></table></div><p>文件分片上传是一种将大文件分割成多个小片段（分片），然后逐个上传这些分片的技术。这种方法有几个优点，包括提高上传的成功率、减少内存占用以及支持断点续传等。下面简要介绍文件分片上传的概念和实现方法。</p><p><strong>前端流程：</strong></p><ol><li>选择文件并读取其大小</li><li>将文件按固定大小（如 1MB）切片（使用 <code>Blob.slice</code>）</li><li>逐片上传（可并发）</li><li>上传成功后通知服务器进行合并</li></ol><p>可以通过hash分片验证是否已经上传,从而提升用户文件上传体验.</p><h3 id="Hash检测-实现秒传"><a href="#Hash检测-实现秒传" class="headerlink" title="Hash检测 实现秒传"></a>Hash检测 实现秒传</h3><p><strong>秒传的关键是“文件去重”</strong> —— 客户端通过<strong>计算文件指纹（如 MD5、SHA256）</strong>，先向服务器查询是否已存在相同文件，如果存在则<strong>跳过上传</strong>，直接“秒传成功”。</p><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li>前端计算文件 hash（通常用 <code>CryptoJS</code>、<code>spark-md5</code>）。</li><li>发请求询问服务器：这个 hash 是否已上传？</li><li>如果服务器返回“存在”：<ul><li>返回文件地址（或秒传成功）</li></ul></li><li>否则再走正常上传流程。</li></ol><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>前端文件 hash 计算是异步的，推荐使用 <code>Web Worker</code> 加速。</li><li>服务端需要维护文件 hash 与实际文件路径的映射表（如 Redis、数据库）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">const file = ref&lt;File | null&gt;(null);</span><br><span class="line">const handleFileChange = (event:Event)=&gt; &#123;</span><br><span class="line">  const target = event.target as HTMLInputElement;</span><br><span class="line">  if (target.files &amp;&amp; target.files.length &gt; 0) &#123;</span><br><span class="line">    file.value = target.files[0] as File;</span><br><span class="line">    console.log(file.value.name);</span><br><span class="line">    const chunks = calculateChunks(file.value);</span><br><span class="line">    calculateHash(chunks).then((hash) =&gt; &#123;</span><br><span class="line">      console.log(&quot;File hash:&quot;, hash);</span><br><span class="line">    &#125;).catch((error) =&gt; &#123;</span><br><span class="line">      console.error(&quot;Error calculating hash:&quot;, error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const calculateChunks = (file:File):Blob[]=&gt;&#123;</span><br><span class="line">  const size = file.size;</span><br><span class="line">  const chunks:Blob[] = [];</span><br><span class="line">  let start = 0;</span><br><span class="line">  while(start &lt; size)&#123;</span><br><span class="line">    const end = Math.min(start + CHUNK_SIZE, size);</span><br><span class="line">    const chunk = file.slice(start, end);</span><br><span class="line">    chunks.push(chunk);</span><br><span class="line">    start = end;</span><br><span class="line">  &#125;</span><br><span class="line">  return chunks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calculateHash = async(chunks:Blob[])=&gt;&#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">   const size = chunks.length;</span><br><span class="line">  console.log(`一共有$&#123;size&#125;个分片`);</span><br><span class="line">  const targets:Blob[] = [];</span><br><span class="line">  const fileReader = new FileReader();</span><br><span class="line">  chunks.forEach((chunk:Blob, index) =&gt; &#123;</span><br><span class="line">    if(index == 0 || index == size - 1)&#123;</span><br><span class="line">      targets.push(chunk);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    targets.push(chunk.slice(0, 2));</span><br><span class="line">    targets.push(chunk.slice(CHUNK_SIZE/2, CHUNK_SIZE/2 + 2));</span><br><span class="line">    targets.push(chunk.slice(CHUNK_SIZE - 2, CHUNK_SIZE));</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  fileReader.readAsArrayBuffer(new Blob(targets));</span><br><span class="line">    const spark =new SparkMD5.ArrayBuffer();</span><br><span class="line">  fileReader.onload = (event:ProgressEvent&lt;FileReader&gt;) =&gt; &#123;</span><br><span class="line">    const arrayBuffer = event.target?.result as ArrayBuffer;</span><br><span class="line">    spark.append(arrayBuffer);</span><br><span class="line">    resolve(spark.end());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fileReader.onerror = (event:ProgressEvent&lt;FileReader&gt;) =&gt; &#123;</span><br><span class="line">    console.error(&quot;Error reading file:&quot;, event);</span><br><span class="line">    reject(event);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="切片上传"><a href="#切片上传" class="headerlink" title="切片上传"></a>切片上传</h3><p>上传表单<code>form/multipart</code>数据,包括切片索引以及hash信息,后端每次下载切片到一个文件夹下.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadChunks = <span class="keyword">async</span> (chunks: Blob[]) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = chunks.map(<span class="function">(<span class="params">chunk: Blob, index: number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    formData.append(<span class="string">&quot;fileHash&quot;</span>, fileHash.value <span class="keyword">as</span> string);</span><br><span class="line">    formData.append(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">    formData.append(<span class="string">&quot;size&quot;</span>, chunk.size.toString());</span><br><span class="line">    formData.append(<span class="string">&quot;chunkIndex&quot;</span>, index.toString());</span><br><span class="line">    formData.append(<span class="string">&quot;chunkHash&quot;</span>, fileHash.value + <span class="string">&quot;-&quot;</span> + index);</span><br><span class="line">    <span class="keyword">return</span> formData;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> MAX_REQUEST = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 并发请求</span></span><br><span class="line">  <span class="keyword">const</span> taskPool: <span class="built_in">Promise</span>&lt;Response&gt;[] = [];</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; data.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = fetch(<span class="string">&quot;http://localhost:3000/upload&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      <span class="attr">body</span>: data[index],</span><br><span class="line">    &#125;);</span><br><span class="line">    taskPool.push(task);</span><br><span class="line"></span><br><span class="line">    task</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;分片上传成功&quot;</span>);</span><br><span class="line">          taskPool.splice(taskPool.indexOf(task), <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">&quot;分片上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;Error uploading chunk:&quot;</span>, error);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">if</span> (taskPool.length == MAX_REQUEST) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.race(taskPool)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.ok) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;分片上传成功&quot;</span>);</span><br><span class="line">            taskPool.splice(taskPool.indexOf(task), <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&quot;分片上传失败&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 只要有一个完成就返回</span></span><br><span class="line">          <span class="comment">// 如果上传成功,移除该任务</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">&quot;Error uploading chunk:&quot;</span>, error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(taskPool);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>大文件切成多个小块（如每块 1MB），<strong>逐个上传</strong>，上传完毕后由服务器<strong>合并为完整文件</strong>。</p><h4 id="实现步骤：-1"><a href="#实现步骤：-1" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p>前端将文件切片，通常通过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunk = file.slice(start, end);</span><br></pre></td></tr></table></figure></li><li><p>每个切片附带索引和文件唯一标识（如 hash）上传。</p></li><li><p>后端接收每个切片，按 hash 和索引编号保存。</p></li><li><p>前端上传完所有切片后，请求服务端<strong>合并文件</strong>。</p></li></ol><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>客户端：控制并发上传（推荐并发数 3～5）。</li><li>服务端：需要记录哪些切片已经上传（可用 Redis 或文件夹索引）。</li><li>最后合并文件时可用 <code>fs.appendFile</code> 或 <code>fs.createWriteStream</code></li></ul><h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> reqData = &#123;</span><br><span class="line">    <span class="attr">fileHash</span>: fileHash.value,</span><br><span class="line">    <span class="attr">fileName</span>: fileName.value,</span><br><span class="line">    <span class="attr">fileTotalSize</span>: file.value?.size,</span><br><span class="line">    <span class="attr">chunkSize</span>: CHUNK_SIZE,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;http://localhost:3000/merge&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(reqData),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;文件合并成功&quot;</span>);</span><br><span class="line">    alert(<span class="string">&quot;合并成功&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;文件合并失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&quot;/merge&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 合并文件 json请求</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileHash, fileName, fileTotalSize, chunkSize &#125; = req.body;</span><br><span class="line">  <span class="keyword">const</span> chunkFile = path.resolve(UPLOAD_DIR, fileHash + getSuffix(fileName));</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(chunkFile)) &#123;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;文件已经存在&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, fileHash);</span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(chunkDir)) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).json(&#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;合并失败,请重新上传&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取目录下文件</span></span><br><span class="line">    <span class="keyword">const</span> mergeFilePath = chunkFile;</span><br><span class="line">    <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">    <span class="keyword">if</span> (chunkPaths.length === <span class="number">0</span>) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).json(&#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;合并失败,请重新上传&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    chunkPaths.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>] - b.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> tasks = chunkPaths.map(<span class="function">(<span class="params">chunkPath, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="keyword">const</span> chunkFilePath = path.resolve(chunkDir, chunkPath);</span><br><span class="line">        <span class="comment">// const fileBuffer = fs.readFileSync(chunkFilePath);</span></span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        <span class="keyword">const</span> readStream = fse.createReadStream(chunkFilePath);</span><br><span class="line">        <span class="keyword">const</span> writeStream = fse.createWriteStream(mergeFilePath, &#123;</span><br><span class="line">          <span class="attr">start</span>: index * chunkSize,</span><br><span class="line">          <span class="attr">end</span>: (index + <span class="number">1</span>) * chunkSize,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// writeStream.on(&quot;finish&quot;, async () =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//   console.log(`删除文件$&#123;chunkFilePath&#125;`);</span></span><br><span class="line">        <span class="comment">//   await fse.unlink(chunkFilePath);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          pipeline(readStream, writeStream).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fse.unlinkSync(chunkFilePath);</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fs.appendFileSync(mergeFilePath, fileBuffer);</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).json(&#123;</span><br><span class="line">        <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;合并失败,请重新上传&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> files = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">    <span class="keyword">const</span> fileCount = files.length;</span><br><span class="line">    <span class="built_in">console</span>.log(fileCount)</span><br><span class="line">    <span class="keyword">if</span> (fileCount === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.rmdir(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;合并成功&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在切片上传完毕之后再发送merge请求.</p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> verifyHash =  <span class="keyword">async</span>(hash: string,<span class="attr">fileName</span>:string) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">&quot;http://localhost:3000/verify&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="attr">fileHash</span>: hash,</span><br><span class="line">      <span class="attr">fileName</span>: fileName,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">resp</span>=&gt;</span>resp.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">existFile</span>:!result.shouldUpload,<span class="attr">existChunks</span>:result?.existChunks&#125;;</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;Error verifying file hash:&quot;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">app.post(<span class="string">&quot;/verify&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; fileHash, fileName &#125; = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回服务器已经上传成功的切片索引</span></span><br><span class="line">  <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, fileHash);</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(chunkDir)) &#123;</span><br><span class="line">    <span class="comment">// 如果存在该目录,查看其中的最大文件索引</span></span><br><span class="line">    <span class="keyword">const</span> files = fs.readdirSync(chunkDir);</span><br><span class="line">    <span class="comment">// const maxIndex = Math.max(...files.map((fileName) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return parseInt(fileName.split(&quot;-&quot;)[1]);</span></span><br><span class="line">    <span class="comment">// &#125;));</span></span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;完整文件不存在&quot;</span>,</span><br><span class="line">      <span class="attr">shouldUpload</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="attr">existChunks</span>: files,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证是否已经有合并后的完整文件</span></span><br><span class="line">  <span class="keyword">const</span> suffix = getSuffix(fileName);</span><br><span class="line">  <span class="keyword">const</span> filePath = path.resolve(UPLOAD_DIR, fileHash + suffix);</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(filePath)) &#123;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;文件已经存在&quot;</span>,</span><br><span class="line">      <span class="attr">shouldUpload</span>:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      <span class="attr">ok</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;完整文件不存在&quot;</span>,</span><br><span class="line">      <span class="attr">shouldUpload</span>:<span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p><strong>上传中断后</strong>，可以<strong>只上传未完成的部分</strong>，而不用从头开始。</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><ul><li>通常与<strong>分片上传结合使用</strong>。</li><li>客户端在重试上传前，先向服务端询问已上传的切片列表。</li><li>客户端只上传未完成的切片，最后合并。</li></ul><h4 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h4><ul><li>客户端需记录上传状态（如切片状态、索引）。</li><li>服务端提供接口返回已有的切片（如 <code>/upload/status?fileHash=xxx</code>）。</li><li>文件 hash 一定要稳定，用于唯一标识该文件上传任务。</li></ul><h3 id="服务端解决方案"><a href="#服务端解决方案" class="headerlink" title="服务端解决方案"></a>服务端解决方案</h3><div class="table-container"><table><thead><tr><th>技术点</th><th>实现方式</th></tr></thead><tbody><tr><td>存储切片</td><td>保存到本地临时目录 or 对象存储（如 OSS、S3）</td></tr><tr><td>存储状态</td><td>Redis（高效） or MongoDB/MySQL</td></tr><tr><td>文件合并</td><td><code>fs.createWriteStream</code> + <code>fs.createReadStream</code></td></tr><tr><td>断点续传状态</td><td>文件夹结构 + index.json、数据库记录</td></tr></tbody></table></div><h3 id="推荐前端工具库"><a href="#推荐前端工具库" class="headerlink" title="推荐前端工具库"></a>推荐前端工具库</h3><ul><li><code>spark-md5</code>：快速计算文件 hash（支持分片 hash）</li><li><code>axios</code>：支持中断、重试、并发控制</li><li>可配合 <code>Web Worker</code> 和 <code>FileReader</code> 异步读取文件<h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4></li></ul><p>Web Workers 是一种让网页内容在后台线程中运行脚本的方式。工作线程可以在不影响用户界面的情况下执行任务。此外，它们可以使用 <code>fetch()</code> 或 <code>XMLHttpRequest</code> API 发起网络请求。一旦创建，一个工作线程可以通过向创建它的 JavaScript 代码指定的事件处理器发送消息来与其通信（反之亦然）</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Using Web Workers - Web APIs | MDN</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileInput&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Worker 实例</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;hash-worker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  result.textContent = <span class="string">&#x27;文件 MD5: &#x27;</span> + event.data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file = <span class="built_in">this</span>.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件为 ArrayBuffer，发送给 Worker</span></span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    worker.postMessage(reader.result); <span class="comment">// ArrayBuffer 发送给 Worker</span></span><br><span class="line">  &#125;;</span><br><span class="line">  reader.readAsArrayBuffer(file);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts">WorkerGlobalScope: importScripts() method - Web APIs | MDN</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 spark-md5（注意路径）或使用 CDN + importScripts</span></span><br><span class="line">importScripts(<span class="string">&#x27;https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrayBuffer = event.data;</span><br><span class="line">  <span class="keyword">const</span> spark = <span class="keyword">new</span> self.SparkMD5.ArrayBuffer();</span><br><span class="line">  spark.append(arrayBuffer);</span><br><span class="line">  <span class="keyword">const</span> hash = spark.end();</span><br><span class="line">  postMessage(hash);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>主线程不卡顿。</li><li>计算任务可异步处理，提升用户体验。</li><li><code>ArrayBuffer</code> 是可转移对象，性能更好（不会拷贝，只是转移）。</li></ul><p><strong>注意事项</strong></p><ul><li>Worker 中<strong>无法访问 DOM</strong>、<code>window</code>。</li><li>Worker 是异步的，不支持 <code>alert</code>、<code>confirm</code> 等。</li><li>跨域引用 <code>worker.js</code> 时需要注意同源策略，或使用 Blob 方式创建 Worker。</li></ul><h3 id="实战优化"><a href="#实战优化" class="headerlink" title="实战优化"></a>实战优化</h3><ul><li><p>支持大文件（如 1GB+），首选分片上传 + 秒传。</p></li><li><p>支持上传失败重试（单个切片失败可重试）。</p></li><li><p>使用服务端合并标记（如 <code>done.flag</code>）避免重复合并。</p></li><li><p>上传前先校验文件 hash，实现秒传。</p></li><li><p>提供进度回调、UI反馈。</p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实现文件上传时,通常会去讨论文件分片上传、秒传以及断点续传等问题,这里整理一下解决方法.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Netty初探</title>
    <link href="https://www.sekyoro.top/2025/05/08/Netty%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2025/05/08/Netty%E5%88%9D%E6%8E%A2/</id>
    <published>2025-05-08T09:50:39.000Z</published>
    <updated>2025-05-14T03:06:12.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Netty 是一个基于 Java NIO 的异步、事件驱动的网络应用框架，旨在简化 TCP/UDP 等协议服务器和客户端的开发。它封装了底层的 NIO 细节，提供了易用的 API，广泛应用于高性能网络通信场景，如 Dubbo、RocketMQ、Elasticsearch 等中间件。<br><span id="more"></span></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ol><li>Channel</li></ol><p>表示一个网络连接的抽象，如 SocketChannel。它是数据读写的通道，支持异步非阻塞操作。</p><ol><li>EventLoop &amp; EventLoopGroup</li></ol><p>EventLoop 是处理 I/O 操作的核心，绑定到一个线程，负责处理 Channel 的所有事件。EventLoopGroup 是 EventLoop 的集合，用于管理多个 EventLoop，实现多线程处理。<a href="https://www.processon.com/view/6575bdbf4861d5331582478d?utm_source=chatgpt.com">developer.aliyun.com+2processon.com+2learn.lianglianglee.com+2</a><a href="https://developer.aliyun.com/article/533797?utm_source=chatgpt.com">developer.aliyun.com</a></p><ol><li>ChannelHandler &amp; ChannelPipeline</li></ol><p>ChannelHandler 是处理入站和出站数据的处理器，ChannelPipeline 是 ChannelHandler 的链式结构，定义了数据处理的流程。</p><ol><li>Bootstrap &amp; ServerBootstrap</li></ol><p>用于初始化客户端和服务器的辅助类，配置 Channel、EventLoopGroup、Handler 等。</p><ol><li>ByteBuf</li></ol><p>Netty 自定义的字节缓冲区，替代了 JDK 的 ByteBuffer，提供更高效的内存管理和读写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个容量为 256 字节的缓冲区</span></span><br><span class="line">ByteBuf buffer = Unpooled.buffer(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用已存在的字节数组创建 ByteBuf（共享数据）</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制字节数组创建 ByteBuf（数据独立）</span></span><br><span class="line">ByteBuf copiedBuffer = Unpooled.copiedBuffer(data);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Echo服务器"><a href="#Echo服务器" class="headerlink" title="Echo服务器"></a>Echo服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Echo server started on port &quot;</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg); <span class="comment">// 将接收到的消息写回客户端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush(); <span class="comment">// 刷新所有待处理的消息到远程节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Http服务器"><a href="#Http服务器" class="headerlink" title="Http服务器"></a>Http服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpHelloWorldServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;FullHttpRequest&gt;() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest req)</span> </span>&#123;</span><br><span class="line">                             FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                                     HttpVersion.HTTP_1_1,</span><br><span class="line">                                     HttpResponseStatus.OK,</span><br><span class="line">                                     ctx.alloc().buffer().writeBytes(<span class="string">&quot;Hello, World!&quot;</span>.getBytes())</span><br><span class="line">                             );</span><br><span class="line">                             response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">                             response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line">                             ctx.writeAndFlush(response);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;HTTP server started on port &quot;</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HttpHelloWorldServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WebSocket服务器"><a href="#WebSocket服务器" class="headerlink" title="WebSocket服务器"></a>WebSocket服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/ws&quot;</span>));</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt;() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> </span>&#123;</span><br><span class="line">                             System.out.println(<span class="string">&quot;Received: &quot;</span> + msg.text());</span><br><span class="line">                             ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;Echo: &quot;</span> + msg.text()));</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocket server started on port &quot;</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> WebSocketServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty 是一个基于 Java NIO 的异步、事件驱动的网络应用框架，旨在简化 TCP/UDP 等协议服务器和客户端的开发。它封装了底层的 NIO 细节，提供了易用的 API，广泛应用于高性能网络通信场景，如 Dubbo、RocketMQ、Elasticsearch 等中间件。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TinyWebServer项目学习</title>
    <link href="https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-20T09:46:11.000Z</published>
    <updated>2025-03-25T08:28:26.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>经典的C++ Linux网络编程项目.<br><span id="more"></span></p><blockquote><p>不相关的话:</p><p>C++后端相关项目集中体现在:Linux环境编程,网络编程,并发(多线程)编程</p><p>常见项目就是webserver以及基于moduo等库进行业务开发(聊天服务,结合mysql,redis)等.比如下面项目:</p><p><a href="https://zhuanlan.zhihu.com/p/688641400">从易到难，推荐9个适合练手的C++项目 - 知乎</a></p><p><a href="https://www.cnblogs.com/xiaokang-coding/p/18531816">应届生必看！23 个高质量 C++ 项目推荐，校招简历秒加分 - 江小康 - 博客园</a></p><p><a href="https://www.nowcoder.com/discuss/353157418395836416">我整理了10个可以写到简历上的C++项目_牛客网</a></p><p><a href="https://zhuanlan.zhihu.com/p/17138007124">GitHub项目推荐—适合练手的13个C++开源项目 - 知乎</a></p></blockquote><h2 id="并发同步方法"><a href="#并发同步方法" class="headerlink" title="并发同步方法"></a>并发同步方法</h2><p>在多线程并发条件下,对于共享资源,需要用锁机制解决.在c++标准中,有<code>mutex</code>,<code>condition_variable</code>以及新增的<code>barrier</code>,<code>latch</code>,<code>counting_semaphore</code>等机制.</p><p>这里使用了linux上的信号量<code>sem_t</code>和<code>pthread_mutex_t</code>锁机制.</p><h3 id="sem-t"><a href="#sem-t" class="headerlink" title="sem_t"></a>sem_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> waitSeconds)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(waitSeconds));</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem); <span class="comment">// 尝试获取信号量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; is running.\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem); <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 初始化信号量，初始值为2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(task, <span class="string">&quot;A&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(task, <span class="string">&quot;B&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(task, <span class="string">&quot;C&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem); <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>sem_wait</code> 函数用于等待一个信号量。它会尝试减少（减1）信号量的计数值。如果信号量的值大于0，则该函数会将信号量的值减1，并立即返回。</p><p>如果信号量的值为0，则调用 <code>sem_wait</code> 的线程或进程会被阻塞，直到另一个线程或进程通过调用 <code>sem_post</code> 增加了信号量的值，使得其大于0为止。</p><p>常用于表示“获取”一个资源或进入临界区。<strong>当信号量代表可用资源的数量时，<code>sem_wait</code> 可以理解为尝试占用一个资源。</strong>成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code></p><p>​    <code>sem_post</code>函数用于增加（加1）信号量的计数值，并通知可能正在等待该信号量的一个线程或进程。该函数总是成功地将信号量的值加1。</p><p>如果有其他线程或进程正在等待这个信号量（即因为信号量的值为0而被阻塞），那么其中一个等待的线程或进程会被唤醒并继续执行。常用于表示“释放”一个资源或离开临界区。<strong>当某个线程完成了对共享资源的操作后，可以通过调用 <code>sem_post</code> 来通知其他线程可以继续操作该资源</strong>。成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code></p><h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITERATIONS 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">increment_counter</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Mutex init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_mutex_t</code> 是 POSIX 线程（也称为 pthreads）库中用于实现互斥锁（mutex）的数据类型。互斥锁是一种同步机制，用于保护共享资源免受并发访问的影响，从而避免数据竞争和不一致的状态。</p><p>互斥锁：互斥锁是一种同步原语，用于确保在任何给定时间只有一个线程可以访问特定的代码段或共享资源。</p><p>初始化与销毁：互斥锁需要先初始化才能使用，并且在不再需要时应该被销毁以释放相关资源。</p><p>加锁与解锁：通过 <code>pthread_mutex_lock()</code> 和 <code>pthread_mutex_unlock()</code> 函数来控制对临界区的访问。</p><ol><li><p><strong>初始化互斥锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要初始化的互斥锁指针。</li><li><code>attr</code>: 互斥锁属性（通常可以传入 <code>NULL</code> 使用默认属性）。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>销毁互斥锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要销毁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>加锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要加锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>尝试加锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要尝试加锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，如果锁已经被其他线程持有则返回 <code>EBUSY</code>，失败返回其他错误码。</li></ul></li><li><p><strong>解锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要解锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li></ol><h3 id="pthread-cond-t"><a href="#pthread-cond-t" class="headerlink" title="pthread_cond_t"></a>pthread_cond_t</h3><p>在 POSIX 线程（也称为 pthreads）中，条件变量（<code>pthread_cond_t</code>）是一种用于线程间通信的同步机制。条件变量允许一个线程等待某个条件成立，而另一个线程可以在满足条件时通知等待的线程继续执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = <span class="built_in">rand</span>() % <span class="number">100</span>; <span class="comment">// 生产随机数</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex); <span class="comment">// 缓冲区满，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(item);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_var); <span class="comment">// 通知消费者</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex); <span class="comment">// 缓冲区空，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        item = <span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_var); <span class="comment">// 通知生产者</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumed: %d\n&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> prod_thread, cons_thread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond_var, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;prod_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cons_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(prod_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cons_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond_var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>初始化条件变量</strong></p><ul><li><p>```c++<br>int pthread_cond_init(pthread_cond_t <em>cond, const pthread_condattr_t </em>attr);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 指向要初始化的条件变量。</span><br><span class="line"><span class="bullet">     -</span> <span class="code">`attr`</span>: 条件变量属性，通常设置为 <span class="code">`NULL`</span> 使用默认属性。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**销毁条件变量**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 要销毁的条件变量。</li><li>返回值：成功返回 <code>0</code>，错误则返回非零错误码。</li></ul></li></ul></li></ol><p>等待和通知</p><ol><li><p><strong>等待条件变量</strong></p><ul><li><p>```c++<br>int pthread_cond_wait(pthread_cond_t <em>cond, pthread_mutex_t </em>mutex);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 条件变量。</span><br><span class="line"><span class="bullet">     -</span> <span class="code">`mutex`</span>: 保护共享资源的互斥锁，必须是在调用前已经锁定的同一个互斥锁。</span><br><span class="line"><span class="bullet">     -</span> 功能：原子地解锁互斥锁并使当前线程进入等待状态，直到被其他线程通过 <span class="code">`pthread_cond_signal`</span> 或 <span class="code">`pthread_cond_broadcast`</span> 唤醒。唤醒后，在重新开始执行之前会自动重新获取互斥锁。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**定时等待条件变量**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 条件变量。</li><li><code>mutex</code>: 保护共享资源的互斥锁。</li><li><code>abstime</code>: 绝对超时时间点，使用 <code>struct timespec</code> 定义。</li><li>功能：类似于 <code>pthread_cond_wait</code>，但是它会在指定的时间过后自动返回，即使条件尚未满足。</li><li>返回值：成功返回 <code>0</code>，超时返回 <code>ETIMEDOUT</code>，其他错误则返回相应的错误码。</li></ul></li></ul></li><li><p><strong>通知单个等待线程</strong></p><ul><li><p>```c++<br>int pthread_cond_signal(pthread_cond_t *cond);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 条件变量。</span><br><span class="line"><span class="bullet">     -</span> 功能：唤醒至少一个正在等待该条件变量的线程。如果有多个线程在等待，则具体唤醒哪一个由实现定义。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> <span class="strong">**广播通知所有等待线程**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 条件变量。</li><li>功能：唤醒所有正在等待该条件变量的线程。</li><li>返回值：成功返回 <code>0</code>，错误则返回非零错误码</li></ul></li></ul></li></ol><h2 id="异步日志写入"><a href="#异步日志写入" class="headerlink" title="异步日志写入"></a>异步日志写入</h2><p>文件读写是IO操作,会引起系统中断的耗时操作. 通过异步写入,</p><p>IO操作设计的阻塞/非阻塞与同步/异步区分:</p><ol><li><strong>阻塞 vs 非阻塞</strong>主要关注于如何处理未准备好数据的情况:是立即返回还是等待。</li><li><strong>同步 vs 异步</strong>则更多地涉及到整个I/O操作流程的设计理念:是否需要等待I/O操作完成才能继续执行。</li></ol><p>利用<strong>单例模式</strong>创建了日志类,这样每个线程都共享这个实例.</p><p>通过多线程写入文件,避免IO的阻塞.  如果使用异步写入,主线程将日志写入到一个阻塞列表,创建的读出线程读取这个阻塞列表并将内容写入文件. </p><p>这个过程涉及到生产者-消费者问题,在加入数据时,判断队列是否满,如果满则返回false表明不能再添加,同时唤醒条件变量等待的线程(也就是读取线程). 如果没满则添加数据,同时也唤醒读取线程.</p><p>当读取数据时,如果队列为空,则阻塞读取线程,释放锁,让写入线程写入阻塞列表(缓冲区). </p><p>所以异步日志创建时就会创建一个消费者线程用于读取数据并写入到文件. 设计一个缓冲区(阻塞队列),利用上面的并发同步方法,也就是一个生产者-消费者模型.</p><p>此外日志有根据日期写入到不同的文件,此外写入的行数超出要求的行数时会另外创建一个日志.</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>复用数据库的连接. 创建包含多个连接的连接池,初始化时根据账号密码以及数据库url创建连接存入list列表,这是个共享资源也需要使用锁进行保护. 这里使用信号量,根据连接数初始化信号量,每当获得一个连接,使用sem.wait(),信号量-1,信号量机制是当信号量为0时进行阻塞,否则减1. 当释放一个连接(将一个连接加入连接池),使用sem.post()信号量加1并唤醒阻塞线程. 对于一些共享资源,比如m_FreeConn和m_CurConn等变量进行锁保护.</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在I/O模型中，同步I/O和异步I/O主要的区别是内核向应用程序通知的是就绪事件还是完成事件，以及是由应用程序还是由内核来完成I/O的读写操作</p><blockquote><p>同步I/O：内核向应用程序通知就绪事件，由应用程序自身来完成I/O的读写操作<br>异步I/O：由内核来完成I/O的读写后向应用程序通知完成事件 </p></blockquote><p>在并发模式中，同步和异步的主要区别是<strong><em>\</em>功能完成的流程是否是顺序化的，是否需要等待**</strong> </p><blockquote><ul><li>同步：当遇到阻塞任务时，会一直等待，直到该任务处理完成，程序完全按照代码顺序执行；</li><li>异步：程序的执行需要由系统事件驱动，程序的执行是不确定的，没有顺序上的要求 </li></ul></blockquote><h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><h4 id="Reactor模式和Proactor模式"><a href="#Reactor模式和Proactor模式" class="headerlink" title="Reactor模式和Proactor模式"></a>Reactor模式和Proactor模式</h4><p>​    <strong>Reactor模式</strong>是一种事件驱动的设计模式，主要用于处理并发的输入操作（如网络连接或文件I/O）。它的主要思想是<strong>将所有I/O操作分派给一个专门的事件循环来处理，这个事件循环会监听多个事件源，并在相应的事件发生时调用对应的处理器（Handler）</strong>。这种模式非常适合于需要处理大量并发连接的应用程序，比如Web服务器。</p><blockquote><p>Reactor 模式的核心是使用事件循环监听多个文件描述符（如套接字），并在事件发生时调用相应的处理器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventHandler</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    fd_set read_fds; <span class="comment">// 监听的文件描述符集合</span></span><br><span class="line">    <span class="keyword">int</span> max_fd;      <span class="comment">// 最大文件描述符</span></span><br><span class="line">    std::vector&lt;EventHandler*&gt; handlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reactor</span>() : <span class="built_in">max_fd</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register_handler</span><span class="params">(<span class="keyword">int</span> fd, EventHandler* handler)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">FD_SET</span>(fd, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; max_fd) &#123;</span><br><span class="line">            max_fd = fd;</span><br><span class="line">        &#125;</span><br><span class="line">        handlers.<span class="built_in">push_back</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run_event_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            fd_set tmp_fds = read_fds;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;tmp_fds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Select error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_fd; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;tmp_fds)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> handler : handlers) &#123;</span><br><span class="line">                        handler-&gt;<span class="built_in">handle_event</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> :</span> <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(<span class="keyword">int</span> fd)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> bytes = <span class="built_in">read</span>(fd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Client disconnected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    <span class="keyword">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    sockaddr_in server_addr&#123;&#125;;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(server_fd, <span class="keyword">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;server_addr), <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line">    <span class="built_in">listen</span>(server_fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Reactor reactor;</span><br><span class="line">    ReadHandler read_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册服务器套接字</span></span><br><span class="line">    reactor.<span class="built_in">register_handler</span>(server_fd, &amp;read_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    reactor.<span class="built_in">run_event_loop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>Proactor模式</strong>是一种异步的事件处理模式，与Reactor模式不同，它允许操作在后台执行，当操作完成时通知应用程序。通常，Proactor模式<strong>涉及到的操作如读写文件或网络I/O都是通过操作系统提供的异步I/O服务来实现</strong>的。然而，在某些不支持异步I/O的操作系统上，<strong>可以通过同步I/O结合多线程或者回调机制来模拟Proactor模式的效果。这意味着主线程可以提交I/O操作给一个工作线程池，然后继续处理其他任务</strong>，而工作线程会在I/O操作完成后通过某种方式（例如回调函数）通知主线程</p><blockquote><p>Proactor 模式依赖于异步 I/O 操作，通常由操作系统提供支持。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proactor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;aiocb*&gt; aio_controls; <span class="comment">// 异步 I/O 控制块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Proactor</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cb : aio_controls) &#123;</span><br><span class="line">            <span class="keyword">delete</span> cb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start_read</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        aiocb* cb = <span class="keyword">new</span> <span class="built_in">aiocb</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(aiocb));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        cb-&gt;aio_fildes = fd;</span><br><span class="line">        cb-&gt;aio_buf = buffer;</span><br><span class="line">        cb-&gt;aio_nbytes = <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) - <span class="number">1</span>;</span><br><span class="line">        cb-&gt;aio_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        aio_controls.<span class="built_in">push_back</span>(cb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">aio_read</span>(cb) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error starting async read.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async read started on fd: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_for_completion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cb : aio_controls) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">aio_error</span>(cb) == EINPROGRESS) &#123;</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">1000</span>); <span class="comment">// 等待操作完成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ssize_t</span> bytes = <span class="built_in">aio_return</span>(cb);</span><br><span class="line">            <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Async read completed. Data: &quot;</span></span><br><span class="line">                          &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cb-&gt;aio_buf) &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Async read failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个文件进行异步读取</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Proactor proactor;</span><br><span class="line">    proactor.<span class="built_in">start_read</span>(fd); <span class="comment">// 开始异步读取</span></span><br><span class="line">    proactor.<span class="built_in">wait_for_completion</span>(); <span class="comment">// 等待完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>特性</th><th>Reactor 模式</th><th>Proactor 模式</th></tr></thead><tbody><tr><td><strong>核心机制</strong></td><td>同步 I/O，事件驱动</td><td>异步 I/O，操作系统支持</td></tr><tr><td><strong>适用场景</strong></td><td>高并发连接，如网络服务器</td><td>高性能 I/O 密集型应用</td></tr><tr><td><strong>复杂度</strong></td><td>较低，易于理解和实现</td><td>较高，需要操作系统支持异步 I/O</td></tr><tr><td><strong>效率</strong></td><td>受限于同步 I/O</td><td>更高效，I/O 操作在后台完成</td></tr><tr><td><strong>典型实现</strong></td><td><code>select</code>、<code>poll</code>、<code>epoll</code></td><td>POSIX AIO、Windows Overlapped I/O</td></tr></tbody></table></div><blockquote><ul><li>reactor模式中，主线程(<strong>I/O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I/O</strong>实现。</li><li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I/O</strong>实现。</li></ul></blockquote><h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><h4 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h4><p><strong>半同步/半异步（Half-Sync/Half-Async）模式</strong>是一种设计模式，用于处理不同类型的并发任务。它通过分离同步和异步的任务处理路径，使得系统能够更高效地管理资源并提高响应速度。这种模式特别适用于那些需要同时处理同步任务（如用户界面交互）和异步任务（如后台计算或I/O操作）的应用场景.</p><p><strong>同步层（Synchronous Layer）</strong>：负责处理需要立即响应的任务，例如用户界面的交互事件。这些任务通常要求快速响应以提供良好的用户体验。</p><p><strong>队列（Queue）</strong>：作为同步层和异步层之间的桥梁，用于传递消息或任务。同步层将任务放入队列中，异步层从队列中取出任务进行处理。</p><p><strong>异步层（Asynchronous Layer）</strong>：负责执行耗时较长的任务，比如文件I/O、网络通信或者复杂的计算。这些任务不会阻塞主线程，从而保证了系统的流畅性。</p><h4 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步/半反应堆模式"></a>半同步/半反应堆模式</h4><p><strong>半同步/半反应堆（Half-Sync/Half-Reactor）</strong>模式是一种混合的设计模式，它<strong>结合了同步和异步处理的优势来管理并发连接</strong>。这种模式通常用于服务器程序中，旨在提高系统的性能和可扩展性。</p><p><strong>Reactor部分</strong>：主要负责监听多个文件描述符（如套接字），并在相应的事件发生时（比如有新的连接请求或数据到达）通知对应的事件处理器。</p><ul><li>主线程运行一个事件循环，调用 <code>select</code>、<code>poll</code> 或者更高效的 <code>epoll</code> 等函数等待感兴趣的事件发生。</li><li>当检测到新的连接请求时，主线程接受该连接，并将其交给工作线程池中的某个线程处理。</li></ul><p><strong>Worker部分</strong>：每个工作线程独立地处理从主线程接收过来的具体连接上的读写操作。</p><ul><li>工作线程执行同步的I/O操作，这意味着它们会在读取或写入数据时阻塞，直到操作完成。</li><li>尽管如此，由于这些操作是在单独的线程中进行的，因此不会影响主线程对新连接的响应速度。</li></ul><h4 id="与半同步-半反应堆的区别"><a href="#与半同步-半反应堆的区别" class="headerlink" title="与半同步/半反应堆的区别"></a>与半同步/半反应堆的区别</h4><ul><li><strong>半同步/半反应堆</strong>：主要用于服务器程序中，其中主线程（Reactor部分）监听新的连接请求，然后将新建立的连接交给工作线程处理。这是一种专门针对网络编程的设计模式，强调的是如何有效地管理和分发多个并发连接。</li><li><strong>半同步/半异步模式</strong>：更加通用，不仅仅局限于网络编程。它可以应用于任何需要同时处理同步任务（如UI更新）和异步任务（如后台数据处理）的场景。其重点在于如何通过分离同步和异步的任务处理路径来优化系统性能和响应速度。</li></ul><p><a href="https://blog.csdn.net/qq_35423154/article/details/108930574?ops_request_misc=%7B%22request%5Fid%22%3A%22168103147416800192255531%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168103147416800192255531&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-108930574-null-null.142^v82^insert_down1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=半同步%2F半异步并发模式&amp;spm=1018.2226.3001.4187">Linux网络编程 | 并发模式：半同步/半异步模式、领导者/追随者模式_linux 网络编程 leadfollow模式-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/58860015">高山仰之可极，谈半同步/半异步网络并发模型 - 知乎</a></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>五种I/O模型</p><blockquote><ul><li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</li><li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li><li><strong>IO复用</strong>:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li><li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p><strong>注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。</strong></p></blockquote><p><strong>IO多路复用</strong>是一种允许单个进程监视多个文件描述符（如套接字、管道等）的技术，当其中任意一个文件描述符准备好进行读写操作时，该技术能够通知应用程序。这种方法可以显著提高服务器程序的性能，因为它避免了为每个连接创建单独线程或进程所带来的开销。</p><blockquote><p>单线程Polling API的常规用法是：</p><p>让Polling API监控服务端socket的状态，然后开始死循循环，循环过程中主要有三种逻辑分支：</p><ol><li>服务端socket的状态变为可读，即表示有客户端发起连接，此时就调用accept建立连接，得到一个客户端fd。将其加入到Polling API的监控集合，并标记其为可读。</li><li>客户端fd的状态变为可读，则调用read/recv从fd读取数据，然后执行业务逻辑，处理完，再将其加入到Polling API的监控集合，并标记其为可写。</li><li>客户端fd的状态变为可写，则调用write/send将数据发送给客户端。</li></ol></blockquote><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select</code>函数监视一组文件描述符，等待它们中的任何一个变为可读、可写或发生异常条件。</p><p>通过三个位图（fd_set类型）来分别表示需要监视的可读、可写及异常事件集合。</p><p>当调用<code>select</code>时，<strong>内核会阻塞当前进程，直到指定的文件描述符集合中的至少一个准备就绪</strong>。</p><p>返回值有响应的文件描述符个数.如果超时，则返回0；如果出错，则返回-1。</p><ol><li><p>在调用 <code>select</code> 之前，你需要将感兴趣的文件描述符添加到 <code>fd_set</code> 中（通过 <code>FD_SET</code>）。</p></li><li><p>当 <code>select</code> 返回时，<strong><code>fd_set</code> 中的内容会被更新，仅保留那些已经“就绪”的文件描述符</strong>。</p></li><li><p>换句话说，<code>select</code> 会清除未就绪的文件描述符，只留下那些可以进行读、写或异常处理的文件描述符。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">          fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>nfds</code>: 要监视的最大文件描述符加1。</li><li><code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>: 分别指向要监视的可读、可写及异常事件的文件描述符集合。</li><li><code>timeout</code>: 等待的时间限制，若设置为NULL则无限期等待。</li></ul><ol><li><code>FD_ZERO</code></li></ol><ul><li><p><strong>功能</strong>：清空一个 <code>fd_set</code> 集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_SET</code></li></ol><ul><li><p><strong>功能</strong>：将一个特定的文件描述符添加到一个 <code>fd_set</code> 集合中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">FD_SET(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_CLR</code></li></ol><ul><li><p><strong>功能</strong>：从一个 <code>fd_set</code> 集合中移除一个特定的文件描述符。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">FD_CLR(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_ISSET</code></li></ol><ul><li><p><strong>功能</strong>：检查一个特定的文件描述符是否在某个 <code>fd_set</code> 集合中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">FD_ISSET(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>fd_set数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    <span class="comment">// __FD_SETSIZE = 1024 表示fd_set是个包含一个1024bit数组的结构体</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><h4 id="select示例代码"><a href="#select示例代码" class="headerlink" title="select示例代码"></a>select示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fds, active_fds;</span><br><span class="line"> <span class="keyword">int</span> max_fd = sockfd;</span><br><span class="line"> std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; clients_fd;</span><br><span class="line"> <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line"> <span class="built_in">FD_SET</span>(sockfd, &amp;read_fds);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 轮询select 直到有连接</span></span><br><span class="line">   timeval timeout&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">   read_fds = active_fds;</span><br><span class="line">   <span class="comment">// select阻塞,直到相应文件描述符就绪(可读,可写或异常)</span></span><br><span class="line">   <span class="comment">// 成功返回时(&gt;=1),fd_set内容更新,仅保留就绪的fd</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">   <span class="built_in">errif</span>(ret &lt; <span class="number">0</span>, <span class="string">&quot;select failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;read_fds)) &#123;</span><br><span class="line">     <span class="comment">// 服务器可读(有connect连接)</span></span><br><span class="line">     sockaddr_in client_addr;</span><br><span class="line">     <span class="keyword">socklen_t</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">     <span class="built_in">bzero</span>(&amp;client_addr, client_addr_len);</span><br><span class="line">     <span class="keyword">int</span> client_sockfd =</span><br><span class="line">         <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     <span class="built_in">FD_SET</span>(client_sockfd, &amp;active_fds);</span><br><span class="line">     max_fd = std::<span class="built_in">max</span>(client_sockfd, max_fd);</span><br><span class="line">     clients_fd.<span class="built_in">push_back</span>(client_sockfd);</span><br><span class="line"></span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;New connection, socket fd: &quot;</span> &lt;&lt; client_sockfd</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it = clients_fd.<span class="built_in">begin</span>(); it != clients_fd.<span class="built_in">end</span>();) &#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> client_fd = *it;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(client_fd, &amp;read_fds)) &#123;</span><br><span class="line">       <span class="comment">//客户端可读数据</span></span><br><span class="line">       <span class="comment">// 读取数据</span></span><br><span class="line">       <span class="keyword">char</span> read_bytes[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">       <span class="keyword">size_t</span> bytes_len = <span class="built_in">read</span>(client_fd, read_bytes, <span class="built_in"><span class="keyword">sizeof</span></span>(read_bytes));</span><br><span class="line">       <span class="keyword">if</span> (bytes_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;client closed...\n&quot;</span>;</span><br><span class="line">         <span class="built_in">close</span>(client_fd);</span><br><span class="line">         <span class="built_in">FD_CLR</span>(client_fd, &amp;active_fds);</span><br><span class="line">         it = clients_fd.<span class="built_in">erase</span>(it);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         std::string resp =</span><br><span class="line">             <span class="string">&quot;你好,你发送了&quot;</span> + std::<span class="built_in">string</span>(read_bytes, bytes_len);</span><br><span class="line">         <span class="built_in">errif</span>(<span class="built_in">write</span>(client_fd, resp.<span class="built_in">c_str</span>(), resp.<span class="built_in">size</span>()) == <span class="number">-1</span>,</span><br><span class="line">               <span class="string">&quot;write socket failed&quot;</span>);</span><br><span class="line">         ++it;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ++it;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;client_fd : clients_fd) &#123;</span><br><span class="line">   <span class="comment">// 关闭所有客户端</span></span><br><span class="line">   <span class="built_in">close</span>(client_fd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// close 关闭服务端</span></span><br><span class="line"> <span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>支持跨平台使用，几乎所有类Unix系统都支持。</li></ul><p><strong>缺点</strong></p><ul><li><strong>文件描述符集合大小有限制</strong>（通常为1024）。</li><li>每次调用都需要重新构建文件描述符集合。</li><li>效率较低，随着监听的文件描述符数量增加性能下降明显。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>poll</code>与<code>select</code>类似，但它使用了一个结构体数组来代替<code>select</code>中的位图。</p><p>这使得它可以处理更多数量的文件描述符，并且没有像<code>select</code>那样的固定上限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>fds</code>: 指向一个包含多个<code>pollfd</code>结构体的数组，每个结构体描述了一个文件描述符及其感兴趣的事件。</li><li><code>nfds</code>: 数组中元素的数量。</li><li><code>timeout</code>: 等待的时间限制，单位为毫秒。</li></ul><p>pollfd数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure describing a polling request.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> events;<span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> revents;<span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>fd</code></strong>：要监视的文件描述符。</p></li><li><p><code>events</code></p><p>：请求监视的事件类型，可以是以下标志的组合：</p><ul><li><code>POLLIN</code>：有数据可读。</li><li><code>POLLPRI</code>：有紧急数据可读。</li><li><code>POLLOUT</code>：准备好写数据。</li><li><code>POLLRDHUP</code>（自 Linux 2.6.17 起）：TCP连接被对端关闭，或对端关闭了写入一半的连接。</li><li><code>POLLERR</code>：发生错误。</li><li><code>POLLHUP</code>：挂起。</li><li><code>POLLNVAL</code>：无效请求；指定的文件描述符无效。</li></ul></li><li><p><strong><code>revents</code></strong>：实际发生的事件，由内核在 <code>poll</code> 调用返回时填充。</p></li></ul><p>事件类型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Event types that can be polled for.  These bits may be set in `events&#x27;</span></span><br><span class="line"><span class="comment">   to indicate the interesting event types; they will appear in `revents&#x27;</span></span><br><span class="line"><span class="comment">   to indicate the status of the file descriptor.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLIN0x001<span class="comment">/* There is data to read.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLPRI0x002<span class="comment">/* There is urgent data to read.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLOUT0x004<span class="comment">/* Writing now will not block.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Event types always implicitly polled for.  These bits need not be set in</span></span><br><span class="line"><span class="comment">   `events&#x27;, but they will appear in `revents&#x27; to indicate the status of</span></span><br><span class="line"><span class="comment">   the file descriptor.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLERR0x008<span class="comment">/* Error condition.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLHUP0x010<span class="comment">/* Hung up.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLNVAL0x020<span class="comment">/* Invalid polling request.  */</span></span></span><br></pre></td></tr></table></figure><h4 id="poll示例代码"><a href="#poll示例代码" class="headerlink" title="poll示例代码"></a>poll示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;pollfd&gt; poll_fds;</span><br><span class="line">pollfd server_pollfd;</span><br><span class="line">server_pollfd.fd = sockfd;</span><br><span class="line">server_pollfd.events = POLLIN; <span class="comment">// 设置事件</span></span><br><span class="line">poll_fds.<span class="built_in">push_back</span>(server_pollfd);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="built_in">poll</span>(poll_fds.<span class="built_in">data</span>(), poll_fds.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">errif</span>(ret &lt; <span class="number">0</span>, <span class="string">&quot;poll error&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (poll_fds.<span class="built_in">at</span>(<span class="number">0</span>).revents &amp; POLLIN) &#123;</span><br><span class="line">    <span class="comment">// 数据读入事件</span></span><br><span class="line">    <span class="comment">// serverfd可读,即可accept</span></span><br><span class="line">    sockaddr_in client_addr&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                           (<span class="keyword">socklen_t</span> *)&amp;addr_len);</span><br><span class="line">    <span class="built_in">errif</span>(client_fd == <span class="number">-1</span>, <span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pollfd client_pollfd;</span><br><span class="line">    client_pollfd.fd = client_fd;</span><br><span class="line">    client_pollfd.events = POLLIN;</span><br><span class="line">    poll_fds.<span class="built_in">push_back</span>(client_pollfd);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New connection, socket fd: &quot;</span> &lt;&lt; client_fd</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = poll_fds.<span class="built_in">begin</span>() + <span class="number">1</span>; it != poll_fds.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">char</span> bytes_read[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">    pollfd &amp;client_pollfd = *it;</span><br><span class="line">    <span class="keyword">size_t</span> read_bytes_len =</span><br><span class="line">        <span class="built_in">read</span>(client_pollfd.fd, bytes_read, <span class="built_in"><span class="keyword">sizeof</span></span>(bytes_read));</span><br><span class="line">    <span class="keyword">if</span> (read_bytes_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 关闭</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;client closed...\n&quot;</span>;</span><br><span class="line">      <span class="built_in">close</span>(client_pollfd.fd);</span><br><span class="line">      it = poll_fds.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// echo</span></span><br><span class="line">      std::string resp =</span><br><span class="line">          <span class="string">&quot;你好,你的请求是&quot;</span> + std::<span class="built_in">string</span>(bytes_read, read_bytes_len);</span><br><span class="line">      <span class="built_in">write</span>(client_pollfd.fd, resp.<span class="built_in">data</span>(), resp.<span class="built_in">size</span>());</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 关闭所有客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pfd : poll_fds) &#123;</span><br><span class="line">      <span class="built_in">close</span>(pfd.fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>不受文件描述符数量的限制。</li><li>对于大量文件描述符的情况比<code>select</code>更高效。</li></ul><p><strong>缺点</strong></p><ul><li>在大量文件描述符的情况下，效率仍然不高，因为每次调用都需要遍历整个文件描述符列表。</li></ul><p>对于大量文件描述符的情况，<code>poll</code> 的性能优于 <code>select</code>，因为它不需要每次调用前都重新初始化文件描述符集合。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li><code>epoll</code>是Linux特有的高级IO多路复用机制，旨在克服<code>select</code>和<code>poll</code>的局限性。</li><li><p>它采用事件驱动的方式，只有当某个文件描述符有事件发生时才会被通知，而不是每次都检查所有文件描述符的状态。</p></li><li><p><code>epoll_create1</code>: 创建一个新的epoll实例。</p></li><li><code>epoll_ctl</code>: 向epoll实例添加、修改或删除关注的文件描述符。</li><li><code>epoll_wait</code>: 等待事件的发生。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建epoll实例</span></span><br><span class="line"><span class="comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class="line"><span class="comment">   The &quot;size&quot; parameter is a hint specifying the number of file</span></span><br><span class="line"><span class="comment">   descriptors to be associated with the new instance.  The fd</span></span><br><span class="line"><span class="comment">   returned by epoll_create() should be closed with close().  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE</span></span><br><span class="line"><span class="comment">   parameter has been dropped.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 控制epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>当使用 <code>epoll_create</code> 或 <code>epoll_create1</code> 函数创建一个新的 <code>epoll</code> 实例时，<strong>Linux 内核会在内部创建一个“事件表”</strong>。<strong>这个事件表本质上是一个动态调整大小的数据结构，用来跟踪所有被注册到该 <code>epoll</code> 实例上的文件描述符及其感兴趣的事件类型</strong>（如可读、可写等）。通过这种方式，应用程序可以向内核注册多个文件描述符，并指定对每个文件描述符感兴趣的事件类型。</p></blockquote><p><strong>epoll_ctl</strong></p><ul><li><p><strong><code>epfd</code></strong>：指向由 <code>epoll_create</code> 或 <code>epoll_create1</code> 创建的 <code>epoll</code> 实例的文件描述符。</p></li><li><p><code>op</code></p><p>：指定要执行的操作类型，可以是以下值之一：</p><ul><li><strong><code>EPOLL_CTL_ADD</code></strong>：将新的文件描述符加入到 <code>epoll</code> 实例的监视列表中，并关联相应的事件。</li><li><strong><code>EPOLL_CTL_MOD</code></strong>：修改已经存在于 <code>epoll</code> 实例中的文件描述符所关注的事件。</li><li><strong><code>EPOLL_CTL_DEL</code></strong>：从 <code>epoll</code> 实例中移除一个文件描述符，不再监视其事件。</li></ul></li><li><p><strong><code>fd</code></strong>：要操作的目标文件描述符。</p></li><li><p><strong><code>event</code></strong>：指向 <code>struct epoll_event</code> 结构体的指针，包含与该文件描述符相关联的事件信息（当 <code>op</code> 是 <code>EPOLL_CTL_ADD</code> 或 <code>EPOLL_CTL_MOD</code> 时需要）。对于 <code>EPOLL_CTL_DEL</code> 操作，此参数可以为 <code>NULL</code>，因为此时仅关心移除文件描述符本身。</p></li></ul><p><strong>epoll_event结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>events</code></strong>：</p><ul><li>表示需要监视的事件类型。</li><li>它是一个位掩码（bitmask），可以是以下标志的组合：<ul><li><strong><code>EPOLLIN</code></strong>：表示文件描述符可读（有数据可读）。</li><li><strong><code>EPOLLOUT</code></strong>：表示文件描述符可写（可以写入数据）。</li><li><strong><code>EPOLLRDHUP</code></strong>：表示对端关闭了连接或关闭了写入方向（自 Linux 2.6.17 起支持）。</li><li><strong><code>EPOLLPRI</code></strong>：表示有紧急数据可读（例如带外数据）。</li><li><strong><code>EPOLLERR</code></strong>：表示发生了错误。</li><li><strong><code>EPOLLHUP</code></strong>：表示挂起（hang up），通常表示对端关闭了连接。</li><li><strong><code>EPOLLET</code></strong>：启用边缘触发模式（Edge-Triggered, ET）。默认是水平触发模式（Level-Triggered, LT）。</li><li><strong><code>EPOLLONESHOT</code></strong>：表示事件只会触发一次，之后需要重新添加到 <code>epoll</code> 实例中。</li></ul></li></ul></li><li><p><strong><code>data</code></strong>：</p><ul><li><p>这是一个联合体（union），允许用户将任意数据与文件描述符关联起来。</p></li><li><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>    *ptr;  <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="keyword">int</span>      fd;   <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> u32;  <span class="comment">// 32位无符号整数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;  <span class="comment">// 64位无符号整数</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>最常见的用法是通过 <code>fd</code> 字段存储文件描述符，以便在事件触发时快速定位对应的文件描述符。</p></li></ul></li></ul><h4 id="epoll示例代码"><a href="#epoll示例代码" class="headerlink" title="epoll示例代码"></a>epoll示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">errif</span>(epoll_fd == <span class="number">-1</span>, <span class="string">&quot;epoll creation failed&quot;</span>);</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENTS = <span class="number">10</span>;</span><br><span class="line"> epoll_event ev, events[MAX_EVENTS];</span><br><span class="line"> ev.events = POLLIN | EPOLLET; <span class="comment">// 水平触发模式</span></span><br><span class="line"> ev.data.fd = sockfd;</span><br><span class="line"> <span class="comment">// 添加服务端fd</span></span><br><span class="line"> ret = <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"> <span class="built_in">errif</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ctl failed&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 等待事件</span></span><br><span class="line">   <span class="keyword">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">errif</span>(nfds == <span class="number">-1</span>, <span class="string">&quot;epoll waut failed&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> ((events[<span class="number">0</span>].data.fd == sockfd) &amp;&amp; (events[<span class="number">0</span>].events &amp; POLLIN)) &#123;</span><br><span class="line">     <span class="comment">// accept就绪</span></span><br><span class="line">     sockaddr_in client_addr;</span><br><span class="line">     <span class="keyword">socklen_t</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">     <span class="keyword">int</span> client_fd =</span><br><span class="line">         <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     epoll_event ev;</span><br><span class="line">     ev.events = EPOLLIN | EPOLLET; <span class="comment">// 水平触发模式</span></span><br><span class="line">     ev.data.fd = client_fd;</span><br><span class="line">     <span class="comment">// 将客户端连接加入epoll实例</span></span><br><span class="line">     ret = <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line">     <span class="built_in">errif</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ctl failed&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_EVENTS; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (events[i].events &amp; POLLIN) &#123;</span><br><span class="line">       <span class="keyword">int</span> client_fd = events[i].data.fd;</span><br><span class="line">       <span class="comment">// read就绪</span></span><br><span class="line">       <span class="keyword">char</span> bytes_read[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">       <span class="keyword">size_t</span> bytes_read_len = <span class="built_in">read</span>(client_fd, bytes_read, <span class="built_in"><span class="keyword">sizeof</span></span>(bytes_read));</span><br><span class="line">       <span class="keyword">if</span> (bytes_read_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;client connection closed...\n&quot;</span>;</span><br><span class="line">         <span class="built_in">close</span>(client_fd);</span><br><span class="line">         <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, <span class="literal">nullptr</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         std::string resp =</span><br><span class="line">             <span class="string">&quot;你好,你发送了:&quot;</span> + std::<span class="built_in">string</span>(bytes_read, bytes_read_len);</span><br><span class="line">         <span class="built_in">write</span>(client_fd, resp.<span class="built_in">data</span>(), resp.<span class="built_in">size</span>());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="built_in">close</span>(epoll_fd);</span><br></pre></td></tr></table></figure><ul><li>默认情况下，<code>epoll</code> 使用水平触发模式（Level-Triggered, LT），即只要文件描述符处于就绪状态，<code>epoll_wait</code> 就会一直返回。</li><li>通过设置 <code>EPOLLET</code> 标志，可以启用边缘触发模式（Edge-Triggered, ET）。在这种模式下，只有当文件描述符的状态发生变化时，<code>epoll_wait</code> 才会返回。</li></ul><p><strong>优点</strong></p><ul><li>高效地管理大量文件描述符。</li><li>只返回活跃的文件描述符，减少了不必要的上下文切换。</li><li>支持边缘触发（Edge Triggered）和水平触发（Level Triggered）两种模式。</li></ul><p><strong>缺点</strong></p><ul><li>仅适用于Linux操作系统，不具有跨平台兼容性。</li></ul><p><strong>注意事项</strong></p><ol><li><strong>边缘触发模式的使用</strong>：<ul><li>在边缘触发模式下，必须一次性读取完所有可用数据，否则可能会丢失事件。</li></ul></li><li><strong>错误处理</strong>：<ul><li>示例代码中包含了基本的错误处理，在实际应用中应更全面地处理各种异常情况。</li></ul></li><li><strong>缓冲区大小</strong>：<ul><li>确保 <code>BUFFER_SIZE</code> 足够大，以避免数据截断。</li></ul></li></ol><p>​    设置epoll触发事件时可以设置水平触发(LT)和边缘触发(ET).</p><p>如果使用 LT 模式，只要文件描述符处于就绪状态（例如，对于读操作而言，意味着有数据可读），每次调用 <code>epoll_wait()</code> 都会返回该文件描述符。这意味着<strong>即使没有完全读取所有可用的数据，在后续的 <code>epoll_wait()</code> 调用中，只要还有未处理的数据，这个文件描述符仍然会被标记为就绪</strong>。</p><p>​    ET 模式仅在文件描述符的状态发生变化时触发一次通知（即从不可读变为可读或反之）。这意味着如果你在一个 <code>epoll_wait()</code> 返回后没有完全处理完所有可用的数据，<strong>那么在下一次调用 <code>epoll_wait()</code> 之前，即使文件描述符仍然处于就绪状态，也不会再次收到通知。因此，你需要确保一次性读取尽可能多的数据直到没有更多数据为止</strong>。</p><ul><li><p>选择 LT 还是 ET 主要取决于你的应用需求</p><ul><li>如果你需要简单的实现，并且对偶尔的重复通知不敏感，LT 是更好的选择。</li><li>如果你追求高性能，并且能够保证每次都能高效地处理所有数据，ET 则可能更适合。</li></ul></li><li><p>通常建议</p><ul><li>对于大多数情况，默认使用 LT 模式即可满足需求。</li><li>在需要处理大量并发连接并且希望减少系统开销的情况下，可以考虑使用 ET 模式，但需要小心处理以避免错过事件。</li></ul><h4 id="LT-模式示例"><a href="#LT-模式示例" class="headerlink" title="LT 模式示例"></a><strong>LT 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line">event.data.fd = listen_sock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line">            <span class="comment">// 接受新连接...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理现有连接上的数据...</span></span><br><span class="line">            <span class="comment">// LT 模式下，如果有剩余数据未读，下次 epoll_wait 仍会通知</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ET-模式示例"><a href="#ET-模式示例" class="headerlink" title="ET 模式示例"></a><strong>ET 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = listen_sock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line">            <span class="comment">// 接受新连接...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ET 模式下，需要循环读取直到 EAGAIN 或 EWOULDBLOCK</span></span><br><span class="line">            <span class="keyword">while</span> ((nread = <span class="built_in">read</span>(events[i].data.fd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nread == <span class="number">-1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ET 模式的特点</strong>：只会在文件描述符状态发生变化时触发一次通知，因此需要开发者确保在每次事件触发时尽可能多地处理数据。</li><li>为什么需要 <code>while</code> 循环<ul><li>确保读取所有可用数据，避免遗漏。</li><li><strong>防止因为缓冲区大小限制或数据分段到达而导致未处理的数据残留</strong>。</li><li>提高数据处理的效率和可靠性。</li></ul></li></ul></li></ul><blockquote><p>在网络编程中，特别是在高并发场景下，以下情况可能导致数据未被完全读取：</p><ul><li><strong>TCP 流的特性</strong>：<ul><li>TCP 是面向流的协议，数据是以字节流的形式传输的，而不是固定大小的消息包。接收方可能会收到部分数据，也可能收到多个消息拼接在一起的数据。</li><li>即使当前已经触发了“可读”事件，你并不能假设一次 <code>read()</code> 调用就能读取到完整的数据块。</li></ul></li><li><strong>缓冲区的限制</strong>：<ul><li>每次调用 <code>read()</code> 时，操作系统内核会将数据从内核缓冲区复制到用户空间缓冲区。如果用户空间缓冲区不足以容纳所有数据，则只能读取一部分数据。</li><li>剩余的数据仍然存在于内核缓冲区中，但在 ET 模式下，如果没有新的事件触发，这些数据将不会被通知给应用程序。</li></ul></li></ul></blockquote><div class="table-container"><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td><strong>跨平台支持</strong></td><td>是</td><td>是</td><td>否（仅Linux）</td></tr><tr><td><strong>最大文件描述符数</strong></td><td>有限制（通常是1024）</td><td>无限制</td><td>无限制</td></tr><tr><td><strong>性能</strong></td><td>随文件描述符数量增加而降低</td><td>相对较好，但仍有改进空间</td><td>非常高效，适合高并发场景</td></tr><tr><td><strong>事件通知方式</strong></td><td>轮询所有文件描述符</td><td>轮询所有文件描述符</td><td>仅通知活跃的文件描述符</td></tr></tbody></table></div><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>实现了一个定时器,定时器包括截至时间,回调函数以及client_data.</p><p>超时的时候调用回调函数,执行将fd从epoll中去除并close(fd),user_count—的操作. 并实现定时器队列,按照定时器的截至事件升序.</p><p>webserver包含多个client_data,client_data包含fd,address以及定时器用于控制超时事件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WebServer::WebServer() &#123;</span><br><span class="line">  <span class="comment">// http_conn类对象</span></span><br><span class="line">  users = <span class="keyword">new</span> http_conn[MAX_FD]; <span class="comment">// 为每个连接创建一个http_conn和client_data对象</span></span><br><span class="line">  <span class="comment">// 用户数据</span></span><br><span class="line">  users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line">  <span class="comment">// root文件夹路径</span></span><br><span class="line">  <span class="keyword">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">  getcwd(server_path, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置文件根目录</span></span><br><span class="line">  <span class="keyword">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">  m_root = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">  <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关书籍和资料"><a href="#相关书籍和资料" class="headerlink" title="相关书籍和资料"></a>相关书籍和资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/689466361">《Linux高性能服务器编程》</a></li><li><a href="https://www.manongbook.com/linux/681.html">Linux多线程服务端编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/460399249">《TCP/IP网络编程》学习笔记 - 知乎</a></li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&amp;mid=2649274278&amp;idx=4&amp;sn=caa323faf0c51d882453c0e0c6a62282&amp;chksm=83ffbefeb48837e841a6dbff292217475d9075e91cbe14042ad6e55b87437dcd01e6d9219e7d&amp;cur_album_id=1339230165934882817&amp;scene=189#wechat_redirect">最新版Web服务器项目详解 - 02 半同步半反应堆线程池（上）</a></p><p>Unix环境高级编程</p><p>Unix网络编程</p><p>类似项目github上有很多</p><p><a href="https://github.com/forthespada/MyPoorWebServer">forthespada/MyPoorWebServer: 一款可运行的基于C++ 实现的WebServer服务器，基于《TCPIP网络编程》和《Linux高性能服务器编程》实现的服务器项目。</a></p><p><a href="https://github.com/linyacool/WebServer">linyacool/WebServer: A C++ High Performance Web Server</a></p><p><a href="https://github.com/Wlgls/30daysCppWebServer">Wlgls/30daysCppWebServer</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的C++ Linux网络编程项目.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
    <category term="webserver" scheme="https://www.sekyoro.top/tags/webserver/"/>
    
  </entry>
  
  <entry>
    <title>Java项目大赏(实习版)</title>
    <link href="https://www.sekyoro.top/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/"/>
    <id>https://www.sekyoro.top/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/</id>
    <published>2025-03-20T09:38:06.000Z</published>
    <updated>2025-07-24T13:00:07.187Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在准备实习,找一些<del>烂大街</del>经典项目练练手.<br><span id="more"></span></p><h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><p>一个项目通常包含公共类(常量,工具以及异常)部分以及实体类部分</p><p><img data-src="https://s2.loli.net/2025/04/22/q8oS52LepZjOgHc.png" alt="image-20250422144407360"></p><p>此外还有service,controller,mapper(repository)层以及一些配置类,拦截器等</p><h4 id="Jwt登录验证"><a href="#Jwt登录验证" class="headerlink" title="Jwt登录验证"></a>Jwt登录验证</h4><ol><li>用户登录请求</li></ol><p>客户端（通常是浏览器或App）发送包含用户名和密码的登录请求到后端。</p><ol><li>服务端验证身份</li></ol><p>后端接收请求，验证用户名和密码是否正确：</p><ul><li>正确：生成 JWT，返回给客户端</li><li>错误：返回认证失败响应</li></ul><ol><li>服务端生成 JWT</li></ol><p>服务端使用 <strong>密钥</strong> 对 payload 进行签名，生成一个完整的 token：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bashCopyEditeyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.    <span class="attr"># Header</span></span><br><span class="line"><span class="attr">eyJ1</span>c<span class="number">2</span>VySWQiOjEyMywidX<span class="symbol">Nlcm5</span>hbWUiOiJ<span class="number">0</span>b<span class="number">20</span>iLCJleHAiOjE<span class="number">3</span>MT<span class="name">M1</span><span class="symbol">NjgwMDB9</span>.  <span class="attr"># Payload</span></span><br><span class="line"><span class="attr">SflKxwRJSMeKKF2</span>QT<span class="number">4</span>fwpMeJf<span class="number">36</span>POk<span class="number">6</span>yJV_adQssw<span class="number">5</span>c  <span class="attr"># Signature</span></span><br></pre></td></tr></table></figure><blockquote><p>服务端此后 <strong>不再保存用户状态</strong>，所有认证信息都由 token 自带。</p></blockquote><ol><li>客户端保存 JWT</li></ol><p>客户端收到 token 后，通常将其存储在：</p><ul><li><code>localStorage</code> / <code>sessionStorage</code></li><li>cookie（慎用，需设置 <code>HttpOnly</code> 和 <code>Secure</code>）</li></ul><ol><li>客户端携带 JWT 访问资源</li></ol><p>客户端每次请求受保护的资源时，在请求头中携带 token：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Authorization:</span> Bearer <span class="params">&lt;token&gt;</span></span><br></pre></td></tr></table></figure><ol><li>服务端验证 JWT</li></ol><ul><li>服务端提取 token，验证签名是否合法、是否过期。</li><li>若合法，解析 payload，拿到 <code>userId</code> 等信息，并执行业务逻辑。</li></ul><h3 id="🔐-JWT-的结构"><a href="#🔐-JWT-的结构" class="headerlink" title="🔐 JWT 的结构"></a>🔐 JWT 的结构</h3><p>JWT 是一个由三部分组成的字符串，用 <code>.</code> 分隔：</p><ol><li>Header（头部）</li></ol><p>描述签名的算法及类型，通常是这样的：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jsonCopyEdit&#123;</span></span><br><span class="line"><span class="keyword"></span>  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Payload（有效载荷）</li></ol><p>存放业务数据，不应包含敏感信息，因为它是明文的。常见字段：</p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>sub</code></td><td>主题（Subject）</td></tr><tr><td><code>exp</code></td><td>过期时间（Expiration Time）</td></tr><tr><td><code>iat</code></td><td>签发时间（Issued At）</td></tr><tr><td><code>userId</code></td><td>自定义字段，通常是用户唯一标识</td></tr><tr><td><code>roles</code></td><td>自定义字段，表示用户权限角色</td></tr></tbody></table></div><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;userId&quot;</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1713568000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Signature（签名）</li></ol><p>由 header 和 payload 使用密钥 <code>secret</code> 签名生成，用于防篡改。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditHMACSHA256(</span><br><span class="line">  <span class="name">base64UrlEncode</span>(<span class="name">header</span>) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(<span class="name">payload</span>),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>🧾 JWT 优点</strong></p><ul><li>无需在服务端存储 Session，实现 <strong>无状态认证</strong></li><li>可跨服务、跨域使用（适合微服务）</li><li>自带用户信息，减少查库压力</li><li>易扩展，可加入权限、组织、平台等字段</li></ul><p><strong>⚠️ 安全建议</strong></p><ul><li><strong>token 不要放敏感信息</strong>（明文可读）</li><li>设置合理的 <strong>过期时间</strong></li><li>通过 <code>HTTPS</code> 传输，防止中间人攻击</li><li>使用 <code>HttpOnly + Secure</code> 的 cookie 保存（如 SSR）</li></ul><h4 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h4><p>开放接口规范有Swagger(springfox)和<strong>OpenAPI</strong>(目前常用).</p><p>可以使用springdoc-openapi或Knife4j工具通过添加注解生成规范</p><p><a href="https://github.com/springdoc/springdoc-openapi">springdoc/springdoc-openapi: Library for OpenAPI 3 with spring-boot</a></p><p><a href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j</a></p><p><img data-src="https://s2.loli.net/2025/04/22/QKmht3v8O4pyAPC.png" alt="image-20250422195017608"></p><h4 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h4><p>增加mapper的插入语句增加员工信息,注意插入错误处理.</p><p>以及通过interceptor,threadlocal存储登录信息.</p><h4 id="分页查询员工"><a href="#分页查询员工" class="headerlink" title="分页查询员工"></a>分页查询员工</h4><p>利用mybatis的pagehelper插件,其通过拦截执行的查询语句修改其中的LIMIT返回结果.首先设置页大小和需要查询的页.</p><ol><li><code>PageHelper.startPage(pageNum, pageSize)</code></li></ol><p>用于设置当前页码和每页条数，<strong>必须在执行查询语句之前调用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 第1页，每页10条</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(users);</span><br></pre></td></tr></table></figure><ol><li><code>PageHelper.offsetPage(offset, limit)</code></li></ol><p>按偏移量方式分页，适合流式加载等场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.offsetPage(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">// 跳过前20条，查询10条</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br></pre></td></tr></table></figure><p>然后在mapper中的sql语句中直接写查询条件,返回Page结果.</p><div class="table-container"><table><thead><tr><th>问题/注意点</th><th>说明</th></tr></thead><tbody><tr><td>startPage 必须紧跟查询语句</td><td>否则分页不起作用（建议不要有中间处理逻辑）</td></tr><tr><td>不支持多线程共享分页上下文</td><td>每次分页只作用于当前线程</td></tr></tbody></table></div><p><code>Page&lt;T&gt;</code>：继承自 <code>ArrayList&lt;T&gt;</code>，直接包含结果数据 + 分页信息；</p><p><code>PageInfo&lt;T&gt;</code>：是一个额外封装类，包含分页信息（适合返回给前端）；</p><h4 id="POJO中日期序列化"><a href="#POJO中日期序列化" class="headerlink" title="POJO中日期序列化"></a>POJO中日期序列化</h4><p><img data-src="https://s2.loli.net/2025/04/23/28JgwEfF7bZNsQz.png" alt="image-20250423140945684"></p><p>在 Spring Boot 项目中，如果你使用的是 Jackson（Spring Boot 默认的 JSON 序列化库），<strong>可以通过配置 <code>ObjectMapper</code> 或 <code>application.yml</code> 来自定义 <code>LocalDateTime</code> / <code>LocalDate</code> / <code>LocalTime</code> 的序列化格式</strong>。</p><p>✅ 方法一：在全局 <code>ObjectMapper</code> 中注册时间模块（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">        <span class="comment">// LocalDateTime</span></span><br><span class="line">        javaTimeModule.addSerializer(LocalDateTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateTimeSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalDateTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LocalDate</span></span><br><span class="line">        javaTimeModule.addSerializer(LocalDate.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalDate.class,</span><br><span class="line">                <span class="keyword">new</span> LocalDateDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LocalTime</span></span><br><span class="line">        javaTimeModule.addSerializer(LocalTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalTimeSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line">        javaTimeModule.addDeserializer(LocalTime.class,</span><br><span class="line">                <span class="keyword">new</span> LocalTimeDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        mapper.registerModule(javaTimeModule);</span><br><span class="line">        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); <span class="comment">// 防止序列化为时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 方法二：使用 <code>@JsonFormat</code> 注解在字段上局部配置</p><p>适合只对个别字段格式化时使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p><img data-src="https://s2.loli.net/2025/04/29/J3v6auIHbXNZxkT.png" alt="image-20250429162721846"></p><h3 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h3><p><img data-src="https://s2.loli.net/2025/04/30/iE9YtUfMhqRXn46.png" alt="image-20250430210633413"></p><h3 id="Websocket主动推送订单消息"><a href="#Websocket主动推送订单消息" class="headerlink" title="Websocket主动推送订单消息"></a>Websocket主动推送订单消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerEndpointExporter 会自动扫描所有 @ServerEndpoint 注解的类。</p><p>注册到 Servlet 容器的 WebSocket 运行时（ServerContainer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/students&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentWebSocketEndpoint</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储所有连接的会话（线程安全）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session.getBasicRemote().sendText(<span class="string">&quot;Connected to Student WebSocket&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 收到客户端消息，广播给所有连接</span></span><br><span class="line">        <span class="keyword">for</span> (Session s : sessions) &#123;</span><br><span class="line">            s.getBasicRemote().sendText(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播学生更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastStudentUpdate</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Apache-Echarts展示信息"><a href="#Apache-Echarts展示信息" class="headerlink" title="Apache Echarts展示信息"></a>Apache Echarts展示信息</h3><h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><p>缓存作用: 降低后端负载,提升读写速度</p><p>开发成本和维护一致性问题</p><h3 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h3><p><a href="https://redis.io/docs/latest/develop/clients/jedis/">Jedis guide (Java) | Docs</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 Jedis 连接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>); <span class="comment">// 假设 Redis 服务运行在本地，默认端口为 6379</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to Redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空 Redis 数据库，确保测试环境干净</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个测试方法执行之后运行</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭 Jedis 连接</span></span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;Disconnected from Redis&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;proanimer&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        String name = jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;proanimer&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:2&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;24&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/04/12/TEPKoIHGYOma4Jy.png" alt="image-20250412221454173" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS));</span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><p><a href="https://spring.io/projects/spring-data-redis">Spring Data Redis</a></p><p><img data-src="https://s2.loli.net/2025/04/13/IPJL4xzF2aGAOfN.png" alt="image-20250413141133598" style="zoom:50%;" /></p><h4 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h4><p>在使用 Spring Data Redis 时，序列化器（Serializer）用于<strong>将 Java 对象转换为适合存储在 Redis 中的格式</strong>（如字节数组），并在从 Redis 读取数据时将其反序列化回 Java 对象。选择合适的序列化器对于确保数据正确性以及优化性能非常重要。默认序列化器是JDK序列化器.</p><ol><li><code>JdkSerializationRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：这是默认的序列化器，使用 Java 的序列化机制来处理对象。</li><li><strong>优点</strong>：支持任意类型的 Java 对象。</li><li><strong>缺点</strong>：生成的数据较大，效率较低，并且只有在同一 JVM 环境下才能正确反序列化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>StringRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：专门用于字符串的序列化器，能够高效地处理字符串类型的数据。</li><li><strong>优点</strong>：简单、快速，适用于大多数键值对场景。</li><li><strong>缺点</strong>：仅限于字符串类型的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>GenericJackson2JsonRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：使用 Jackson 库将对象序列化为 JSON 格式。</li><li><strong>优点</strong>：易于阅读和调试，支持复杂对象结构。</li><li><strong>缺点</strong>：相对于其他二进制格式（如 Protocol Buffers），JSON 的体积更大，解析速度较慢。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Jackson2JsonRedisSerializer</code></li></ol><ul><li><strong>描述</strong>：类似于 <code>GenericJackson2JsonRedisSerializer</code>，但它允许你指定序列化的具体类型。</li><li><strong>优点</strong>：可以更精确地控制序列化过程。</li><li><strong>缺点</strong>：需要提前知道序列化对象的确切类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, MyObject&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, MyObject&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    Jackson2JsonRedisSerializer&lt;MyObject&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(MyObject.class);</span><br><span class="line">    template.setValueSerializer(serializer);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>OxmSerializer</code></li></ol><ul><li><strong>描述</strong>：用于 XML 数据的序列化/反序列化。</li><li><strong>优点</strong>：适用于需要以 XML 格式存储数据的场景。</li><li><strong>缺点</strong>：XML 数据通常比 JSON 更大，处理速度也较慢。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    OxmSerializer serializer = <span class="keyword">new</span> Jaxb2Marshaller(); <span class="comment">// 示例使用 JAXB</span></span><br><span class="line">    template.setValueSerializer(serializer);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>自定义序列化器</li></ol><p>根据业务需求，你也可以实现自己的序列化器，只需要实现 <code>RedisSerializer&lt;T&gt;</code> 接口即可。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRedisSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">MyCustomType</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(MyCustomType t) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="comment">// 实现序列化逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyCustomType <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="comment">// 实现反序列化逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在配置中使用自定义序列化器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, MyCustomType&gt; <span class="title">customRedisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, MyCustomType&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.setValueSerializer(<span class="keyword">new</span> CustomRedisSerializer());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/04/13/VKJzFQulyvWTSfa.png" alt="image-20250413160821439"></p><h3 id="基于Session的登陆"><a href="#基于Session的登陆" class="headerlink" title="基于Session的登陆"></a>基于Session的登陆</h3><p><img data-src="https://s2.loli.net/2025/03/20/VqbA8F34U17C9xZ.png" alt="image-20250320175751672"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">sendCode</span><span class="params">(String phone, HttpSession session)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1.校验</span></span><br><span class="line">      <span class="comment">/*  String phoneRegex = &quot;^1[3-9]\\d&#123;9&#125;$&quot;;</span></span><br><span class="line"><span class="comment">        if (!phone.matches(phoneRegex)) &#123;</span></span><br><span class="line"><span class="comment">            return Result.fail(&quot;手机号格式错误&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">boolean</span> phoneInvalid = RegexUtils.isPhoneInvalid(phone);</span><br><span class="line"><span class="comment">//        2.如果不符合</span></span><br><span class="line">        <span class="keyword">if</span> (phoneInvalid) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        3.符合,生成验证码</span></span><br><span class="line">        String code = RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//        4.保存验证码到session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line"><span class="comment">//        5.发送验证码</span></span><br><span class="line">        log.debug(StrUtil.format(<span class="string">&quot;发送验证码成功，验证码：&#123;&#125;&quot;</span>, code));</span><br><span class="line"><span class="comment">//        返回ok</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1.校验手机号和验证码</span></span><br><span class="line">        String phone = loginForm.getPhone();</span><br><span class="line">        <span class="keyword">boolean</span> phoneInvalid = RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">        <span class="keyword">if</span> (phoneInvalid) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String code = loginForm.getCode();</span><br><span class="line">        String codeInSession = (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!code.equals(codeInSession)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2.查询用户</span></span><br><span class="line">        User user = query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//            不存在 创建用户</span></span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        3.保存用户信息到session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">createUserWithPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(<span class="number">8</span>));</span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注册登录问题,可以使用拦截器方便注册登陆以及校验权限,  从基于session到基于redis</p><p>基于session的登陆, 验证码存在session中,在拦截器中获取session或者请求头中的信息,</p><p>可以使用ThreadLocal,在拦截器方法中存储用户信息避免其他线程访问. 登陆成功将发送生成的token给客户端,并且存在服务端session中.</p><p>每次访问,在进行权限校验中,根据token在session得到用户信息,如果有就通过权限校验.</p><p>通过重写WebMvcConfigure类添加拦截器与路径,重写Interceptor类</p><blockquote><p>WebMvcConfigure类可以用于添加拦截器与静态资源处理以及CORS等等.</p><p>Interceptor类允许你在请求被 <strong>Controller 处理之前</strong>、<strong>Controller 处理之后但在视图渲染之前</strong>、以及<strong>整个请求处理完成之后</strong>进行拦截和处理。它提供了一种灵活的方式来对请求进行预处理和后处理，而无需修改 Controller 或业务逻辑代码。</p><p><code>HandlerInterceptor</code> 的主要作用是实现 AOP（面向切面编程）的理念，对 Web 请求处理流程进行<strong>横向切割</strong>，用于实现一些通用的功能，例如：</p><ol><li><strong>权限校验/身份认证：</strong> 在请求到达 Controller 之前，检查用户是否已登录或是否有权限访问某个资源。</li><li><strong>日志记录：</strong> 记录请求的进入、退出时间，以及请求参数、响应状态等信息。</li><li><strong>性能监控：</strong> 计算请求的处理时间，进行性能分析。</li><li><strong>数据预处理：</strong> 在 Controller 处理之前对请求参数进行一些统一的格式化或校验。</li><li><strong>跨域处理：</strong> 添加或修改响应头，处理 CORS 相关的逻辑。</li><li><strong>国际化：</strong> 根据用户请求的语言设置，切换对应的语言环境。</li><li><strong>会话管理：</strong> 检查会话状态，或进行会话续期。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        String key  = LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> UserDTO(), <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h4><p><img data-src="https://s2.loli.net/2025/04/14/xZREAUpPzkQBiVF.png" alt="image-20250414154105418"></p><h4 id="基于Redis的短信登陆"><a href="#基于Redis的短信登陆" class="headerlink" title="基于Redis的短信登陆"></a>基于Redis的短信登陆</h4><p><img data-src="https://s2.loli.net/2025/04/14/bVvPz25pxkyMqB9.png" alt="image-20250414161242250"></p><p>基于session的问题  多台tomcat不共享session</p><p>使用基于redis的登陆注册</p><p>当登陆时，如果使用账号+手机验证码形式，当前端发送验证码请求，将手机号码和生成的手机验证码存在对应的缓存中，然后登陆时校验。成功就返回一个token，然后将token存在缓存中.可以使用user_id作key.   </p><p>  在使用session登陆时,存储信息直接利用了servlet,tomcat提供的session机制,服务器会创建对应会话的session并返回JSESSIONID给客户端,客户端会主动携带该id,服务器直接访问对应的session对象及其包含属性即可.</p><p>而使用redis登陆,确定缓存的值对象类型</p><p><img data-src="https://s2.loli.net/2025/07/15/5lLUKEwJnexXoua.png" alt="image-20250715141126358"></p><p>当进入用户权限网页时,读取httpservletRequest中的参数,从请求中获取token,在缓存中查找,找到就满足.  客户端将token放在sessionStorage中进行保存,请求时放在header中的<code>authorization</code>头中,服务端在对应请求头中拿到token.</p><h4 id="优化拦截器"><a href="#优化拦截器" class="headerlink" title="优化拦截器"></a>优化拦截器</h4><p><img data-src="https://s2.loli.net/2025/04/14/36voF12n9YepEkI.png" alt="image-20250414210106336"></p><p>原本的拦截器只拦截需要权限的controller,但是如果已经有cookie的用户只访问不需要权限的controller就不会更新redis.   也就是说已登陆用户访问不需要权限的网页不会更新缓存,导致一段时间后失效.</p><p><img data-src="https://s2.loli.net/2025/04/14/sUTIzrhMgqNpR7H.png" alt="image-20250414210226312"></p><p>因此添加全局拦截器,访问所有页面,如果是已登陆用户,更新缓存中TTL,否则什么也不做,直接放行,对于需要权限的拦截器进行检测.</p><h4 id="登陆以及权限校验关键问题"><a href="#登陆以及权限校验关键问题" class="headerlink" title="登陆以及权限校验关键问题"></a>登陆以及权限校验关键问题</h4><p><strong>基于session或者基于redis缓存</strong></p><p>session存在tomcat集群不共享的问题,当请求切换到不同tomcat服务时导致数据丢失</p><p><strong>拦截器配置  通过interceptor或者自己通过AOP实现校验</strong></p><p>通过拦截器,在请求或者session中拿到校验信息</p><p>可以使用ThreadLocal在拦截器中直接在session或者redis中获得信息</p><p><strong>此外还有基于JWT的无状态认证机制,服务器本身不存储session.</strong></p><p>在登陆成功后,客户端每次携带jwt,JWT本身存储了用户的一些关键信息,具体来说,JWT包含头部,负载,签名.</p><p>头部包含算法类型,负载包括注册声明、公共声明以及私有声明. 签名是通过密钥加密后的头部和负载加密. </p><blockquote><p>Payload 部分是 Base64url 编码的，不是加密的。这意味着任何人都可以解码 Payload 并读取其中的内容。因此，绝不能在 Payload 中存放敏感信息</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  </span><br><span class="line">   <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;user_123&quot;</span>,        <span class="comment">// 用户ID</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alice Smith&quot;</span>,    <span class="comment">// 用户名</span></span><br><span class="line">  <span class="attr">&quot;roles&quot;</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>], <span class="comment">// 用户角色</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1752496261</span>,        <span class="comment">// 过期时间戳</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1752492661</span>         <span class="comment">// 签发时间戳  //注意这些部分都会进行base64编码</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">&quot;signature&quot;</span>:HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(payload), secret) <span class="comment">//使用 Header 中指定的算法（如 HS256 或 RS256）和服务器端的密钥 (Secret Key)（对于对称加密，如 HS256）或私钥（对于非对称加密，如 RS256）对连接后的字符串进行签名。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，这三部分用点连接起来，就构成了完整的 JWT 字符串，例如： <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></p><h3 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h3><p><img data-src="https://s2.loli.net/2025/04/14/HTdpXizlnASGQqv.png" alt="image-20250414220321389"></p><p><img data-src="https://s2.loli.net/2025/04/14/jc9OQH8oFwMLz5K.png" alt="image-20250414233753517"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img data-src="https://s2.loli.net/2025/04/15/p72NIzH9MfZaxnR.png" alt="image-20250415103603707"></p><p><img data-src="https://s2.loli.net/2025/04/15/y7bowaDxTL2f8GJ.png" alt="image-20250415103926298"></p><div class="table-container"><table><thead><tr><th>策略</th><th>读操作</th><th>写操作</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Cache Aside</strong></td><td>先查缓存，再查数据库</td><td>更新数据库后删除缓存</td><td>简单、灵活、一致性较好</td><td>存在短暂不一致、未命中时性能较差</td><td>数据读多写少、一致性要求不高</td></tr><tr><td><strong>Read/Write Through</strong></td><td>缓存负责未命中处理</td><td>缓存负责同步到数据库</td><td>透明性好、一致性好</td><td>复杂性高、可能成为性能瓶颈</td><td>数据一致性要求高</td></tr><tr><td><strong>Write Behind Caching</strong></td><td>先查缓存，再查数据库</td><td>异步批量写回数据库</td><td>写性能高、吞吐量大</td><td>数据丢失风险、一致性差</td><td>数据写多读少、一致性要求低</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/04/15/TU3KbireNcB4G67.png" alt="image-20250415105910579"></p><p><img data-src="https://s2.loli.net/2025/04/15/CFEZY2mKqnwljAW.png" alt="image-20250415111429325"></p><p><img data-src="https://s2.loli.net/2025/04/15/LqgUJKSZD9Gfad6.png" alt="image-20250415111703513"></p><div class="table-container"><table><thead><tr><th>名称</th><th>触发场景</th><th>结果</th><th>常见解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>请求的数据本就不存在（DB 也无）</td><td>每次请求都打到数据库</td><td>缓存空值、布隆过滤器</td></tr><tr><td>缓存击穿</td><td>某个热点 key 恰好过期了</td><td>大量请求同时访问 DB，瞬时压力大</td><td>加互斥锁、热点预热</td></tr><tr><td>缓存雪崩</td><td>大量 key 在同一时间过期</td><td>缓存失效，数据库压力激增</td><td>加随机过期时间、限流、降级</td></tr></tbody></table></div><p>布隆过滤器是基于一个 <strong>bit 数组</strong> + 多个 <strong>哈希函数</strong>：</p><ol><li>初始创建一个很大的 bit 数组（如 1 亿位，全是 0）。</li><li>插入元素时，用多个哈希函数对元素哈希，得到多个下标位置，把这些位置设为 1。</li><li>查询时，对待查元素用相同的哈希函数求下标：<ul><li>若所有对应 bit 位都是 1 → 可能存在</li><li>有任意一个 bit 是 0 → 一定不存在</li></ul></li></ol><p><img data-src="https://s2.loli.net/2025/04/15/MozbdO6Ly2aCI4E.png" alt="image-20250415133050673"></p><p><img data-src="https://s2.loli.net/2025/04/15/aujZnwSzgiUxloL.png" alt="image-20250415143221507"></p><p><img data-src="https://s2.loli.net/2025/04/15/xBTlfUn6WmDpwIJ.png" alt="image-20250415144016106"></p><p><img data-src="https://s2.loli.net/2025/04/15/Tcd5tCruUKo6wvM.png" alt="image-20250415144408811"></p><p><img data-src="https://s2.loli.net/2025/04/15/x5ayubhtcrSK8qQ.png" alt="image-20250415144944179"></p><p><img data-src="https://s2.loli.net/2025/04/15/EBpdcml8I7tLvxU.png" alt="image-20250415145118864"></p><h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><p>全局ID生成器,在分布式系统下用来生成全局唯一ID的工具.</p><p>满足:唯一性,高可用,高性能,递增性,安全性.</p><p><img data-src="https://s2.loli.net/2025/04/15/3LSmM7p8e5gfXcN.png" alt="image-20250415194042557"></p><p><img data-src="https://s2.loli.net/2025/04/15/tXm5rvyNMhbxeYL.png" alt="image-20250415231649294" style="zoom:67%;" /></p><p><img data-src="https://s2.loli.net/2025/04/16/zTXyB8Uo7RKWmc2.png" alt="image-20250416162534054" style="zoom:67%;" /></p><h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁  乐观锁"></a>悲观锁  乐观锁</h4><p><img data-src="https://s2.loli.net/2025/04/16/9QRuCerNJpmcHaf.png" alt="image-20250416192913692"></p><p>乐观锁的关键是判断之前查询得到的数据是否被修改过.常见方式:</p><ol><li>版本号法</li></ol><p>给数据添加版本号,每次更新的时候查询数据对应的版本,如果版本号跟之前的不同则表明更新过了. </p><p><img data-src="https://s2.loli.net/2025/04/16/3tu9mqXVNyoDZYT.png" alt="image-20250416194812142"></p><ol><li>CAS法</li></ol><p><img data-src="https://s2.loli.net/2025/04/16/eCKmRn4QDs7pSLA.png" alt="image-20250416212059026" style="zoom:67%;" /></p><p>一人一单,使用悲观锁,加锁. 但在分布式系统下,多个实例下进程不相干,无法进行线程同步,需要实现分布式锁.</p><p>分布式锁:满足分布式系统或集群模式下多进程可见并且互斥的锁</p><p><img data-src="https://s2.loli.net/2025/04/17/t4sZY1NizPOvRcX.png" alt="image-20250417095719500"></p><p>基于Redis的分布式锁</p><p>使用<code>setnx</code></p><p><img data-src="https://s2.loli.net/2025/04/17/JBC3Xe1HPmpfnwa.png" alt="image-20250417124148443"></p><p>注意如果出现业务耗时超过key的ttl,导致其他线程拿到锁,在删除锁时检查value是否一致。</p><p>redis lua脚本</p><p><img data-src="https://s2.loli.net/2025/04/17/X7GMsSg59QjnaRf.png" alt="image-20250417133641854"></p><p><img data-src="https://s2.loli.net/2025/04/17/AG1vHk7s2u6FexB.png" alt="image-20250417143320701"></p><h4 id="Redisson可重入锁"><a href="#Redisson可重入锁" class="headerlink" title="Redisson可重入锁"></a>Redisson可重入锁</h4><p><img data-src="https://s2.loli.net/2025/04/17/2jkGcgNIYylmQL8.png" alt="image-20250417152425433"></p><h4 id="可重试-更新超时时间"><a href="#可重试-更新超时时间" class="headerlink" title="可重试/更新超时时间"></a>可重试/更新超时时间</h4><p><img data-src="https://s2.loli.net/2025/04/17/lytxPu8ZirBRH5s.png" alt="image-20250417181249028"></p><p><img data-src="https://s2.loli.net/2025/04/17/EYhwIoeVBgmkHfU.png" alt="image-20250417181558824"></p><p>所以利用redis缓存作分布式锁的需要核心解决的<strong>可重入</strong>和<strong>超时重试机制</strong>.</p><h4 id="主从一致性问题"><a href="#主从一致性问题" class="headerlink" title="主从一致性问题"></a>主从一致性问题</h4><p>一、单机多实例（适合开发和测试环境）</p><p>配置不同的实例端口,多个配置文件启动多个实例.</p><p>二、多机集群,在每台服务器上创建一个 Redis 配置文件（如 <code>redis-cluster.conf</code>），并添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ul><li><code>cluster-enabled yes</code>：启用集群模式。</li><li><code>cluster-config-file nodes.conf</code>：指定集群节点配置文件。</li><li><code>cluster-node-timeout 5000</code>：设置节点超时时间（毫秒）</li></ul><p><img data-src="https://s2.loli.net/2025/04/17/UiIyGpJA4RoP7Dh.png" alt="image-20250417232039727"></p><p><img data-src="https://s2.loli.net/2025/04/18/cn3NCI9O24upUlg.png" alt="image-20250418111401540"></p><p><img data-src="https://s2.loli.net/2025/04/18/IRiKpLMBV1cCUs3.png" alt="image-20250418143910127"></p><p><img data-src="https://s2.loli.net/2025/04/18/bS3QAUKsTHoRY1q.png" alt="image-20250418182224084"></p><h4 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h4><p><img data-src="https://s2.loli.net/2025/04/18/ayrfSevJ8TdGUF3.png" alt="image-20250418200244539"></p><h4 id="基于list数据结构"><a href="#基于list数据结构" class="headerlink" title="基于list数据结构"></a>基于list数据结构</h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 2^32^ -1个元素。主要利用<code>BRPOP</code>移除列表元素,如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止. 同时通过<code>LPUSH</code>添加值.</p><p><img data-src="https://s2.loli.net/2025/04/18/9ih5CDwLBlKNERW.png" alt="image-20250418203901472"></p><h5 id="pubsub-点对点消息消息模型"><a href="#pubsub-点对点消息消息模型" class="headerlink" title="pubsub 点对点消息消息模型"></a>pubsub 点对点消息消息模型</h5><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="img"></p><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="img"></p><p><img data-src="https://s2.loli.net/2025/04/18/7LEADu5klUBta8Q.png" alt="image-20250418210559430"></p><p><img data-src="https://s2.loli.net/2025/04/18/2lE9g7iU3WBpsIy.png" alt="image-20250418210832702"></p><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列(MQ，Message Queue),Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消<strong>息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃</strong>。</p><p>简单来说发布订阅 (pub/sub) 可以分发消息，但<strong>无法记录历史消息。</strong></p><p><strong>而 Redis Stream 提供了消息的持久化和主备复制功能</strong>，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2020/09/en-us_image_0167982791.png" alt="img"></p><ul><li><strong>Stream</strong>: 在 Redis 中，一个 Stream 就是一个追加日志类型的键值对集合。</li><li><strong>Entry</strong>: 每个流中的元素称为 Entry 或者 Message，由唯一标识符（ID）和数据字段组成。</li><li><strong>Consumer Group</strong>: 允许不同的消费者组从同一个流中读取消息，每个组可以独立地跟踪自己已经消费的消息位置。</li><li><strong>ID</strong>: 每条消息都有一个唯一的 ID，格式为 <code>&lt;timestamp&gt;-&lt;sequence&gt;</code>，其中时间戳是消息添加时的时间，序列号用于区分同一毫秒内添加的消息。</li></ul><p><img data-src="https://s2.loli.net/2025/04/18/N41xhBcZ6qTWUiG.png" alt="image-20250418223626722"></p><p><img data-src="https://s2.loli.net/2025/04/18/JE9ZNCxDHaBWpw1.png" alt="image-20250418224505431" style="zoom: 33%;" /></p><h5 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h5><p><img data-src="https://s2.loli.net/2025/04/18/oTspnQeVrkqgOcv.png" alt="image-20250418225321965"></p><p>给消费者分类,消息漏读,消息确认避免消息丢失.</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>XADD</code></td><td>添加消息到 Stream</td></tr><tr><td><code>XRANGE</code> / <code>XREVRANGE</code></td><td>范围读取消息（正/反向）</td></tr><tr><td><code>XREAD</code></td><td>阻塞或非阻塞读取消息</td></tr><tr><td><code>XGROUP CREATE</code></td><td>创建消费者组</td></tr><tr><td><code>XREADGROUP</code></td><td>按消费者组读取消息</td></tr><tr><td><code>XACK</code></td><td>确认消息已处理</td></tr><tr><td><code>XPENDING</code></td><td>查看待处理（未 ack）消息</td></tr><tr><td><code>XDEL</code></td><td>删除指定消息</td></tr><tr><td><code>XTRIM</code></td><td>裁剪旧消息，控制 Stream 大小</td></tr><tr><td><code>XLEN</code></td><td>获取 Stream 长度</td></tr><tr><td><code>XINFO</code></td><td>获取 Stream / Consumer 详细信息</td></tr></tbody></table></div><h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br></pre></td></tr></table></figure><blockquote><p>创建名为 <code>mygroup</code> 的消费者组，<code>$</code> 从最新消息开始消费，<code>MKSTREAM</code> 可自动创建 Stream。</p></blockquote><h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 2 STREAMS mystream &gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&gt;</code> 表示读取尚未分配的消息（新消息）。</p></blockquote><h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XACK mystream mygroup 1686900000000-0</span><br></pre></td></tr></table></figure><h4 id="查看未确认消息"><a href="#查看未确认消息" class="headerlink" title="查看未确认消息"></a>查看未确认消息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPENDING mystream mygroup</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>XINFO STREAM mystream</code></td><td>查看 stream 本体信息</td></tr><tr><td><code>XINFO GROUPS mystream</code></td><td>查看所有消费者组信息</td></tr><tr><td><code>XINFO CONSUMERS mystream mygroup</code></td><td>查看某个消费者组中各个消费者状态</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/04/18/sVrCm1K7YTewhaq.png" alt="image-20250418233032176"></p><p>消费者组中的多消费者争抢消息体现在</p><p>在 Redis Stream 中使用 <strong>消费者组（Consumer Group）</strong> 时，有个关键的机制是：</p><blockquote><p>➤ <strong>同一个消费者组内，一个消息只会被分配给一个消费者处理。</strong></p></blockquote><p>这意味着：</p><ul><li><p>如果消费者 A <strong>已经读取并 ack（确认）了一条消息</strong>，那么：</p><ul><li>同组内的消费者 B 是 <strong>无法再读取这条消息</strong> 的。</li><li>除非你专门指定消息 ID 重新读取（例如用 <code>XREADGROUP</code> + 指定 ID）。</li></ul></li><li><p>如果你希望 <strong>消费者 B</strong> 能“读到之前被其他消费者已处理的消息”，你必须显式指定 ID，并该消息<strong>未被 ack</strong>或使用 <code>XPENDING</code> 查找。</p><h5 id="✅如何让消费者读取“历史消息”？"><a href="#✅如何让消费者读取“历史消息”？" class="headerlink" title="✅如何让消费者读取“历史消息”？"></a>✅如何让消费者读取“历史消息”？</h5><p>场景 1：消息还未被 ack（pending）</p><p>可以通过 <code>XPENDING</code> + <code>XCLAIM</code> 把消息“抢过来”：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditPendingMessages pending = stringRedisTemplate.ops<span class="constructor">ForStream()</span></span><br><span class="line">    .pending(<span class="string">&quot;mystream&quot;</span>, <span class="string">&quot;mygroup&quot;</span>, <span class="module-access"><span class="module"><span class="identifier">Range</span>.</span></span>unbounded<span class="literal">()</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (PendingMessage message : pending) &#123;</span><br><span class="line">    <span class="comment">// 把未 ack 的消息交给当前消费者</span></span><br><span class="line">    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.ops<span class="constructor">ForStream()</span>.claim(</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Consumer</span>.</span></span>from(<span class="string">&quot;mygroup&quot;</span>, <span class="string">&quot;consumer2&quot;</span>),</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Duration</span>.</span></span><span class="keyword">of</span><span class="constructor">Seconds(5)</span>,</span><br><span class="line">        message.get<span class="constructor">Id()</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景 2：消息已被 ack，想重复读取</p><p>Redis 默认设计下是不会让你“重复消费”被 ack 的消息的，<strong>但你可以手动读取它（不是 group 模式）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用消费者组，直接用 XREAD + ID</span></span><br><span class="line">List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.opsForStream()</span><br><span class="line">    .read(StreamOffset.fromStart(<span class="string">&quot;mystream&quot;</span>)); <span class="comment">// 或者用具体 ID</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>XRANGE</code> 来精确读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某条历史消息</span></span><br><span class="line">stringRedisTemplate.opsForStream()</span><br><span class="line">    .range(<span class="string">&quot;mystream&quot;</span>, Range.closed(<span class="string">&quot;1682390889639-0&quot;</span>, <span class="string">&quot;1682390889639-0&quot;</span>));</span><br></pre></td></tr></table></figure><p>| 场景                                | 是否能重新读取                 |<br>| —————————————————- | ——————————————— |<br>| 消费者组内，消息已被 ack            | ❌（除非用非 group 方式手动读） |<br>| 消费者组内，消息未被 ack（pending） | ✅（可以用 XCLAIM 抢回来）      |<br>| 想让多个消费者都能读一条消息        | ❌（组内不支持；需非 group 读） |</p></li></ul><p><img data-src="https://s2.loli.net/2025/04/18/ay8uA5fSi3RvTMV.png" alt="image-20250418233143096"></p><p><img data-src="https://s2.loli.net/2025/04/19/4rg9LteAzoDlaWb.png" alt="image-20250419131039088" style="zoom:50%;" /></p><p><img data-src="https://s2.loli.net/2025/04/19/muwJasz9gGTxAHK.png" alt="image-20250419131059130"></p><h3 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h3><h4 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h4><p><img data-src="https://s2.loli.net/2025/04/20/p92Zqc4evEjimXY.png" alt="image-20250420143555600"></p><h4 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h4><p><img data-src="https://s2.loli.net/2025/04/20/Y2jI3QHEemkOBvi.png" alt="image-20250420144640978"></p><h4 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h4><p>写两个接口,一个查看是否关注,另一个进行关注或取关.</p><p>关注的数据表设计为user_id和follower_id. 为一个关注记录</p><p><img data-src="https://s2.loli.net/2025/04/20/OqkUF4G21LYZM5K.png" alt="image-20250420200822771"></p><p><img data-src="https://s2.loli.net/2025/04/20/hNcu5avy2WmPBMk.png" alt="image-20250420200856032"></p><h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h4><p><img data-src="https://s2.loli.net/2025/04/20/thV71ZUKQlaqs3i.png" alt="image-20250420200600057"></p><p>在新增关注时添加缓存,同时利用redis中的set交集操作在缓存中得到共同关注</p><h4 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h4><p><img data-src="https://s2.loli.net/2025/04/20/gCqrxOB86TdfhLb.png" alt="image-20250420220334492"></p><p><img data-src="https://s2.loli.net/2025/04/21/8wXL5PpFBWu1c6K.png" alt="image-20250421092155097"></p><p>通过推模式,通过分页滚动读取关注用户发布的博客数据. 用户发布博客时将博客id加入关注自己的粉丝的收件箱, 使用sorted set,以时间戳为score(即推模式)</p><p><img data-src="https://s2.loli.net/2025/04/21/9IYeW5iocs3u1PB.png" alt="image-20250421224913326"></p><p>关键是利用最新的时间戳去拿最新的博客id,同时利用偏移量滤去相同的时间戳(默认不会重复). 如果考虑发布时间重复,也可以在存储score时在时间戳基础上加一个随机值避免score重复.</p><h4 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h4><p><a href="https://www.runoob.com/redis/redis-geo.html">Redis GEO | 菜鸟教程</a></p><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p><p>Redis GEO 操作方法有：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><p>geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p><p>geoadd 语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure><ul><li>m ：米，默认单位。</li><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</li><li>WITHCOORD: 将位置元素的经度和纬度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li><li>COUNT 限定返回的记录数。</li><li>ASC: 查找结果根据距离从近到远排序。</li><li>DESC: 查找结果根据从远到近排序。</li></ul><h4 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h4><p><img data-src="https://s2.loli.net/2025/04/22/61cqOWxZMwnfemh.png" alt="image-20250422105634699"></p><p><img data-src="https://s2.loli.net/2025/04/22/aGspbuONkSMdqxf.png" alt="image-20250422111632294"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"><span class="keyword">int</span> dayOfYear = now.getDayOfYear();</span><br><span class="line"><span class="keyword">int</span> year = now.getYear();</span><br><span class="line">String key = SIGN_KEY + UserHolder.getUser().getId()+ <span class="string">&quot;:&quot;</span> + year;</span><br><span class="line">Boolean signSuccess = stringRedisTemplate.opsForValue().setBit(key, dayOfYear-<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (BooleanUtil.isTrue(signSuccess)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;签到失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h4><p>使用<code>bitfield</code>查询一个范围内的二进制返回十进制数据.</p><p><img data-src="https://s2.loli.net/2025/04/22/dfuNzSwYlVOsJD1.png" alt="image-20250422121102888"></p><h4 id="UV统计-HyperLogLog"><a href="#UV统计-HyperLogLog" class="headerlink" title="UV统计  HyperLogLog"></a>UV统计  HyperLogLog</h4><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><img data-src="https://s2.loli.net/2025/04/22/MEm6zF5nt28TBch.png" alt="image-20250422121540587"></p><p><img data-src="https://s2.loli.net/2025/04/22/ztXRO9DFqkU68xV.png" alt="image-20250422122336390"></p><h1 id="EasyChat"><a href="#EasyChat" class="headerlink" title="EasyChat"></a>EasyChat</h1><h3 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h3><p><img data-src="https://s2.loli.net/2025/05/02/C8LFUSamDZfsJPA.png" alt="image-20250502155041889"></p><p><img data-src="https://s2.loli.net/2025/05/02/WABFut1yEYeLSPa.png" alt="image-20250502195913653"></p><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>登陆时检查心跳缓存避免别处登陆,完成后保存用户信息缓存,并查询联系人存在缓存中.</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册完成后,主要是创建了机器人账号并加入了会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SysSettingDto sysSettingDto = redisComponet.getSysSetting();</span><br><span class="line">String contactId = sysSettingDto.getRobotUid();</span><br><span class="line">String contactName = sysSettingDto.getRobotNickName();</span><br><span class="line">String senMessage = sysSettingDto.getRobotWelcome();</span><br><span class="line">senMessage = StringTools.cleanHtmlTag(senMessage);</span><br><span class="line"><span class="comment">//增加机器人好友</span></span><br><span class="line">UserContact userContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">userContact.setUserId(userId);</span><br><span class="line">userContact.setContactId(contactId);</span><br><span class="line">userContact.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">userContact.setCreateTime(curDate);</span><br><span class="line">userContact.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">userContact.setLastUpdateTime(curDate);</span><br><span class="line">userContactMapper.insert(userContact);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加会话信息</span></span><br><span class="line">String sessionId = StringTools.getChatSessionId4User(<span class="keyword">new</span> String[]&#123;userId, contactId&#125;);</span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(senMessage);</span><br><span class="line">chatSession.setSessionId(sessionId);</span><br><span class="line">chatSession.setLastReceiveTime(curDate.getTime());</span><br><span class="line"><span class="keyword">this</span>.chatSessionMapper.insert(chatSession);</span><br><span class="line"></span><br><span class="line">ChatSessionUser applySessionUser = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">applySessionUser.setUserId(userId);</span><br><span class="line">applySessionUser.setContactId(contactId);</span><br><span class="line">applySessionUser.setContactName(contactName);</span><br><span class="line">applySessionUser.setSessionId(sessionId);</span><br><span class="line"><span class="keyword">this</span>.chatSessionUserMapper.insertOrUpdate(applySessionUser);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加聊天消息</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setMessageType(MessageTypeEnum.CHAT.getType());</span><br><span class="line">chatMessage.setMessageContent(senMessage);</span><br><span class="line">chatMessage.setSendUserId(contactId);</span><br><span class="line">chatMessage.setSendUserNickName(contactName);</span><br><span class="line">chatMessage.setSendTime(curDate.getTime());</span><br><span class="line">chatMessage.setContactId(userId);</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><h4 id="保存用户信息"><a href="#保存用户信息" class="headerlink" title="保存用户信息"></a>保存用户信息</h4><p>更新用户信息,controller参数设置为userInfo,然后将其中的不能修改的信息设置为null.</p><p>如果更改了昵称,更新缓存中的用户信息,键为token. </p><p>除了更新userinfo表,如果昵称不一样还要更新chat_session_user表,根据contact</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新相关表冗余的字段</span></span><br><span class="line">String contactNameUpdate = null;</span><br><span class="line"><span class="keyword">if</span> (!dbInfo.get<span class="constructor">NickName()</span>.equals(userInfo.get<span class="constructor">NickName()</span>)) &#123;</span><br><span class="line">    contactNameUpdate = userInfo.get<span class="constructor">NickName()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contactNameUpdate<span class="operator"> == </span>null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新token中的昵称</span></span><br><span class="line">TokenUserInfoDto tokenUserInfoDto = redisComponet.get<span class="constructor">TokenUserInfoDtoByUserId(<span class="params">userInfo</span>.<span class="params">getUserId</span>()</span>);</span><br><span class="line">tokenUserInfoDto.set<span class="constructor">NickName(<span class="params">contactNameUpdate</span>)</span>;</span><br><span class="line">redisComponet.save<span class="constructor">TokenUserInfoDto(<span class="params">tokenUserInfoDto</span>)</span>;</span><br><span class="line"></span><br><span class="line">chatSessionUserService.update<span class="constructor">RedundanceInfo(<span class="params">contactNameUpdate</span>, <span class="params">userInfo</span>.<span class="params">getUserId</span>()</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringTools</span>.</span></span>is<span class="constructor">Empty(<span class="params">contactName</span>)</span>) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">ChatSessionUser updateInfo = <span class="keyword">new</span> <span class="constructor">ChatSessionUser()</span>;</span><br><span class="line">updateInfo.set<span class="constructor">ContactName(<span class="params">contactName</span>)</span>;</span><br><span class="line"><span class="comment">// 更新chat_session_user中的contact_name</span></span><br><span class="line">ChatSessionUserQuery chatSessionUserQuery = <span class="keyword">new</span> <span class="constructor">ChatSessionUserQuery()</span>;</span><br><span class="line">chatSessionUserQuery.set<span class="constructor">ContactId(<span class="params">contactId</span>)</span>;</span><br><span class="line">this.chatSessionUserMapper.update<span class="constructor">ByParam(<span class="params">updateInfo</span>, <span class="params">chatSessionUserQuery</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后针对联系人,发送名称更新的ws消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">userContactQuery.setContactId(contactId);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">List&lt;UserContact&gt; userContactList = userContactMapper.selectList(userContactQuery);</span><br><span class="line"><span class="keyword">for</span> (UserContact userContact : userContactList) &#123;</span><br><span class="line">    MessageSendDto messageSendDto = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">    messageSendDto.setContactType(contactTypeEnum.getType());</span><br><span class="line">    messageSendDto.setContactId(userContact.getUserId());</span><br><span class="line">    messageSendDto.setExtendData(contactName);</span><br><span class="line">    messageSendDto.setMessageType(MessageTypeEnum.CONTACT_NAME_UPDATE.getType());</span><br><span class="line">    messageSendDto.setSendUserId(contactId);</span><br><span class="line">    messageSendDto.setSendUserNickName(contactName);</span><br><span class="line">    messageHandler.sendMessage(messageSendDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上传的头像文件不为空,则下载到服务器对应路径. BASE_FOLDER+FILE+AVATAR+user_id.jpg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avatarFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String baseFolder = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE;</span><br><span class="line">    File targetFileFolder = <span class="keyword">new</span> File(baseFolder + Constants.FILE_FOLDER_AVATAR_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!targetFileFolder.exists()) &#123;</span><br><span class="line">        targetFileFolder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String filePath = targetFileFolder.getPath() + <span class="string">&quot;/&quot;</span> + userInfo.getUserId() + Constants.IMAGE_SUFFIX;</span><br><span class="line">    avatarFile.transferTo(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    avatarCover.transferTo(<span class="keyword">new</span> File(filePath + Constants.COVER_IMAGE_SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h4><p>直接查询即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TokenUserInfoDto tokenUserInfoDto = getTokenUserInfo(request);</span><br><span class="line">UserInfo userInfo = userInfoService.getUserInfoByUserId(tokenUserInfoDto.getUserId());</span><br><span class="line">UserInfoVO userInfoVO = CopyTools.copy(userInfo, UserInfoVO.class);</span><br><span class="line">userInfoVO.setAdmin(tokenUserInfoDto.getAdmin());</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(userInfoVO);</span><br></pre></td></tr></table></figure><h4 id="更新密码"><a href="#更新密码" class="headerlink" title="更新密码"></a>更新密码</h4><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><h3 id="群组管理"><a href="#群组管理" class="headerlink" title="群组管理"></a>群组管理</h3><p><img data-src="https://s2.loli.net/2025/05/02/XZeaDzgW8tl5LMA.png" alt="image-20250502195944284"></p><p><img data-src="https://s2.loli.net/2025/05/02/psnG2CViDxzf8YQ.png" alt="image-20250502200016447"></p><h4 id="查看自己群聊"><a href="#查看自己群聊" class="headerlink" title="查看自己群聊"></a>查看自己群聊</h4><p>查询user_contact表,群组owner是自己,创建时间降序,群组状态正常.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     TokenUserInfoDto tokenUserInfoDto = getTokenUserInfo(request);</span><br><span class="line">       GroupInfoQuery infoQuery = <span class="keyword">new</span> GroupInfoQuery();</span><br><span class="line">       infoQuery.setGroupOwnerId(tokenUserInfoDto.getUserId());</span><br><span class="line">       infoQuery.setOrderBy(<span class="string">&quot;create_time desc&quot;</span>);</span><br><span class="line">infoQuery.setStatus(GroupStatusEnum.NORMAL.getStatus());</span><br><span class="line">       List&lt;GroupInfo&gt; groupInfoList = <span class="keyword">this</span>.groupInfoService.findListByParam(infoQuery);</span><br><span class="line">       <span class="keyword">return</span> getSuccessResponseVO(groupInfoList);</span><br></pre></td></tr></table></figure><h4 id="查看群聊信息"><a href="#查看群聊信息" class="headerlink" title="查看群聊信息"></a>查看群聊信息</h4><p>根据groupId,首先看群聊是否存在,以及自己是否在群聊中,查询user_contact表(设置联系状态是好友),如果在群聊中才能继续查看. 查询groupInfo表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TokenUserInfoDto tokenUserInfoDto = getTokenUserInfo(request);</span><br><span class="line">UserContact userContact = <span class="keyword">this</span>.userContactService.getUserContactByUserIdAndContactId(tokenUserInfoDto.getUserId(), groupId);</span><br><span class="line"><span class="keyword">if</span> (userContact == <span class="keyword">null</span> || !UserContactStatusEnum.FRIEND.getStatus().equals(userContact.getStatus())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;你不在群聊或者群聊不存在或已经解散&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">GroupInfo groupInfo = <span class="keyword">this</span>.groupInfoService.getGroupInfoByGroupId(groupId);</span><br><span class="line"><span class="keyword">if</span> (groupInfo == <span class="keyword">null</span> || !GroupStatusEnum.NORMAL.getStatus().equals(groupInfo.getStatus())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;群聊不存在或已经解散&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> groupInfo;</span><br></pre></td></tr></table></figure><p>同时查询user_contact表查询群成员个数一起返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">Integer memberCount = <span class="keyword">this</span>.userContactService.findCountByParam(userContactQuery);</span><br><span class="line">groupInfo.setMemberCount(memberCount);</span><br></pre></td></tr></table></figure><p>上面是查看群聊信息,但不包含群聊中成员,还有一个接口可以查询群成员,也就是在user_contact表中查看contact_id是群id,状态是联系人的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GroupInfo groupInfo = getGroupDetailCommon(request, groupId);</span><br><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">userContactQuery.setQueryUserInfo(<span class="keyword">true</span>);</span><br><span class="line">userContactQuery.setOrderBy(<span class="string">&quot;create_time asc&quot;</span>);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">List&lt;UserContact&gt; userContactList = <span class="keyword">this</span>.userContactService.findListByParam(userContactQuery);</span><br><span class="line">GroupInfoVO groupInfoVo = <span class="keyword">new</span> GroupInfoVO();</span><br><span class="line">groupInfoVo.setGroupInfo(groupInfo);</span><br><span class="line">groupInfoVo.setUserContactList(userContactList);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(groupInfoVo);</span><br></pre></td></tr></table></figure><h4 id="创建-更新群聊"><a href="#创建-更新群聊" class="headerlink" title="创建/更新群聊"></a>创建/更新群聊</h4><p>创建与更新群聊接口类似,传入groupId,如果为空则创建群聊.</p><p>一个用户创建群聊个数有限,所以先进行查询看是否满足条件. </p><p>满足之后,插入群聊信息,user_contact联系信息,用户联系人缓存更新,channelContextUtils加入群组channelGroup,插入chat_session_user表,插入session_user表,插入chat_message表,最后发送messageSendDto.</p><p>如果是更新群聊,则更新群组信息,更新user_contact表与chat_session_user表(主要更新群聊名称)</p><p>更新chat_session_user中contact_name.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChatSessionUser updateInfo = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">updateInfo.setContactName(contactName);</span><br><span class="line"></span><br><span class="line">ChatSessionUserQuery chatSessionUserQuery = <span class="keyword">new</span> ChatSessionUserQuery();</span><br><span class="line">chatSessionUserQuery.setContactId(contactId);</span><br><span class="line"><span class="keyword">this</span>.chatSessionUserMapper.updateByParam(updateInfo, chatSessionUserQuery);</span><br></pre></td></tr></table></figure><p>然后发送ws消息通知群聊成员更改了群名称.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageSendDto messageSendDto = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">messageSendDto.setContactType(UserContactTypeEnum.getByPrefix(contactId).getType());</span><br><span class="line">messageSendDto.setContactId(contactId);</span><br><span class="line">messageSendDto.setExtendData(contactName);</span><br><span class="line">messageSendDto.setMessageType(MessageTypeEnum.CONTACT_NAME_UPDATE.getType());</span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br></pre></td></tr></table></figure><p>用户更改昵称其实类似,也需要向他的联系人通知</p><p>如果上传了群聊头像文件,则存储到一个文件路径, basePath+FILE_FOLDER_FILE+FILE_FOLDER_AVATAR_NAME+群聊id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String baseFolder = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE;</span><br><span class="line">File targetFileFolder = <span class="keyword">new</span> File(baseFolder + Constants.FILE_FOLDER_AVATAR_NAME);</span><br><span class="line"><span class="keyword">if</span> (!targetFileFolder.exists()) &#123;</span><br><span class="line">    targetFileFolder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">String filePath = targetFileFolder.getPath() + <span class="string">&quot;/&quot;</span> + groupInfo.getGroupId() + Constants.IMAGE_SUFFIX;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    avatarFile.transferTo(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    avatarCover.transferTo(<span class="keyword">new</span> File(filePath + Constants.COVER_IMAGE_SUFFIX));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;头像上传失败&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;头像上传失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解散群聊"><a href="#解散群聊" class="headerlink" title="解散群聊"></a>解散群聊</h4><p>更新group_info状态群聊被解散,更新联系人user_contact状态为删除(contact_id为群id),删除对应缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新群解散状态</span></span><br><span class="line">GroupInfo updateInfo = <span class="keyword">new</span> GroupInfo();</span><br><span class="line">updateInfo.setStatus(GroupStatusEnum.DISSOLUTION.getStatus());</span><br><span class="line"><span class="keyword">this</span>.groupInfoMapper.updateByGroupId(updateInfo, groupId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新user_contact状态 删除</span></span><br><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">userContactQuery.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line"></span><br><span class="line">UserContact updateUserContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">updateUserContact.setStatus(UserContactStatusEnum.DEL.getStatus());</span><br><span class="line">userContactMapper.updateByParam(updateUserContact, userContactQuery);</span><br><span class="line"><span class="comment">// 删除对应联系人缓存</span></span><br><span class="line">List&lt;UserContact&gt; userContactList = <span class="keyword">this</span>.userContactMapper.selectList(userContactQuery);</span><br><span class="line">    <span class="keyword">for</span> (UserContact userContact : userContactList) &#123;</span><br><span class="line">        redisComponet.removeUserContact(userContact.getUserId(), userContact.getContactId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除此之外,更新chat_session表群解散消息和时间,插入chat_message表更新群解散消息,GROUP_CONTEXT_MAP删除群组channelGroup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String sessionId = StringTools.getChatSessionId4Group(groupId);</span><br><span class="line">Date curTime = <span class="keyword">new</span> Date();</span><br><span class="line">String messageContent = MessageTypeEnum.DISSOLUTION_GROUP.getInitMessage();</span><br><span class="line"><span class="comment">//更新会话消息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(messageContent);</span><br><span class="line">chatSession.setLastReceiveTime(curTime.getTime());</span><br><span class="line">chatSessionMapper.updateBySessionId(chatSession, sessionId);</span><br><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setSendTime(curTime.getTime());</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessage.setMessageType(MessageTypeEnum.DISSOLUTION_GROUP.getType());</span><br><span class="line">chatMessage.setContactId(groupId);</span><br><span class="line">chatMessage.setMessageContent(messageContent);</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>还需要给发送群成员ws消息,告知群组解散.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//发送解散群消息</span></span><br><span class="line">        MessageSendDto messageSendDto = <span class="module-access"><span class="module"><span class="identifier">CopyTools</span>.</span></span>copy(chatMessage, <span class="module-access"><span class="module"><span class="identifier">MessageSendDto</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">        messageHandler.send<span class="constructor">Message(<span class="params">messageSendDto</span>)</span>;</span><br><span class="line"> <span class="comment">// 在channelContextUtils.java中 给群聊channelGroup发送消息,这个group中的所有channel,也就是群成员都会接收到这个群解散消息</span></span><br><span class="line">ChannelGroup group = <span class="module-access"><span class="module"><span class="identifier">GROUP_CONTEXT_MAP</span>.</span></span>get(messageSendDto.get<span class="constructor">ContactId()</span>);</span><br><span class="line"><span class="keyword">if</span> (group<span class="operator"> == </span>null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">group.write<span class="constructor">AndFlush(<span class="params">new</span> TextWebSocketFrame(JSON.<span class="params">toJSONString</span>(<span class="params">messageSendDto</span>)</span>));</span><br><span class="line"><span class="comment">// 然后移除GROUP_CONTEXT_MAP中的channelGroup并关闭group</span></span><br><span class="line">  <span class="keyword">if</span> (MessageTypeEnum.DISSOLUTION_GROUP<span class="operator"> == </span>messageTypeEnum) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">GROUP_CONTEXT_MAP</span>.</span></span>remove(messageSendDto.get<span class="constructor">ContactId()</span>);</span><br><span class="line">            group.close<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="退出群聊"><a href="#退出群聊" class="headerlink" title="退出群聊"></a>退出群聊</h4><p>除了检查传递过来的groupId是否合法之外(群存在且未解散,创建者不能退出群聊),查询user_contact,更新状态为删除(代码中直接删除了行记录)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GroupInfo groupInfo = groupInfoMapper.selectByGroupId(groupId);</span><br><span class="line"><span class="keyword">if</span> (groupInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建者不能退出群聊，只能解散群</span></span><br><span class="line"><span class="keyword">if</span> (userId.equals(groupInfo.getGroupOwnerId())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line">Integer count = userContactMapper.deleteByUserIdAndContactId(userId, groupId);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入chat_session_user表退群消息以及chat_message消息,更新联系人缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UserInfo userInfo = userInfoMapper.selectByUserId(userId);</span><br><span class="line"></span><br><span class="line">String sessionId = StringTools.getChatSessionId4Group(groupId);</span><br><span class="line">Date curTime = <span class="keyword">new</span> Date();</span><br><span class="line">String messageContent = String.format(messageTypeEnum.getInitMessage(), userInfo.getNickName());</span><br><span class="line"><span class="comment">//更新会话消息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(messageContent);</span><br><span class="line">chatSession.setLastReceiveTime(curTime.getTime());</span><br><span class="line">chatSessionMapper.updateBySessionId(chatSession, sessionId);</span><br><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setSendTime(curTime.getTime());</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessage.setMessageType(messageTypeEnum.getType());</span><br><span class="line">chatMessage.setContactId(groupId);</span><br><span class="line">chatMessage.setMessageContent(messageContent);</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>然后就是使用messageHandler发送消息,有人退群了发送给群组channelGroup,也就是所有群成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(groupId);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">Integer memberCount = <span class="keyword">this</span>.userContactMapper.selectCount(userContactQuery); <span class="comment">// 发送了群成员个数</span></span><br><span class="line"></span><br><span class="line">MessageSendDto messageSendDto = CopyTools.copy(chatMessage, MessageSendDto.class);</span><br><span class="line">messageSendDto.setExtendData(userId); <span class="comment">// 发送了退群人</span></span><br><span class="line">messageSendDto.setMemberCount(memberCount);</span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br></pre></td></tr></table></figure><h4 id="删除或者添加群成员"><a href="#删除或者添加群成员" class="headerlink" title="删除或者添加群成员"></a>删除或者添加群成员</h4><p>还是类似的流程,先判断成员id和群组id本身是不是在user_contact成员状态,如果是才能进行下一步. 删除和添加类似,如果是删除成员,操作类似成员退出群成员,但message类型是REMOVE_GROUP(12, “%s被管理员移出了群聊”, “被管理员移出了群聊”).而不是LEAVE_GROUP,user_contact,chat_session,chat_message表更新(代码中user_contact记录被删除),消息也会发送给群组,会在处理时删除缓存,以及移除组中的channel.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">group.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(messageSendDto)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除群聊</span></span><br><span class="line">MessageTypeEnum messageTypeEnum = MessageTypeEnum.getByType(messageSendDto.getMessageType());</span><br><span class="line"><span class="keyword">if</span> (MessageTypeEnum.LEAVE_GROUP == messageTypeEnum || MessageTypeEnum.REMOVE_GROUP == messageTypeEnum) &#123;</span><br><span class="line">    String userId = (String) messageSendDto.getExtendData();</span><br><span class="line">    redisComponet.removeUserContact(userId, messageSendDto.getContactId());</span><br><span class="line">    Channel channel = USER_CONTEXT_MAP.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    group.remove(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是添加群成员,类似addContact,applyuserId是contactId,联系人是群组id. 具体流程类似,更新/插入user_contact状态,更新缓存,更新chat_session表,添加群组channel,更新chat_message,最后发送消息(主要目的是当前机子可能没有该群组的channel,通过redisson发布订阅,其他机子取出CONTEXT_MAP中的channel,不为空就发送消息).</p><p>假设一个场景,有许多用户登陆了不同服务器</p><p><img data-src="https://s2.loli.net/2025/07/22/XnkZECm7cG23dlD.png" alt="image-20250722160015745"></p><h4 id="加入群聊"><a href="#加入群聊" class="headerlink" title="加入群聊"></a>加入群聊</h4><p>类似添加好友addContact</p><h3 id="联系人管理"><a href="#联系人管理" class="headerlink" title="联系人管理"></a>联系人管理</h3><p><img data-src="https://s2.loli.net/2025/05/05/vODxw84bH7LguBa.png" alt="image-20250505174711397"></p><p><img data-src="https://s2.loli.net/2025/05/02/psnG2CViDxzf8YQ.png" alt="image-20250502200016447"></p><h4 id="搜索用户"><a href="#搜索用户" class="headerlink" title="搜索用户"></a>搜索用户</h4><p>需要使用user_info表根据传过来的用户id查询,如果是用户,还需要查询昵称、性别等信息.</p><p>如果是群聊,还会返回群名称. 同时查询user_contact表设置联系状态.</p><h4 id="申请添加联系人"><a href="#申请添加联系人" class="headerlink" title="申请添加联系人"></a>申请添加联系人</h4><p>添加联系人时,首先判断一些信息,比如contact_id是否合法(存在),是否被拉黑等. </p><p>user_contact_apply表包含apply_id为主键,意味着可以同一用户可以申请多次添加联系人</p><p><img data-src="https://s2.loli.net/2025/07/21/qXQrNahUbLdZw5p.png" alt="image-20250721225848826"></p><p>省去对参数的校验,首先查询user_contact表状态是否被拉黑了,被拉黑就无法申请了. </p><p>当满足这些条件,然后判断是否需要申请还是直接就能添加.</p><h4 id="直接添加联系人"><a href="#直接添加联系人" class="headerlink" title="直接添加联系人"></a>直接添加联系人</h4><p>如果能直接添加,就进行添加好友操作(如果是群聊需要判断是否超出人数)</p><p>能想到的操作就是,插入user_contact表,<strong>如果是好友,就需要互相添加.</strong>,如果是群组,直接插入一条即可(user_id,group_id)</p><p><img data-src="https://s2.loli.net/2025/07/21/Mf9eRWBC2mu1plw.png" alt="image-20250721215035264"></p><p>也就是user_id分别为申请人和接收人,然后更新联系人缓存.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserContact&gt; contactList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//申请人添加对方</span></span><br><span class="line">UserContact userContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">userContact.setUserId(applyUserId);</span><br><span class="line">userContact.setContactId(contactId);</span><br><span class="line">userContact.setContactType(contactType);</span><br><span class="line">userContact.setCreateTime(curDate);</span><br><span class="line">userContact.setLastUpdateTime(curDate);</span><br><span class="line">userContact.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">contactList.add(userContact);</span><br><span class="line"><span class="comment">//如果是申请好友 接收人添加申请人  群组不用添加对方为好友</span></span><br><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.USER.getType().equals(contactType)) &#123;</span><br><span class="line">    userContact = <span class="keyword">new</span> UserContact();</span><br><span class="line">    userContact.setUserId(receiveUserId);</span><br><span class="line">    userContact.setContactId(applyUserId);</span><br><span class="line">    userContact.setContactType(contactType);</span><br><span class="line">    userContact.setCreateTime(curDate);</span><br><span class="line">    userContact.setLastUpdateTime(curDate);</span><br><span class="line">    userContact.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">    contactList.add(userContact);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量加入</span></span><br><span class="line">userContactMapper.insertOrUpdateBatch(contactList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是好友申请,接收人也添加申请人为联系人</span></span><br><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.USER.getType().equals(contactType)) &#123;</span><br><span class="line">    redisComponet.addUserContact(receiveUserId, applyUserId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//审核通过，将申请人的联系人添加上 我 或 群组</span></span><br><span class="line">redisComponet.addUserContact(applyUserId, contactId);</span><br></pre></td></tr></table></figure><p>在创建好友联系后,就是创建会话以及消息信息了,具体操作也是表插入/更新操作.</p><p>具体来说,对于用户会话表,包括(user_id,contact_id,)session_id,contact_name</p><p><img data-src="https://s2.loli.net/2025/07/21/rn2d8Njp3DWHQYB.png" alt="image-20250721091337069"></p><p>插入这个数据不难,但需要考虑可能之前这两人就是好友但进行过删好友操作,这条记录不会删除,所以就进行更新. 注意这个表也是(user_id,contact_id)联合主键,如果是好友,也需要插入相互的两条用户会话.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询接收人信息</span></span><br><span class="line">    UserInfo contactUser = <span class="keyword">this</span>.userInfoMapper.selectByUserId(contactId);</span><br><span class="line">    applySessionUser.setContactName(contactUser.getNickName());</span><br><span class="line">    chatSessionUserList.add(applySessionUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受人session</span></span><br><span class="line">    ChatSessionUser contactSessionUser = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">    contactSessionUser.setUserId(contactId);</span><br><span class="line">    contactSessionUser.setContactId(applyUserId);</span><br><span class="line">    contactSessionUser.setSessionId(sessionId);</span><br><span class="line">    contactSessionUser.setLastReceiveTime(curDate.getTime());</span><br><span class="line">    contactSessionUser.setLastMessage(applyInfo);</span><br><span class="line">    <span class="comment">//查询申请人信息</span></span><br><span class="line">    UserInfo applyUserInfo = <span class="keyword">this</span>.userInfoMapper.selectByUserId(applyUserId);</span><br><span class="line">    contactSessionUser.setContactName(applyUserInfo.getNickName());</span><br><span class="line">    chatSessionUserList.add(contactSessionUser);</span><br><span class="line">    <span class="keyword">this</span>.chatSessionUserMapper.insertOrUpdateBatch(chatSessionUserList);</span><br></pre></td></tr></table></figure><p>对于会话记录,只需要插入/更新一条,核心是更新最新消息和接收时间. (sql使用INSERT INTO xxx on duplicate key update xx)插入或者更新冗余键.向表中插入新行时，如果遇到与现有行的 <strong>PRIMARY KEY（主键）</strong> 或 <strong>UNIQUE KEY（唯一键）</strong> 冲突的情况，则执行 <code>UPDATE</code> 操作</p><p><img data-src="https://s2.loli.net/2025/07/21/oKpGdkxvjiJtVC2.png" alt="image-20250721091312712"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建会话</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setSessionId(sessionId);</span><br><span class="line">chatSession.setLastReceiveTime(curDate.getTime());</span><br><span class="line">chatSession.setLastMessage(applyInfo);</span><br><span class="line"><span class="keyword">this</span>.chatSessionMapper.insertOrUpdate(chatSession);</span><br></pre></td></tr></table></figure><p>主要更新最新消息和时间.</p><p>最后更新消息内容,插入消息表,消息表主键message_id,记录了消息的发送者和接收者,session_id,消息类型,文件类型等.只需要插入一条即可,不需要互相插入.</p><p><img data-src="https://s2.loli.net/2025/07/21/nFU6EcNfQlRx8Oz.png" alt="image-20250721202934542"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">ChatMessage chatMessage = <span class="keyword">new</span> ChatMessage();</span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setMessageType(MessageTypeEnum.ADD_FRIEND.getType());</span><br><span class="line">chatMessage.setMessageContent(applyInfo);</span><br><span class="line">chatMessage.setSendUserId(applyUserId);</span><br><span class="line">chatMessage.setSendUserNickName(applyUserInfo.getNickName());</span><br><span class="line">chatMessage.setSendTime(curDate.getTime());</span><br><span class="line">chatMessage.setContactId(contactId);</span><br><span class="line">chatMessage.setContactType(UserContactTypeEnum.USER.getType());</span><br><span class="line">chatMessage.setStatus(MessageStatusEnum.SENDED.getStatus());</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>最后利用messageSendDto发送给用户以及接收者(因为成功加了好友).</p><p>注意设置的消息类型有多种,比如添加好友成功<code>ADD_FRIEND(1, &quot;&quot;, &quot;添加好友打招呼消息&quot;)</code>,群组创建成功等消息类型,以及文件上传,强制下线,退出群聊等等消息都会通过ws发给用户并记录在chatMessage的类型中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INIT(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;连接WS获取信息&quot;</span>),</span><br><span class="line">ADD_FRIEND(<span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;添加好友打招呼消息&quot;</span>),</span><br><span class="line">CHAT(<span class="number">2</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;普通聊天消息&quot;</span>),</span><br><span class="line">GROUP_CREATE(<span class="number">3</span>, <span class="string">&quot;群组已经创建好，可以和好友一起畅聊了&quot;</span>, <span class="string">&quot;群创建成功&quot;</span>),</span><br><span class="line">CONTACT_APPLY(<span class="number">4</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;好友申请&quot;</span>),</span><br><span class="line">MEDIA_CHAT(<span class="number">5</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;媒体文件&quot;</span>),</span><br><span class="line">FILE_UPLOAD(<span class="number">6</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;文件上传完成&quot;</span>),</span><br><span class="line">FORCE_OFF_LINE(<span class="number">7</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;强制下线&quot;</span>),</span><br><span class="line">DISSOLUTION_GROUP(<span class="number">8</span>, <span class="string">&quot;群聊已解散&quot;</span>, <span class="string">&quot;解散群聊&quot;</span>),</span><br><span class="line">ADD_GROUP(<span class="number">9</span>, <span class="string">&quot;%s加入了群组&quot;</span>, <span class="string">&quot;加入群聊&quot;</span>),</span><br><span class="line">CONTACT_NAME_UPDATE(<span class="number">10</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;更新群昵称&quot;</span>),</span><br><span class="line">LEAVE_GROUP(<span class="number">11</span>, <span class="string">&quot;%s退出了群聊&quot;</span>, <span class="string">&quot;退出群聊&quot;</span>),</span><br><span class="line">REMOVE_GROUP(<span class="number">12</span>, <span class="string">&quot;%s被管理员移出了群聊&quot;</span>, <span class="string">&quot;被管理员移出了群聊&quot;</span>),</span><br><span class="line">ADD_FRIEND_SELF(<span class="number">13</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;添加好友打招呼消息发送给自己&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MessageSendDto messageSendDto = CopyTools.copy(chatMessage, MessageSendDto.class);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送给接受好友申请的人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送给申请人 发送人就是接收人，联系人就是申请人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">messageSendDto.setMessageType(MessageTypeEnum.ADD_FRIEND_SELF.getType());</span><br><span class="line">messageSendDto.setContactId(applyUserId);</span><br><span class="line">messageSendDto.setExtendData(contactUser);</span><br><span class="line">messageHandler.sendMessage(messageSendDto);</span><br></pre></td></tr></table></figure><p>因为是好友添加成功所以需要向双方都发送ws消息,但接收者,消息类型和内容不太相同.</p><p>如果添加的是群组,同样的首先插入user_contact表,这时只需要插入一条记录即可.同时更新申请者联系人缓存.此外还要将这个用户channel加入群聊channelGroup中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入群组</span></span><br><span class="line">         ChatSessionUser chatSessionUser = <span class="keyword">new</span> ChatSessionUser();</span><br><span class="line">         chatSessionUser.setUserId(applyUserId);</span><br><span class="line">         chatSessionUser.setContactId(contactId);</span><br><span class="line">         GroupInfo groupInfo = <span class="keyword">this</span>.groupInfoMapper.selectByGroupId(contactId);</span><br><span class="line">         chatSessionUser.setContactName(groupInfo.getGroupName());</span><br><span class="line">         chatSessionUser.setSessionId(sessionId);</span><br><span class="line">         <span class="keyword">this</span>.chatSessionUserMapper.insertOrUpdate(chatSessionUser);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//将群组加入到用户的联系人列表</span></span><br><span class="line">         redisComponet.addUserContact(applyUserId, groupInfo.getGroupId());</span><br><span class="line"></span><br><span class="line">         channelContextUtils.addUser2Group(applyUserId, groupInfo.getGroupId());</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2Group</span><span class="params">(String userId, String groupId)</span> </span>&#123;</span><br><span class="line">    Channel channel = USER_CONTEXT_MAP.get(userId);</span><br><span class="line">    add2Group(groupId, channel);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add2Group</span><span class="params">(String groupId, Channel context)</span> </span>&#123;</span><br><span class="line">    ChannelGroup group = GROUP_CONTEXT_MAP.get(groupId);</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        group = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">        GROUP_CONTEXT_MAP.put(groupId, group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    group.add(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后插入/更新chat_session_user表(因为后续要添加会话消息),也只需要插入一条,而chat_session表插入/更新消息和接收时间,chat_session中的消息类型以及内容就是添加群消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UserInfo applyUserInfo = <span class="keyword">this</span>.userInfoMapper.selectByUserId(applyUserId);</span><br><span class="line"></span><br><span class="line">String sendMessage = String.format(MessageTypeEnum.ADD_GROUP.getInitMessage(), applyUserInfo.getNickName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加session信息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setSessionId(sessionId);</span><br><span class="line">chatSession.setLastReceiveTime(curDate.getTime());</span><br><span class="line">chatSession.setLastMessage(sendMessage);</span><br><span class="line"><span class="keyword">this</span>.chatSessionMapper.insertOrUpdate(chatSession);</span><br></pre></td></tr></table></figure><p>最后还是需要使用messageHandler发送messagesendDto,发送给群的有人进入了群的消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送群消息</span></span><br><span class="line">MessageSendDto messageSend = CopyTools.copy(chatMessage, MessageSendDto.class);</span><br><span class="line">messageSend.setContactId(groupInfo.getGroupId());</span><br><span class="line"><span class="comment">//获取群人数量</span></span><br><span class="line">UserContactQuery userContactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">userContactQuery.setContactId(contactId);</span><br><span class="line">userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">Integer memberCount = <span class="keyword">this</span>.userContactMapper.selectCount(userContactQuery);</span><br><span class="line">messageSend.setMemberCount(memberCount);</span><br><span class="line">messageSend.setContactName(groupInfo.getGroupName());</span><br><span class="line">messageHandler.sendMessage(messageSend);</span><br></pre></td></tr></table></figure><h4 id="插入申请请求"><a href="#插入申请请求" class="headerlink" title="插入申请请求"></a>插入申请请求</h4><p>请求的状态枚举如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT(<span class="number">0</span>, <span class="string">&quot;待处理&quot;</span>),</span><br><span class="line">PASS(<span class="number">1</span>, <span class="string">&quot;已同意&quot;</span>),</span><br><span class="line">REJECT(<span class="number">2</span>, <span class="string">&quot;已拒绝&quot;</span>),</span><br><span class="line">BLACKLIST(<span class="number">3</span>, <span class="string">&quot;已拉黑&quot;</span>);;</span><br></pre></td></tr></table></figure><p>如果不能直接添加,就需要插入/更新user_contact_apply表.</p><p>如果不存在该记录(通过user_id，contact_id,receiver_id创建了唯一索引),则直接插入请求信息.</p><p>否则更新user_contact_apply状态为待处理(也就是说)并更新请求时间和请求信息.</p><p>此外,申请消息会通过ws发送给接收者(如果没有user_contact_apply记录或者其状态不为待处理)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dbApply == <span class="keyword">null</span> || !UserContactApplyStatusEnum.INIT.getStatus().equals(dbApply.getStatus())) &#123;</span><br><span class="line">    <span class="comment">//如果是待处理状态就不发消息，避免重复发送</span></span><br><span class="line">    <span class="comment">//发送ws消息</span></span><br><span class="line">    MessageSendDto messageSend = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">    messageSend.setMessageType(MessageTypeEnum.CONTACT_APPLY.getType());</span><br><span class="line">    messageSend.setMessageContent(applyInfo);</span><br><span class="line">    messageSend.setContactId(receiveUserId);</span><br><span class="line">    messageHandler.sendMessage(messageSend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>messageSendDto成员如下,包括消息id,会话id,发送和接受这,消息内容,发送时间以及消息类型等等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSendDto</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1045752033171142417L</span>;</span><br><span class="line">    <span class="comment">//消息ID</span></span><br><span class="line">    <span class="keyword">private</span> Long messageId;</span><br><span class="line">    <span class="comment">//会话ID</span></span><br><span class="line">    <span class="keyword">private</span> String sessionId;</span><br><span class="line">    <span class="comment">//发送人</span></span><br><span class="line">    <span class="keyword">private</span> String sendUserId;</span><br><span class="line">    <span class="comment">//发送人昵称</span></span><br><span class="line">    <span class="keyword">private</span> String sendUserNickName;</span><br><span class="line">    <span class="comment">//联系人ID</span></span><br><span class="line">    <span class="keyword">private</span> String contactId;</span><br><span class="line">    <span class="comment">//联系人名称</span></span><br><span class="line">    <span class="keyword">private</span> String contactName;</span><br><span class="line">    <span class="comment">//消息内容</span></span><br><span class="line">    <span class="keyword">private</span> String messageContent;</span><br><span class="line">    <span class="comment">//最后的消息</span></span><br><span class="line">    <span class="keyword">private</span> String lastMessage;</span><br><span class="line">    <span class="comment">//消息类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer messageType;</span><br><span class="line">    <span class="comment">//发送时间</span></span><br><span class="line">    <span class="keyword">private</span> Long sendTime;</span><br><span class="line">    <span class="comment">//联系人类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer contactType;</span><br><span class="line">    <span class="comment">//扩展信息</span></span><br><span class="line">    <span class="keyword">private</span> T extendData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息状态 0:发送中  1:已发送 对于文件是异步上传用状态处理</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件信息</span></span><br><span class="line">    <span class="keyword">private</span> Long fileSize;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="keyword">private</span> Integer fileType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//群员</span></span><br><span class="line">    <span class="keyword">private</span> Integer memberCount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查询申请请求"><a href="#查询申请请求" class="headerlink" title="查询申请请求"></a>查询申请请求</h4><p>查询user_contact_apply表,receiver_id是自己id的记录,因为这个表包含联合主键(apply_user_id,contact_id,receiver_id).  按照last_apply_time降序,还可以返回联系人昵称.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;base_result_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    a.*</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.queryContactInfo&quot;</span>&gt;</span></span><br><span class="line">        ,CASE</span><br><span class="line">        WHEN a.contact_type = 0 THEN u.nick_name</span><br><span class="line">        WHEN a.contact_type = 1 THEN g.group_name</span><br><span class="line">        END as contactName</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    FROM</span><br><span class="line">    user_contact_apply a</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.queryContactInfo&quot;</span>&gt;</span></span><br><span class="line">        LEFT JOIN user_info u ON u.user_id = a.apply_user_id and a.receive_user_id = #&#123;query.receiveUserId&#125;</span><br><span class="line">        LEFT JOIN group_info g ON g.group_id = a.contact_id and a.receive_user_id = #&#123;query.receiveUserId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;query_condition&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.orderBy!=null&quot;</span>&gt;</span></span><br><span class="line">        order by $&#123;query.orderBy&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.simplePage!=null&quot;</span>&gt;</span></span><br><span class="line">        limit #&#123;query.simplePage.start&#125;,#&#123;query.simplePage.end&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="处理申请请求"><a href="#处理申请请求" class="headerlink" title="处理申请请求"></a>处理申请请求</h4><p>除了正常流程的参数检验和合法之外,更新user_contact_apply表状态,如果允许请求,执行上述添加联系人操作,如果拒绝,后端什么也不做,如果是拉黑,user_contact状态记录为<strong>第一次被拉黑</strong>,后续不再允许申请添加,然后插入/更新user_contact表</p><h3 id="联系人详情-删除和拉黑联系人"><a href="#联系人详情-删除和拉黑联系人" class="headerlink" title="联系人详情,删除和拉黑联系人"></a>联系人详情,删除和拉黑联系人</h3><p>加载联系人,也就是从user_contact表中查询,根据user_id和contact_id查询,如果是查询联系人,同时也会查询联系人名字、性别等信息,如果是群组,也会查询群昵称和群人数等. 此外,user_contact的状态必须是朋友,或者被删除,被拉黑. 也就是说如果被其删除,但没有删除联系人,也能加载它.</p><p>联系人详情有两个接口,一个获取任意用户的信息,通过contact_id获取用户信息,并返回联系状态.</p><p>如果是查询联系人详情,会设置查询状态,如果不是好友,被删除,被拉黑或者被首次拉黑,其余报异常. 因为如果被删除/拉黑依然能查看状态.</p><p>删除和拉黑好友时处理类似,首先修改user_contact状态,如果是删除,还需要增加被删除的一条(contact_id,user_id)记录,拉黑类似. 然后需要删除双方联系人缓存. 因为缓存中只保存好友关系的联系人,删除和被删除,拉黑和被拉黑都不存在,这个缓存内容是用来发送聊天消息的.</p><h3 id="获取用户信息、修改密码与退出登录"><a href="#获取用户信息、修改密码与退出登录" class="headerlink" title="获取用户信息、修改密码与退出登录"></a>获取用户信息、修改密码与退出登录</h3><h3 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h3><p>用户管理  靓号管理  群组管理</p><h3 id="登陆时加载消息"><a href="#登陆时加载消息" class="headerlink" title="登陆时加载消息"></a>登陆时加载消息</h3><blockquote><p>离线消息处理</p></blockquote><p>在登陆校验完成后,<strong>将联系人存入缓存,将token和用户信息存入缓存</strong>,并返回用户信息.</p><p>当客户端发送ws连接时,会携带token,服务端利用token获取用户信息,然后加载聊天消息.</p><p>具体来说,在缓存中获取联系人,将自己的channel加入群聊的channelGroup中(如果没有创建channelGroup放入GROUP_CONTEXT_MAP中)</p><p>然后将自己的channel放入USER_CONTEXT_MAP中,更新用户心跳缓存和最新登陆时间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String channelId = channel.id().toString();</span><br><span class="line">        AttributeKey attributeKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!AttributeKey.exists(channelId)) &#123;</span><br><span class="line">            attributeKey = AttributeKey.newInstance(channel.id().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attributeKey = AttributeKey.valueOf(channel.id().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.attr(attributeKey).set(userId);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; contactList = redisComponet.getUserContactList(userId);</span><br><span class="line">        <span class="keyword">for</span> (String groupId : contactList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groupId.startsWith(UserContactTypeEnum.GROUP.getPrefix())) &#123;</span><br><span class="line">                add2Group(groupId, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        USER_CONTEXT_MAP.put(userId, channel);</span><br><span class="line">        redisComponet.saveUserHeartBeat(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新用户最后连接时间</span></span><br><span class="line">        UserInfo updateInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        updateInfo.setLastLoginTime(<span class="keyword">new</span> Date());</span><br><span class="line">        userInfoMapper.updateByUserId(updateInfo, userId);</span><br></pre></td></tr></table></figure><p>首先<strong>查询用户会话信息,也就是chat_session_user表,相同的聊天双方,sessionId相同,主键是user_id和contact_id联合主键,根据user_id查看用户会话可以获取有聊天会话的联系人信息,如果是群聊也会查询群聊人数,</strong>chat_session表主键是session_id.</p><p>在mapper中,查询用户会话信息就是获取chat_session_user聊天会话对方名称,id以及session会话最新的聊天信息,如果是群聊还要查群聊人数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 1、查询会话信息 查询用户所有会话，避免换设备会话不同步</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         ChatSessionUserQuery sessionUserQuery = <span class="keyword">new</span> ChatSessionUserQuery();</span><br><span class="line">         sessionUserQuery.setUserId(userId);</span><br><span class="line">         sessionUserQuery.setOrderBy(<span class="string">&quot;last_receive_time desc&quot;</span>);</span><br><span class="line">         List&lt;ChatSessionUser&gt; chatSessionList = chatSessionUserMapper.selectList(sessionUserQuery);</span><br><span class="line">         WsInitData wsInitData = <span class="keyword">new</span> WsInitData();</span><br><span class="line">         wsInitData.setChatSessionList(chatSessionList);</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;base_result_map&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.*,</span><br><span class="line">    c.last_message lastMessage,</span><br><span class="line">    c.last_receive_time lastReceiveTime,</span><br><span class="line">    case when SUBSTRING(contact_id, 1, 1) =&#x27;G&#x27;</span><br><span class="line">    THEN (select count(1) from user_contact uc where uc.contact_id = u.contact_id)</span><br><span class="line">    else 0</span><br><span class="line">    end memberCount</span><br><span class="line">    FROM chat_session_user u inner join chat_session c on c.session_id = u.session_id</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;query_condition&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.orderBy!=null&quot;</span>&gt;</span></span><br><span class="line">        order by $&#123;query.orderBy&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;query.simplePage!=null&quot;</span>&gt;</span></span><br><span class="line">        limit #&#123;query.simplePage.start&#125;,#&#123;query.simplePage.end&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要给客户端发送离线时其他人的聊天消息(离线之前的消息通过客户端查数据库),</p><p>查询流程是: 首先查询联系人,如果是群聊,联系的id是群组id,同时加上自己的id作为contact_id,查询chatMessage消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 2、查询聊天消息</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//查询用户的联系人</span></span><br><span class="line">          UserContactQuery contactQuery = <span class="keyword">new</span> UserContactQuery();</span><br><span class="line">          contactQuery.setContactType(UserContactTypeEnum.GROUP.getType());</span><br><span class="line">          contactQuery.setUserId(userId);</span><br><span class="line">          List&lt;UserContact&gt; groupContactList = userContactMapper.selectList(contactQuery);</span><br><span class="line">          List&lt;String&gt; groupIdList = groupContactList.stream().map(item -&gt; item.getContactId()).collect(Collectors.toList());</span><br><span class="line">          <span class="comment">//将自己也加进去</span></span><br><span class="line">          groupIdList.add(userId);</span><br><span class="line"></span><br><span class="line">          ChatMessageQuery messageQuery = <span class="keyword">new</span> ChatMessageQuery();</span><br><span class="line">          messageQuery.setContactIdList(groupIdList);</span><br><span class="line">          messageQuery.setLastReceiveTime(lastOffTime);</span><br><span class="line">          List&lt;ChatMessage&gt; chatMessageList = chatMessageMapper.selectList(messageQuery);</span><br><span class="line">          wsInitData.setChatMessageList(chatMessageList);</span><br></pre></td></tr></table></figure><p>最后查询好友申请数,也就是contact_apply中还未处理的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、查询好友申请</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserContactApplyQuery applyQuery = <span class="keyword">new</span> UserContactApplyQuery();</span><br><span class="line">    applyQuery.setReceiveUserId(userId);</span><br><span class="line">    applyQuery.setLastApplyTimestamp(sourceLastOffTime);</span><br><span class="line">    applyQuery.setStatus(UserContactApplyStatusEnum.INIT.getStatus());</span><br><span class="line">    Integer applyCount = userContactApplyMapper.selectCount(applyQuery);</span><br><span class="line">    wsInitData.setApplyCount(applyCount);</span><br></pre></td></tr></table></figure><p>最后要将这些消息发送给用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">MessageSendDto messageSendDto = <span class="keyword">new</span> MessageSendDto();</span><br><span class="line">messageSendDto.setMessageType(MessageTypeEnum.INIT.getType()); <span class="comment">// messageSendDto设置ws消息类型</span></span><br><span class="line">messageSendDto.setContactId(userId);</span><br><span class="line">messageSendDto.setExtendData(wsInitData);</span><br><span class="line"></span><br><span class="line">sendMsg(messageSendDto, userId);</span><br></pre></td></tr></table></figure><h3 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h3><p>主要使用ws发送消息,但多机环境下向不同服务器发送ws消息不共享,使用Redisson基于rediss消息订阅发送消息,解决集群环境下发送消息(因为集群中的服务器都通过redission订阅了相同主题)</p><p><img data-src="https://s2.loli.net/2025/07/21/y6cuUbi5AOKPRVr.png" alt="image-20250721223758683"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;messageHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MessageHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_TOPIC = <span class="string">&quot;message.topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChannelContextUtils channelContextUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lisMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RTopic rTopic = redissonClient.getTopic(MESSAGE_TOPIC);</span><br><span class="line">        rTopic.addListener(MessageSendDto.class, (MessageSendDto, sendDto) -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;收到广播消息:&#123;&#125;&quot;</span>, JSON.toJSONString(sendDto));</span><br><span class="line">            channelContextUtils.sendMessage(sendDto);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(MessageSendDto sendDto)</span> </span>&#123;</span><br><span class="line">        RTopic rTopic = redissonClient.getTopic(MESSAGE_TOPIC);</span><br><span class="line">        rTopic.publish(sendDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库设计上,使用chat_session,chat_session_user以及chat_message表</p><p>session表包括sessionId(与聊天双方相关)以及最新消息和接收时间</p><p><img data-src="https://s2.loli.net/2025/07/21/oKpGdkxvjiJtVC2.png" alt="image-20250721091312712"></p><p>chat_session_user表包括sessionId(与聊天双方相关)以及最新消息和接收时间. 一个chat_session_user表对应一个session表,通过session_id查询最新的消息.</p><p><img data-src="https://s2.loli.net/2025/07/21/rn2d8Njp3DWHQYB.png" alt="image-20250721091337069"></p><p>chat_message表包括具体消息,包括发送者和接收者,sessionId,messageId以及消息类型,文件类型,状态,发送者昵称,文件类型,文件名称等</p><p><img data-src="https://s2.loli.net/2025/07/21/nFU6EcNfQlRx8Oz.png" alt="image-20250721202934542"></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>用户向联系人发送消息,主要就是插入chat_message表以及更新session表,messageHandler发送消息.</p><p>难点是处理文件上传和message发送状态.  首先判断不是机器人,如果不是,判断聊天contact_id是否合法.  </p><p>接着判断消息类型和contact类型,如果是用户,就是用户之间聊天,生成sessionId方式不同,接着更新chat_session表,如果是group,消息类型不是创建群这种消息,就需要带着userId,表明谁发送的存储在chat_session表中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.USER == contactTypeEnum) &#123;</span><br><span class="line">    sessionId = StringTools.getChatSessionId4User(<span class="keyword">new</span> String[]&#123;sendUserId, contactId&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sessionId = StringTools.getChatSessionId4Group(contactId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新会话消息</span></span><br><span class="line">ChatSession chatSession = <span class="keyword">new</span> ChatSession();</span><br><span class="line">chatSession.setLastMessage(messageContent);</span><br><span class="line"><span class="keyword">if</span> (UserContactTypeEnum.GROUP == contactTypeEnum &amp;&amp; !MessageTypeEnum.GROUP_CREATE.getType().equals(messageTypeEnum.getType())) &#123;</span><br><span class="line">    chatSession.setLastMessage(tokenUserInfoDto.getNickName() + <span class="string">&quot;：&quot;</span> + messageContent);</span><br><span class="line">&#125;</span><br><span class="line">lastMessage = chatSession.getLastMessage();</span><br><span class="line"><span class="comment">//如果是媒体文件</span></span><br><span class="line">chatSession.setLastReceiveTime(curTime);</span><br><span class="line">chatSessionMapper.updateBySessionId(chatSession, sessionId);</span><br><span class="line"><span class="comment">//记录消息消息表</span></span><br><span class="line">chatMessage.setSessionId(sessionId);</span><br><span class="line">chatMessage.setSendUserId(sendUserId);</span><br><span class="line">chatMessage.setSendUserNickName(tokenUserInfoDto.getNickName());</span><br><span class="line">chatMessage.setSendTime(curTime);</span><br><span class="line">chatMessage.setContactType(contactTypeEnum.getType());</span><br><span class="line">chatMessage.setStatus(status);</span><br><span class="line">chatMessageMapper.insert(chatMessage);</span><br></pre></td></tr></table></figure><p>如果发送的是文件类型,由于需要上传,消息类型设置为正在发送,等文件上传完毕再更新.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer status = MessageTypeEnum.MEDIA_CHAT == messageTypeEnum ? MessageStatusEnum.SENDING.getStatus() : MessageStatusEnum.SENDED.getStatus();</span><br></pre></td></tr></table></figure><p>最后通过messageHandler发送消息</p><p>如果是机器人,机器人会直接发送消息过去,也就是再次调用saveMessage方法本身,再在方法中通过messageHandler发送回用户.</p><p>最后会将发送的消息再传到客户端,方便拿到消息id.</p><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>controller参数包括messageId,检查发送者是否messageId对应消息的发送者.是上传文件,首先检查文件大小限制.然后直接上传即可(没有做秒传,分片续传等).</p><p>下载的路径遵循BASE_FOLDER+FILE+yyyyMM+messageid.suffix</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String fileName = file.getOriginalFilename();</span><br><span class="line">String fileExtName = StringTools.getFileSuffix(fileName);</span><br><span class="line">String fileRealName = messageId + fileExtName;</span><br><span class="line">String month = DateUtil.format(<span class="keyword">new</span> Date(message.getSendTime()), DateTimePatternEnum.YYYYMM.getPattern());</span><br><span class="line">File folder = <span class="keyword">new</span> File(appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + month);</span><br><span class="line"><span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">    folder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File uploadFile = <span class="keyword">new</span> File(folder.getPath() + <span class="string">&quot;/&quot;</span> + fileRealName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.transferTo(uploadFile);</span><br><span class="line">    <span class="keyword">if</span> (cover != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cover.transferTo(<span class="keyword">new</span> File(uploadFile.getPath() + Constants.COVER_IMAGE_SUFFIX));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;上传文件失败&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件上传失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更新chat_message表,利用拿到的messageId,状态改为已发送.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ChatMessage updateInfo = <span class="keyword">new</span> <span class="constructor">ChatMessage()</span>;</span><br><span class="line">updateInfo.set<span class="constructor">Status(MessageStatusEnum.SENDED.<span class="params">getStatus</span>()</span>);</span><br><span class="line">ChatMessageQuery messageQuery = <span class="keyword">new</span> <span class="constructor">ChatMessageQuery()</span>;</span><br><span class="line">messageQuery.set<span class="constructor">MessageId(<span class="params">messageId</span>)</span>;</span><br><span class="line">chatMessageMapper.update<span class="constructor">ByParam(<span class="params">updateInfo</span>, <span class="params">messageQuery</span>)</span>;</span><br></pre></td></tr></table></figure><p>最后通过messageHandler发送给消息的接收者,表明文件上传成功,可以下载了.消息内容包含messageId,这样接收者可以利用这个id下载文件</p><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p>注意文件包括用户/群聊头像还包括消息中的文件,如果是消息id(全为整数),就会根据消息id查询发送时间,拼接为文件路径,然后下载. 首先检查消息接收者是否符合.</p><p>然后通过消息id和发送时间找到对应路径的文件,BASE_FOLDER+FILE+yyyyMM+message_id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String month = DateUtil.format(<span class="keyword">new</span> Date(message.getSendTime()), DateTimePatternEnum.YYYYMM.getPattern());</span><br><span class="line">File folder = <span class="keyword">new</span> File(appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + month);</span><br><span class="line"><span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">    folder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">String fileName = message.getFileName();</span><br><span class="line">String fileExtName = StringTools.getFileSuffix(fileName);</span><br><span class="line">String fileRealName = messageId + fileExtName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cover != <span class="keyword">null</span> &amp;&amp; cover) &#123;</span><br><span class="line">    fileRealName = fileRealName + Constants.COVER_IMAGE_SUFFIX;</span><br><span class="line">&#125;</span><br><span class="line">File file = <span class="keyword">new</span> File(folder.getPath() + <span class="string">&quot;/&quot;</span> + fileRealName);</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_602);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> file;</span><br></pre></td></tr></table></figure><p>否则是用户/群聊Id(U或者G前缀),拼接用户id找到路径然后下载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String avatarFolderName = Constants.FILE_FOLDER_FILE + Constants.FILE_FOLDER_AVATAR_NAME;</span><br><span class="line">String avatarPath = appConfig.getProjectFolder() + avatarFolderName + fileId + Constants.IMAGE_SUFFIX;</span><br><span class="line"><span class="keyword">if</span> (showCover) &#123;</span><br><span class="line">    avatarPath = avatarPath + Constants.COVER_IMAGE_SUFFIX;</span><br><span class="line">&#125;</span><br><span class="line">file = <span class="keyword">new</span> File(avatarPath);</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_602);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载使用<code>FileInputStream</code>和<code>HttpServletResponse.getOutputStream()</code>,每次读1024字节(1KB),避免文件过大.注意设置response头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;application/x-msdownload; charset=UTF-8&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;&quot;</span>);</span><br><span class="line">response.setContentLengthLong(file.length());</span><br></pre></td></tr></table></figure><p>主要设置content-type,content-disposition,content-length头</p><h1 id="EasyPan"><a href="#EasyPan" class="headerlink" title="EasyPan"></a>EasyPan</h1><p><a href="https://docs.qq.com/doc/DY1JTbU9kSkRPUUVY">03.Java项目创建</a></p><h3 id="IDE设置"><a href="#IDE设置" class="headerlink" title="IDE设置"></a>IDE设置</h3><h4 id="JDK位置设置"><a href="#JDK位置设置" class="headerlink" title="JDK位置设置"></a>JDK位置设置</h4><p><img data-src="https://s2.loli.net/2025/05/14/Wpwxn17jzJYgNiZ.png" alt="image-20250514230635404"></p><h4 id="编译器自动构建与热交换"><a href="#编译器自动构建与热交换" class="headerlink" title="编译器自动构建与热交换"></a>编译器自动构建与热交换</h4><p><img data-src="https://s2.loli.net/2025/05/14/IouNVMneLkvw5xd.png" alt="image-20250514230730743"></p><p><img data-src="https://s2.loli.net/2025/05/14/fHxKr3uUjsJwGTV.png" alt="image-20250514230903350"></p><p><img data-src="https://s2.loli.net/2025/05/14/VIFQjYLmdoMyuT4.png" alt="image-20250514230936534"></p><h4 id="设置Maven位置"><a href="#设置Maven位置" class="headerlink" title="设置Maven位置"></a>设置Maven位置</h4><p><img data-src="https://s2.loli.net/2025/05/14/AYdCIP8NLceGyig.png" alt="image-20250514231336188"></p><h4 id="设置文件编码"><a href="#设置文件编码" class="headerlink" title="设置文件编码"></a>设置文件编码</h4><p><img data-src="https://s2.loli.net/2025/05/14/gfJ2BtnGVdkwj4a.png" alt="image-20250514231119345"></p><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p><img data-src="https://s2.loli.net/2025/05/14/PWJutmFC9iZyXNn.png" alt="image-20250514231258500"></p><p>或创建Spring Boot项目</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="POM-xml"><a href="#POM-xml" class="headerlink" title="POM.xml"></a>POM.xml</h4><h5 id="项目基本信息"><a href="#项目基本信息" class="headerlink" title="项目基本信息"></a>项目基本信息</h5><ul><li><code>&lt;modelVersion&gt;</code>：指定 POM 模型的版本，通常为 <code>4.0.0</code>。</li><li><code>&lt;groupId&gt;</code>：定义项目所属的组织或公司，通常使用反向域名表示。</li><li><code>&lt;artifactId&gt;</code>：项目的唯一标识符，通常对应项目名称。</li><li><code>&lt;version&gt;</code>：项目的当前版本号。</li><li><code>&lt;packaging&gt;</code>：指定项目的打包方式，如 <code>jar</code>、<code>war</code> 等。</li><li><code>&lt;name&gt;</code>：项目的名称。</li><li><code>&lt;description&gt;</code>：项目的简要描述。</li></ul><h5 id="继承与模块管理"><a href="#继承与模块管理" class="headerlink" title="继承与模块管理"></a>继承与模块管理</h5><ul><li><code>&lt;parent&gt;</code>：指定当前项目继承的父 POM，便于共享统一的配置和依赖管理。</li><li><code>&lt;modules&gt;</code>：在多模块项目中，列出所有子模块的目录名称。</li></ul><h5 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h5><ul><li><code>&lt;dependencies&gt;</code>：列出项目所需的所有依赖项。</li><li><code>&lt;dependencyManagement&gt;</code>：用于统一管理依赖的版本信息，子项目可以引用而无需指定版本。</li><li><code>&lt;repositories&gt;</code>：指定额外的远程仓库地址，以获取依赖。</li></ul><h5 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h5><ul><li><p><code>&lt;build&gt;</code>：定义项目的构建相关配置。</p><ul><li><code>&lt;sourceDirectory&gt;</code>：指定源代码目录。</li><li><code>&lt;outputDirectory&gt;</code>：指定编译输出目录。</li><li><code>&lt;plugins&gt;</code>：配置构建过程中使用的插件，如 <code>maven-compiler-plugin</code> 等。</li></ul><p><strong>默认目录结构</strong></p><ul><li><strong>主源代码目录</strong>：<code>src/main/java</code></li><li><strong>主资源目录</strong>：<code>src/main/resources</code></li><li><strong>测试源代码目录</strong>：<code>src/test/java</code></li><li><strong>测试资源目录</strong>：<code>src/test/resources</code></li><li><strong>构建输出目录</strong>：<code>target/</code></li><li><strong>主类输出目录</strong>：<code>target/classes</code></li><li><strong>测试类输出目录</strong>：`target/test-classes</li></ul><p>这些默认设置源自于 Maven 的 Super POM<a href="https://maven.apache.org/ref/3.9.9/maven-model-builder/super-pom.html">Maven Model Builder – Super POM</a>，所有项目在未显式配置的情况下都会继承这些设置</p><p><strong>自定义输入目录</strong></p><p>如果项目结构不同于 Maven 的默认结构，可以在 <code>pom.xml</code> 中自定义输入目录。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/my-src<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>src/my-test<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/my-resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述配置将主源代码目录更改为 <code>src/my-src</code>，测试源代码目录更改为 <code>src/my-test</code>，资源目录更改为 <code>src/my-resources</code>。</p></li></ul><h5 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h5><ul><li><code>&lt;properties&gt;</code>：定义可在 POM 中引用的变量，便于统一管理版本号等信息。 </li></ul><h5 id="构建环境与发布配置"><a href="#构建环境与发布配置" class="headerlink" title="构建环境与发布配置"></a>构建环境与发布配置</h5><ul><li><code>&lt;profiles&gt;</code>：定义不同的构建配置，便于在不同环境下使用。</li><li><code>&lt;distributionManagement&gt;</code>：配置项目的发布信息，如部署到的仓库地址等。</li></ul><p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html">Introduction to the POM – Maven</a></p><h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><blockquote><p>Spring Boot 使用 Commons Logging 进行所有内部日志记录，但底层日志实现保持开放。为 Java Util Logging、Log4j2 和 Logback 提供了默认配置。在每种情况下，日志记录器都预先配置为使用控制台输出，同时也可以选择文件输出。</p></blockquote><p><img data-src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongju/logback-6ba1b465-5533-49dd-b875-48a10ba29f8e.png" alt="img" style="zoom:67%;" /></p><p>当前版本logback中重要组件包括appender,也就是配置日志的输出目的地，通过 name 属性指定名字，通过 class 属性指定目的地：</p><ul><li>ch.qos.logback.core.ConsoleAppender：输出到控制台。</li><li>ch.qos.logback.core.FileAppender：输出到文件。</li><li>ch.qos.logback.core.rolling.RollingFileAppender：文件大小超过阈值时产生一个新文件。</li></ul><p>encoder,logger以及root,它只支持一个属性——level，值可以为：TRACE、DEBUG、INFO、WARN、ERROR、ALL、OFF.</p><p><strong><code>&lt;property&gt;</code></strong>：定义的变量可以在整个配置文件中通过 <code>$&#123;&#125;</code> 引用，便于维护和修改。</p><p><strong><code>&lt;appender&gt;</code></strong>：定义日志的输出方式。</p><ul><li><strong><code>ConsoleAppender</code></strong>：将日志输出到控制台。</li><li><strong><code>RollingFileAppender</code></strong>：将日志输出到文件，并支持按时间滚动生成新文件。</li></ul><p><strong><code>&lt;logger&gt;</code></strong>：为特定的包或类设置日志级别和输出方式。</p><p><strong><code>&lt;root&gt;</code></strong>：定义默认的日志级别和输出方式，适用于未被其他 <code>logger</code> 捕获的日志。</p><p>pattern 用来指定日志的输出格式：</p><ul><li><code>%d</code>：输出的时间格式。</li><li><code>%thread</code>：日志的线程名。</li><li><code>%-5level</code>：日志的输出级别，填充到 5 个字符。比如说 info 只有 4 个字符，就填充一个空格，这样日志信息就对齐了。</li><li><code>%logger&#123;length&#125;</code>：logger 的名称，length 用来缩短名称。没有指定表示完整输出；0 表示只输出 logger 最右边点号之后的字符串；其他数字表示输出小数点最后边点号之前的字符数量。</li><li><code>%msg</code>：日志的具体信息。</li><li><code>%n</code>：换行符。</li><li><code>%relative</code>：输出从程序启动到创建日志记录的时间，单位为毫秒。</li></ul><p><code>logback-spring.xml</code>提供了<code>&lt;springProperty&gt;</code>以及<code>&lt;springProfile&gt;</code>可以读取springBoot配置文件中的属性.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;stdot&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;fileNamePattern&gt;$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;totalSizeCap&gt;5G&lt;/totalSizeCap&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;maxHistory&gt;30&lt;/maxHistory&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/rollingPolicy&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- rollover daily --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>20GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">source</span>=<span class="string">&quot;project.folder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;log.root.level&quot;</span> <span class="attr">source</span>=<span class="string">&quot;log.root.level&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FOLDER&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;easypan.log&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    &lt;logger name=&quot;top.sekyoro.easypan&quot; level=&quot;$&#123;log.root.level&#125;&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;appender-ref ref=&quot;stdot&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;appender-ref ref=&quot;file&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/logger&gt;   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;log.root.level&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;stdot&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.spring.io/spring-boot/reference/features/logging.html#features.logging.logback-extensions">Logging :: Spring Boot</a></li><li><a href="https://logback.qos.ch/manual/encoders.html">Chapter 5: Encoders</a></li><li><a href="https://logback.qos.ch/codes.html#layoutInsteadOfEncoder">Logback Error Codes</a></li><li><a href="https://javabetter.cn/gongju/logback.html#_03、把-log4j-properties-转成-logback-test-xml">Logback：Spring Boot内置的日志处理框架 | 二哥的Java进阶之路</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/boot-features-logging.html#boot-features-logback-extensions">26. Logging</a></li></ul><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><h5 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h5><ul><li><code>server.port=8080</code>：设置应用的端口号。</li><li><code>server.servlet.context-path=/api</code>：设置应用的上下文路径。</li></ul><h5 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h5><ul><li><code>spring.application.name=myapp</code>：设置应用的名称。</li></ul><h5 id="数据源配置（以-MySQL-为例）"><a href="#数据源配置（以-MySQL-为例）" class="headerlink" title="数据源配置（以 MySQL 为例）"></a>数据源配置（以 MySQL 为例）</h5><ul><li><code>spring.datasource.url=jdbc:mysql://localhost:3306/db_example</code></li><li><code>spring.datasource.username=root</code></li><li><code>spring.datasource.password=secret</code></li><li><code>spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</code></li><li><code>spring.jpa.hibernate.ddl-auto=update</code>：设置 JPA 的 DDL 策略。</li></ul><h5 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h5><ul><li><code>logging.level.root=INFO</code>：设置根日志级别。</li><li><code>logging.level.com.example=DEBUG</code>：设置特定包的日志级别。</li><li><code>logging.file.name=logs/app.log</code>：设置日志文件名称。</li><li><code>logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n</code>：设置控制台日志输出格式</li></ul><h5 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h5><ul><li><code>spring.mail.host=smtp.example.com</code></li><li><code>spring.mail.port=587</code></li><li><code>spring.mail.username=user@example.com</code></li><li><code>spring.mail.password=secret</code></li><li><code>spring.mail.properties.mail.smtp.auth=true</code></li><li><code>spring.mail.properties.mail.smtp.starttls.enable=true</code></li></ul><h5 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h5><ul><li><code>spring.security.user.name=admin</code></li><li><code>spring.security.user.password=secret</code></li><li><code>spring.security.user.roles=USER,ADMIN</code></li></ul><h5 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h5><ul><li><code>spring.cache.type=simple</code>：设置缓存类型。</li><li><code>spring.cache.cache-names=users,transactions</code>：定义缓存名称。</li></ul><h5 id="国际化配置"><a href="#国际化配置" class="headerlink" title="国际化配置"></a>国际化配置</h5><ul><li><code>spring.messages.basename=messages</code>：设置消息资源文件的基础名称。</li><li><code>spring.messages.encoding=UTF-8</code>：设置消息资源文件的编码。</li></ul><h5 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h5><ul><li><code>spring.main.allow-bean-definition-overriding=true</code>：允许覆盖 Bean 定义。</li><li><code>spring.profiles.active=dev</code>：设置活动的配置文件。</li></ul><p><strong>注意</strong>:1.新版本中,<code>spring.mvc.throw-exception-if-no-handler-found</code> 属性已被<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/deprecated-list.html">弃用</a>，建议不再使用。默认情况下,Spring Boot 会返回 404 响应，无需额外配置。</p><p>2.<code>spring.mvc.favicon.enable=false</code>配置属性已弃用。此外，Spring Boot 不再提供默认的 favicon，因为此图标可被视为信息泄露,可以增加对应handler.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/favicon.ico&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.baeldung-cn.com/spring-boot-favicon">Spring Boot中favicon的指南 | Baeldung中文网</a></p><p>相关文档</p><ul><li><a href="https://docs.spring.io/spring-boot/appendix/application-properties/index.html">Common Application Properties :: Spring Boot</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/common-application-properties.html">Appendix A. Common application properties</a></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">7090</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/api</span></span><br><span class="line"><span class="comment">#session过期时间 60M 一个小时</span></span><br><span class="line"><span class="meta">server.servlet.session.timeout</span>=<span class="string">PT60M</span></span><br><span class="line"><span class="comment">#处理favicon</span></span><br><span class="line"><span class="comment">#spring.mvc.favicon.enable=false</span></span><br><span class="line"><span class="comment">#异常处理</span></span><br><span class="line"><span class="comment">#spring.mvc.throw-exception-if-no-handler-found=true</span></span><br><span class="line"><span class="meta">spring.web.resources.add-mappings</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#数据库配置</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/easypan?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.pool-name</span>=<span class="string">HikariCPDatasource</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.idle-timeout</span>=<span class="string">180000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.max-lifetime</span>=<span class="string">1800000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="comment">#发送邮件配置相关</span></span><br><span class="line"><span class="comment"># 配置邮件服务器的地址 smtp.qq.com</span></span><br><span class="line"><span class="meta">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="comment"># 配置邮件服务器的端口（465或587）</span></span><br><span class="line"><span class="meta">spring.mail.port</span>=<span class="string">465</span></span><br><span class="line"><span class="comment"># 配置用户的账号</span></span><br><span class="line"><span class="meta">spring.mail.username</span>=<span class="string">test@qq.com</span></span><br><span class="line"><span class="comment"># 配置用户的密码</span></span><br><span class="line"><span class="meta">spring.mail.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 配置默认编码</span></span><br><span class="line"><span class="meta">spring.mail.default-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># SSL 连接配置</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment"># 开启 debug，这样方便开发者查看邮件发送日志</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.debug</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#邮件配置结束</span></span><br><span class="line"><span class="comment">#Spring redis配置</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.data.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.data.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.data.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.data.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.data.redis.timeout</span>=<span class="string">2000</span></span><br></pre></td></tr></table></figure><h3 id="业务重点流程"><a href="#业务重点流程" class="headerlink" title="业务重点流程"></a>业务重点流程</h3><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img data-src="https://s2.loli.net/2025/07/22/Udzg4jYavtVsL3Z.png" alt="image-20250722174319746"></p><p>表中(file_id,user_id)为联合主键. controller参数包含fileId,file,fileName,filePid,fileMd5,chunkIndex,chunks. </p><p>当刚开始上传时,chunkIndex=0,查看filemd5是否包含这个文件,并且当前空闲空间+文件空间大于总空间,如果查到了,则直接上传,如果文件名重复,重命名,插入数据库(file_id和文件名可能不同,还需要在数据库中插入)</p><p>然后更新使用空间,然后返回秒传响应即可. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chunkIndex=0下</span></span><br><span class="line">FileInfoQuery infoQuery = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">infoQuery.setFileMd5(fileMd5);</span><br><span class="line">infoQuery.setSimplePage(<span class="keyword">new</span> SimplePage(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">infoQuery.setStatus(FileStatusEnums.USING.getStatus());</span><br><span class="line">List&lt;FileInfo&gt; dbFileList = <span class="keyword">this</span>.fileInfoMapper.selectList(infoQuery);</span><br><span class="line"><span class="comment">//秒传</span></span><br><span class="line"><span class="keyword">if</span> (!dbFileList.isEmpty()) &#123;</span><br><span class="line">    FileInfo dbFile = dbFileList.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//判断文件状态</span></span><br><span class="line">    <span class="keyword">if</span> (dbFile.getFileSize() + spaceDto.getUseSpace() &gt; spaceDto.getTotalSpace()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_904);</span><br><span class="line">    &#125;</span><br><span class="line">    dbFile.setFileId(fileId);</span><br><span class="line">    dbFile.setFilePid(filePid);</span><br><span class="line">    dbFile.setUserId(webUserDto.getUserId());</span><br><span class="line">    dbFile.setFileMd5(<span class="keyword">null</span>);</span><br><span class="line">    dbFile.setCreateTime(curDate);</span><br><span class="line">    dbFile.setLastUpdateTime(curDate);</span><br><span class="line">    dbFile.setStatus(FileStatusEnums.USING.getStatus());</span><br><span class="line">    dbFile.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">    dbFile.setFileMd5(fileMd5);</span><br><span class="line">    fileName = autoRename(filePid, webUserDto.getUserId(), fileName);</span><br><span class="line">    dbFile.setFileName(fileName);</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.insert(dbFile);</span><br><span class="line">    resultDto.setStatus(UploadStatusEnums.UPLOAD_SECONDS.getCode());</span><br><span class="line">    <span class="comment">//更新用户空间使用</span></span><br><span class="line">    updateUserSpace(webUserDto, dbFile.getFileSize());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后获取这个切片当前占用存储,如果大于总空间就报异常.</p><p>然后确定下载的chunk路径,BASE_FOLDER+FILE+user_id_file_id+chunkIndex,然后下载到对应位置,增加占用的临时存储空间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂存在临时目录</span></span><br><span class="line">String tempFolderName = appConfig.getProjectFolder() + Constants.FILE_FOLDER_TEMP;</span><br><span class="line">String currentUserFolderName = webUserDto.getUserId() + fileId;</span><br><span class="line"><span class="comment">//创建临时目录</span></span><br><span class="line">tempFileFolder = <span class="keyword">new</span> File(tempFolderName + currentUserFolderName);</span><br><span class="line"><span class="keyword">if</span> (!tempFileFolder.exists()) &#123;</span><br><span class="line">    tempFileFolder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断磁盘空间</span></span><br><span class="line">Long currentTempSize = redisComponent.getFileTempSize(webUserDto.getUserId(), fileId);</span><br><span class="line"><span class="keyword">if</span> (file.getSize() + currentTempSize + spaceDto.getUseSpace() &gt; spaceDto.getTotalSpace()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_904);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File newFile = <span class="keyword">new</span> File(tempFileFolder.getPath() + <span class="string">&quot;/&quot;</span> + chunkIndex);</span><br><span class="line">file.transferTo(newFile);</span><br><span class="line"><span class="comment">//保存临时大小</span></span><br><span class="line">redisComponent.saveFileTempSize(webUserDto.getUserId(), fileId, file.getSize());</span><br><span class="line"><span class="comment">//不是最后一个分片，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (chunkIndex &lt; chunks - <span class="number">1</span>) &#123;</span><br><span class="line">    resultDto.setStatus(UploadStatusEnums.UPLOADING.getCode());</span><br><span class="line">    <span class="keyword">return</span> resultDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是最后一个分片,直接返回,响应设置上传状态.</p><p>当上传完最后一个文件分片时,表示上传完成,将相关文件信息插入数据库,文件状态设置为TRANSFER. 也做了缩略图处理,如果是视频,生成缩略图(使用ffmepg String cmd = “ffmpeg -i %s -y -vframes 1 -vf scale=%d:%d/a %s”;),如果是图片,也可以压缩得到缩略图String cmd = “ffmpeg -i %s -vf scale=%d:-1 %s -y”; 此外,视频会进行切割,得到不同的ts片段和m3u8索引文件. 如果是h.265转为h.264,h.264转成ts,然后进行切片得到ts文件与m3u8索引文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建同名切片目录</span></span><br><span class="line">File tsFolder = <span class="keyword">new</span> File(videoFilePath.substring(<span class="number">0</span>, videoFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line"><span class="keyword">if</span> (!tsFolder.exists()) &#123;</span><br><span class="line">    tsFolder.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String CMD_GET_CODE = <span class="string">&quot;ffprobe -v error -select_streams v:0 -show_entries stream=codec_name %s&quot;</span>;</span><br><span class="line">String cmd = String.format(CMD_GET_CODE, videoFilePath);</span><br><span class="line">String result = ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line">result = result.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">result = result.substring(result.indexOf(<span class="string">&quot;=&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">String codec = result.substring(<span class="number">0</span>, result.indexOf(<span class="string">&quot;[&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//转码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;hevc&quot;</span>.equals(codec)) &#123;</span><br><span class="line">    String newFileName = videoFilePath.substring(<span class="number">0</span>, videoFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>)) + <span class="string">&quot;_&quot;</span> + videoFilePath.substring(videoFilePath.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="keyword">new</span> File(videoFilePath).renameTo(<span class="keyword">new</span> File(newFileName));</span><br><span class="line">    String CMD_HEVC_264 = <span class="string">&quot;ffmpeg -i %s -c:v libx264 -crf 20 %s&quot;</span>;</span><br><span class="line">    cmd = String.format(CMD_HEVC_264, newFileName, videoFilePath);</span><br><span class="line">    ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">new</span> File(newFileName).delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String CMD_TRANSFER_2TS = <span class="string">&quot;ffmpeg -y -i %s  -vcodec copy -acodec copy -bsf:v h264_mp4toannexb %s&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String CMD_CUT_TS = <span class="string">&quot;ffmpeg -i %s -c copy -map 0 -f segment -segment_list %s -segment_time 30 %s/%s_%%4d.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line">String tsPath = tsFolder + <span class="string">&quot;/&quot;</span> + Constants.TS_NAME;</span><br><span class="line"><span class="comment">//生成.ts</span></span><br><span class="line">cmd = String.format(CMD_TRANSFER_2TS, videoFilePath, tsPath);</span><br><span class="line">ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//生成索引文件.m3u8 和切片.ts</span></span><br><span class="line">cmd = String.format(CMD_CUT_TS, tsPath, tsFolder.getPath() + <span class="string">&quot;/&quot;</span> + Constants.M3U8_NAME, tsFolder.getPath(), fileId);</span><br><span class="line">ProcessUtils.executeCommand(cmd, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//删除index.ts</span></span><br><span class="line"><span class="keyword">new</span> File(tsPath).delete();</span><br></pre></td></tr></table></figure><p>同时异步进行文件合并,文件合并就是将chunks写入到一个文件中.同时更新数据库中文件状态.</p><p>在事务提交之后调用合并,截取封面以及视频编码等业务.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务提交后调用异步方法</span></span><br><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronization() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fileInfoService.transferFile(fileInfo.getFileId(), webUserDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h3><h4 id="普通文件预览"><a href="#普通文件预览" class="headerlink" title="普通文件预览"></a>普通文件预览</h4><h4 id="缩略图预览"><a href="#缩略图预览" class="headerlink" title="缩略图预览"></a>缩略图预览</h4><h4 id="视频预览"><a href="#视频预览" class="headerlink" title="视频预览"></a>视频预览</h4><p>返回m3u8索引文件以及ts文件,</p><p>如果是下载ts文件,为了避免下载单个文件过大或者说进行播放时需要分片播放,可以通过在请求头携带range</p><p>而响应头携带</p><p><code>206</code> 响应通常伴随的头部：</p><p>当服务器返回 <code>206 Partial Content</code> 状态码时，通常会同时设置以下响应头：</p><ol><li><p><strong><code>Content-Range</code></strong>:</p><ul><li><strong>作用：</strong> 这是最重要的头，它明确告知客户端当前响应体中包含的是<strong>整个资源的哪一部分</strong>，以及<strong>整个资源的总大小</strong>。</li><li><strong>格式：</strong> <code>Content-Range: bytes &lt;start&gt;-&lt;end&gt;/&lt;total_length&gt;</code></li><li><strong>示例：</strong> <code>Content-Range: bytes 1024-2047/2048</code> 表示响应体中是文件的第 1024 字节到第 2047 字节，整个文件总大小是 2048 字节。</li></ul></li><li><p><strong><code>Content-Length</code></strong>:</p><ul><li><strong>作用：</strong> 表示<strong>当前响应体中实际传输的字节数</strong>（即 <code>end - start + 1</code>）。</li><li><strong>示例：</strong> 如果 <code>Content-Range</code> 是 <code>bytes 1024-2047/2048</code>，那么 <code>Content-Length</code> 应该是 <code>1024</code>。</li></ul></li><li><p><strong><code>Content-Type</code></strong>:</p><ul><li><strong>作用：</strong> 仍然需要指示响应体中内容的媒体类型（MIME type），即使是部分内容。</li></ul></li><li><p><strong><code>Accept-Ranges</code></strong>:</p><ul><li><strong>作用：</strong> 通常在第一次（完整）请求时就设置 <code>Accept-Ranges: bytes</code>，告诉客户端服务器支持范围请求。如果服务器返回 <code>206</code> 状态码，这意味着它肯定支持 <code>bytes</code> 范围。</li></ul><hr><p>分片下载，也称为<strong>断点续传（Resumable Download）或范围请求（Range Request）</strong>，是 HTTP 协议允许客户端只请求资源的部分内容的一种机制。当客户端需要进行分片下载时，它会在请求头中携带特定的信息来告诉服务器它想要哪些部分的数据。</p><h5 id="分片下载时客户端请求头携带的关键信息"><a href="#分片下载时客户端请求头携带的关键信息" class="headerlink" title="分片下载时客户端请求头携带的关键信息"></a>分片下载时客户端请求头携带的关键信息</h5><p>在分片下载场景中，客户端的 HTTP 请求头主要会携带以下一个或多个关键信息：</p><p><code>Range</code> 请求头</p><p>这是进行分片下载<strong>最核心、最重要</strong>的请求头。它明确告诉服务器客户端想要获取资源内容的哪一部分。</p><ul><li><p><strong>作用：</strong> 指示客户端请求的是文件的特定字节范围。</p></li><li><p><strong>格式：</strong> <code>Range: bytes=&lt;start&gt;-&lt;end&gt;</code></p><ul><li><code>&lt;start&gt;</code>: 想要获取的起始字节偏移量（从 0 开始计数）。</li><li><code>&lt;end&gt;</code>: 想要获取的结束字节偏移量。</li></ul></li><li><p><strong>常用变体：</strong></p><ul><li><strong>请求从某个字节到文件末尾：</strong> <code>Range: bytes=1024-</code><ul><li>这表示客户端想要从文件的第 1024 字节开始，一直到文件末尾的所有内容。</li></ul></li><li><strong>请求文件的最后 N 个字节：</strong> <code>Range: bytes=-500</code><ul><li>这表示客户端想要文件的最后 500 个字节。</li></ul></li><li><strong>请求多个不连续的范围：</strong> <code>Range: bytes=0-100, 200-300</code> (服务器不一定支持，但 HTTP 规范允许)<ul><li>这表示客户端想要第 0-100 字节和第 200-300 字节。</li></ul></li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/path/to/large_file.zip</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=5242880-10485759  # 请求文件的第 5MB 到 第 10MB 部分</span><br></pre></td></tr></table></figure></li></ul><p><code>If-Range</code> 请求头 (用于条件范围请求)</p><p>这个请求头通常与 <code>Range</code> 一起使用，以实现<strong>条件性断点续传</strong>。它允许客户端在请求特定范围之前，先验证资源是否在上次下载后被修改过。</p><ul><li><p><strong>作用：</strong> 如果服务器上资源的 <code>ETag</code> 或 <code>Last-Modified</code> 日期与 <code>If-Range</code> 中的值匹配，服务器才会返回请求的范围内容（<code>206 Partial Content</code>）。否则，服务器会忽略 <code>Range</code> 头，并返回整个文件（<code>200 OK</code>），因为资源已经被修改，部分内容可能已经不再有效。</p></li><li><p><strong>格式：</strong></p><ul><li><code>If-Range: &quot;&lt;ETag_value&gt;&quot;</code> (使用资源的 ETag)</li><li><code>If-Range: &lt;HTTP-date&gt;</code> (使用资源的 Last-Modified 日期)</li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/path/to/large_file.zip</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=5242880-         # 客户端请求续传</span><br><span class="line"><span class="attribute">If-Range</span><span class="punctuation">: </span>&quot;abcdef1234567890&quot;  # 如果资源的ETag与此匹配，则继续传输范围内容</span><br></pre></td></tr></table></figure><ul><li>如果服务器发现文件的 ETag 变了，说明文件被修改了，它会返回整个文件（<code>200 OK</code>）。</li><li>如果 ETag 没变，服务器就会返回请求的范围内容（<code>206 Partial Content</code>）。</li></ul></li></ul></li></ol><p>重要响应状态码:206 部分内容 301 永久重定向 302 暂时重定向 </p><h3 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>首先校验文件名字,在当前目录下不能有重名的</p><p>插入file_info表,设置FOLER类型,插入即可. 但注意插入完成后再次进行查询确保只有一个 </p><p>这时因为在并发条件下,如果一个两个事务执行,开始时它们查到没有重名,而进行插入,其中一个拿到互斥锁插入成功并提交事务. 释放锁后,另一个拿到锁也进行插入,插入后需要进行当前读看是否唯一.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">checkFileName(filePid, userId, folderName, FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line">FileInfo fileInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">fileInfo.setFileId(StringTools.getRandomString(Constants.LENGTH_10));</span><br><span class="line">fileInfo.setUserId(userId);</span><br><span class="line">fileInfo.setFilePid(filePid);</span><br><span class="line">fileInfo.setFileName(folderName);</span><br><span class="line">fileInfo.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">fileInfo.setCreateTime(curDate);</span><br><span class="line">fileInfo.setLastUpdateTime(curDate);</span><br><span class="line">fileInfo.setStatus(FileStatusEnums.USING.getStatus());</span><br><span class="line">fileInfo.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.insert(fileInfo);</span><br><span class="line"></span><br><span class="line">FileInfoQuery fileInfoQuery = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">fileInfoQuery.setFilePid(filePid);</span><br><span class="line">fileInfoQuery.setUserId(userId);</span><br><span class="line">fileInfoQuery.setFileName(folderName);</span><br><span class="line">fileInfoQuery.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">fileInfoQuery.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">Integer count = <span class="keyword">this</span>.fileInfoMapper.selectCount(fileInfoQuery); <span class="comment">// select xx for update</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件夹&quot;</span> + folderName + <span class="string">&quot;已经存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fileInfo.setFileName(folderName);</span><br><span class="line">fileInfo.setLastUpdateTime(curDate);</span><br><span class="line"><span class="keyword">return</span> fileInfo;</span><br></pre></td></tr></table></figure><h4 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h4><p>传入路径,路径是每个目录的id相连,比如11122/3344,表示在这个目录下.</p><p>获取这两个目录的信息,相当于获取了从根目录到当前目录的所有目录信息</p><h4 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h4><p>根据传入的fileId判断文件是否存在(是否合法),然后检查文件名是否重复,不重复再进行更新文件名称.</p><p>重命名类似新建目录,重命名完成后也需要看是否唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">FileInfo fileInfo = <span class="keyword">this</span>.fileInfoMapper.selectByFileIdAndUserId(fileId, userId);</span><br><span class="line"><span class="keyword">if</span> (fileInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fileInfo.getFileName().equals(fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileInfo;</span><br><span class="line">&#125;</span><br><span class="line">String filePid = fileInfo.getFilePid();</span><br><span class="line">checkFileName(filePid, userId, fileName, fileInfo.getFolderType());</span><br><span class="line"><span class="comment">//文件获取后缀</span></span><br><span class="line"><span class="keyword">if</span> (FileFolderTypeEnums.FILE.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">    fileName = fileName + StringTools.getFileSuffix(fileInfo.getFileName());</span><br><span class="line">&#125;</span><br><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line">FileInfo dbInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">dbInfo.setFileName(fileName);</span><br><span class="line">dbInfo.setLastUpdateTime(curDate);</span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.updateByFileIdAndUserId(dbInfo, fileId, userId);</span><br><span class="line"></span><br><span class="line">FileInfoQuery fileInfoQuery = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">fileInfoQuery.setFilePid(filePid);</span><br><span class="line">fileInfoQuery.setUserId(userId);</span><br><span class="line">fileInfoQuery.setFileName(fileName);</span><br><span class="line">fileInfoQuery.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">Integer count = <span class="keyword">this</span>.fileInfoMapper.selectCount(fileInfoQuery);</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件名&quot;</span> + fileName + <span class="string">&quot;已经存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fileInfo.setFileName(fileName);</span><br><span class="line">fileInfo.setLastUpdateTime(curDate);</span><br><span class="line"><span class="keyword">return</span> fileInfo;</span><br></pre></td></tr></table></figure><h4 id="获取所有目录"><a href="#获取所有目录" class="headerlink" title="获取所有目录"></a>获取所有目录</h4><p>获得父目录id,同时为了方便移动文件,传递需要移动文件的id,排除掉这些文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(getUserInfoFromSession(session).getUserId());</span><br><span class="line">query.setFilePid(filePid);</span><br><span class="line">query.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line"><span class="keyword">if</span> (!StringTools.isEmpty(currentFileIds)) &#123;</span><br><span class="line">    query.setExcludeFileIdArray(currentFileIds.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">query.setOrderBy(<span class="string">&quot;create_time desc&quot;</span>);</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = fileInfoService.findListByParam(query);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(CopyTools.copyList(fileInfoList, FileInfoVO.class));</span><br></pre></td></tr></table></figure><h4 id="移动文件-目录"><a href="#移动文件-目录" class="headerlink" title="移动文件/目录"></a>移动文件/目录</h4><p>首先判断传入的文件id是否合法,比如文件是否存在,移动到的目录是否存在,然后取出移动到的目录的所有文件名放在一个map中,遍历需要移动的文件,如果名称在map中,则进行重命名,然后更新文件信息,例如pid(目录)和文件名.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setFilePid(filePid);</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">List&lt;FileInfo&gt; dbFileList = fileInfoService.findListByParam(query);</span><br><span class="line"></span><br><span class="line">Map&lt;String, FileInfo&gt; dbFileNameMap = dbFileList.stream().collect(Collectors.toMap(FileInfo::getFileName, Function.identity(), (file1, file2) -&gt; file2));</span><br><span class="line"><span class="comment">//查询选中的文件</span></span><br><span class="line">query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line">List&lt;FileInfo&gt; selectFileList = fileInfoService.findListByParam(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所选文件重命名</span></span><br><span class="line"><span class="keyword">for</span> (FileInfo item : selectFileList) &#123;</span><br><span class="line">    FileInfo rootFileInfo = dbFileNameMap.get(item.getFileName());</span><br><span class="line">    <span class="comment">//文件名已经存在，重命名被还原的文件名</span></span><br><span class="line">    FileInfo updateInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">    <span class="keyword">if</span> (rootFileInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String fileName = StringTools.rename(item.getFileName());</span><br><span class="line">        updateInfo.setFileName(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    updateInfo.setFilePid(filePid);</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.updateByFileIdAndUserId(updateInfo, item.getFileId(), userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回收站回收、还原以及彻底删除文件"><a href="#回收站回收、还原以及彻底删除文件" class="headerlink" title="回收站回收、还原以及彻底删除文件"></a>回收站回收、还原以及彻底删除文件</h3><h4 id="回收文件-目录"><a href="#回收文件-目录" class="headerlink" title="回收文件/目录"></a>回收文件/目录</h4><p>将传入的文件id依次加入到list中,如果它是目录,再递归将其下的文件放入list中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAllSubFolderFileIdList</span><span class="params">(List&lt;String&gt; fileIdList, String userId, String fileId, Integer delFlag)</span> </span>&#123;</span><br><span class="line">    fileIdList.add(fileId);</span><br><span class="line">    FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">    query.setUserId(userId);</span><br><span class="line">    query.setFilePid(fileId);</span><br><span class="line">    query.setDelFlag(delFlag);</span><br><span class="line">    query.setFolderType(FileFolderTypeEnums.FOLDER.getType());</span><br><span class="line">    List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line">    <span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">        findAllSubFolderFileIdList(fileIdList, userId, fileInfo.getFileId(), delFlag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样选中的所有文件目录以及子目录都在list中,都进行更新为删除状态即可.</p><p>然后再将选中的文件和目录更新为回收状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String[] fileIdArray = fileIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line"><span class="keyword">if</span> (fileInfoList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; delFilePidList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">    findAllSubFolderFileIdList(delFilePidList, userId, fileInfo.getFileId(), FileDelFlagEnums.USING.getFlag());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将目录下的所有文件更新为已删除</span></span><br><span class="line"><span class="keyword">if</span> (!delFilePidList.isEmpty()) &#123;</span><br><span class="line">    FileInfo updateInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">    updateInfo.setDelFlag(FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.updateFileDelFlagBatch(updateInfo, userId, delFilePidList, <span class="keyword">null</span>, FileDelFlagEnums.USING.getFlag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将选中的文件更新为回收站</span></span><br><span class="line">List&lt;String&gt; delFileIdList = Arrays.asList(fileIdArray);</span><br><span class="line">FileInfo fileInfo = <span class="keyword">new</span> FileInfo();</span><br><span class="line">fileInfo.setRecoveryTime(<span class="keyword">new</span> Date());</span><br><span class="line">fileInfo.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.updateFileDelFlagBatch(fileInfo, userId, <span class="keyword">null</span>, delFileIdList, FileDelFlagEnums.USING.getFlag());</span><br></pre></td></tr></table></figure><h3 id="回收站相关"><a href="#回收站相关" class="headerlink" title="回收站相关"></a>回收站相关</h3><h4 id="加载回收站文件"><a href="#加载回收站文件" class="headerlink" title="加载回收站文件"></a>加载回收站文件</h4><p>设置好文件删除标志即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setPageSize(pageSize);</span><br><span class="line">query.setPageNo(pageNo);</span><br><span class="line">query.setUserId(getUserInfoFromSession(session).getUserId());</span><br><span class="line">query.setOrderBy(<span class="string">&quot;recovery_time desc&quot;</span>);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line">PaginationResultVO result = fileInfoService.findListByPage(query);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(convert2PaginationVO(result, FileInfoVO.class));</span><br></pre></td></tr></table></figure><h4 id="回收站文件复原"><a href="#回收站文件复原" class="headerlink" title="回收站文件复原"></a>回收站文件复原</h4><p>关键是需要复原目录中的所有文件,同时如果文件在复原的目录中有重名需要改名.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] fileIdArray = fileIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; delFileSubFolderFileIdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//找到所选文件子目录文件ID</span></span><br><span class="line"><span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">        findAllSubFolderFileIdList(delFileSubFolderFileIdList, userId, fileInfo.getFileId(), FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取要复原的所有文件的id以及子目录的id,迭代的获取文件id,将文件状态都更新为在使用(从DELETE到USING).</p><p>然后默认恢复文件到根目录,获取根目录中的所有文件放在一个map中,遍历回收站中文件如果有重名更新名字,然后更新状态(从RECYCLE到USING)</p><h4 id="删除回收站文件"><a href="#删除回收站文件" class="headerlink" title="删除回收站文件"></a>删除回收站文件</h4><p>直接删除即可.</p><p>更新用户可用空间以及缓存.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String[] fileIdArray = fileIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line">query.setUserId(userId);</span><br><span class="line">query.setFileIdArray(fileIdArray);</span><br><span class="line"><span class="keyword">if</span> (!adminOp) &#123;</span><br><span class="line">    query.setDelFlag(FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line">&#125;</span><br><span class="line">List&lt;FileInfo&gt; fileInfoList = <span class="keyword">this</span>.fileInfoMapper.selectList(query);</span><br><span class="line">List&lt;String&gt; delFileSubFolderFileIdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//找到所选文件子目录文件ID</span></span><br><span class="line"><span class="keyword">for</span> (FileInfo fileInfo : fileInfoList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">        findAllSubFolderFileIdList(delFileSubFolderFileIdList, userId, fileInfo.getFileId(), FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所选文件，子目录中的文件</span></span><br><span class="line"><span class="keyword">if</span> (!delFileSubFolderFileIdList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fileInfoMapper.delFileBatch(userId, delFileSubFolderFileIdList, <span class="keyword">null</span>, adminOp ? <span class="keyword">null</span> : FileDelFlagEnums.DEL.getFlag());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除所选文件</span></span><br><span class="line"><span class="keyword">this</span>.fileInfoMapper.delFileBatch(userId, <span class="keyword">null</span>, Arrays.asList(fileIdArray), adminOp ? <span class="keyword">null</span> : FileDelFlagEnums.RECYCLE.getFlag());</span><br><span class="line"></span><br><span class="line">Long useSpace = <span class="keyword">this</span>.fileInfoMapper.selectUseSpace(userId);</span><br><span class="line">UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">userInfo.setUseSpace(useSpace);</span><br><span class="line"><span class="keyword">this</span>.userInfoMapper.updateByUserId(userInfo, userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置缓存</span></span><br><span class="line">UserSpaceDto userSpaceDto = redisComponent.getUserSpaceUse(userId);</span><br><span class="line">userSpaceDto.setUseSpace(useSpace);</span><br><span class="line">redisComponent.saveUserSpaceUse(userId, userSpaceDto);</span><br></pre></td></tr></table></figure><h3 id="外部分享文件"><a href="#外部分享文件" class="headerlink" title="外部分享文件"></a>外部分享文件</h3><h4 id="创建下载链接"><a href="#创建下载链接" class="headerlink" title="创建下载链接"></a>创建下载链接</h4><p>主要是返回一个密码给用户端,用户端后续携带下载文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInfo fileInfo = fileInfoService.getFileInfoByFileIdAndUserId(fileId, userId);</span><br><span class="line"><span class="keyword">if</span> (fileInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileFolderTypeEnums.FOLDER.getType().equals(fileInfo.getFolderType())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line">String code = StringTools.getRandomString(Constants.LENGTH_50);</span><br><span class="line">DownloadFileDto downloadFileDto = <span class="keyword">new</span> DownloadFileDto();</span><br><span class="line">downloadFileDto.setDownloadCode(code);</span><br><span class="line">downloadFileDto.setFilePath(fileInfo.getFilePath());</span><br><span class="line">downloadFileDto.setFileName(fileInfo.getFileName());</span><br><span class="line"></span><br><span class="line">redisComponent.saveDownloadCode(code, downloadFileDto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(code);</span><br></pre></td></tr></table></figure><p>根据fileId,userId获取文件信息,将文件信息与code存入缓存</p><h4 id="下载文件-1"><a href="#下载文件-1" class="headerlink" title="下载文件"></a>下载文件</h4><p>根据传入的code获取缓存中的文件信息,根据文件信息拼接下载地址下载文件.注意设置response的响应头.content-type和content-disposition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DownloadFileDto downloadFileDto = redisComponent.getDownloadCode(code);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == downloadFileDto) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String filePath = appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE + downloadFileDto.getFilePath();</span><br><span class="line">String fileName = downloadFileDto.getFileName();</span><br><span class="line">response.setContentType(<span class="string">&quot;application/x-msdownload; charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (request.getHeader(<span class="string">&quot;User-Agent&quot;</span>).toLowerCase().indexOf(<span class="string">&quot;msie&quot;</span>) &gt; <span class="number">0</span>) &#123;<span class="comment">//IE浏览器</span></span><br><span class="line">    fileName = URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileName = <span class="keyword">new</span> String(fileName.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=\&quot;&quot;</span> + fileName + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">readFile(response, filePath);</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/07/24/PKgE1ckHUmQdXWZ.png" alt="image-20250724203722676"></p><p>分享文件就是创建分享信息,并设置shared插入file_share表.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ShareValidTypeEnums typeEnum = ShareValidTypeEnums.getByType(share.getValidType());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == typeEnum) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ResponseCodeEnum.CODE_600);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeEnum != ShareValidTypeEnums.FOREVER) &#123;</span><br><span class="line">    share.setExpireTime(DateUtil.getAfterDate(typeEnum.getDays()));</span><br><span class="line">&#125;</span><br><span class="line">Date curDate = <span class="keyword">new</span> Date();</span><br><span class="line">share.setShareTime(curDate);</span><br><span class="line"><span class="keyword">if</span> (StringTools.isEmpty(share.getCode())) &#123;</span><br><span class="line">    share.setCode(StringTools.getRandomString(Constants.LENGTH_5));</span><br><span class="line">&#125;</span><br><span class="line">share.setShareId(StringTools.getRandomString(Constants.LENGTH_20));</span><br><span class="line"><span class="keyword">this</span>.fileShareMapper.insert(share);</span><br></pre></td></tr></table></figure><p>其他人要来下载,传入sharedId,查表获得分享信息,同时增加分享浏览次数.并将分享信息存入session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/checkShareCode&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">checkShareCode</span><span class="params">(HttpSession session,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@VerifyParam(required = true)</span> String shareId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@VerifyParam(required = true)</span> String code)</span> </span>&#123;</span><br><span class="line">    SessionShareDto shareSessionDto = fileShareService.checkShareCode(shareId, code);</span><br><span class="line">    session.setAttribute(Constants.SESSION_SHARE_KEY + shareId, shareSessionDto);</span><br><span class="line">    <span class="keyword">return</span> getSuccessResponseVO(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后后续通过sharedId可以获得分享的文件信息和分享者等信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">getShareLoginInfo</span><span class="params">(HttpSession session, <span class="meta">@VerifyParam(required = true)</span> String shareId)</span> </span>&#123;</span><br><span class="line">    SessionShareDto shareSessionDto = getSessionShareFromSession(session, shareId);</span><br><span class="line">    <span class="keyword">if</span> (shareSessionDto == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getSuccessResponseVO(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ShareInfoVO shareInfoVO = getShareInfoCommon(shareId);</span><br><span class="line">    <span class="comment">//判断是否是当前用户分享的文件</span></span><br><span class="line">    SessionWebUserDto userDto = getUserInfoFromSession(session);</span><br><span class="line">    <span class="keyword">if</span> (userDto != <span class="keyword">null</span> &amp;&amp; userDto.getUserId().equals(shareSessionDto.getShareUserId())) &#123;</span><br><span class="line">        shareInfoVO.setCurrentUser(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shareInfoVO.setCurrentUser(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSuccessResponseVO(shareInfoVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的,通过shareId获取文件表,注意检查对应的文件id等于filePid或者filePid文件的filePid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SessionShareDto shareSessionDto = checkShare(session, shareId);</span><br><span class="line">FileInfoQuery query = <span class="keyword">new</span> FileInfoQuery();</span><br><span class="line"><span class="keyword">if</span> (!StringTools.isEmpty(filePid) &amp;&amp; !Constants.ZERO_STR.equals(filePid)) &#123;</span><br><span class="line">    fileInfoService.checkRootFilePid(shareSessionDto.getFileId(), shareSessionDto.getShareUserId(), filePid);</span><br><span class="line">    query.setFilePid(filePid);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    query.setFileId(shareSessionDto.getFileId());</span><br><span class="line">&#125;</span><br><span class="line">query.setUserId(shareSessionDto.getShareUserId());</span><br><span class="line">query.setOrderBy(<span class="string">&quot;last_update_time desc&quot;</span>);</span><br><span class="line">query.setDelFlag(FileDelFlagEnums.USING.getFlag());</span><br><span class="line">PaginationResultVO resultVO = fileInfoService.findListByPage(query);</span><br><span class="line"><span class="keyword">return</span> getSuccessResponseVO(convert2PaginationVO(resultVO, FileInfoVO.class));</span><br></pre></td></tr></table></figure><p>获取对应文件信息.</p><p>下载类似的,首先通过createDownloadUrl创建下载连接以及code,存入缓存,然后后续可以下载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/createDownloadUrl/&#123;shareId&#125;/&#123;fileId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">createDownloadUrl</span><span class="params">(HttpSession session,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@PathVariable(&quot;shareId&quot;)</span> <span class="meta">@VerifyParam(required = true)</span> String shareId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="meta">@PathVariable(&quot;fileId&quot;)</span> <span class="meta">@VerifyParam(required = true)</span> String fileId)</span> </span>&#123;</span><br><span class="line">    SessionShareDto shareSessionDto = checkShare(session, shareId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.createDownloadUrl(fileId, shareSessionDto.getShareUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/download/&#123;code&#125;&quot;)</span></span><br><span class="line"><span class="meta">@GlobalInterceptor(checkLogin = false, checkParams = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="meta">@PathVariable(&quot;code&quot;)</span> <span class="meta">@VerifyParam(required = true)</span> String code)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.download(request, response, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="EasyLive"><a href="#EasyLive" class="headerlink" title="EasyLive"></a>EasyLive</h1><h3 id="参考博主"><a href="#参考博主" class="headerlink" title="参考博主"></a>参考博主</h3><p><a href="https://space.bilibili.com/499388891">程序员老罗的个人空间-程序员老罗个人主页-哔哩哔哩视频</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在准备实习,找一些&lt;del&gt;烂大街&lt;/del&gt;经典项目练练手.&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://www.sekyoro.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP与HTTP编程</title>
    <link href="https://www.sekyoro.top/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.sekyoro.top/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/</id>
    <published>2025-03-12T07:05:02.000Z</published>
    <updated>2025-03-19T13:42:30.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>复习基础知识. TCP/IP以及HTTP是计算机网络以及互联网开发的基础.<br><span id="more"></span></p><p><a href="https://www.runoob.com/tcpip/tcpip-tutorial.html">TCP/IP 教程 | 菜鸟教程</a></p><p><a href="https://www.runoob.com/np/tcp-protocol.html">TCP 协议 | 菜鸟教程</a></p><p><a href="https://www.geeksforgeeks.org/tcp-ip-model/">TCP/IP Model - GeeksforGeeks</a></p><p><a href="https://www.w3school.com.cn/tcpip/index.asp">TCP/IP 教程</a></p><p><a href="https://liaoxuefeng.com/books/java/network/basic/index.html">网络编程基础 - Java教程 - 廖雪峰的官方网站</a></p><p>相关书籍:<a href="https://github.com/wengjianhong/Kunlun/tree/master/PDF">Kunlun/PDF at master · wengjianhong/Kunlun</a></p><p>Linux命令查看:<a href="https://www.man7.org/linux/man-pages/">Linux man pages online</a></p><p><a href="https://linux.die.net/">Linux Documentation</a></p><p><a href="https://www.kernel.org/doc/man-pages/">The Linux man-pages project</a></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP 是用于因特网 (Internet) 的通信协议。计算机通信协议是对那些计算机必须遵守以便彼此通信的的规则的描述。</p><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p><p>TCP/IP 指传输控制协议/网际协议（<strong>Transmission Control Protocol Internet Protocol</strong>）。</p><p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准</p><p><img data-src="https://s2.loli.net/2025/03/15/JdNpVR5weBxFmI2.png" alt="image-20250315132629613"></p><blockquote><p>通过数据链路层和传输层的数据都有限制,如图. 在传输层不能超过TCP最大报文段长度(MSS). 比如一次写入大于MSS的数据,再加上HTTP头部信息,超过了MSS后在传输层会将这些信息分段.</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/15/lxrdIhWqZcEs5tf.png" alt="image-20250315132914577"></p><blockquote><p>每个层会加上头部或头尾部</p></blockquote><p>TCP/IP协议栈属于操作系统(内核态)的行为,</p><p>应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发 数据的 TCP 和 UDP 协议，这两个传输协议会接受应⽤层的委托执⾏收发数据的操作。</p><p><img data-src="https://s2.loli.net/2025/03/15/aVJc2KbCXsxEvPh.png" alt="image-20250315164613174"></p><p>用户态通过使用socket库结合对应HTTP协议搭建应用程序</p><h4 id="传输层TCP协议"><a href="#传输层TCP协议" class="headerlink" title="传输层TCP协议"></a>传输层TCP协议</h4><blockquote><p>TCP数据包格式</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/15/GroHmCts5Z4WjJL.png" alt="image-20250315165319850"></p><p>​    ⾸先，源端⼝号和⽬标端⼝号是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤.</p><p>​     接下来有包的序号，这个是为了解决包乱序的问题。 还有应该有的是确认号，⽬的是确认发出去对⽅是否有收到.(超时重传,通过定时器和确认序号ack)</p><p>​    如果没有收到就应该重新发送，直到送达， 这个是为了解决丢包的问题。 接下来还有⼀些状态位。例如  SYN 是发起⼀个连接， ACK 是回复， RST 是重新连接， FIN 是结束连接等。TCP 是⾯向连接的，因⽽双⽅要维护连接的状态，这些带状态位的包的发送，会引起双⽅的状态 变更。 还有⼀个重要的就是窗⼝⼤⼩.(面向连接)</p><p>​    TCP 要做流量控制，通信双⽅各声明⼀个窗⼝（缓存⼤⼩），标识⾃⼰当前能够的处理能⼒，别发送的太快，撑死我，也别发的太慢，饿死我。 除了做流量控制以外.(流量控制,通过窗口大小的滑动窗口机制)</p><p>​    TCP还会做拥塞控制，对于真正的通路堵⻋不堵⻋，它⽆能为⼒，唯⼀能做的就是控制⾃⼰，也即控制发送的速度(TCP采用了几种算法来动态地调整发送速率以适应网络状况).</p><blockquote><ul><li><strong>流量控制</strong>专注于匹配发送方与接收方之间的处理能力，防止发送方发送超出接收方处理能力的数据量。</li><li><strong>拥塞控制</strong>则着眼于整个网络的状态，试图找到合适的发送速率，既不过度占用网络资源导致拥塞，也不过于保守浪费带宽。</li></ul></blockquote><ol><li>慢启动（Slow Start）</li></ol><p>当一个TCP连接开始时，发送方不知道网络的状态，也不知道接收方能够接受数据的速度。慢启动阶段通过指数增长的方式逐渐增加拥塞窗口（Congestion Window, cwnd）的大小，以便探测网络的容量。初始时，cwnd通常设置为一个小值（如1个最大段大小MSS）。每成功接收到一个ACK确认，cwnd就增加一个MSS。这个过程持续到遇到首个丢包事件或者达到慢启动阈值（ssthresh）。</p><ol><li>拥塞避免（Congestion Avoidance）</li></ol><p>一旦cwnd的值达到或超过ssthresh，TCP进入拥塞避免阶段。在这个阶段，cwnd的增长速度变缓，采用线性增长方式，即每次往返时间（RTT）只允许cwnd增加一个MSS/cwnd。这有助于更精细地探测网络的最大吞吐量，而不会像慢启动那样迅速使网络过载。</p><ol><li>快速重传（Fast Retransmit）</li></ol><p>快速重传机制用于在未超时的情况下检测到丢包。如果发送方连续收到三个对同一数据段的重复ACK，这意味着该数据段可能已经丢失，发送方将立即重传丢失的数据段，而不是等待定时器超时。这样做可以更快地恢复丢失的数据包，减少等待时间。</p><ol><li>快速恢复（Fast Recovery）</li></ol><p>快速恢复与快速重传配合使用。当发送方由于收到三次重复ACK而触发快速重传后，它会进入快速恢复状态。在此状态下，发送方不执行慢启动，而是调整ssthresh到当前cwnd的一半，并从那里继续尝试增大cwnd，直到不再收到重复的ACK为止。这有助于快速从丢包中恢复，而不必回到慢启动状态。</p><blockquote><p>连接时三次握手</p><p>这个所谓的「连接」，只是双⽅计算机⾥维护⼀个状态机，在连接建⽴的过程中，双⽅的状态变化时序图 </p></blockquote><p>在 HTTP 传输数据之前，⾸先需要 TCP 建⽴连接，TCP 连接的建⽴，通常称为三次握⼿。</p><p><img data-src="https://s2.loli.net/2025/03/15/ld7fpEhMHxOzgNt.png" alt="image-20250315165832577"></p><p>三次握⼿⽬的是保证双⽅都有发送和接收的能⼒。</p><p>使用netstat -antp,查看tcp连接状态</p><p><img data-src="https://s2.loli.net/2025/03/15/bQADsTaFn9R7oNt.png" alt="image-20250315173636652"></p><p><img data-src="https://s2.loli.net/2025/03/15/c7VGWhk6n3rS98C.png" alt="image-20250315181426136"></p><h4 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h4><p>TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</p><p><img data-src="https://s2.loli.net/2025/03/15/ne5z3l6mODxcG1J.png" alt="image-20250315182247041"></p><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为  TCP。 06 （⼗六进制）,表示协议为TCP</p><blockquote><p>在 Linux 操作系统,可以使⽤  route -n 命令查看当前系统的路由表</p></blockquote><p>IP数据包包括首部长度和总长度. 此外当IP数据包大于底层协议所允许的大小(MTU)时进行分片.</p><p>IP分片的主要特点：</p><ul><li><strong>标识（Identification）</strong>：所有分片都共享相同的标识值，以便目标主机可以识别这些分片属于同一个原始数据报。</li><li><strong>标志（Flags）</strong>：包含三个比特位，其中两个用于控制是否还有更多的分片以及是否允许分片。</li><li><strong>片偏移（Fragment Offset）</strong>：表示该分片在原始数据报中的位置，帮助接收端按照正确的顺序重组数据报。</li></ul><p>分片过程</p><ol><li>当一个IP数据包准备发送时，如果其大小超过了出站接口的MTU，则需要进行分片。</li><li>每个生成的分片<strong>都将包含源地址、目的地址、标识字段和标志字段等信息。</strong></li><li>除了最后一个分片外，其他所有分片都将填充到它们的最大长度，而最后一个分片可能小于最大长度。</li><li>接收方收到所有分片后，根据标识字段、标志字段和片偏移字段重组原始数据报</li></ol><p>⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。<strong>在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输</strong>。 ⼀般在 TCP/IP 通信⾥，MAC 包头的协议类型只使⽤： 0800 ： IP 协议 0806 ： ARP 协议</p><p>当不知道MAC地址时,需要  ARP 协议帮我们找到路由器的 MAC 地址。</p><blockquote><p>ARP 协议会在以太⽹中以⼴播的形式，对以太⽹所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC  地址告诉我”。 然后就会有⼈回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p></blockquote><p><strong>如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址</strong>。然后将这 个 MAC 地址写⼊ MAC 头部，MAC 头部就完成了。</p><p>操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间 就⼏分钟。 也就是说，在发包时： 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP  缓存中的地址。 ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询。</p><p>⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此需要将数字信息 转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。 负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序。 ⽹卡驱动获取⽹络包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符， 在末尾加上⽤于检测错误的帧校验序列</p><p><img data-src="https://s2.loli.net/2025/03/16/lRTEm9kAhZMtqD8.png" alt="image-20250316153840683"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是应用层协议,类似的应用层协议有FTP,SFTP,TELNET等. HTTP协议对于请求报文和响应报文有不同的格式要求. HTTP版本有1.0,1.1与2.0.</p><p><img data-src="https://s2.loli.net/2025/03/15/BpEqolHja4TALvS.png" alt="image-20250315154823886"></p><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><h3 id="IPV4与IPV6"><a href="#IPV4与IPV6" class="headerlink" title="IPV4与IPV6"></a>IPV4与IPV6</h3><h3 id="RPC与HTTP"><a href="#RPC与HTTP" class="headerlink" title="RPC与HTTP"></a>RPC与HTTP</h3><ul><li><strong>RPC（Remote Procedure Call，远程过程调用）</strong>:是一种协议，允许一个程序通过网络请求另一个地址空间中的子程序或服务，而无需了解底层网络细节。它旨在让开发者像调用本地函数一样调用远程服务。</li><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>:是一个用于传输超媒体文档的应用层协议，主要用于Web浏览器与Web服务器之间的通信。尽管最初设计是为了支持网页浏览，但HTTP也被广泛应用于构建RESTful API等服务接口</li></ul><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><ul><li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺 陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</li><li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次 握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。</li><li>两者的默认端⼝不⼀样，HTTP 默认端⼝号是 80，HTTPS 默认端⼝号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加⼊了  SSL/TLS 协议，可以解决安全⻛险： 信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。 校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴ 告。 身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p>代码随想录、阿秀、labuladong、小林coding、JavaGuide</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习基础知识. TCP/IP以及HTTP是计算机网络以及互联网开发的基础.&lt;br&gt;</summary>
    
    
    
    
    <category term="TCP/IP" scheme="https://www.sekyoro.top/tags/TCP-IP/"/>
    
    <category term="HTTP" scheme="https://www.sekyoro.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>mini-java-guide</title>
    <link href="https://www.sekyoro.top/2025/03/09/mini-java-guide/"/>
    <id>https://www.sekyoro.top/2025/03/09/mini-java-guide/</id>
    <published>2025-03-09T02:10:08.000Z</published>
    <updated>2025-07-19T08:05:01.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习很潮很流行的Java以及相关框架.<br><span id="more"></span></p><p><a href="https://liaoxuefeng.com/books/java/introduction/index.html">简介 - Java教程 - 廖雪峰的官方网站</a></p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java基础-1"><a href="#Java基础-1" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-java-lang"><a href="#1-java-lang" class="headerlink" title="1. java.lang.*"></a>1. java.lang.*</h3><p>这是默认导入的包，包含基本类和接口。</p><ul><li><strong>Object</strong>：所有类的超类。</li><li><strong>String</strong>：不可变字符串类，用于文本处理。</li><li><strong>StringBuilder/StringBuffer</strong>：可变字符串类，适用于频繁修改字符串的场景。<code>StringBuffer</code>是线程安全的版本。</li><li><strong>System</strong>：提供系统相关的信息和操作，如<code>System.out.println()</code>打印输出。</li><li><strong>Math</strong>：提供数学计算的方法，如三角函数、对数等。</li><li><strong>Integer, Double 等包装类</strong>：基本类型的对象表示形式，支持自动装箱/拆箱。</li></ul><h3 id="2-java-util"><a href="#2-java-util" class="headerlink" title="2. java.util.*"></a>2. java.util.*</h3><p>包含了集合框架、日期时间工具、随机数生成器等实用工具类。</p><ul><li><strong>Collection 接口及其实现类</strong>（如ArrayList, LinkedList, HashSet, TreeSet等）：提供了不同类型的集合实现。</li><li><strong>Map 接口及其实现类</strong>（如HashMap, TreeMap等）：键值对存储结构。</li><li><strong>Iterator</strong>：遍历集合的标准方式。</li><li><strong>Date, Calendar, LocalDate, LocalDateTime</strong>（Java 8+）：处理日期和时间。</li><li><strong>Random</strong>：生成伪随机数。</li><li><strong>Arrays</strong>：提供操作数组的各种静态方法。</li></ul><p>函数式编程(function)包提供了一些功能接口</p><ul><li><p><strong><code>Function&lt;T, R&gt;</code></strong>：接受一个参数并返回结果。</p></li><li><p><strong><code>Predicate&lt;T&gt;</code></strong>：接受一个输入参数并返回布尔值。方法签名：`boolean test(T t)``</p></li><li><p><code>`BiFunction&lt;T, U, R&gt;</code>：接受两个输入参数并返回结果。<strong>方法签名</strong>：<code>R apply(T t, U u)</code></p></li><li><p><code>UnaryOperator&lt;T&gt;</code> ：接受一个参数并返回相同类型的值，是 <code>Function&lt;T, T&gt;</code> 的特化形式。 <strong>方法签名</strong>：<code>T apply(T t)</code></p></li><li><p><code>BinaryOperator&lt;T&gt;</code>：接受两个相同类型的参数并返回相同类型的值，是 <code>BiFunction&lt;T, T, T&gt;</code> 的特化形式。 <strong>方法签名</strong>：`T apply(T t, T u)```</p></li><li><p><code>BiPredicate&lt;T, U&gt;</code>：接受两个输入参数并返回布尔值。<strong>方法签名</strong>：<code>boolean test(T t, U u)</code>,用于需要基于两个输入值进行条件判断的场景</p></li><li><p><strong><code>Supplier&lt;T&gt;</code></strong>：适用于你需要从无到有地“生产”数据的场合。它不接收任何参数，但是可以返回你所需要的类型的实例。这使得它非常适合用于延迟初始化、配置加载等场景。</p></li><li><strong><code>BiConsumer&lt;T, U&gt;</code></strong>：当你需要处理或操作一对相关的值，并且这些操作的结果并不重要（即不需要返回值）时非常有用。比如，你可能想要记录一组键值对的日志，或者将两个值合并在一起而不关心最终结果。</li></ul><h3 id="3-java-io"><a href="#3-java-io" class="headerlink" title="3. java.io.*"></a>3. java.io.*</h3><p>提供输入输出流的支持，用于读写文件或进行网络通信。</p><ul><li><strong>InputStream/OutputStream</strong>：字节流基类。</li><li><strong>Reader/Writer</strong>：字符流基类。</li><li><strong>File</strong>：文件或目录路径名的抽象表示形式。</li><li><strong>BufferedReader/BufferedWriter, BufferedInputStream/BufferedOutputStream</strong>：提高I/O效率的缓冲类。</li></ul><h3 id="4-java-nio"><a href="#4-java-nio" class="headerlink" title="4. java.nio.*"></a>4. java.nio.*</h3><p>新的I/O API，提供了更高效的非阻塞I/O操作。</p><ul><li><strong>Path, Paths</strong>：用于处理文件系统路径。</li><li><strong>Files</strong>：提供对文件的操作方法。</li><li><strong>ByteBuffer</strong>及其他缓冲区类型：用于高效地管理字节序列。</li></ul><h3 id="5-java-net"><a href="#5-java-net" class="headerlink" title="5. java.net.*"></a>5. java.net.*</h3><p>网络编程相关的API。</p><ul><li><strong>URL, URI</strong>：统一资源定位符/标识符。</li><li><strong>URLConnection</strong>：与URL建立连接。</li><li><strong>Socket, ServerSocket</strong>：TCP/IP套接字编程的基础类。</li><li><strong>DatagramPacket, DatagramSocket</strong>：UDP协议的支持。</li></ul><h3 id="6-java-text"><a href="#6-java-text" class="headerlink" title="6. java.text.*"></a>6. java.text.*</h3><p>用于格式化和解析文本。</p><ul><li><strong>NumberFormat, DecimalFormat</strong>：数字格式化。</li><li><strong>DateFormat, SimpleDateFormat</strong>：日期格式化。</li><li><strong>MessageFormat</strong>：根据模式格式化消息。</li></ul><h3 id="7-java-time"><a href="#7-java-time" class="headerlink" title="7. java.time.*"></a>7. java.time.*</h3><p>Java 8引入的新日期时间API。</p><ul><li><strong>Instant</strong>：表示时间线上的一点。</li><li><strong>LocalDate, LocalTime, LocalDateTime</strong>：分别表示不带时区的日期、时间和日期时间。</li><li><strong>ZonedDateTime, OffsetDateTime</strong>：带有时区信息的日期时间。</li></ul><h3 id="8-并发相关"><a href="#8-并发相关" class="headerlink" title="8. 并发相关"></a>8. 并发相关</h3><ul><li><strong>Thread</strong>：创建和控制线程。</li><li><strong>Runnable</strong>：线程执行的目标接口。</li><li><strong>ExecutorService, Executors</strong>：更高级别的线程管理。</li><li><strong>Lock, ReentrantLock</strong>：比同步块更灵活的锁定机制。</li><li><strong>ConcurrentHashMap</strong>：线程安全的哈希表实现。</li></ul><h3 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h3><ul><li><strong>Optional</strong>（Java 8+）：避免空指针异常的一种设计模式。</li><li><strong>Stream API</strong>（Java 8+）：提供了一种高效且易于使用的集合元素处理方式。</li></ul><div class="table-container"><table><thead><tr><th>访问修饰符</th><th>同一类</th><th>同一包</th><th>子类（不同包）</th><th>全局</th></tr></thead><tbody><tr><td><code>public</code></td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td><code>protected</code></td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>默认</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td><code>private</code></td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></div><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>成员内部类,静态内部类,局部内部类,匿名内部类</p><p><img data-src="https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png" alt="image-20250319142346062"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">outerclass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String age;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">innerclass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is an inner class&quot;</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png" alt="image-20250319142856906"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">innercls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is an inner class&quot;</span>);</span><br><span class="line">        System.out.println(innercls.<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img data-src="https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png" alt="image-20250319144727002"></p><p><img data-src="https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png" alt="image-20250319150803696"></p><h3 id="集合Collection与Map"><a href="#集合Collection与Map" class="headerlink" title="集合Collection与Map"></a>集合Collection与Map</h3><p>数组和集合的区别：</p><p>数组</p><ul><li><p><strong>固定大小</strong>：数组一旦创建，其大小是固定的，不能动态增加或减少元素。</p></li><li><p><strong>类型安全</strong>：数组可以是基本数据类型（如 <code>int[]</code>, <code>double[]</code>）或对象类型（如 <code>String[]</code>）。对于对象类型的数组，所有元素都必须是该类的实例或者 <code>null</code>。</p></li><li><p><strong>内存连续</strong>：数组中的元素在内存中是连续存储的，这使得访问速度非常快，因为可以通过计算偏移量直接访问任何元素（时间复杂度为 O(1)）。</p></li><li><p>声明方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个包含5个整数的数组</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;; <span class="comment">// 初始化时赋值</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ul><li>访问速度快，支持随机访问。</li><li>对于小规模、固定数量的数据集非常适合。</li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><strong>定义与特性</strong></p><ul><li><p><strong>动态大小</strong>：<code>List</code> 接口的主要实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许动态添加和删除元素，这意味着你可以根据需要扩展或缩小列表的大小。</p></li><li><p><strong>接口与实现</strong>：<code>List</code> 是一个接口，常用的实现包括 <code>ArrayList</code> 和 <code>LinkedList</code>。<code>ArrayList</code> 底层基于数组实现，而 <code>LinkedList</code> 则是一个双向链表。</p></li><li><p><strong>类型安全</strong>：<code>List</code> 只能存储对象，不能直接存储基本数据类型（但可以使用自动装箱/拆箱功能处理基本数据类型）。</p></li><li><p>声明方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ul><li>动态大小，方便添加和删除元素。</li><li>提供了丰富的操作方法，比如 <code>add()</code>, <code>remove()</code>, <code>get()</code>, <code>indexOf()</code> 等等。</li><li>更好的抽象层次，代码更加灵活易读。</li></ul><p><strong>缺点</strong></p><ul><li>相比于数组，某些操作可能效率较低，例如在 <code>ArrayList</code> 中插入或删除中间位置的元素会导致其他元素移动；而在 <code>LinkedList</code> 中查找元素则需要从头或尾遍历整个列表。</li></ul><p>ArrayList使用数组实现,查询快,增删慢</p><p>LinkedList使用双向链表实现,查询慢,增删快,尤其对于首尾操作</p><p><img data-src="https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png" alt="image-20250318215401958"></p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p><img data-src="https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png" alt="image-20250318220123427"></p><p>HashSet使用哈希表实现,增删改查性能较好 </p><p><img data-src="https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png" alt="image-20250318220818128"></p><p><img data-src="https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png" alt="image-20250318221151248"></p><p>HashSet去重主要依赖于两个关键方法：<code>hashCode()</code> 和 <code>equals()</code>。</p><ol><li><strong>hashCode() 方法</strong>：<ul><li>当你尝试将一个对象添加到 HashSet 中时，HashSet 会首先调用这个对象的 <code>hashCode()</code> 方法来计算该对象的哈希值。</li><li>这个哈希值决定了对象在内部哈希表中的存储位置（即所谓的“桶”）。</li></ul></li><li><strong>equals() 方法</strong>：<ul><li>如果两个对象有相同的哈希值（或者它们被分配到了同一个桶中），HashSet 将使用 <code>equals()</code> 方法来进一步检查这两个对象是否真正相等。</li><li>如果 <code>equals()</code> 返回 <code>true</code>，则认为这两个对象是重复的，新对象不会被添加到集合中。如果 <code>equals()</code> 返回 <code>false</code>，即使哈希值相同，这两个对象也被认为是不同的，并且都会被添加到集合中。</li></ul></li></ol><p>对于自定义类的对象，如果你希望它们能够正确地在 HashSet 中进行去重，你需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，以确保具有相同业务含义的对象返回相同的哈希码并且 <code>equals()</code> 方法也返回 <code>true</code>。</p><p>TreeSet底层基于红黑树,可排序,不重复,无索引</p><p><img data-src="https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png" alt="image-20250318231528714"></p><p><img data-src="https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png" alt="image-20250318234747847"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><img data-src="https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png" alt="image-20250319103421264"></p><p><img data-src="https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png" alt="image-20250319104523905"></p><p>Map的遍历方式</p><p><img data-src="https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png" alt="image-20250319110144222"></p><p><strong>使用 for-each 循环和 entrySet()</strong></p><p>这是最常用的遍历方式之一，因为它提供了对键和值的访问。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.<span class="keyword">Entry</span>&lt;String, Integer&gt; <span class="keyword">entry</span> : <span class="type">map.entrySet</span>()) &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">entry</span>.getKey() + <span class="string">&quot;: &quot;</span> + <span class="keyword">entry</span>.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器</strong></p><p>使用迭代器可以更灵活地控制遍历过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Java 8 的 Stream API</strong></p><p>通过 <code>stream()</code> 方法可以利用 Stream API 来遍历或进行其他操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach(entry -&gt; </span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者对于某些特定的操作，比如过滤、映射等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream()</span><br><span class="line">   .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">   .forEach(entry -&gt; System.out.println(entry.getKey()));</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png" alt="image-20250319114156720"></p><p>Stream流包括中间方法和最终方法,中间方法使用filter,map,调用完成后会返回新的流</p><p><img data-src="https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png" alt="image-20250319120025921"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">alist.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">alist.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = alist.stream().map((String a) -&gt; a + <span class="string">&quot;a&quot;</span>).toList();</span><br><span class="line">List&lt;Double&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.stream().filter(s-&gt; !s.isEmpty()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">list.stream().sorted(Comparator.comparingDouble(String::length).reversed()).forEach(System.out::println);</span><br><span class="line">blist.stream().sorted(Double::compare).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重 limit只需要一个参数 skip跳过前几个</span></span><br><span class="line">blist.stream().distinct().skip(<span class="number">1</span>).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成map</span></span><br><span class="line">list.stream().collect(Collectors.toMap(Function.identity(), String::length)).forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v));</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; a = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 合并两个流</span></span><br><span class="line">Stream.concat(a, integerStream).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>java集合类-&gt;实现的数据结构</p><p>Collections List Set HashSet LinkedHashSet TreeSet</p><p>Map</p><p>HashMap LinkedHashMap TreeMap</p><p><strong><code>HashMap</code></strong></p><ul><li><strong>底层实现：</strong> JDK 8 之前是<strong>数组 + 链表</strong>；JDK 8 及之后是<strong>数组 + 链表/红黑树</strong>。当链表长度超过阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率（从 O(N) 优化到 O(log N)）。</li><li><strong>特点：</strong><ul><li><strong>非线程安全：</strong> 在多线程环境下，如果不进行同步处理，可能出现数据不一致或死循环（早期版本）等问题。</li><li><strong>允许键和值为 <code>null</code>：</strong> 最多允许一个键为 <code>null</code>，允许多个值为 <code>null</code>。</li><li><strong>无序性：</strong> 不保证元素的迭代顺序。</li><li><strong>性能：</strong> 增删查的平均时间复杂度为 O(1)。</li></ul></li><li><strong>适用场景：</strong> 单线程环境或需要高性能的非线程安全哈希表场景。</li></ul><p>Hashtable(线程安全)</p><p><strong><code>Hashtable</code></strong></p><ul><li><strong>底层实现：</strong> 也是基于<strong>数组 + 链表</strong>。</li><li><strong>特点：</strong><ul><li><strong>线程安全：</strong> 所有公共方法都使用了 <code>synchronized</code> 关键字进行同步，因此是线程安全的。</li><li><strong>不允许键和值为 <code>null</code>：</strong> 如果尝试插入 <code>null</code> 键或 <code>null</code> 值，会抛出 <code>NullPointerException</code>。</li><li><strong>性能：</strong> 由于同步开销，性能比 <code>HashMap</code> 低。</li></ul></li></ul><p>ArrayList与LinkedList区别</p><p>动态数组 连续内存 查询O(1) 增删需要移动元素O(N)</p><p>双向链表 查询O(N) 首位增删O(1)</p><p>HashMap原理,如何扩容</p><p>数组+链表/红黑树 插入元素时进行哈希,使用链地址法解决哈希冲突</p><p>当 <code>HashMap</code> 中的元素数量 <code>size</code> 达到 <code>capacity * loadFactor</code> 时，<code>HashMap</code> 就会进行扩容操作。这个过程在 <code>resize()</code> 方法中实现。</p><h4 id="扩容流程："><a href="#扩容流程：" class="headerlink" title="扩容流程："></a>扩容流程：</h4><ol><li><strong>创建新数组：</strong><ul><li><code>HashMap</code> 会创建一个新的 <code>Node</code> 数组，其容量是原数组的两倍。例如，如果原容量是 16，新容量就是 32。</li></ul></li><li><strong>数据迁移（Rehash）：</strong><ul><li>这是扩容中最耗时的一步。<code>HashMap</code> 会遍历原数组中的每一个桶。</li><li>对于每个桶中的链表或红黑树，会将其中的所有 <code>Node</code> 元素<strong>重新计算哈希值和在新数组中的索引位置</strong>，然后移动到新数组中对应的桶里。</li></ul></li></ol><p>为什么是两倍扩容？为什么是 2 的幂次方？</p><ul><li><strong>两倍扩容：</strong> 使得 <code>capacity</code> 始终保持为 2 的幂次方，这对于通过位运算 <code>hash &amp; (capacity - 1)</code> 来快速计算索引至关重要。如果 <code>capacity</code> 不是 2 的幂次方，那么 <code>hash % capacity</code> 的性能会降低，并且哈希值分布可能不均匀，增加冲突。</li><li><strong>计算索引的优化：</strong> 当容量从 <code>N</code> 扩容到 <code>2N</code> 时，一个键在旧数组中的索引是 <code>hash &amp; (N - 1)</code>。在新数组中，它的索引是 <code>hash &amp; (2N - 1)</code>。<ul><li>对于每个 <code>Node</code>，它的新的索引位置要么和旧索引相同，要么是旧索引 <code>+ N</code>。</li><li>这个判断依据是 <code>(hash &amp; N)</code> 是否为 <code>0</code>。如果为 <code>0</code>，则新索引不变；如果不为 <code>0</code>，则新索引是旧索引 <code>+ N</code>。</li><li>这种设计避免了对每个元素重新进行复杂的取模运算，<strong>显著提高了数据迁移的效率</strong>。</li></ul></li></ul><p>在 JDK 8 中，<code>resize</code> 过程也进行了优化，它不再需要重新计算每个元素的哈希值，而是利用了容量是 2 的幂次方的特性。</p><p>当容量从 <code>N</code> 变为 <code>2N</code> 时，对于一个节点 <code>e</code>，它的新索引只会有两种情况：<code>e.hash &amp; (N-1)</code> (即原位置) 或者 <code>e.hash &amp; (N-1) + N</code> (即原位置 + N)。 这个判断可以简化为查看 <code>e.hash</code> 的第 <code>N</code> 位（即 <code>(hash &amp; N)</code>）是 <code>0</code> 还是 <code>1</code>。</p><ul><li>如果 <code>(hash &amp; N) == 0</code>，则节点仍在原索引位置。</li><li>如果 <code>(hash &amp; N) != 0</code>，则节点会移动到 <code>原索引 + N</code> 的位置。</li></ul><p>这样，在扩容时，每个桶的链表（或红黑树）可以被<strong>分成两条链表（或红黑树）</strong>，一条留在原位置，另一条移动到新位置（原位置 + N），从而大大提高了数据迁移的效率，避免了逐个重新哈希。</p><p>红黑树 -&gt;B,B+树区别</p><p>红黑树是一种<strong>自平衡的二叉查找树（Binary Search Tree, BST）</strong>。它通过给节点着色（红色或黑色）并遵循一系列规则来保证树的平衡，<strong>确保任何路径从根节点到叶子节点的最长路径不会超过最短路径的两倍</strong>，<strong>从而使所有操作的时间复杂度保持在 O(logN)。</strong></p><p><strong>平衡通过颜色和旋转：</strong> 通过节点的颜色（红/黑）属性和插入/删除时的<strong>旋转（Rotations）</strong>和<strong>重新着色（Recoloring）</strong>操作来维持近似平衡。</p><p><strong>所有数据都在节点中：</strong> 每个节点都存储着实际的键值对。</p><p><strong>高度：</strong> 树的高度相对较小，但比 AVL 树（另一种平衡二叉树）可能略高，但其插入和删除的平均性能更好。</p><h3 id="B-树-B-Tree"><a href="#B-树-B-Tree" class="headerlink" title="B 树 (B-Tree)"></a>B 树 (B-Tree)</h3><ul><li><strong>基本概念：</strong> B 树是一种<strong>多路平衡查找树</strong>。与二叉树不同，B 树的每个节点可以有<strong>多个子节点</strong>（通常多于两个）。它的设计核心是为了<strong>优化磁盘 I/O 操作</strong>，因为磁盘读写是块（block）为单位的，B 树通过增加节点的分支数（阶数）来降低树的高度，从而减少磁盘访问次数。</li><li><strong>核心特性：</strong><ol><li><strong>多路（M 阶树）：</strong> 每个节点可以有 <code>M</code> 个子节点（<code>M &gt; 2</code>），并包含 <code>M-1</code> 个键。</li><li><strong>节点内有序：</strong> 每个节点中的键值是排序的。</li><li><strong>节点内存储数据：</strong> <strong>非叶子节点和叶子节点都可以存储实际的键值数据</strong>（或指向数据的指针）。</li><li><strong>所有叶子节点在同一层：</strong> 这保证了从根到任何叶子节点的查找路径长度相同，因此查找效率稳定。</li><li><strong>为磁盘优化：</strong> 节点的大小通常被设计为与磁盘块大小相匹配，一次磁盘 I/O 可以读取更多的键。</li></ol></li><li><strong>典型应用场景：</strong><ul><li><strong>文件系统和数据库索引：</strong> B 树被广泛应用于文件系统（如 NTFS, HFS+）和某些数据库系统（如 MongoDB）的索引结构。</li><li><strong>数据量大，无法完全加载到内存：</strong> 当数据存储在磁盘等外部存储介质上，且需要最小化磁盘 I/O 次数时，B 树是理想选择。</li></ul></li></ul><hr><h3 id="3-B-树-B-Tree"><a href="#3-B-树-B-Tree" class="headerlink" title="3. B+ 树 (B+ Tree)"></a>3. B+ 树 (B+ Tree)</h3><ul><li><p><strong>基本概念：</strong> B+ 树是 B 树的一种<strong>变体</strong>，它对 B 树进行了进一步的优化，使其更适合于<strong>数据库索引</strong>和文件系统。B+ 树的核心特点是<strong>所有的数据都存储在叶子节点，并且叶子节点之间通过链表连接</strong>。</p></li><li><p><strong>核心特性：</strong></p><ol><li><strong>多路（M 阶树）：</strong> 与 B 树类似，每个节点可以有 <code>M</code> 个子节点。</li><li><strong>非叶子节点只存储键（索引）：</strong> 非叶子节点（内部节点）只存储键（或索引），不存储实际的键值数据。这使得每个非叶子节点可以存储更多的键，从而降低树的高度，进一步减少磁盘 I/O。</li><li><strong>所有数据都在叶子节点：</strong> 所有的实际键值数据（或指向数据的指针）都存储在<strong>叶子节点</strong>中。</li><li><strong>叶子节点通过链表连接：</strong> 所有叶子节点构成一个<strong>有序的链表</strong>。</li><li><strong>所有键都在叶子节点出现：</strong> 即使是存在于非叶子节点中的键，也会在叶子节点中再次出现。</li></ol></li><li><p><strong>典型应用场景：</strong></p><ul><li><strong>关系型数据库索引（如 MySQL 的 InnoDB 存储引擎）：</strong> 这是 B+ 树最主要的应用场景。</li><li><strong>需要高效的范围查询和全表扫描：</strong> 由于叶子节点通过链表连接且包含所有数据，范围查询变得非常高效，只需找到起始叶子节点，然后沿着链表遍历即可。全表扫描也只需遍历叶子节点链表。</li></ul><h3 id="红黑树、B-树、B-树的主要区别总结"><a href="#红黑树、B-树、B-树的主要区别总结" class="headerlink" title="红黑树、B 树、B+ 树的主要区别总结"></a>红黑树、B 树、B+ 树的主要区别总结</h3><p>| 特性           | 红黑树 (Red-Black Tree)                                      | B 树 (B-Tree)                                   | B+ 树 (B+ Tree)                                              |<br>| ——————— | —————————————————————————————— | ———————————————————————- | —————————————————————————————— |<br>| <strong>结构类型</strong>   | <strong>二叉查找树</strong> (每个节点最多 2 个子节点)                     | <strong>多路查找树</strong> (每个节点可以有 M 个子节点)      | <strong>多路查找树</strong> (B 树的变体，每个节点可以有 M 个子节点)       |<br>| <strong>平衡方式</strong>   | 节点着色 (红/黑) + 旋转 + 重新着色                           | 节点分裂/合并 (所有叶子节点在同一层)            | 节点分裂/合并 (所有叶子节点在同一层)                         |<br>| <strong>数据存储</strong>   | <strong>所有节点</strong>都存储键值对                                     | <strong>非叶子节点和叶子节点</strong>都可能存储键值数据      | <strong>只有叶子节点</strong>存储键值数据，非叶子节点只存储键（索引）     |<br>| <strong>查询路径</strong>   | 从根到目标节点的路径长度可能不同 (近似平衡)                  | 从根到任何键的路径长度相同 (所有叶子在同一层)   | <strong>所有查找必须达到叶子节点</strong>，路径长度相同，查询效率稳定     |<br>| <strong>范围查询</strong>   | 效率相对较低，需要中序遍历                                   | 效率一般，需要进行多节点的中序遍历              | <strong>效率高</strong>，所有叶子节点通过链表连接，可顺序遍历             |<br>| <strong>磁盘 I/O</strong>   | 针对内存设计，<strong>不考虑磁盘 I/O 优化</strong>，树高较高，可能导致多次 I/O | 为磁盘优化，降低树高，减少 I/O 次数             | <strong>进一步优化磁盘 I/O</strong>，非叶子节点只存索引，可装更多键，树更矮胖，且范围查询更高效 |<br>| <strong>典型应用</strong>   | 内存中的集合 (<code>TreeMap</code>, <code>std::map</code>)                         | 文件系统 (部分)、一些 NoSQL 数据库 (如 MongoDB) | <strong>关系型数据库索引</strong> (如 MySQL 的 InnoDB), 文件系统          |<br>| <strong>父节点冗余</strong> | 无                                                           | 有 (键可能出现在父节点和其子节点中)             | <strong>有</strong> (非叶子节点的键也会出现在其子节点中，最终在叶子节点中) |</p></li></ul><p>如果你主要处理<strong>内存中的数据</strong>，且需要高效的<strong>单点查找、插入和删除</strong>（且对范围查询不那么敏感），<strong>红黑树</strong>通常是更好的选择，因为它实现相对简单，且在内存中性能优异。</p><p>如果你处理<strong>大量数据，需要存储在磁盘上</strong>，并且要<strong>最小化磁盘 I/O 次数</strong>，<strong>B 树</strong>是一个好的选择。</p><p>如果你处理的是<strong>数据库索引</strong>或需要<strong>频繁进行范围查询</strong>的场景，<strong>B+ 树</strong>无疑是最佳选择，因为它通过将所有数据集中在叶子节点并用链表连接，极大地优化了范围查找和全表扫描的性能。</p><p>concurrentHashMap实现  JDK7 分段锁 JDK8+ CAS+synchronized+Node</p><p>JDK 8 对 <code>ConcurrentHashMap</code> 进行了<strong>彻底的重构</strong>，放弃了分段锁的设计，转而采用 <strong>CAS（Compare-And-Swap）+ <code>synchronized</code> + 红黑树</strong> 的混合策略。</p><p>核心思想：</p><p><strong>取消 Segment 概念：</strong> JDK 8 中不再有 <code>Segment</code> 类。取而代之的是一个由 <code>Node</code> 数组组成的哈希表。</p><ol><li><strong>锁的粒度：</strong><ul><li><strong>读操作：</strong> 大部分读操作仍然是无锁的，通过 <code>volatile</code> 和 <code>final</code> 关键字保证可见性。</li><li><strong>写操作：</strong> 写操作（put、remove）只锁定发生冲突的哈希桶的<strong>头节点（Node）</strong>。当多个线程操作不同的哈希桶时，它们之间不会互相阻塞，实现了更高的并发度。</li><li><strong><code>synchronized</code> 代替 <code>ReentrantLock</code>：</strong> JDK 8 使用 <code>synchronized</code> 关键字替代了 <code>ReentrantLock</code>。这是因为 JDK 8 对 <code>synchronized</code> 关键字进行了大量优化，使其性能已经非常接近甚至超越了 <code>ReentrantLock</code>，并且代码实现更为简洁。</li></ul></li><li><strong>链表转红黑树：</strong> 与 <code>HashMap</code> 类似，当链表长度超过阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率（从 O(N) 优化到 O(log N)）。这在哈希冲突严重时能有效避免性能下降。</li><li><strong>CAS 操作：</strong> 在进行一些非阻塞操作（如扩容时的迁移、<code>size</code> 统计）时，会利用 CAS 操作来保证原子性。例如，在修改 <code>size</code> 变量时，会使用 <code>CAS</code> 操作。</li></ol><p><code>ConcurrentHashMap</code> 在 JDK 7 中的实现 (分段锁 Segment)</p><p>在 JDK 7 中，<code>ConcurrentHashMap</code> 主要通过<strong>分段锁（Segment）</strong>的机制来实现高并发。</p><p>核心思想：</p><ol><li><strong>分段（Segmentation）：</strong> 整个 <code>ConcurrentHashMap</code> 被分成若干个独立的段（Segment），每个段都是一个独立的 <code>ReentrantLock</code>。默认情况下，通常有 16 个或更多个段，这意味着理论上可以支持 16 个或更多个并发的写入操作。</li><li><strong>写操作的并发：</strong> 当一个线程需要写入（put、remove）数据时，它只需要锁定数据所在的那个 Segment，而其他线程仍然可以并发地访问（读写）其他 Segment。这大大减少了锁的粒度。</li><li><strong>读操作的并发：</strong> 大多数读操作（get）是无锁的。它通过 <code>volatile</code> 关键字来保证数据的可见性，允许多个线程同时读取。在某些情况下（如 Segment 的 <code>modCount</code> 发生变化），可能需要进行二次检查以确保数据一致性。</li><li><strong>结构：</strong><ul><li>内部有一个 <code>Segment</code> 数组，<code>Segment</code> 继承自 <code>ReentrantLock</code>。</li><li>每个 <code>Segment</code> 内部包含一个 <code>HashEntry</code> 数组（类似于 <code>HashMap</code> 的底层数组）和链表结构。</li><li>哈希函数会先确定键属于哪个 Segment，然后再在该 Segment 内部计算哈希值，定位到具体的 <code>HashEntry</code> 数组索引。</li></ul></li></ol><p>多线程安全环境下使用集合,线程安全的集合.</p><p><strong>面试题：</strong> 如何在多线程环境下使用集合？请列举并解释几种线程安全的集合类。</p><ul><li><strong><code>Vector</code> 和 <code>Hashtable</code>：</strong><ul><li><strong>原理：</strong> 通过在每个方法上加 <code>synchronized</code> 关键字实现粗粒度同步（锁住整个对象）。</li><li><strong>缺点：</strong> 性能低下，因为同一时间只有一个线程能访问集合的任何方法，并发度很低。</li></ul></li><li><strong><code>Collections.synchronizedList/Set/Map()</code>：</strong><ul><li><strong>原理：</strong> 这是一系列工厂方法，它返回一个由底层非线程安全集合（如 <code>ArrayList</code>, <code>HashMap</code>）包装而成的线程安全版本。同样是通过 <code>synchronized</code> 关键字对所有方法进行同步。</li><li><strong>缺点：</strong> 与 <code>Vector</code>/<code>Hashtable</code> 类似，也是粗粒度同步，性能瓶颈明显。</li></ul></li><li><strong><code>ConcurrentHashMap</code>：</strong> (推荐用于并发Map)<ul><li><strong>原理：</strong> 采用<strong>分段锁（Segment）</strong>（JDK 7）或 <strong>CAS + Synchronized + Node</strong>（JDK 8）实现更细粒度的并发控制。在 JDK 8 中，取消了 Segment，直接使用 <code>synchronized</code> 锁住哈希桶的头节点，结合 CAS 操作，实现了更高的并发度。</li><li><strong>特点：</strong> 读操作通常不需要加锁，写操作只锁住受影响的部分，大大提高了并发性能。</li><li><strong>适用场景：</strong> 高并发场景下对 Map 的读写操作。</li></ul></li><li><strong><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>：</strong> (推荐用于并发List/Set，写少读多)<ul><li><strong>原理：</strong> 写时复制（Copy-On-Write）。当对集合进行写操作（添加、修改、删除）时，会先复制一份底层数组，在新数组上完成修改，然后将新数组的引用指向集合。读操作则不需要加锁，直接读取旧数组。</li><li><strong>特点：</strong><ul><li><strong>读写分离：</strong> 读操作完全是无锁的，性能极高。</li><li><strong>写操作开销大：</strong> 每次写操作都会复制整个数组，对于数据量大且写操作频繁的场景，性能会很差。</li><li><strong>数据一致性：</strong> 读到的可能是旧版本的数据（写操作过程中），是<strong>最终一致性</strong>。</li></ul></li><li><strong>适用场景：</strong> 读操作远远多于写操作的并发场景，例如黑名单、白名单、事件监听器列表等。</li></ul></li></ul><h4 id="异常、泛型与集合框架"><a href="#异常、泛型与集合框架" class="headerlink" title="异常、泛型与集合框架"></a>异常、泛型与集合框架</h4><p>Java中异常的类继承体系</p><p><img data-src="https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png" alt="image-20250311153912955"></p><p>运行时异常(extends RuntimeException:数组索引越界</p><p>编译异常(extends Exception). 编译时异常需要通过try-catch或throw丢出异常进行处理,</p><p>运行时异常不需要特别处理</p><p>此外异常可以分为业务类和运行逻辑类,一些代码中的异常应该被catch然后向上抛给业务类或者直接处理. </p><p><img data-src="https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png" alt="image-20250311175150716"></p><p>泛型允许编写可以<strong>处理不同类型数据的类、接口和方法，而无需在代码中明确指定具体类型</strong>。泛型提供了更强的类型检查，并且消除了对类型转换的需求，从而使得代码更加安全和易于维护。</p><p><strong>类型参数</strong>：在定义泛型类或方法时使用占位符（通常为大写字母如 <code>T</code>, <code>E</code>, <code>K</code>, <code>V</code> 等），代表实际应用中的类型。</p><ul><li><strong>类型安全</strong>：编译器会在编译期进行类型检查，减少运行时出现的 <code>ClassCastException</code> 错误。</li><li><strong>消除类型转换</strong>：由于类型信息在编译时已知，因此不需要显式的类型转换。</li></ul><h4 id="使用泛型类"><a href="#使用泛型类" class="headerlink" title="使用泛型类"></a>使用泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">integerBox.set(<span class="number">10</span>);</span><br><span class="line">Integer intValue = integerBox.get();</span><br><span class="line"></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">String strValue = stringBox.get();</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>你也可以定义泛型方法，即在方法级别上使用泛型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    String[] stringArray = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    printArray(intArray);</span><br><span class="line">    printArray(stringArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>&lt;T&gt;</code> 在方法签名前声明了类型参数，这样这个方法就可以接受任意类型的数组作为参数。</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>类似地，也可以定义泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringContainer</span> <span class="keyword">implements</span> <span class="title">Container</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 泛型是在 Java 5 中引入的，而在此之前已经存在了大量的 Java 代码库。如果直接在 JVM 层面实现泛型支持，那么这些现有的代码可能会因为缺乏泛型信息而不兼容。通过类型擦除，Java 编译器能够在编译时移除泛型类型信息，并将泛型代码转换为非泛型代码，这样就可以确保新旧代码可以无缝地一起工作</p></blockquote><p><strong>通配符</strong></p><p>有时可能需要编写能够与多种类型工作的代码，但并不需要知道这些类型的具体细节。这时可以使用通配符 <code>?</code>：</p><ul><li><strong>无界通配符</strong>：<code>&lt;?&gt;</code> 表示可以是任何类型。</li><li><strong>有界通配符</strong>：<code>&lt;? extends T&gt;</code> 和 <code>&lt;? super T&gt;</code> 分别表示类型必须是 <code>T</code> 或其子类，以及 <code>T</code> 或其父类。</li></ul><p><strong>泛型的优点</strong></p><ol><li><strong>类型安全</strong>：编译器可以在编译时进行更多的类型检查，减少运行时错误。</li><li><strong>消除强制类型转换</strong>：不再需要手动将对象转换回原始类型。</li><li><strong>提高代码重用性</strong>：通过泛型，相同的逻辑可以应用于不同的数据类型。</li></ol><p>Java集合是一种容器,类似于数组但集合的大小可变.</p><p><img data-src="https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png" alt="image-20250314192425271"></p><p><img data-src="https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png" alt="image-20250314230501695"></p><h3 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h3><p><img data-src="https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png" alt="image-20250319170141141"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sekyoro.tutorThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: workspace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: com.sekyoro.tutorThread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: threadDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/19 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">easyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a mini thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">miniCallable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">miniCallable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Thread et = <span class="keyword">new</span> easyThread();</span><br><span class="line">        et.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> miniThread()).start();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; mc = <span class="keyword">new</span> miniCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        Integer i = ft.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png" alt="image-20250319171222472"></p><p>线程同步解决线程安全问题</p><p><strong>同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png" alt="image-20250319173439131"></p><p><strong>同步方法</strong></p><p><img data-src="https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png" alt="image-20250319173832373"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">          money -= m;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Lock锁</strong></p><p><img data-src="https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png" alt="image-20250319174259793"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>显式锁（Explicit Lock）</p><ul><li><p>ReentrantLock 类提供了比synchronized更灵活的锁操作，例如可中断的锁等待、尝试非阻塞获取锁、超时获取锁等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 受保护的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>读写锁（ReadWriteLock）</li></ol><p>ReadWriteLock 接口 和 ReentrantReadWriteLock 实现类.允许多个读操作同时进行，但在写操作时排斥所有其他读写操作。适用于读多写少的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">rwl.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rwl.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>条件变量（Condition）</li></ol><p>Condition 接口与显式锁配合使用，提供类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    condition.await(); <span class="comment">// 相当于 wait()</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    condition.signal(); <span class="comment">// 相当于 notify()</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>StampedLock</li></ol><p>StampedLock 类是Java 8引入的一种新的锁类型，支持乐观读锁策略，适用于读多写少且大部分读操作不会发生冲突的情况。它提供了三种模式：写锁、悲观读锁和乐观读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> stamp = stampedLock.readLock(); <span class="comment">// 悲观读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stamp = stampedLock.writeLock(); <span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> optimisticStamp = stampedLock.tryOptimisticRead(); <span class="comment">// 乐观读锁</span></span><br><span class="line"><span class="comment">// 验证并使用乐观读锁...</span></span><br><span class="line"><span class="keyword">if</span> (!stampedLock.validate(optimisticStamp)) &#123;</span><br><span class="line">    <span class="comment">// 如果验证失败，则需要重新获取悲观读锁或写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池</strong></p><ol><li>ThreadPoolExecutor创建线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程池</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用线程池处理任务</span></span><br><span class="line">Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="number">3</span>);</span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png" alt="image-20250319205156594"></p><p><img data-src="https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png" alt="image-20250319205627740"></p><ol><li>利用Executors创建线程池</li></ol><p><img data-src="https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png" alt="image-20250319210516204"></p><p>利用ThreadPoolExecutor设置不同参数调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反射、注解与动态代理"><a href="#反射、注解与动态代理" class="headerlink" title="反射、注解与动态代理"></a>反射、注解与动态代理</h3><p>反射是指在运行时动态地获取类的信息以及操作对象的能力。通常情况下，Java 编译器会在编译期确定所有类型和成员变量的访问权限及调用方式，而反射则允许你在运行时进行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 直接通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 使用对象的 getClass() 方法</span></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">clazz = obj.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三: 通过全限定类名字符串</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的class类可以用来<strong>创建实例</strong>、<strong>访问字段</strong>、<strong>调用方法</strong>等</p><p>创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 假设 MyClass 有一个无参构造函数</span></span><br><span class="line">    Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定参数类型的构造函数</span></span><br><span class="line">    Constructor&lt;MyClass&gt; constructor = clazz.getConstructor(paramType.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    MyClass instance = constructor.newInstance(args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解（Annotations）</strong>是一种元数据形式，它提供了关于程序代码的额外信息，但这些信息并不直接改变程序的运行逻辑。注解自 Java 5 引入以来，已经成为 Java 开发中不可或缺的一部分，用于简化开发流程、提供配置信息、增强代码的功能等</p><ul><li><strong>定义</strong>：注解是接口的一种特殊形式，它通过 <code>@interface</code> 关键字来定义，并可以附加到类、方法、变量、参数、包声明等语言元素上。</li><li><strong>用途</strong>：主要用于编译时检查、运行时处理和生成源代码或文档。</li></ul><ol><li><strong>标记注解</strong>：没有成员变量，仅作为标记使用，如 <code>@Override</code>。</li><li><strong>单值注解</strong>：只有一个值，通常省略名称直接指定值，如 <code>@SuppressWarnings(&quot;unchecked&quot;)</code>。</li><li><strong>完整注解</strong>：包含多个成员变量，需要明确指定每个成员的值。</li></ol><p>元注解是指用来注解其他注解的注解，主要包括以下几个：</p><ul><li><code>@Retention</code>：定义了注解的存在阶段（SOURCE, CLASS, RUNTIME）。</li><li><code>@Target</code>：指定了注解可以应用的目标元素类型（TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE 等）。</li><li><code>@Documented</code>：表明这个注解应该被 javadoc 工具记录。</li><li><code>@Inherited</code>：允许子类继承父类中的注解。</li><li><code>@Repeatable</code>：从 Java 8 开始支持，表示相同的注解可以在同一地方多次使用。</li></ul><p><strong>注解的解析</strong></p><p>检查方法和类等是否包含对应注解,若包含则进行相关调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">annotationDemo annotationDemo = <span class="keyword">new</span> annotationDemo();</span><br><span class="line"> Class&lt;?&gt; aClass = annotationDemo.class;</span><br><span class="line"> Method[] methods = aClass.getMethods();</span><br><span class="line"> <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">     <span class="keyword">if</span> (method.isAnnotationPresent( MyTest.class)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             MyTest declaredAnnotation = method.getDeclaredAnnotation(MyTest.class);</span><br><span class="line">             method.invoke(annotationDemo);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>Proxy.newProxyInstance创建代理,参数包括类加载器,需要实现的接口,和代理需要做的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StarService <span class="title">createProxy</span><span class="params">(StarService starService)</span></span>&#123;</span><br><span class="line">        StarService o = (StarService)Proxy.newProxyInstance(ProxyUtils.class.getClassLoader(), starService.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">               String methodName = method.getName();</span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;sing&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;sing a song: &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;dance a dance&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">if</span>(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>  method.invoke(starService,args);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>类加载过程主要包括三个阶段：<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>。</p><ul><li><strong>加载</strong>：通过类的全限定名获取定义此类的二进制字节流，并将其转换为方法区中的运行时数据结构，在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象。</li><li><strong>链接</strong>：包括验证、准备和解析三个步骤。验证确保被加载类的正确性；准备则为类变量分配内存并设置默认初始值；解析是将类、接口、字段和方法的符号引用转为直接引用的过程。</li><li><strong>初始化</strong>：执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程，对静态变量和静态代码块进行初始化。</li></ul><p>Java 类加载器使用双亲委派模型来搜索类或资源。<strong>当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成</strong>，每一层的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器。<strong>只有当父类加载器无法加载该类时，子类加载器才会尝试自己加载</strong></p><p>Java 提供了三种内置的类加载器：</p><ul><li><strong>Bootstrap ClassLoader</strong>：这是最顶层的类加载器，由本地代码实现，通<strong>常用于加载核心 JDK 类库</strong>（如 <code>rt.jar</code>）。 无法直接访问,显示为null</li><li><strong>Extension ClassLoader</strong>：扩展类加载器，<strong>用来加载位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 JAR 包</strong>。 (目前使用PlatformClassLoader,加载 JDK 提供的平台模块中的类，例如 <code>java.sql</code>, <code>java.xml</code>, <code>javax.*</code> 等模块化的平台类。)</li><li><strong>Application ClassLoader</strong>：应用程序类加载器，<strong>负责加载用户类路径（ClassPath）上指定的类库</strong></li></ul><p>Java 提供了一些常用的方法来操作类加载器：</p><p><strong>(1) <code>loadClass(String name)</code></strong></p><p>加载指定名称的类或接口。如果已经加载过，则直接返回对应的 <code>Class</code> 对象；如果没有，则按照双亲委派机制尝试加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) <code>findClass(String name)</code></strong></p><p>查找指定名称的类。默认实现会抛出 <code>ClassNotFoundException</code> 异常，通常需要自定义类加载器覆盖此方法以提供具体的类查找逻辑。</p><p><strong>(3) <code>defineClass(byte[] b, int off, int len)</code></strong></p><p>将一个字节数组转换成一个类的 <code>Class</code> 对象。一般不直接调用，主要用于自定义类加载器。</p><p><strong>(4) <code>getResource(String name)</code> 和 <code>getResourceAsStream(String name)</code></strong></p><p>用于查找资源文件。前者返回资源的 URL，后者返回资源的输入流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL resourceUrl = getClass().getClassLoader().getResource(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>(5) <code>getParent()</code></strong></p><p>返回该类加载器的父类加载器。注意，Bootstrap ClassLoader 没有父类加载器，所以对于 Bootstrap ClassLoader 调用 <code>getParent()</code> 将返回 <code>null</code>。</p><p><strong>4. 自定义类加载器</strong></p><p>有时我们需要根据特定的需求来自定义类加载器。可以通过继承 <code>java.lang.ClassLoader</code> 并重写 <code>findClass</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name); <span class="comment">// 实现类数据加载逻辑</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="comment">// 加载类数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实现自定义类加载器的基本步骤：</p><ol><li><p>继承 <code>ClassLoader</code></p><ul><li>创建一个类并继承 <code>ClassLoader</code>。</li></ul></li><li><p>重写 <code>findClass()</code> 方法(遵从双亲委派机制)</p><ul><li>实现自定义的类加载逻辑。</li></ul></li><li><p>调用 <code>defineClass()</code> 方法</p><ul><li>将字节码转换为 <code>Class</code> 对象。</li></ul><p>class对象相同需要classloader相同,相同的classloader进行loadclass相同的类得到的class相同</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类的根路径</span></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取类的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Class not found: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptedClassData = decrypt(classData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义类</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, decryptedClassData, <span class="number">0</span>, decryptedClassData.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类的字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String path = classPath + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">             ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            <span class="keyword">int</span> buffer;</span><br><span class="line">            <span class="keyword">while</span> ((buffer = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟解密过程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        <span class="comment">// 简单的异或解密</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = (<span class="keyword">byte</span>) (data[i] ^ <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义类加载器</span></span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">&quot;path/to/classes/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义类加载器加载类</span></span><br><span class="line">        Class&lt;?&gt; clazz = customClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Loaded class: &quot;</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建实例并调用方法</span></span><br><span class="line">        Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>).invoke(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h4><p>线程上下文类加载器（Thread Context ClassLoader）是 Java 提供的一种机制，允许开发者在线程中设置和获取类加载器。这种机制主要用于解决某些特定场景下类加载的问题，尤其是在复杂的类层次结构或模块化系统中。</p><p><strong>线程上下文类加载器的作用</strong></p><ol><li><strong>解决类加载器隔离问题</strong>：<ul><li>在 Java 应用程序中，不同的类加载器可能会形成类加载器树，这导致了类加载器之间的隔离性。</li><li>例如，在 Web 容器或 OSGi 等环境中，不同应用或模块可能使用不同的类加载器来加载各自的类。在这种情况下，如果一个类需要加载另一个类加载器负责加载的类，则会遇到问题。</li><li>线程上下文类加载器提供了一种绕过双亲委派模型的方式，允许当前线程使用指定的类加载器来加载类。</li></ul></li><li><strong>支持框架和库的开发</strong>：<ul><li>许多框架和库（如 JNDI、JDBC 驱动等）依赖于线程上下文类加载器来加载必要的类。</li><li>这些框架通常不知道具体的类加载器，因此它们可以利用线程上下文类加载器来动态地加载所需的类。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadContextClassLoaderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取默认的上下文类加载器</span></span><br><span class="line">            ClassLoader defaultClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(<span class="string">&quot;默认的上下文类加载器: &quot;</span> + defaultClassLoader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个新的类加载器（例如自定义类加载器）</span></span><br><span class="line">            ClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置新的上下文类加载器</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(customClassLoader);</span><br><span class="line">            System.out.println(<span class="string">&quot;设置后的上下文类加载器: &quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用上下文类加载器加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载的类: &quot;</span> + clazz.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 实现类的查找逻辑</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="comment">// 模拟从文件或其他来源读取类数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img data-src="https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png" alt="image-20250320221417773"></p><p>程序计数器: 线程私有</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>判断对象可以回收</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>工作原理</p><ol><li><strong>初始化</strong>：每当创建一个新的对象时，该对象的引用计数器被初始化为1。</li><li><strong>增加引用</strong>：每当有新的引用指向这个对象时（例如，将对象赋值给另一个变量），该对象的引用计数加1。</li><li><strong>减少引用</strong>：每当某个引用不再指向该对象时（例如，变量超出作用域或重新赋值），该对象的引用计数减1。</li><li><strong>回收内存</strong>：当一个对象的引用计数降为0时，表示没有其他引用指向该对象，这时就可以立即回收该对象所占用的内存。</li></ol><p>缺点:</p><p><strong>无法处理循环引用</strong>：如果两个或多个对象相互引用形成环状结构，则即使这些对象实际上已经不可达，它们的引用计数也不会变为0，导致内存泄漏。为了克服这个问题，一些语言引入了弱引用（weak references）或专门的循环检测机制。</p><p><strong>多线程环境下的复杂性</strong>：在多线程环境下，对引用计数的修改需要同步操作，以防止竞态条件（race condition），这也增加了实现的复杂性和运行时的开销</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析的基本思想是<strong>从一组被称为“根节点”（root set）的对象开始，遍历所有可以通过这些根节点直接或间接引用到的对象，并将它们标记为存活</strong>。未被标记的对象则被认为是不可达的，可以被安全地回收。</p><blockquote><p>在命令行中输入 <code>jps</code> 可以列出所有由当前用户启动的 Java 进程的基本信息</p><p><code>-q</code>：仅输出 JVM 的进程 ID，不输出类名、jar 名等信息</p><p><code>-l</code>：输出主类的完整包名；如果进程执行的是 jar 文件，则输出 jar 文件的完整路径</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:[live,]format=b,file=&lt;filename&gt;.hprof &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li><code>live</code>：如果指定了这个选项，则只转储存活的对象；如果不指定，则转储所有对象。</li><li><code>format=b</code>：表示输出格式为二进制，默认就是二进制格式，所以通常省略不写。</li><li><code>&lt;filename&gt;.hprof</code>：指定生成的堆转储文件的名字。</li><li><code>&lt;pid&gt;</code>：目标Java进程的进程ID。</li></ul><p>引用</p><p><img data-src="https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png" alt="image-20250320220503285"></p><p>强引用 软引用 弱引用</p><p>软引用:垃圾回收时且内存不足时会被回收掉</p><p>虚引用  引用队列</p><p>终结器引用</p><ul><li><strong>强引用</strong>：日常编程中最常用的引用类型，几乎所有对象都是通过强引用创建的。</li><li><strong>软引用</strong>：适用于缓存场景，当内存不足时，允许GC回收缓存数据。</li><li><strong>弱引用</strong>：适合于需要自动清理的资源管理场景，例如监听器或回调函数列表中的对象。</li><li><strong>虚引用</strong>：主要用于了解对象何时被垃圾回收，常用于做一些清理工作，比如清除本地内存、关闭文件等</li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p><strong>标记-清除</strong></p><ul><li>这是最基本的垃圾回收算法，分为两个阶段：标记和清除。在标记阶段，GC从根集合（GC Roots）开始遍历所有可达对象，并标记它们为存活对象；在清除阶段，未被标记的对象即被视为垃圾对象并被回收</li><li>优点是实现简单，适用于任何对象的内存管理；<strong>缺点是会产生内存碎片</strong>，因为<strong>删除了不可达对象后留下的空闲内存可能是不连续的</strong>，这可能导致后续大对象分配失败。</li></ul><p><strong>复制（Copying）算法</strong>：</p><ul><li>复制算法将堆内存划分为两部分，每次只使用其中一部分。当这部分内存用完时，GC会暂停应用，将存活对象复制到另一部分内存中，并清空原内存区域</li><li>此算法避免了内存碎片问题，但代价是只能使用一半的内存空间，且对于存活率较高的对象效率较低。</li></ul><p>复制算法将可用内存分为两部分，通常称为From Space和To Space。</p><p>程序只使用其中一部分（From Space），当这部分内存满后，GC会遍历From Space中的所有对象，将存活的对象复制到To Space，并且更新这些对象的引用指向新的位置。</p><p>清理完From Space后，它变为可用空间，而To Space则成为下次分配新对象的空间</p><p>这个过程有效地避免了内存碎片化的问题，因为每次清理后的内存区域都是连续的</p><p><strong>标记-整理（Mark-Compact）算法</strong>：</p><ul><li>标记-整理算法结合了标记-清除和复制的优点，在标记阶段与标记-清除类似，但在清除阶段，它会将存活的对象移动到内存的一端，然后清理掉端边界以外的空间</li><li>它解决了内存碎片问题，但需要移动存活对象，增加了回收的开销。</li></ul><p>标记整理算法首先执行标记阶段，这与标记清除算法相同，即通<strong>过可达性分析找到所有存活的对象并进行标记</strong>。</p><p>接下来是整理阶段，在这个阶段，<strong>所有的存活对象会被移动到内存的一端，这样可以确保所有的空闲空间都在另一端</strong>，形成一个连续的块。</p><p>最后一步是<strong>对剩余的未被标记的部分进行清理，释放出连续的内存块</strong></p><p><strong>分代收集（Generational Collection）算法</strong>：</p><ul><li>分代收集是一种基于对象生命周期特征优化的策略，将堆内存划分为年轻代（Young Generation）和老年代（Old Generation）。年轻代通常采用复制算法，而老年代则采用标记-清除或标记-整理算法</li><li>这种方法利用了大多数对象“朝生夕死”的特点，提高了垃圾回收的效率。</li></ul><p><strong>1. 堆内存分区</strong></p><p>在分代垃圾回收中，堆内存通常被划分为三个主要区域：</p><ul><li><strong>年轻代（Young Generation）</strong>：<ul><li>主要用于存放新创建的对象。</li><li>进一步细分为一个 Eden 区和两个 Survivor 区（From 和 To）。</li></ul></li><li><strong>老年代（Old Generation）</strong>：<ul><li>存放的是经过多次垃圾回收后仍然存活的对象，这些对象被认为具有较长的生命期。</li></ul></li><li><strong>永久代/元空间（Permanent Generation/Metaspace）</strong>：<ul><li>在 Java 8 之前称为永久代，之后改为元空间，主要用于存储类的元数据、方法描述等信息，并不属于堆的一部分。</li></ul></li></ul><p><strong>2. 分代垃圾回收过程</strong></p><p><strong>年轻代垃圾回收（Minor GC）</strong></p><ul><li><strong>Eden 区与 Survivor 区</strong>：当一个新的对象被创建时，它首先被分配到 Eden 区。如果 Eden 区满了，就会触发一次 Minor GC。</li><li><strong>复制算法</strong>：Minor GC 使用这种算法来清理垃圾对象。在这个过程中，存活的对象会被复制到其中一个 Survivor 区（假设为 From），同时清除 Eden 区。</li><li><strong>Survivor 区交换</strong>：下一次 Minor GC 发生时，Eden 区和当前的 From Survivor 区中的存活对象会被复制到另一个 Survivor 区（To）。然后这两个角色会互换（即原来的 From 变成 To，反之亦然）。</li><li><strong>晋升至老年代</strong>：当某个对象经历了若干次 Minor GC 后仍然存活（默认情况下是 15 次），它将被移动到老年代。</li></ul><p><strong>老年代垃圾回收（Major GC / Full GC）</strong></p><ul><li><strong>Full GC</strong>：当老年代也满时，将会触发 Full GC，这会同时清理年轻代和老年代。由于老年代中的对象通常是长期存活的，所以 Full GC 的频率远低于 Minor GC，但其执行成本更高。</li><li><strong>标记-清除或标记-整理算法</strong>：对于老年代，可能会使用这两种算法之一。标记-清除算法简单地标识并删除不再使用的对象，但会导致内存碎片化；标记-整理算法则会在清理的同时压缩内存，减少碎片。</li></ul><p>一些常用的 JVM 参数，用于调整分代垃圾回收行为：</p><ul><li><strong>年轻代相关参数</strong>：<ul><li><code>-Xmn&lt;size&gt;</code>：设置年轻代大小。</li><li><code>-XX:SurvivorRatio=&lt;ratio&gt;</code>：设置 Eden 区与 Survivor 区的比例（默认为 8:1）。</li><li><code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>：设置对象晋升到老年代的最大年龄（默认为 15）。</li></ul></li><li><strong>老年代相关参数</strong>：<ul><li><code>-Xms&lt;size&gt;</code>：设置堆内存初始大小。</li><li><code>-Xmx&lt;size&gt;</code>：设置堆内存最大大小。</li></ul></li><li><strong>垃圾回收器选择</strong>：<ul><li><code>-XX:+UseSerialGC</code>：启用 Serial 收集器。</li><li><code>-XX:+UseParallelGC</code>：启用 Parallel 收集器。</li><li><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器。</li><li><code>-XX:+UseG1GC</code>：启用 G1 收集器。</li><li><code>-XX:+UseZGC</code>：启用 ZGC 收集器。</li><li><code>-XX:+UseShenandoahGC</code>：启用 Shenandoah 收集器</li></ul></li></ul><p><strong>(1) 基本 GC 日志</strong></p><ul><li><code>-XX:+PrintGCDetails</code>：打印详细的垃圾回收日志。</li><li><code>-XX:+PrintGC</code> 或 <code>-verbose:gc</code>：打印简单的垃圾回收日志（仅显示每次 GC 的时间和类型）。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -XX:+PrintGC MyApplication</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">1024</span>K-&gt;<span class="number">512</span>K(<span class="number">2048</span>K)] <span class="number">1024</span>K-&gt;<span class="number">768</span>K(<span class="number">6144</span>K), <span class="number">0.0023456</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><p><strong>(2) 打印时间戳</strong></p><ul><li><code>-XX:+PrintGCTimeStamps</code>：在每条 GC 日志前添加时间戳（从 JVM 启动开始的时间）。</li><li><code>-XX:+PrintGCDateStamps</code>：在每条 GC 日志前添加实际日期和时间。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps MyApplication</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">03</span>-<span class="number">29</span>T<span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>.<span class="number">000</span>+<span class="number">0000</span>: <span class="number">1</span>.<span class="number">234</span>:<span class="meta"> [GC (Allocation Failure) ...]</span></span><br></pre></td></tr></table></figure><p><strong>(3) 将 GC 日志写入文件</strong></p><ul><li><code>-Xloggc:&lt;file&gt;</code>：将 GC 日志写入指定文件。</li><li>结合其他参数可以生成更详细的日志文件。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -Xloggc:gc.log MyApplication</span><br></pre></td></tr></table></figure><p><strong>2. 调整堆内存大小</strong></p><ul><li><code>-Xms&lt;size&gt;</code>：设置 JVM 堆内存的初始大小。例如 <code>-Xms512m</code> 表示初始堆大小为 512MB。</li><li><code>-Xmx&lt;size&gt;</code>：设置 JVM 堆内存的最大大小。例如 <code>-Xmx2g</code> 表示最大堆大小为 2GB。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512m -Xmx2g MyApplication</span><br></pre></td></tr></table></figure><p><strong>3. 调整年轻代和老年代比例</strong></p><ul><li><code>-XX:NewRatio=&lt;ratio&gt;</code>：设置老年代与年轻代的比例。例如 <code>-XX:NewRatio=3</code> 表示老年代与年轻代的比例为 3:1。</li><li><code>-XX:SurvivorRatio=&lt;ratio&gt;</code>：设置 Eden 区与 Survivor 区的比例。例如 <code>-XX:SurvivorRatio=8</code> 表示 Eden 区与每个 Survivor 区的比例为 8:1。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:NewRatio=3 -XX:SurvivorRatio=8 MyApplication</span><br></pre></td></tr></table></figure><p><strong>4. 设置元空间大小</strong></p><ul><li><code>-XX:MetaspaceSize=&lt;size&gt;</code>：设置元空间的初始大小。</li><li><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code>：设置元空间的最大大小。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m MyApplication</span><br></pre></td></tr></table></figure><p><strong>5. 设置线程栈大小</strong></p><ul><li><code>-Xss&lt;size&gt;</code>：设置每个线程的栈大小。例如 <code>-Xss512k</code> 表示每个线程的栈大小为 512KB。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512k MyApplication</span><br></pre></td></tr></table></figure><p><strong>6. 启用特定垃圾回收器</strong></p><ul><li><code>-XX:+UseSerialGC</code>：启用 Serial 收集器（单线程）。</li><li><code>-XX:+UseParallelGC</code>：启用 Parallel 收集器（多线程，关注吞吐量）。</li><li><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器（低延迟，适合 Web 应用）。</li><li><code>-XX:+UseG1GC</code>：启用 G1 收集器（适合大内存应用）。</li><li><code>-XX:+UseZGC</code>：启用 ZGC 收集器（超低延迟，适合大内存）。</li><li><code>-XX:+UseShenandoahGC</code>：启用 Shenandoah 收集器（超低延迟）。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseG1GC MyApplication</span><br></pre></td></tr></table></figure><p><strong>7. 设置 GC 暂停时间目标</strong></p><ul><li><code>-XX:MaxGCPauseMillis=&lt;time&gt;</code>：设置 GC 的最大暂停时间目标（单位为毫秒）。只对 G1 和 ZGC 有效。</li><li><code>-XX:GCTimeRatio=&lt;ratio&gt;</code>：设置 GC 时间与应用程序运行时间的比例。例如 <code>-XX:GCTimeRatio=19</code> 表示 GC 时间占总时间的 1/20。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 MyApplication</span><br></pre></td></tr></table></figure><p><strong>8. 监控 JVM 性能</strong></p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当发生 OutOfMemoryError 时自动生成堆转储文件。</li><li><code>-XX:HeapDumpPath=&lt;path&gt;</code>：指定堆转储文件的路径。</li><li><code>-XX:+PrintCommandLineFlags</code>：打印 JVM 启动时的所有命令行参数。</li><li><code>-XX:+PrintFlagsFinal</code>：打印所有 JVM 参数及其最终值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./heapdump.hprof MyApplication</span><br></pre></td></tr></table></figure><p><strong>9. 其他常用参数</strong></p><ul><li><code>-D&lt;property&gt;=&lt;value&gt;</code>：设置系统属性。例如 <code>-Dfile.encoding=UTF-8</code>。</li><li><code>-server</code>：启用服务器模式（默认情况下大多数 JVM 都会自动启用此模式）。</li><li><code>-XX:+DisableExplicitGC</code>：禁用通过 <code>System.gc()</code> 显式触发的垃圾回收。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dfile.encoding=UTF-8 -server -XX:+DisableExplicitGC MyApplication</span><br></pre></td></tr></table></figure><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p><strong>1. Serial 收集器</strong></p><ul><li><strong>工作模式</strong>：单线程运行，适用于单核处理器或客户端应用。</li><li><strong>应用场景</strong>：适合内存较小的应用程序，特别是那些对响应时间要求不高且资源有限的环境。</li><li><strong>优点</strong>：实现简单，对于小型应用程序非常有效。</li><li><strong>缺点</strong>：由于是单线程执行，在进行垃圾回收时会暂停所有其他的工作线程（Stop-The-World, STW），这会导致较长时间的停顿。</li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure><p><strong>2. Parallel 收集器（也称为 Throughput Collector）</strong></p><ul><li><strong>工作模式</strong>：多线程并行执行，适用于多核处理器环境下的服务器端应用。</li><li><strong>关注点</strong>：提高吞吐量，即减少垃圾回收时间占总运行时间的比例。</li><li><strong>年轻代</strong>：使用标记-复制算法。</li><li><strong>老年代</strong>：使用标记-整理算法。</li><li><strong>优点</strong>：通过并行处理提高了垃圾回收效率，减少了总的停顿时间。</li><li><strong>缺点</strong>：仍然会有较长的停顿时间，特别是在老年代垃圾回收期间。</li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p>为了优化老年代的收集性能，可以加上 <code>-XX:+UseParallelOldGC</code> 来启用老年代的并行压缩。</p><p><strong>3. CMS（Concurrent Mark Sweep）收集器</strong></p><ul><li><p><strong>工作模式</strong>：专注于减少停顿时间，尽可能地与应用程序并发执行大部分垃圾回收工作。</p></li><li><p>主要阶段</p><p>：</p><ul><li>初始标记（Initial Mark）</li><li>并发标记（Concurrent Mark）</li><li>再标记（Remark）</li><li>并发清除（Concurrent Sweep）</li></ul></li><li><p><strong>优点</strong>：尽量减少了应用程序的停顿时间。</p></li><li><p><strong>缺点</strong>：虽然减少了停顿时间，但增加了总体的CPU占用率；无法压缩内存，可能导致内存碎片化问题；在某些情况下可能会导致“Concurrent Mode Failure”。</p></li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p><strong>4. G1（Garbage First）收集器</strong></p><ul><li><p><strong>设计理念</strong>：旨在提供可预测的停顿时间和高吞吐量。G1 将堆划分为多个区域（Region），优先回收垃圾最多的区域。</p></li><li><p>主要特性</p><p>：</p><ul><li>可以设置最大停顿时间目标。</li><li>支持大堆内存管理，并能有效避免内存碎片。</li><li>在进行垃圾回收时，尝试同时清理年轻代和老年代。</li></ul></li><li><p><strong>优点</strong>：相比 CMS，G1 提供了更好的停顿时间控制，并减少了内存碎片的问题。</p></li><li><p><strong>缺点</strong>：配置相对复杂，可能需要更多的调优才能达到最佳效果。</p></li></ul><p>启用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><h3 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h3><p>CAS（Compare-And-Swap，比较并交换）是一种重要的原子操作机制，广泛应用于多线程并发控制中。它<strong>允许在不使用锁的情况下实现对共享数据的同步访问</strong>，从而<strong>避免了传统锁机制可能带来的性能瓶颈和死锁问题</strong>。CAS操作包含三个参数：内存位置V、预期原值A和新值B。只有当内存位置V的值等于预期原值A时，才会将内存位置V的值更新为新值B，并返回操作是否成功的布尔值；否则，不做任何操作</p><p>在 Java 中，<code>java.util.concurrent.atomic</code> 包提供了基于 CAS 的原子类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等。这些类内部使用了 <code>Unsafe</code> 类提供的底层 CAS 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger value = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// 使用 AtomicInteger 实现 CAS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数器的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = value.get(); <span class="comment">// 获取当前值</span></span><br><span class="line">            next = current + <span class="number">1</span>;    <span class="comment">// 计算下一个值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!value.compareAndSet(current, next)); <span class="comment">// 尝试 CAS 更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计数器的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CASCounter counter = <span class="keyword">new</span> CASCounter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程并发增加计数器</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终计数器的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final counter value: &quot;</span> + counter.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h5><p>乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是两种处理并发控制的策略，它们在如何管理数据冲突方面采取了不同的方法。</p><p>乐观锁则假设不会发生并发冲突，因此不会主动加锁。它允许所有事务同时读取并尝试修改数据，但在提交更改前检查是否有其他事务已经修改了相同的数据。如果有，则拒绝此次修改或根据具体业务逻辑进行重试或其他处理。</p><p>悲观锁假设会发生并发冲突，因此在操作数据时会直接加锁，防止其他事务对该数据进行修改直到当前事务完成。</p><p><strong>使用悲观锁</strong>的方式可能是这样的：在处理订单时首先锁定库存记录，然后检查库存是否足够，若足够则扣减库存并提交事务释放锁；否则回滚事务并告知用户库存不足。</p><p><strong>使用乐观锁</strong>的方式则是：在开始处理订单时不加锁，而是记录下当前库存记录的版本号或时间戳。在准备扣减库存时再次检查版本号或时间戳是否未变，若未变则扣减库存并更新版本号/时间戳；若有变化则表明期间有其他订单已修改了库存，此时可以选择重试或通知用户稍后再试。</p><h5 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h5><ol><li>CAS 操作</li></ol><p>CAS（Compare-And-Swap）是实现原子操作的核心机制。它是一个低级别的、硬件提供的原子指令，通常用于无锁算法中。一个典型的 CAS 操作包含三个参数：</p><ul><li><strong>内存位置 V</strong>：要更新的数据在内存中的地址。</li><li><strong>预期值 A</strong>：期望在内存位置 V 处找到的值。</li><li><strong>新值 B</strong>：如果内存位置 V 的当前值等于预期值 A，则将该位置的值更新为新值 B。</li></ul><p>CAS 操作会检查内存位置 V 的当前值是否与预期值 A 相等。如果相等，则将内存位置 V 更新为新值 B，并返回成功；如果不相等，则不进行任何修改，并返回失败。这个过程是原子性的，意味着在同一时刻只能有一个线程成功执行 CAS 操作。</p><blockquote><p>传统的 <code>AtomicLong</code> (以及AtomicInteger等)使用 CAS（Compare-And-Swap）操作来保证线程安全，但在高并发情况下，多个线程同时竞争同一个值时，CAS 操作可能会频繁失败并重试，导致性能下降。</p><p><code>LongAdder</code> 的设计目标是解决这个问题。它通过<strong>分段锁</strong>的思想将数据分散到多个变量中，减少了线程间的竞争，从而提高了性能。最终结果可以通过这些变量汇总得到。</p></blockquote><ol><li>Java 内存模型 (JMM)</li></ol><p>Java 内存模型定义了多线程环境下变量的可见性和顺序性规则。为了保证线程间共享变量的一致性，Java 提供了 <code>volatile</code> 关键字和同步块 (<code>synchronized</code>) 来确保变量的可见性。原子类内部使用了类似的技术来确保线程间的可见性，即使它们自身并不总是需要显式的同步块。</p><ol><li>Unsafe 类</li></ol><p>Java 的原子类内部通常使用 <code>sun.misc.Unsafe</code> 类提供的本地方法来直接调用底层的 CAS 操作。虽然 <code>Unsafe</code> 类并不是官方推荐的 API，但它被广泛应用于高性能并发库中，如 <code>java.util.concurrent</code> 包内的实现。通过 <code>Unsafe</code>，开发者可以绕过 Java 的安全检查直接与操作系统交互，这使得它可以非常高效地执行 CAS 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInt = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子递增</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Initial value: &quot;</span> + atomicInt.get());</span><br><span class="line">        atomicInt.incrementAndGet(); <span class="comment">// 自增1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After increment: &quot;</span> + atomicInt.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子更新</span></span><br><span class="line">        atomicInt.updateAndGet(x -&gt; x * <span class="number">2</span>); <span class="comment">// 使用函数式更新</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After update: &quot;</span> + atomicInt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的设计初衷是为了<strong>消除无竞争情况下的同步原语，进一步提高程序的运行性能</strong>。当一个线程访问同步块并获取锁时,<strong>会在对象头中记录当前线程的ID，表示该线程占有了这个对象的锁。</strong></p><p>当大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得时，使用偏向锁可以减少不必要的同步操作。</p><p>特性：当没有其他线程尝试获取同一个锁时，持有偏向锁的线程不需要进行同步操作。</p><p>如果有其他线程尝试获取偏向锁，则会发生偏向锁撤销，锁可能会升级为轻量级锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>Java 轻量级锁是 JVM 提供的一种优化机制，旨在<strong>减少多线程环境下获取锁的开销</strong>。它主要通过使用 CAS（Compare-And-Swap）操作来避免传统锁带来的性能损耗，<strong>适用于线程竞争较少的情况</strong>。轻量级锁是 Java 锁机制的一部分，它可以动态升级为重量级锁以应对更高的竞争情况。</p><ul><li>在线程交替执行同步块且存在轻微的竞争时，轻量级锁能够通过CAS（Compare-and-Swap）操作来避免线程阻塞和上下文切换。</li><li>特性<ul><li>每个线程都有自己的栈帧，其中包含用于存储锁的记录空间（Lock Record）。当线程试图获取轻量级锁时，会将对象头中的Mark Word复制到该线程的锁记录中，并尝试通过CAS操作将对象头指向该线程的锁记录。</li><li>若<strong>多个线程同时请求轻量级锁且自旋一定次数后仍未成功获取锁，则锁将膨胀为重量级锁</strong>。</li></ul></li></ul><h4 id="轻量级锁的工作原理"><a href="#轻量级锁的工作原理" class="headerlink" title="轻量级锁的工作原理"></a>轻量级锁的工作原理</h4><ol><li><strong>加锁过程</strong><ul><li>当一个线程尝试获取锁时，如果对象没有被锁定（锁标志位为“01”），JVM 会在当前线程的栈帧中创建一个称为 Lock Record 的空间，并<strong>将对象头中的 Mark Word 复制到这个 Lock Record 中</strong>。</li><li>然后，线程会尝试用 CAS 操作<strong>将对象头中的 Mark Word 更新为指向该线程 Lock Record 的指针</strong>。如果成功，则该线程获得了锁。</li><li>如果 CAS 操作失败，意味着另一个线程已经持有了锁，这时当前线程会自旋（忙等）一段时间，尝试重新获取锁。</li></ul></li><li><strong>解锁过程</strong><ul><li>当线程退出同步块时，会使用 CAS 操作尝试将对象头中的 Mark Word 恢复为其原始值（即从 Lock Record 中拷贝回来的 Displaced Mark Word）。</li><li>如果 CAS 操作成功，则表示没有其他线程尝试获取该锁，锁被成功释放。</li><li>如果 CAS 操作失败，说明有其他线程尝试获取过该锁，此时轻量级锁将会膨胀为重量级锁。</li></ul></li><li><strong>锁的升级</strong><ul><li>轻量级锁在遇到高竞争（即多个线程频繁尝试获取同一把锁）的情况下，可能会膨胀为重量级锁。这是因为持续的自旋等待会消耗大量的 CPU 资源。</li><li>一旦锁升级为重量级锁，后续试图获取锁的线程将进入阻塞状态，直到锁被释放。</li></ul></li><li><strong>适用场景</strong><ul><li>轻量级锁适用于线程竞争不激烈、锁占用时间较短的情况。在这种情况下，轻量级锁能够通过 CAS 操作和自旋来避免线程的阻塞和上下文切换，从而提高程序的并发性能。</li><li>对于锁竞争较为激烈的场景，建议使用 ReentrantLock 或者其他的高级同步机制，因为这些机制提供了更灵活的锁管理和更好的性能表现。</li></ul></li></ol><h4 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h4><p>重量级锁通过操作系统提供的互斥量（mutex）来实现线程间的同步，这种锁会让线程调用者进入阻塞状态，并被操作系统挂起。</p><p>在高竞争环境下，即多个线程频繁争夺同一资源时，重量级锁能够确保数据的一致性和完整性。</p><p>特性</p><ul><li>锁住的线程会被挂起直到锁被释放，此时其他等待的线程才有可能获取锁。</li><li>由于<strong>涉及用户态到内核态的切换以及线程的挂起和唤醒，重量级锁的开销较大</strong>。</li></ul><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>锁膨胀（Lock Escalation）在Java中通常指的是synchronized关键字背后的锁机制随着竞争条件的变化而动态升级的过程。具体来说，在Java虚拟机（JVM）中，锁的状态可以经历从无锁状态到偏向锁、轻量级锁，最后到重量级锁的转变过程。这个过程称为锁膨胀或锁升级，并且它是一个单向的过程，即锁只能从低级别向高级别升级，不能降级。</p><p>锁膨胀的具体过程：</p><ol><li><strong>无锁状态</strong>：当对象刚创建时，没有线程尝试获取该对象上的锁，此时处于无锁状态。</li><li><strong>偏向锁状态</strong>：当第一个线程尝试获取对象上的锁时，JVM会将锁设置为偏向锁，并记录下持有偏向锁的线程ID。如果之后还是同一个线程访问，则不需要再次进行加锁操作，直接进入同步块执行代码。偏向锁的目标是减少无实际竞争情况下的锁获取成本。</li><li><strong>轻量级锁状态</strong>：如果有第二个线程尝试获取已经被偏向锁持有的对象的锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS（Compare and Swap）操作来尝试获取锁，以减少锁的竞争和系统的开销。轻量级锁适用于多个线程交替执行同步块的情况。</li><li><strong>重量级锁状态</strong>：当多个线程长时间竞争同一个对象的锁时，轻量级锁会升级为重量级锁。重量级锁采用操作系统的互斥量（Mutex）来实现，确保线程的安全性。在这种状态下，JVM会创建一个等待队列，将等待获取锁的线程挂起在队列中。重量级锁会导致较大的性能开销，因为它涉及到用户态与内核态之间的切换。</li></ol><p>锁膨胀的设计目的是为了优化多线程环境下的性能。通过这种方式，JVM可以根据不同的并发场景自动调整锁的状态，从而减少不必要的性能损耗。例如，在几乎没有竞争的情况下，偏向锁可以提供很好的性能；而在有少量竞争的情况下，轻量级锁可以通过自旋避免阻塞，提高效率；只有在高竞争的情况下，才会升级为重量级锁。这种机制使得synchronized在大多数情况下都能够高效运行。</p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><ol><li>减少上锁时间</li><li>减少锁的颗粒度  使用concurrentHashMap</li><li>锁粗化 多次循环进入同步块不如在同步块内进行循环</li><li>锁消除</li><li>读写分离</li></ol><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p><strong>1. 继承 <code>Thread</code> 类</strong></p><p><strong>(1) 基本原理</strong></p><p>通过继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，调用 <code>start()</code> 方法启动线程。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        thread2.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>简单直观，易于理解。</li></ul><p><strong>(4) 缺点</strong></p><ul><li><p>Java 不支持多重继承，如果一个类已经继承了其他类，则无法再继承 <code>Thread</code>。</p><p><strong>2. 实现 <code>Runnable</code> 接口</strong></p></li></ul><p><strong>(1) 基本原理</strong></p><p>通过实现 <code>Runnable</code> 接口并实现 <code>run()</code> 方法，将 <code>Runnable</code> 对象传递给 <code>Thread</code> 构造器来启动线程。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        thread2.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>更灵活：可以避免因为继承 <code>Thread</code> 而导致的多重继承问题。</li><li>适合资源共享（多个线程共享同一个 <code>Runnable</code> 实例）。</li></ul><p><strong>(4) 缺点</strong></p><ul><li>需要显式地将 <code>Runnable</code> 对象传递给 <code>Thread</code>。</li></ul><p><strong>3. 使用 <code>Callable</code> 和 <code>FutureTask</code></strong></p><p><strong>(1) 基本原理</strong></p><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但<strong>它可以返回结果，并且可以抛出异常。<code>FutureTask</code> 是一个包装类，</strong>用于管理 <code>Callable</code> 的执行结果。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable running: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回计算结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(futureTask1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(futureTask2);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result from thread1: &quot;</span> + futureTask1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Result from thread2: &quot;</span> + futureTask2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>可以返回结果。</li><li>可以捕获线程中的异常。</li><li>适合需要获取线程执行结果的场景。</li></ul><p><strong>(4) 缺点</strong></p><ul><li>相比 <code>Runnable</code>，代码稍微复杂一些。</li></ul><p><strong>4. 使用线程池（推荐）</strong></p><p><strong>(1) 基本原理</strong></p><p>Java 提供了 <code>ExecutorService</code> 接口和 <code>Executors</code> 工厂类，用于管理和复用线程，避免频繁创建和销毁线程带来的开销。</p><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing task: &quot;</span> + name + <span class="string">&quot; in thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.submit(<span class="keyword">new</span> Task(<span class="string">&quot;Task-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown(); <span class="comment">// 关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 优点</strong></p><ul><li>高效：线程池可以复用线程，减少线程创建和销毁的开销。</li><li>灵活：可以设置线程池大小、任务队列等。</li><li>易于管理：提供更高级的任务调度和生命周期管理功能。</li></ul><p><strong>(4) 缺点</strong></p><ul><li>初学者可能觉得使用线程池的 API 比较复杂。</li></ul><p><strong>5. 使用 Lambda 表达式（简化代码）</strong></p><p>从 Java 8 开始，可以使用 Lambda 表达式进一步简化线程的创建和使用。</p><p><strong>(1) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式实现 Runnable</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda thread running: &quot;</span> + Thread.currentThread().getName())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式提交任务到线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        executor.submit(() -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda task running: &quot;</span> + Thread.currentThread().getName())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 优点</strong></p><ul><li>简洁：减少了样板代码。</li><li>易读：代码更加紧凑。</li></ul><p><strong>6. 总结与选择建议</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承 <code>Thread</code> 类</td><td>简单任务，快速验证</td><td>简单直观</td><td>不能多重继承</td></tr><tr><td>实现 <code>Runnable</code> 接口</td><td>多线程共享资源</td><td>灵活，避免多重继承限制</td><td>需要显式传递 <code>Runnable</code></td></tr><tr><td>使用 <code>Callable</code> 和 <code>FutureTask</code></td><td>需要返回结果或处理异常的任务</td><td>支持返回值和异常处理</td><td>代码稍微复杂</td></tr><tr><td>使用线程池</td><td>长时间运行的任务，或者需要高效管理线程的场景</td><td>高效，易于管理</td><td>API 较复杂</td></tr><tr><td>使用 Lambda 表达式</td><td>简化代码，尤其是在线程池中</td><td>代码简洁</td><td>依赖 Java 8+</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/30/CYqToSF1d9ax7lA.png" alt="image-20250330162459693"></p><h4 id="Syncronized优化原理"><a href="#Syncronized优化原理" class="headerlink" title="Syncronized优化原理"></a>Syncronized优化原理</h4><p><code>synchronized</code> 的底层实现依赖于 JVM 提供的<strong>监视器锁（Monitor）\</strong>机制，而监视器锁最终映射到操作系统提供的*<em>互斥锁（Mutex Lock）*</em>。具体来说，<code>synchronized</code> 的工作原理分为以下几个阶段：</p><p><strong>(1) Monitor（监视器）</strong></p><ul><li>每个 Java 对象都有一个与之关联的监视器（Monitor），也称为“内置锁”或“监视器锁”。</li><li>监视器的作用是确保同一时刻只有一个线程能够持有该锁并执行同步代码。</li></ul><p><strong>(2) 对象头中的 Mark Word</strong></p><ul><li>在 HotSpot 虚拟机中，每个 Java 对象都有一个对象头（Object Header），其中包含一个 <code>Mark Word</code>。</li><li><code>Mark Word</code> 用来存储对象的元信息，例如哈希码、GC 分代年龄、锁状态等。</li><li>当线程尝试获取锁时，<code>Mark Word</code> 的内容会动态变化，表示锁的状态（无锁、偏向锁、轻量级锁、重量级锁）。</li></ul><p><strong>(3) 锁的升级机制</strong></p><p>为了优化性能，<code>synchronized</code> 实现了锁的升级机制，从低开销的锁逐步升级到高开销的锁。锁的升级过程如下：</p><ol><li><strong>无锁状态</strong>：<ul><li>初始状态下，对象没有被任何线程锁定。</li></ul></li><li><strong>偏向锁（Biased Locking）</strong>：<ul><li>如果某个线程多次进入同步代码块，JVM 会将锁偏向于该线程。</li><li>偏向锁通过在 <code>Mark Word</code> 中记录线程 ID 来实现，避免每次加锁和解锁都需要 CAS（Compare-And-Swap）操作。</li><li>偏向锁适用于单线程访问同步代码块的场景。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）</strong>：<ul><li>当有多个线程竞争同一个锁时，偏向锁会升级为轻量级锁。</li><li>轻量级锁使用自旋的方式尝试获取锁，减少线程上下文切换的开销。</li><li>如果自旋成功，则直接获取锁；如果自旋失败，则升级为重量级锁。</li></ul></li><li><strong>重量级锁（Heavyweight Locking）</strong>：<ul><li>当竞争激烈时，轻量级锁会升级为重量级锁。</li><li>重量级锁依赖于操作系统的互斥锁（Mutex Lock），会导致线程阻塞和唤醒，开销较大。</li></ul></li></ol><p><strong>(4) 锁的释放</strong></p><ul><li>当线程退出同步代码块时，会释放锁。</li><li>JVM 会根据锁的状态（偏向锁、轻量级锁、重量级锁）进行相应的处理，恢复对象头的 <code>Mark Word</code> 状态。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>ReentrantLock</code></th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>JVM 内置关键字</td><td>显式锁，API 实现</td></tr><tr><td><strong>锁优化</strong></td><td>支持偏向锁、轻量级锁</td><td>不支持</td></tr><tr><td><strong>公平性</strong></td><td>非公平锁</td><td>支持公平锁</td></tr><tr><td><strong>可中断性</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>超时机制</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>条件变量</strong></td><td>不支持</td><td>支持（通过 <code>Condition</code>）</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/30/8PW4irnVQOo1U7M.png" alt="image-20250330171150577"></p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code> 是 Java 提供的一种可重入的互斥锁，它位于 <code>java.util.concurrent.locks</code> 包中，是 <code>Lock</code> 接口的一个实现类。相比于 <code>synchronized</code> 关键字，<code>ReentrantLock</code> 提供了更灵活、更强大的锁机制，适用于复杂的并发场景。</p><p>可重入锁（Reentrant Lock） 指的是一个线程可以多次获取同一个锁而不被自己阻塞。这意味着如果一个线程已经持有了某个锁，并尝试再次获取该锁，则该操作会成功，而不是导致死锁。每次获取锁时，锁内部的计数器会增加；每次释放锁时，计数器会减少；只有当计数器归零时，锁才会真正被释放，允许其他线程获取。</p><h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行一些操作</span></span><br><span class="line">            secondMethod();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行更多操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><p>“可打断”（Interruptible）指的是线程在<strong>等待某种资源或处于阻塞状态时,是否能够响应中断请求并进行相应的处理</strong>.当一个线程处于不可打断的状态下（如通过某些同步机制等待获取锁）,它将不会响应中断信号；而在可打断状态下,线程可以捕获到中断请求,并根据应用逻辑决定如何处理这个中断.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptibleLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is trying to acquire the lock.&quot;</span>);</span><br><span class="line">            <span class="comment">// 尝试获取锁，但是可以响应中断</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; has acquired the lock.&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟任务处理</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; was interrupted while waiting for the lock.&quot;</span>);</span><br><span class="line">            <span class="comment">// 处理中断，通常这里需要做一些清理工作</span></span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        InterruptibleLockExample example = <span class="keyword">new</span> InterruptibleLockExample();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                example.performTask();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Worker-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让 t1 先开始尝试获取锁</span></span><br><span class="line">                example.performTask();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Worker-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 主线程等待一段时间后中断 t2</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尝试获取锁"><a href="#尝试获取锁" class="headerlink" title="尝试获取锁"></a>尝试获取锁</h5><ul><li><code>boolean tryLock()</code><ul><li>尝试获取锁。如果锁可用，则立即获取并返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li><li><code>boolean tryLock(long timeout, TimeUnit unit)</code><ul><li>尝试在指定时间内获取锁。如果在超时前获取到锁，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul></li></ul><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p><code>ReentrantLock</code> <strong>默认是非公平锁</strong>。也就是说，当多个线程竞争锁时，默认情况下新来的线程可能会直接插队获取锁，而不需要严格按照线程等待的顺序（FIFO 队列）来分配锁。</p><p><strong>公平锁与非公平锁的区别</strong></p><ol><li><strong>公平锁（Fair Lock）</strong><ul><li>公平锁会按照线程请求锁的顺序（即 FIFO 队列）来分配锁。</li><li>这种方式可以避免线程饥饿问题，但可能会导致性能下降，因为线程切换的开销较高。</li></ul></li><li><strong>非公平锁（Non-Fair Lock）</strong><ul><li>非公平锁允许插队，即新来的线程可以直接尝试获取锁，而不需要排队。</li><li>这种方式减少了线程上下文切换的开销，提高了吞吐量，但在高并发场景下可能导致某些线程长时间无法获取锁（饥饿问题）。</li></ul></li></ol><h5 id="与条件变量"><a href="#与条件变量" class="headerlink" title="与条件变量"></a>与条件变量</h5><p>在并发编程中，条件变量是一种用于线程间协调的机制。它允许一个或多个线程等待某个条件变为真，而不是忙等（busy-waiting）。在Java中，<code>Condition</code> 接口由 <code>ReentrantLock</code> 类提供支持，<strong>每个 <code>ReentrantLock</code> 可以创建多个 <code>Condition</code> 实例，从而实现更加灵活的线程控制</strong>。</p><p><code>Condition</code> 接口的主要方法</p><ul><li><strong>await()</strong>：使当前线程等待，并释放锁。直到其他线程调用 <code>signal()</code> 或 <code>signalAll()</code> 方法唤醒它。</li><li><strong>signal()</strong>：唤醒一个等待该条件的线程。如果有多个线程在等待，则选择其中的一个。</li><li><strong>signalAll()</strong>：唤醒所有等待该条件的线程。</li><li><strong>awaitUninterruptibly()</strong>：类似于 <code>await()</code>，但是不会响应中断。</li><li><strong>awaitNanos(long nanosTimeout)</strong>、<strong>awaitUntil(Date deadline)</strong>：带超时的等待方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] buffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerConsumerExample</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == buffer.length) &#123; <span class="comment">// Buffer is full</span></span><br><span class="line">                notFull.await(); <span class="comment">// Wait until buffer is not full</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer[count] = value;</span><br><span class="line">            count++;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// Signal that buffer is not empty now</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123; <span class="comment">// Buffer is empty</span></span><br><span class="line">                notEmpty.await(); <span class="comment">// Wait until buffer is not empty</span></span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">int</span> value = buffer[count];</span><br><span class="line">            notFull.signal(); <span class="comment">// Signal that buffer is not full now</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumerExample example = <span class="keyword">new</span> ProducerConsumerExample(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Runnable producerTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    example.produce(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumerTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> value = example.consume();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producerTask).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumerTask).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p><code>volatile</code> 是 Java 中的一个关键字，用于修饰变量，它提供了一种<strong>比锁更轻量级的同步机制</strong>。尽管 <code>volatile</code> 并不能替代 synchronized 关键字所提供的所有功能，但在某些特定场景下，它可以有效地保证线程间的可见性和有序性。</p><p><strong>工作原理</strong></p><ol><li><strong>可见性</strong>：<strong>当一个线程对一个 <code>volatile</code> 变量进行写操作时，会将该变量立即刷新到主内存中</strong>。而当其他线程读取这个 <code>volatile</code> 变量时，它们会被强制从主内存中重新读取这个变量的最新值，而不是使用自己工作内存中的缓存副本。这就确保了所有线程都能看到最新的变量值。</li><li><strong>禁止指令重排序优化</strong>：Java 编译器和处理器可以对指令进行重排序以提高执行效率。然而，这种重排序可能会导致多线程环境下的程序出现意料之外的行为。<code>volatile</code> 变量可以防止编译器对涉及该变量的操作进行指令重排序，从而保持代码的预期执行顺序。</li></ol><p>虽然 <code>volatile</code> 和原子类（如 <code>AtomicInteger</code>）都提供了线程安全的操作，但它们之间存在一些关键差异：</p><ul><li><strong>原子性</strong>：<code>volatile</code> 只能保证变量的可见性和有序性，不能保证复合操作（比如增加、减少）的原子性。而原子类通过使用 CAS（比较并交换）等硬件级别的原子操作来保证操作的原子性。</li><li><strong>性能</strong>：由于 <code>volatile</code> 不需要像锁那样复杂的开销，因此在只涉及简单状态更新的情况下，它的性能通常优于基于锁的解决方案。但是，在需要进行复杂的状态转换或需要保证原子性的场景下，原子类可能是更好的选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is waiting for the flag to be set.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// 等待直到flag被设置为true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Flag has been set, thread is proceeding.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程暂停一段时间</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志位</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flag has been set by main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code> 适用于以下场景：</p><ul><li>变量的写入不依赖于其当前值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li><li>对变量的访问都是原子操作（例如，简单的布尔标志）。</li></ul><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize; <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeoutUnit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeoutUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeoutUnit = timeoutUnit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size()&lt;coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                taskQueue.put(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1) task不为空</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.task != <span class="keyword">null</span> ||(task = taskQueue.take()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notEmptyWaitSet = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmptyWaitSet.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(t);</span><br><span class="line">            notEmptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">           <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   nanos = notEmptyWaitSet.awaitNanos(nanos);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           T t = queue.removeFirst();</span><br><span class="line">              emptyWaitSet.signal();</span><br><span class="line">              <span class="keyword">return</span> t;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用JDK提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程数</span></span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 最大线程数</span></span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 时间单位</span></span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 线程工厂</span></span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">// 拒绝策略</span></span><br><span class="line">        RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            keepAliveTime,</span><br><span class="line">            unit,</span><br><span class="line">            workQueue,</span><br><span class="line">            threadFactory,</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           Future&lt;Integer&gt; submit = threadPoolExecutor.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(submit.get());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/30/Y9PDFgfRLC8Bdp6.png" alt="image-20250330221744556"></p><ol><li><strong>corePoolSize</strong>：<ul><li>核心线程数，即线程池中始终保持的最小线程数量。</li><li>即使这些线程处于空闲状态，也不会被销毁（除非设置了 <code>allowCoreThreadTimeOut</code>）。</li></ul></li><li><strong>maximumPoolSize</strong>：<ul><li>线程池允许的最大线程数。</li><li>当任务队列已满且当前线程数小于 <code>maximumPoolSize</code> 时，线程池会创建新线程来处理任务。</li></ul></li><li><strong>keepAliveTime</strong>：<ul><li>空闲线程的存活时间。</li><li>如果线程数超过 <code>corePoolSize</code>，多余的空闲线程会在空闲一段时间后被回收。</li></ul></li><li><strong>unit</strong>：<ul><li><code>keepAliveTime</code> 的时间单位，例如 <code>TimeUnit.SECONDS</code>。</li></ul></li><li><strong>workQueue</strong>：<ul><li>任务队列，用于保存等待执行的任务。</li><li>常见实现包括：<ul><li><code>ArrayBlockingQueue</code>：有界队列。</li><li><code>LinkedBlockingQueue</code>：无界队列。</li><li><code>SynchronousQueue</code>：不存储任务，直接交给线程执行。</li></ul></li></ul></li><li><strong>threadFactory</strong>：<ul><li>创建线程的工厂，用于自定义线程的名称、优先级等属性。</li><li>默认使用 <code>Executors.defaultThreadFactory()</code>。</li></ul></li><li><strong>handler</strong>：<ul><li>拒绝策略，当线程池无法处理新任务时（例如线程池已满且任务队列已满），会调用此策略。</li><li>常见实现包括：<ul><li><code>AbortPolicy</code>：抛出 <code>RejectedExecutionException</code> 异常。</li><li><code>CallerRunsPolicy</code>：由调用线程（提交任务的线程）执行该任务。</li><li><code>DiscardPolicy</code>：直接丢弃任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后尝试重新提交新任务。</li></ul></li></ul></li></ol><p><strong>3. 线程池的工作原理</strong></p><ol><li><strong>任务提交</strong>：<ul><li>当一个任务被提交到线程池时，线程池会根据当前线程数和任务队列的状态决定如何处理任务。</li></ul></li><li><strong>任务分配逻辑</strong>：<ul><li>如果当前线程数小于 <code>corePoolSize</code>，即使有空闲线程，也会创建新线程来执行任务。</li><li>如果当前线程数等于或大于 <code>corePoolSize</code>，任务会被放入任务队列中等待。</li><li>如果任务队列已满且当前线程数小于 <code>maximumPoolSize</code>，线程池会创建新线程来执行任务。</li><li>如果任务队列已满且当前线程数等于 <code>maximumPoolSize</code>，则触发拒绝策略。</li></ul></li><li><strong>线程回收</strong>：<ul><li>如果线程数超过 <code>corePoolSize</code>，多余的空闲线程会在空闲一段时间（<code>keepAliveTime</code>）后被回收</li></ul></li></ol><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><ol><li>创建固定大小的线程池 - <code>newFixedThreadPool</code></li></ol><p>该方法返回一个固定大小的线程池，适用于需要限制并发线程数的场景。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为3的线程池</span></span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            fixedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程池中的线程数量是固定的。</li><li>如果所有线程都在忙，新的任务将等待直到有空闲线程可用。</li></ul><ol><li>创建单线程化的线程池 - <code>newSingleThreadExecutor</code></li></ol><p>该方法返回一个只有一个工作线程的线程池，适用于需要保证顺序执行任务的场景。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个单线程化的线程池</span></span><br><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            singleThreadExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        singleThreadExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有提交的任务按照提交顺序依次执行。</li><li>即使发生故障，也会重新创建一个线程来替代原来的线程继续处理后续任务。</li></ul><ol><li>创建一个会根据需要创建新线程的线程池 - <code>newCachedThreadPool</code></li></ol><p>该方法返回一个可根据需要创建新线程的线程池，适用于执行大量短期异步任务的场景。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个缓存线程池</span></span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            cachedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程池可以根据需要创建新线程，并在空闲60秒后回收未使用的线程。</li><li>适合执行大量短期异步任务的应用程序。</li></ul><ol><li>创建支持定时及周期性任务执行的线程池 - <code>newScheduledThreadPool</code></li></ol><p>该方法返回一个支持定时和周期性任务执行的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个支持定时及周期性任务执行的线程池</span></span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时执行任务，延迟2秒后执行</span></span><br><span class="line">        scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This task is run after a delay of 2 seconds&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周期性执行任务，初始延迟2秒后开始执行，之后每隔3秒执行一次</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This task is run periodically every 3 seconds&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记得关闭线程池</span></span><br><span class="line">        <span class="comment">// scheduledThreadPool.shutdown(); 在实际应用中，可能需要在适当的时候调用shutdown()来关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持延迟执行任务或周期性执行任务。</li><li><code>schedule()</code> 方法用于一次性延迟执行任务。</li><li><code>scheduleAtFixedRate()</code> 方法用于周期性执行任务。</li></ul><ol><li>使用自定义线程工厂</li></ol><p>你可以通过提供自定义的 <code>ThreadFactory</code> 来定制线程的创建过程，比如设置线程名称、优先级等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactoryExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadFactory customThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;CustomThread-&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>, customThreadFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程工厂允许更灵活地控制线程的创建过程。</p><p><img data-src="https://s2.loli.net/2025/03/30/Uqb7n83iNwsRuoB.png" alt="image-20250330223813273"></p><p><strong>线程池关闭方法</strong></p><ol><li><code>shutdown()</code></li></ol><ul><li><strong>描述</strong>：该方法不会立即强制关闭线程池，而是<strong>首先停止接收新的任务，并尝试完成已经提交的任务</strong>。</li><li>行为<ul><li>已经提交到线程池中的任务将继续执行直至完成。</li><li>此方法调用后，如果尝试向线程池提交新任务，则会根据线程池的拒绝策略处理（通常是抛出 <code>RejectedExecutionException</code>）。</li></ul></li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down the executor...&quot;</span>);</span><br><span class="line">        executor.shutdown(); <span class="comment">// 发出关闭信号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Some tasks are still running&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;All tasks finished.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>shutdownNow()</code></li></ol><ul><li><strong>描述</strong>：尝试<strong>立即停止所有正在执行的任务，并暂停处理等待的任务</strong>。</li><li>行为<ul><li>它试图终止所有正在执行的任务，并返回一个等待执行的任务列表。</li><li>并不能保证能够立即停止正在执行的任务，因为任务可能无法响应中断。</li></ul></li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownNowExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on thread &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; was interrupted.&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Attempting to shutdown the executor now...&quot;</span>);</span><br><span class="line">        List&lt;Runnable&gt; notExecutedTasks = executor.shutdownNow(); <span class="comment">// 尝试立即关闭</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Number of tasks that will not be executed: &quot;</span> + notExecutedTasks.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>awaitTermination(long timeout, TimeUnit unit)</code></li></ol><ul><li><strong>描述</strong>：阻塞当前线程直到线程池中的所有任务都已完成执行，或者超时发生，或者当前线程被中断。</li><li>行为<ul><li>通常与 <code>shutdown()</code> 方法一起使用，以确保所有任务都在程序退出之前完成。</li><li>返回值为 <code>true</code> 表示所有任务都已经完成；返回 <code>false</code> 则表示由于超时而未完成。</li></ul></li></ul><p>可以通过调用 <code>isShutdown()</code> 方法来检查线程池是否已经被标记为关闭。此外，<code>isTerminated()</code> 可用于判断线程池是否已经完全终止（即所有任务都已完成）</p><h4 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h4><p>线程安全的集合类是用于在多线程环境中安全地存储和操作数据的工具。这些集合类通过<strong>内部的同步机制</strong>或<strong>无锁算法（如 CAS）</strong>来保证线程安全。</p><p><img data-src="https://s2.loli.net/2025/03/30/cBvlUxGDnWa84Yp.png" alt="image-20250330225400344"></p><h5 id="Vector-和-Hashtable"><a href="#Vector-和-Hashtable" class="headerlink" title="Vector 和 Hashtable"></a><code>Vector</code> 和 <code>Hashtable</code></h5><p>这两个类是早期 Java 提供的线程安全集合类，但现在已被更高效的替代品取代。</p><p><strong><code>Vector</code></strong></p><ul><li>线程安全的动态数组，类似于 <code>ArrayList</code>，但所有操作都通过 <code>synchronized</code> 加锁。</li><li>性能较低，推荐使用 <code>CopyOnWriteArrayList</code> 或 <code>Collections.synchronizedList()</code> 替代。</li></ul><p><strong><code>Hashtable</code></strong></p><ul><li>线程安全的哈希表，类似于 <code>HashMap</code>，但所有操作都通过 <code>synchronized</code> 加锁。</li><li>推荐使用 <code>ConcurrentHashMap</code> 替代。</li></ul><h5 id="同步包装类（Collections-synchronizedXxx-方法）"><a href="#同步包装类（Collections-synchronizedXxx-方法）" class="headerlink" title="同步包装类（Collections.synchronizedXxx() 方法）"></a>同步包装类（<code>Collections.synchronizedXxx()</code> 方法）</h5><p>Java 的 <code>Collections</code> 类提供了一组静态方法，可以将普通的非线程安全集合包装成线程安全的集合。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCollectionsExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程安全的 ArrayList</span></span><br><span class="line">        List&lt;String&gt; synchronizedList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程安全的 HashMap</span></span><br><span class="line">        Map&lt;String, String&gt; synchronizedMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用时仍需手动加锁以保证复合操作的线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (synchronizedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!synchronizedList.isEmpty()) &#123;</span><br><span class="line">                synchronizedList.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>内部通过 <code>synchronized</code> 关键字实现同步。</li><li>简单易用，但性能较差，因为所有操作都需要竞争同一把锁。</li><li>复合操作（如迭代、条件检查等）需要外部手动加锁。</li></ul><h5 id="Concurrent-系列集合"><a href="#Concurrent-系列集合" class="headerlink" title="Concurrent 系列集合"></a><code>Concurrent</code> 系列集合</h5><p><code>java.util.concurrent</code> 包中提供了多个高性能的线程安全集合类，它们基于分段锁（Segment Lock）或其他无锁算法（如 CAS），性能优于传统的同步集合。</p><p><strong>常用类</strong></p><ul><li><strong><code>ConcurrentHashMap</code></strong>：<ul><li>线程安全的 <code>Map</code> 实现。</li><li>支持高并发访问，性能优于 <code>Hashtable</code>。</li><li>内部通过分段锁或 CAS 操作实现线程安全。</li></ul></li><li><strong><code>ConcurrentSkipListMap</code></strong>：<ul><li>线程安全的有序 <code>Map</code> 实现。</li><li>基于跳表（Skip List）实现。</li></ul></li><li><strong><code>ConcurrentSkipListSet</code></strong>：<ul><li>线程安全的有序 <code>Set</code> 实现。</li></ul></li><li><strong><code>ConcurrentLinkedQueue</code></strong>：<ul><li>线程安全的无界非阻塞队列。</li><li>基于链表实现，支持高并发。</li></ul></li><li><strong><code>ConcurrentLinkedDeque</code></strong>：<ul><li>线程安全的双端队列。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;C&quot;</span>, key -&gt; <span class="number">3</span>); <span class="comment">// 如果不存在则添加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>高性能，支持高并发。</li><li>提供了丰富的原子操作（如 <code>computeIfAbsent</code>、<code>merge</code> 等）。</li><li>适用于高并发场景。</li></ul><h5 id="阻塞队列（Blocking-Queue）"><a href="#阻塞队列（Blocking-Queue）" class="headerlink" title="阻塞队列（Blocking Queue）"></a>阻塞队列（Blocking Queue）</h5><p>阻塞队列是线程安全的队列，当队列为空或满时，会阻塞线程直到满足条件。</p><p><strong>常用类</strong></p><ul><li><strong><code>ArrayBlockingQueue</code></strong>：<ul><li>有界阻塞队列，基于数组实现。</li><li>需要指定容量。</li></ul></li><li><strong><code>LinkedBlockingQueue</code></strong>：<ul><li>无界或有界阻塞队列，基于链表实现。</li><li>默认情况下是无界的（容量为 <code>Integer.MAX_VALUE</code>）。</li></ul></li><li><strong><code>PriorityBlockingQueue</code></strong>：<ul><li>线程安全的优先级队列。</li><li>元素按优先级排序。</li></ul></li><li><strong><code>SynchronousQueue</code></strong>：<ul><li>不存储元素的阻塞队列。</li><li>每次插入操作必须等待一个对应的移除操作。</li></ul></li><li><strong><code>DelayQueue</code></strong>：<ul><li>用于延迟处理元素的阻塞队列。</li><li>元素只有在延迟时间到期后才能被取出。</li></ul></li></ul><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;C&quot;</span>); <span class="comment">// 队列满时阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">                System.out.println(queue.take()); <span class="comment">// 队列空时阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        producer.join();</span><br><span class="line">        consumer.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>适用于生产者-消费者模型。</li><li>提供了阻塞操作（如 <code>put</code> 和 <code>take</code>）。</li><li>可以控制队列的容量。</li></ul><h5 id="CopyOnWrite-系列集合"><a href="#CopyOnWrite-系列集合" class="headerlink" title="CopyOnWrite 系列集合"></a><code>CopyOnWrite</code> 系列集合</h5><p><code>CopyOnWrite</code> 系列集合适用于读多写少的场景，其核心思想是：每次修改时复制一份新的数据副本，从而避免读写冲突。</p><p><strong>常用类</strong></p><ul><li><strong><code>CopyOnWriteArrayList</code></strong>：<ul><li>线程安全的 <code>List</code> 实现。</li><li>适用于读操作远多于写操作的场景。</li></ul></li><li><strong><code>CopyOnWriteArraySet</code></strong>：<ul><li>基于 <code>CopyOnWriteArrayList</code> 实现的线程安全 <code>Set</code>。</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历（无需额外加锁）</span></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>修改操作（如 <code>add</code>、<code>remove</code>）会创建数据副本，因此写操作成本较高。</li><li>读操作不需要加锁，性能高。</li><li>不适合频繁写入的场景。</li></ul><div class="table-container"><table><thead><tr><th>集合类型</th><th>场景</th><th>特点</th></tr></thead><tbody><tr><td><code>Collections.synchronizedXxx()</code></td><td>简单线程安全需求</td><td>所有操作加锁，性能较低</td></tr><tr><td><code>Vector</code> / <code>Hashtable</code></td><td>兼容旧代码</td><td>过时，不推荐</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>读多写少</td><td>写操作成本高，读操作无需加锁</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>高并发场景</td><td>高性能，支持原子操作</td></tr><tr><td>阻塞队列（如 <code>ArrayBlockingQueue</code>）</td><td>生产者-消费者模型</td><td>提供阻塞操作，支持容量控制</td></tr></tbody></table></div><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="HashMap并发死链问题"><a href="#HashMap并发死链问题" class="headerlink" title="HashMap并发死链问题"></a>HashMap并发死链问题</h4><p><code>HashMap</code> 的底层实现是一个数组（桶）和链表/红黑树的结合。当发生哈希冲突时，多个键值对会被存储在同一个桶中，形成链表或红黑树。在多线程环境下，如果多个线程同时对 <code>HashMap</code> 进行写操作（如扩容或插入），可能会破坏链表的结构，导致链表形成环状结构（即死链）。</p><p><strong>具体原因：</strong></p><ul><li>扩容时的并发问题<ul><li>当 <code>HashMap</code> 的容量不足时，会触发扩容操作（<code>resize()</code> 方法），将旧数组中的元素重新分配到新数组中。</li><li>在多线程环境下，多个线程可能同时执行扩容操作，导致链表节点被错误地连接，形成环形链表。</li></ul></li><li>链表插入时的并发问题<ul><li>多个线程同时插入元素时，可能会导致链表节点的指针被错误地修改，从而形成环形链表。</li></ul></li></ul><p>一旦链表形成了环形结构，后续的读操作（如 <code>get()</code>）会在遍历链表时陷入无限循环。</p><p>为了避免 <code>HashMap</code> 的并发死链问题，可以采取以下几种解决方案：</p><p><strong>(1) 使用线程安全的集合类</strong></p><ul><li>使用ConcurrentHashMap替代HashMap<ul><li><code>ConcurrentHashMap</code> 是专门为多线程环境设计的线程安全集合类。</li><li>它通过分段锁（Segment Lock）或 CAS 操作来保证线程安全，避免了死链问题。</li></ul></li></ul><p><strong>(2) 手动加锁</strong></p><ul><li>如果必须使用 <code>HashMap</code>，可以通过 <code>synchronized</code> 或显式锁（如 <code>ReentrantLock</code>）来保护对其的修改操作。</li></ul><p><strong>(3) 使用 <code>Collections.synchronizedMap()</code> 包装</strong></p><ul><li>将 <code>HashMap</code> 包装成线程安全的集合。</li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="Maven✨"><a href="#Maven✨" class="headerlink" title="Maven✨"></a>Maven✨</h2><p><a href="https://maven.apache.org/guides/getting-started/index.html">Maven Getting Started Guide – Maven</a></p><p><a href="https://www.runoob.com/maven/maven-tutorial.html">Maven 教程 | 菜鸟教程</a></p><p><a href="https://www.bilibili.com/video/BV1Ah411S7ZE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">黑马程序员Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven_哔哩哔哩_bilibili</a></p><blockquote><p>项目中源码目录,资源文件夹目录等都是maven设置的</p></blockquote><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">${basedir}</td><td style="text-align:left">存放pom.xml和所有的子目录</td></tr><tr><td style="text-align:left">${basedir}/src/main/java</td><td style="text-align:left">项目的java源代码</td></tr><tr><td style="text-align:left">${basedir}/src/main/resources</td><td style="text-align:left">项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td style="text-align:left">${basedir}/src/test/java</td><td style="text-align:left">项目的测试类，比如说Junit代码</td></tr><tr><td style="text-align:left">${basedir}/src/test/resources</td><td style="text-align:left">测试用的资源</td></tr><tr><td style="text-align:left">${basedir}/src/main/webapp/WEB-INF</td><td style="text-align:left">web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td style="text-align:left">${basedir}/target</td><td style="text-align:left">打包输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/classes</td><td style="text-align:left">编译输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/test-classes</td><td style="text-align:left">测试编译输出目录</td></tr><tr><td style="text-align:left">Test.java</td><td style="text-align:left">Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td style="text-align:left">~/.m2/repository</td><td style="text-align:left">Maven默认的本地仓库目录位置</td></tr></tbody></table></div><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p><div class="table-container"><table><thead><tr><th style="text-align:left">节点</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">project</td><td style="text-align:left">工程的根标签。</td></tr><tr><td style="text-align:left">modelVersion</td><td style="text-align:left">模型版本需要设置为 4.0。</td></tr><tr><td style="text-align:left">groupId</td><td style="text-align:left">这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td></tr><tr><td style="text-align:left">artifactId</td><td style="text-align:left">这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td></tr><tr><td style="text-align:left">version</td><td style="text-align:left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></td></tr></tbody></table></div><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他常用元素"><a href="#其他常用元素" class="headerlink" title="其他常用元素"></a>其他常用元素</h3><p><strong>properties</strong>: 定义项目中的一些属性变量:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repositories: 定义项目的依赖库:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>dependencyManagement</strong>: 用于管理依赖的版本，特别是在多模块项目中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>profiles: 用于定义不同的构建配置，可以根据不同的环境进行构建：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>development<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>production<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承: 通过parent元素，一个POM文件可以继承另一个POM文件的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>聚合: 通过modules元素，一个POM文件可以管理多个子模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png" alt="img"></p><div class="table-container"><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">处理</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">验证 validate</td><td style="text-align:left">验证项目</td><td style="text-align:left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:left">编译 compile</td><td style="text-align:left">执行编译</td><td style="text-align:left">源代码编译在此阶段完成</td></tr><tr><td style="text-align:left">测试 Test</td><td style="text-align:left">测试</td><td style="text-align:left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left">包装 package</td><td style="text-align:left">打包</td><td style="text-align:left">将编译后的代码打包成可分发的格式，例如 JAR 或 WAR</td></tr><tr><td style="text-align:left">检查 verify</td><td style="text-align:left">检查</td><td style="text-align:left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:left">安装 install</td><td style="text-align:left">安装</td><td style="text-align:left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:left">部署 deploy</td><td style="text-align:left">部署</td><td style="text-align:left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table></div><p>为了完成 default 生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。</p><p>Maven 有以下三个标准的生命周期：</p><p><strong>1、Clean 生命周期：</strong></p><ul><li><strong>clean</strong>：删除目标目录中的编译输出文件。这通常是在构建之前执行的，以确保项目从一个干净的状态开始。</li></ul><p><strong>2、Default 生命周期（也称为 Build 生命周期）：</strong></p><ul><li><strong>validate</strong>：验证项目的正确性，例如检查项目的版本是否正确。</li><li><strong>compile</strong>：编译项目的源代码。</li><li><strong>test</strong>：运行项目的单元测试。</li><li><strong>package</strong>：将编译后的代码打包成可分发的格式，例如 JAR 或 WAR。</li><li><strong>verify</strong>：对项目进行额外的检查以确保质量。</li><li><strong>install</strong>：将项目的构建结果安装到本地 Maven 仓库中，以供其他项目使用。</li><li><strong>deploy</strong>：将项目的构建结果复制到远程仓库，以供其他开发人员或团队使用。</li></ul><p><strong>3、Site 生命周期：</strong></p><ul><li><strong>site</strong>：生成项目文档和站点信息。</li><li><strong>deploy-site</strong>：将生成的站点信息发布到远程服务器，以便共享项目文档。</li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>在 Maven 的术语中，仓库是一个位置（place）。</p><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。</p><p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。</p><p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p><p>Maven 仓库有三种类型：</p><ul><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ul><p>Maven 的本地仓库，<strong>在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建</strong>。</p><p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p><blockquote><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。</p></blockquote><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0    http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:/MyLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span> <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。</p><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p><p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p><p>中央仓库的关键概念：</p><ul><li>这个仓库由 Maven 社区管理。</li><li>不需要配置。</li><li>需要通过网络才能访问。</li></ul><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><p>举例说明，使用下面的 pom.xml，<strong>Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.common-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--自定义远程仓库--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。</p><p><strong>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件</strong>，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想使用其它代理仓库，可在 <strong><repositories></repositories></strong> 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在你的 pom.xml 文件 <strong><denpendencies></denpendencies></strong> 节点中加入你要引用的文件信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>[GROUP_ID]<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>[ARTIFACT_ID]<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>[VERSION]<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><strong><code>mvn clean</code></strong><ul><li>清理项目，删除 <code>target</code> 目录（该目录包含了编译和打包过程中生成的所有文件）。</li></ul></li><li><strong><code>mvn compile</code></strong><ul><li>编译项目的源代码。默认情况下，会查找 <code>src/main/java</code> 目录下的所有 <code>.java</code> 文件，并将编译后的 <code>.class</code> 文件输出到 <code>target/classes</code> 目录中。</li></ul></li><li><strong><code>mvn test</code></strong><ul><li>使用合适的单元测试框架（如 JUnit 或 TestNG）运行项目的测试代码。默认情况下，测试代码位于 <code>src/test/java</code> 目录下。</li></ul></li><li><strong><code>mvn package</code></strong><ul><li>将编译好的字节码打包成可分发的格式，例如 JAR 或 WAR 文件。这个命令首先执行 <code>compile</code> 和 <code>test</code>，然后将项目打包并存放在 <code>target</code> 目录中。</li></ul></li><li><strong><code>mvn install</code></strong><ul><li>安装打包好的构件到本地仓库（通常是用户主目录下的 <code>.m2/repository</code>），以便它可以被其他项目作为依赖使用。此命令还会执行 <code>package</code> 的所有步骤。</li></ul></li><li><strong><code>mvn deploy</code></strong><ul><li>在集成或发布阶段使用，用于将最终包复制到远程仓库，使得其他开发者或项目可以共享这个构件。</li></ul></li><li><strong><code>mvn site</code></strong><ul><li>生成关于项目的站点文档，包括测试覆盖率报告、依赖列表等信息。</li></ul></li><li><strong><code>mvn clean install</code></strong><ul><li>组合命令，先清理项目 (<code>clean</code>) 然后安装 (<code>install</code>) 到本地仓库。这是非常常见的组合，用于确保在干净环境下重新构建整个项目。</li></ul></li><li><strong><code>mvn dependency:tree</code></strong><ul><li>显示项目依赖树，有助于分析依赖冲突或了解项目依赖关系。</li></ul></li><li><strong><code>mvn archetype:generate</code></strong><ul><li>生成一个新的 Maven 项目结构，通过交互式的方式选择项目模板</li></ul></li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL✨"><a href="#MySQL✨" class="headerlink" title="MySQL✨"></a>MySQL✨</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一组操作的集合,不可分割的一个工作单位. 事务会把所有操作作为一个整体向系统提交或撤销操作,即这些操作要么同时成功,要么同时失败.</p><p>事务四大特性</p><ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。</li><li><strong>一致性（Consistency）</strong>：事务应该将数据库从一种一致状态转换为另一种一致状态。</li><li><strong>隔离性（Isolation）</strong>：并发事务之间相互隔离，不会互相干扰。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，所做的更改将是永久性的，即使系统发生故障也不会丢失。</li></ul><p><img data-src="https://s2.loli.net/2025/03/29/qaAURO3uTdrxlEY.png" alt="image-20250329225640854"></p><h5 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h5><p>多个事务并发进行的问题</p><h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p>一个事务读到另外一个事务还没有提交的数据</p><h6 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h6><p>一个事务先后读取同一条记录,但两次读取的数据不同,称之为不可重复读</p><h6 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h6><p>一个事务按照条件查询数据时,没有对应的数据行,但是在插入数据时,又发现这行数据已经存在</p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>MySQL 支持四种标准的事务隔离级别：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>:最低级别的隔离，允许脏读、不可重复读和幻读。</li><li><strong>读已提交（Read Committed）</strong>:防止脏读，但允许不可重复读和幻读。</li><li><strong>可重复读（Repeatable Read）</strong>:默认级别，防止脏读和不可重复读，但允许幻读。</li><li><strong>串行化（Serializable）</strong>:最高级别的隔离，完全防止脏读、不可重复读和幻读，但会降低并发性能。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">-- 或者</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p><strong>1. 默认情况下：事务需要显式提交</strong></p><ul><li>在 <code>START TRANSACTION</code> 开始一个事务后，所有对数据库的修改操作（如 <code>UPDATE</code>、<code>INSERT</code> 等）都只会暂时存在于事务的上下文中，而不会直接写入数据库。</li><li>这些更改对其他事务是不可见的（根据隔离级别），直到你显式调用 <code>COMMIT</code> 提交事务。</li><li>如果你调用 <code>ROLLBACK</code>，则所有的更改会被撤销，数据库恢复到事务开始前的状态。</li></ul><p><strong>2. 如果未提交且会话结束</strong></p><ul><li><p>如果你在事务中执行了更新语句，但没有显式调用COMMITROLLBACK</p><p>，然后会话意外终止（例如客户端断开连接），MySQL 的行为如下：</p><ul><li><strong>InnoDB 存储引擎</strong>（支持事务）：事务会被自动回滚，所有未提交的更改都会被撤销。</li><li><strong>MyISAM 存储引擎</strong>（不支持事务）：由于 MyISAM 不支持事务，所有操作会立即生效，无法回滚。</li></ul></li></ul><p><strong>3. autocommit 模式的影响</strong></p><ul><li>MySQL 默认开启了 <strong>autocommit 模式</strong>（<code>autocommit=1</code>）。在这种模式下，每条单独的 SQL 语句都会被视为一个独立的事务，并在执行后自动提交。</li><li>当你使用 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 时，会临时禁用 autocommit 模式，直到事务结束（通过 <code>COMMIT</code> 或 <code>ROLLBACK</code>）。</li><li>如果你没有显式提交事务，而会话结束时 autocommit 模式重新启用，InnoDB 会自动回滚未提交的事务。</li></ul><p><img data-src="https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png" alt="image-20250326191732721"></p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p><img data-src="https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png" alt="image-20250326192221989"></p><p><strong>1. InnoDB</strong></p><ul><li><p><strong>默认存储引擎</strong>：从 MySQL 5.5 开始成为默认存储引擎。</p></li><li><p>特性</p><ul><li><strong>事务支持</strong>：完全支持 ACID（原子性、一致性、隔离性、持久性）属性，适合需要高可靠性和数据一致性的应用。</li><li><strong>行级锁定</strong>：提供高效的并发处理能力，减少了锁冲突的可能性。</li></ul><blockquote><p>行级锁定是指在对数据进行操作时，只锁定受影响的具体行而不是整个表。这意味着在同一张表中，不同事务可以同时对不同的行进行读写操作。</p></blockquote><ul><li><strong>外键支持</strong>：唯一支持外键约束的存储引擎，有助于维护数据完整性和引用完整性。</li><li><strong>崩溃恢复</strong>：通过 redo 和 undo 日志实现快速崩溃恢复。</li><li><strong>聚簇索引</strong>：每个表都使用主键作为聚簇索引，提高了查询效率。</li></ul></li></ul><p><strong>2. MyISAM</strong></p><ul><li><strong>早期默认存储引擎</strong>：在 MySQL 5.5 之前是默认的存储引擎。</li><li>特性<ul><li><strong>不支持事务</strong>：适用于对事务要求不高、以读操作为主的场景。</li><li><strong>表级锁定</strong>：整个表被锁定进行写入操作，可能导致高并发下的性能瓶颈。</li><li><strong>全文索引</strong>：MyISAM 支持全文搜索，这在某些文本检索应用中非常有用。</li><li><strong>压缩表</strong>：可以创建只读压缩表，节省存储空间。</li><li><strong>简单高效</strong>：对于简单的查询操作，MyISAM 提供了较高的性能。</li></ul></li></ul><p><strong>3. Memory (Heap)</strong></p><ul><li><strong>内存中的表</strong>：数据存放在内存中，因此访问速度非常快。</li><li>特性<ul><li><strong>临时性</strong>：重启服务器后数据丢失，适用于缓存数据或临时计算。</li><li><strong>表级锁定</strong>：由于是内存操作，锁定粒度较粗并不会显著影响性能。</li><li><strong>哈希索引</strong>：默认使用哈希索引，对于精确匹配查询特别有效。</li><li><strong>不支持事务</strong>：与 MyISAM 类似，Memory 引擎也不支持事务。</li></ul></li></ul><p><img data-src="https://s2.loli.net/2025/03/29/TolUSndakcOP3ti.png" alt="image-20250329230207046"></p><p><img data-src="https://s2.loli.net/2025/03/29/zI1SvEeYGsfFkpy.png" alt="image-20250329230247585"></p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><img data-src="https://s2.loli.net/2025/03/29/TmRpyswKoazBdO3.png" alt="image-20250329230936523"></p><ul><li><strong>定义</strong>：索引是一种特殊的数据结构，用于加速数据库表中数据的检索速度。</li><li><strong>目的</strong>：减少查询时需要扫描的数据量，从而提高查询性能。</li><li><p><strong>代价</strong>：虽然索引可以加快查询速度，但它们也会占用额外的存储空间，并且在进行插入、更新和删除操作时会增加一些开销。</p><p><strong>B-Tree 索引</strong></p></li><li><p><strong>适用范围</strong>：这是 MySQL 中最常用的索引类型，默认情况下，<code>CREATE INDEX</code> 创建的就是 B-Tree 索引。</p></li><li><p>特点</p><ul><li>支持全键值、键值范围和键前缀查找（如 <code>LIKE &#39;abc%&#39;</code>）。</li><li>能够有效地支持等值查询和范围查询（例如 <code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>IN</code> 等）。</li><li>适用于大多数类型的比较操作（包括 <code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。</li></ul></li></ul><p><strong>(1) 阶数（Order）</strong></p><ul><li>B 树的阶数 t是一个定义其结构的重要参数。每个节点最多可以有 2t−1个键值，并且至少包含 t−1个键值（除了根节点外）。每个内部节点最多有 2t个子节点。</li><li><p>这种设计确保了树的高度保持较低，从而减少了查找所需的时间。<strong>(2) 节点类型</strong></p></li><li><p><strong>内部节点</strong>：除了叶子节点之外的所有节点。它们存储键值和指向子节点的指针。</p></li><li><strong>叶子节点</strong>：位于树的最底层，直接存储数据或指向数据的指针。</li></ul><p><strong>2. B+ 树（B+Tree）</strong></p><p><strong>定义</strong></p><ul><li>B+ 树是 B 树的一种变体，特别优化了范围查询性能。与 B 树不同的是，B+ 树的所有数据都存储在叶子节点中，而内部节点仅用于导航目的。</li></ul><p><strong>特点</strong></p><ul><li><strong>所有数据都在叶子节点</strong>：这意味着所有的实际数据记录都存储在叶子节点上，而不是分散在整棵树中。这样做的好处是可以将更多的键值放入内部节点，从而进一步降低树的高度。</li><li><strong>叶子节点链表</strong>：B+ 树的叶子节点通过双向链表连接在一起，这极大地提高了范围查询的效率，因为一旦定位到起始位置，就可以沿着链表顺序访问后续的数据。</li><li><strong>更高的分支因子</strong>：由于内部节点不存储数据，因此可以容纳更多的子节点指针，这有助于进一步减少树的高度，提高查找效率。</li></ul><p><strong>3. B 树 vs. B+ 树</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>B 树</th><th>B+ 树</th></tr></thead><tbody><tr><td><strong>数据存储位置</strong></td><td>内部节点和叶子节点都可以存储数据</td><td><strong>仅叶子节点存储数据</strong>，内部节点仅用于导航</td></tr><tr><td><strong>叶子节点连接</strong></td><td>不具备叶子节点间的直接连接</td><td><strong>叶子节点之间通过链表相连</strong>，便于范围查询</td></tr><tr><td><strong>树的高度</strong></td><td>较高，因为内部节点也需要存储数据</td><td>更低，因为<strong>内部节点可以存储更多键值</strong>，减少了树的高度</td></tr><tr><td><strong>适用场景</strong></td><td>适合于大多数基本查询操作</td><td>特别<strong>适合于范围查询</strong>和排序操作</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/29/dIRX1Fx5kQ2gPra.png" alt="image-20250329231556772"></p><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>B树</strong></th><th><strong>B+树</strong></th></tr></thead><tbody><tr><td><strong>数据存储</strong></td><td><strong>数据（key-value）存储在所有节点（叶子+内部）</strong></td><td><strong>数据仅存储在叶子节点</strong>，内部节点只存 key</td></tr><tr><td><strong>指针</strong></td><td><strong>内部节点的指针指向子节点</strong></td><td><strong>叶子节点间有额外的顺序指针（双向链表）</strong></td></tr><tr><td><strong>搜索</strong></td><td><strong>可以在非叶子节点找到数据</strong>，搜索可能提前结束</td><td><strong>必须走到叶子节点才能找到数据</strong>，查询路径固定</td></tr><tr><td><strong>范围查询</strong></td><td><strong>范围查询效率较低</strong>，需回溯</td><td><strong>范围查询效率高</strong>（叶子节点是链表，顺序扫描快）</td></tr><tr><td><strong>磁盘I/O</strong></td><td><strong>较多随机I/O</strong></td><td><strong>较少随机I/O，访问更快</strong></td></tr><tr><td><strong>树的高度</strong></td><td><strong>相对较高</strong></td><td><strong>相对较低</strong>（因为内部节点更小，能容纳更多 key）</td></tr></tbody></table></div><p><img data-src="https://s2.loli.net/2025/03/30/7TQF6gL1Cro5w2R.png" alt="image-20250330000450278"></p><p><img data-src="https://s2.loli.net/2025/03/29/H6AyOzY18MKCcPJ.png" alt="image-20250329231337759"></p><p><img data-src="https://s2.loli.net/2025/03/30/MXwuylP5fqpNBz4.png" alt="image-20250330000930507"></p><div class="table-container"><table><thead><tr><th>特性</th><th>聚集索引</th><th>二级索引</th></tr></thead><tbody><tr><td><strong>物理存储</strong></td><td>数据按索引键顺序存储</td><td>数据存储位置与索引无关，索引中包含指向数据行的指针</td></tr><tr><td><strong>数量限制</strong></td><td>每个表只能有一个</td><td>可以有多个</td></tr><tr><td><strong>查询效率</strong></td><td>对于按索引键排序的查询非常高效</td><td>需要两次查找（先找索引，再找数据行），但适用于多种查询条件</td></tr><tr><td><strong>更新开销</strong></td><td>更新可能导致大量数据重排，开销较大</td><td>更新仅需修改索引结构，开销相对较小</td></tr></tbody></table></div><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><p><strong>1. 使用 <code>EXPLAIN</code> 分析查询性能</strong></p><p>🔹 <code>EXPLAIN</code> 可以 <strong>分析 SQL 查询的执行计划</strong>，查看 <strong>索引使用情况</strong>、<strong>扫描方式</strong> 和 <strong>查询优化器的决策</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>关键字段解读</strong>：</p><div class="table-container"><table><thead><tr><th><strong>字段</strong></th><th><strong>作用</strong></th><th><strong>优化建议</strong></th></tr></thead><tbody><tr><td><code>id</code></td><td>查询的执行顺序</td><td>ID 越大，优先执行</td></tr><tr><td><code>select_type</code></td><td>查询类型</td><td><code>SIMPLE</code> 是最优</td></tr><tr><td><code>table</code></td><td>查询的表</td><td>确保表索引优化</td></tr><tr><td><code>type</code></td><td>访问类型</td><td><code>ALL</code>(全表扫描) 最差，<code>index</code>、<code>ref</code>、<code>range</code>、<code>const</code> 最优</td></tr><tr><td><code>possible_keys</code></td><td>可能使用的索引</td><td>如果 <code>NULL</code>，说明没有合适的索引</td></tr><tr><td><code>key</code></td><td>实际使用的索引</td><td>确保索引合理</td></tr><tr><td><code>rows</code></td><td>需要扫描的行数</td><td>越少越好</td></tr><tr><td><code>Extra</code></td><td>额外信息</td><td><strong>避免 <code>Using filesort</code> 和 <code>Using temporary</code></strong></td></tr></tbody></table></div><p>🔹 <strong>优化示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;test@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/30/jpQ7nwHN8rg34Jq.png" alt="image-20250330111354571"></p><p><strong>2. 使用 <code>SHOW PROFILE</code> 进行 SQL 运行时间分析</strong></p><p>🔹 <code>SHOW PROFILE</code> 详细分析 SQL <strong>在各个阶段的执行时间</strong>，如 <strong>解析、优化、执行、发送数据</strong>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEditSET profiling = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email = <span class="string">&#x27;test@example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br></pre></td></tr></table></figure><p>🔹 <strong>查看 SQL 具体耗时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE <span class="keyword">FOR</span> QUERY <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>优化方向</strong></p><ul><li><strong>如果 <code>sending data</code> 耗时长</strong> ➝ 可能需要优化索引或减少返回数据量。</li><li><strong>如果 <code>query optimization</code> 耗时长</strong> ➝ SQL 逻辑复杂，可以考虑优化子查询或 JOIN。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/KcSBGzw6C1W5Iho.png" alt="image-20250330112810495"></p><p><strong>3. 使用 <code>SHOW STATUS</code> 获取数据库运行状态</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Threads%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>关键指标</strong></p><div class="table-container"><table><thead><tr><th><strong>指标</strong></th><th><strong>作用</strong></th><th><strong>优化建议</strong></th></tr></thead><tbody><tr><td><code>Threads_running</code></td><td>当前正在执行的查询数</td><td><strong>避免长时间运行的查询</strong></td></tr><tr><td><code>Threads_connected</code></td><td>当前连接数</td><td><strong>优化连接池配置</strong></td></tr><tr><td><code>Slow_queries</code></td><td>慢查询数量</td><td><strong>检查慢查询日志</strong></td></tr><tr><td><code>Handler_read_rnd_next</code></td><td>全表扫描次数</td><td><strong>应减少</strong>（索引优化）</td></tr></tbody></table></div><p><strong>4. 慢查询日志分析</strong></p><p>🔹 <strong>开启慢查询日志</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 记录执行时间 &gt;1秒的查询</span></span><br></pre></td></tr></table></figure><p>🔹 <strong>查看慢查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.slow_log <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_time <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>🚀 <strong>优化方法</strong></p><ul><li><strong>使用索引，减少 <code>ALL</code> 扫描</strong></li><li><strong>优化 <code>JOIN</code>，避免 <code>Using temporary</code></strong></li><li><strong>避免 <code>ORDER BY</code> + <code>LIMIT</code> 造成的 <code>filesort</code></strong></li></ul><p><strong>5. 索引优化</strong></p><p><strong>（1）使用合适的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_name <span class="keyword">ON</span> users(name);</span><br></pre></td></tr></table></figure><ul><li><p><strong>单列索引</strong>：适用于<strong>单个查询字段</strong></p></li><li><p><strong>复合索引</strong>：适用于 <strong><code>WHERE col1 AND col2</code></strong></p></li><li><p><strong>前缀索引</strong>：适用于<strong>长字符串字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_email <span class="keyword">ON</span> users(email(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></li></ul><p><strong>（2）避免索引失效</strong></p><p>🔹 <strong>索引会失效的情况</strong></p><div class="table-container"><table><thead><tr><th><strong>错误写法</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><code>WHERE name LIKE &#39;%abc&#39;</code></td><td><code>%</code> 开头索引失效</td></tr><tr><td><code>WHERE DATE(create_time) = &#39;2024-03-30&#39;</code></td><td><strong>函数</strong> 使索引失效</td></tr><tr><td><code>WHERE id + 1 = 10</code></td><td><strong>计算操作</strong> 使索引失效</td></tr></tbody></table></div><p>🔹 <strong>优化索引查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：避免前导 %</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式 2：索引时间范围查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">&#x27;2024-03-30&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2024-03-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>6. SQL 语句优化</strong></p><p><strong>（1）避免 <code>SELECT \*</code></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>🔹 <strong>减少不必要的数据传输，提高查询效率</strong></p><p><strong>（2）避免 <code>OR</code>，改为 <code>UNION ALL</code></strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEdit<span class="comment">-- ❌ 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 改成 UNION ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>🔹 <strong><code>OR</code> 可能导致索引失效，而 <code>UNION ALL</code> 可提高性能</strong></p><p><strong>（3）避免 <code>NOT IN</code>，改用 <code>NOT EXISTS</code></strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEdit<span class="comment">-- ❌ NOT IN 可能导致全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 使用 NOT EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users u <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> u.id = o.user_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>🔹 <strong><code>NOT EXISTS</code> 在大数据量下查询效率更高</strong></p><div class="table-container"><table><thead><tr><th><strong>优化点</strong></th><th><strong>方法</strong></th></tr></thead><tbody><tr><td><strong>SQL 分析</strong></td><td><code>EXPLAIN</code>、<code>SHOW PROFILE</code></td></tr><tr><td><strong>索引优化</strong></td><td><code>CREATE INDEX</code>，避免索引失效</td></tr><tr><td><strong>慢查询优化</strong></td><td><code>SHOW SLOW LOGS</code>，减少 <code>SELECT *</code></td></tr><tr><td><strong>SQL 语句优化</strong></td><td><strong>避免 <code>OR</code>，使用 <code>EXISTS</code></strong></td></tr><tr><td><strong>缓存优化</strong></td><td><strong>使用 Redis</strong>，调整 <code>query_cache_size</code></td></tr><tr><td><strong>服务器配置优化</strong></td><td><strong>优化 <code>innodb_buffer_pool_size</code>、<code>max_connections</code></strong></td></tr></tbody></table></div><p><strong>1. 最左前缀法则</strong></p><p><strong>定义</strong></p><ul><li><p><strong>最左前缀法则</strong>指的是，在使用组合索引时，查询条件必须从索引的最左边开始匹配。只有满足这个规则，MySQL 才能利用该索引来加速查询。</p></li><li><p>例如，如果你在一个表上创建了一个组合索引</p></li></ul>  <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">col1</span>, col2, col3)</span><br></pre></td></tr></table></figure><p>  ，那么以下查询可以有效利用该索引：</p><p>  sql</p><p>  深色版本</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 = <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 = <span class="string">&#x27;value&#x27;</span> <span class="keyword">AND</span> col2 = <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 = <span class="string">&#x27;value&#x27;</span> <span class="keyword">AND</span> col2 = <span class="string">&#x27;value&#x27;</span> <span class="keyword">AND</span> col3 = <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  但是，如果查询条件不包含col1或者跳过了col1，则无法完全利用该索引：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能利用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col2 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col3 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><ul><li>组合索引实际上是对多个列进行排序后构建的索引结构。MySQL 在查找数据时，会首先根据索引中最左边的列进行过滤，然后再依次考虑后面的列。</li><li>因此，为了最大化索引的利用率，查询条件应该尽可能地从最左边的列开始，并且保持连续</li></ul><p>模糊查询,如果是头部进行模糊,索引不会失效.</p><p>在索引上进行运算,索引会失效.</p><p><strong>1. <code>LIKE</code> 以 <code>%</code> 开头</strong></p><p>❌ <strong>错误示例</strong>（索引失效，全表扫描）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>LIKE &#39;%XXX&#39;</code> <strong>前面有通配符</strong>，MySQL <strong>无法利用 B+ 树索引</strong>，只能<strong>全表扫描</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Alice%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><p><strong><code>Alice%</code> 结尾带 <code>%</code>，索引仍然有效</strong>。</p></li><li><p>若要支持前缀匹配，可 <strong>使用全文索引（FULLTEXT）</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlCopyEdit<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> FULLTEXT(name);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Alice&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. <code>OR</code> 可能导致索引失效</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><strong><code>name</code> 和 <code>age</code> 上都有索引</strong>，但 <code>OR</code> 让 MySQL <strong>无法同时使用多个索引</strong>，会导致全表扫描。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：使用 UNION（若 name 和 age 都有索引）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><code>UNION ALL</code> <strong>分两次查询，分别使用索引</strong>，<strong>避免全表扫描</strong>。</li></ul><p><strong>3. <code>NOT IN</code> 可能导致索引失效</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>NOT IN</code> 可能触发全表扫描，因为 MySQL 需要 <strong>检查每一行是否符合条件</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：改用 NOT EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> u.id <span class="operator">=</span> o.user_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong><code>NOT EXISTS</code> 性能更优</strong>，可有效利用索引。</li></ul><p><strong>4. 对索引列进行计算</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>id + 1 = 10</code> <strong>对索引字段进行了计算</strong>，导致 MySQL <strong>无法使用索引</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>尽量避免索引列上的计算</strong>。</li></ul><p><strong>5. 对索引列使用函数</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(phone, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;138&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>LEFT(phone, 3)</code> <strong>对 <code>phone</code> 列进行了函数操作</strong>，导致索引失效。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;138%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>避免对索引列使用函数</strong>，可以使用 <code>LIKE &#39;XXX%&#39;</code>。</li></ul><p><strong>6. 数据类型不匹配</strong></p><p>❌ <strong>错误示例</strong>（索引失效）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">13812345678</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><code>phone</code> 列是 <strong><code>VARCHAR(11)</code> 类型</strong>，但查询时传入的是 <strong>数值</strong>（<code>INT</code>）。</li><li>MySQL <strong>会进行隐式类型转换</strong>，导致索引失效。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13812345678&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>保证查询参数类型与索引列类型一致</strong>。</li></ul><p><strong>7. 范围查询 (<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>) 导致索引失效</strong></p><p>❌ <strong>错误示例</strong>（索引失效部分字段）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li><strong><code>age &gt; 30</code> 是范围查询</strong>，<strong>索引可能只用到 <code>age</code>，导致 <code>name</code> 不能被索引优化</strong>。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>调整查询字段顺序，让等值查询 (<code>=</code>) 在前</strong>，<strong>让 MySQL 更容易使用索引</strong>。</li></ul><p><strong>8. <code>ORDER BY</code> + <code>LIMIT</code> 可能导致索引失效</strong></p><p>❌ <strong>错误示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li>当 <code>LIMIT</code> 偏移量过大时，MySQL <strong>仍然会扫描大量数据</strong>，导致性能下降。</li></ul><p>✅ <strong>正确优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式 1：使用覆盖索引</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式 2：使用子查询优化</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10000</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>📌 <strong>优化点</strong>：</p><ul><li><strong>尽量减少 <code>LIMIT</code> 偏移量</strong>，可用 <strong>子查询</strong> 或 <strong>覆盖索引</strong> 提高效率。</li></ul><p><strong>索引失效的常见原因总结</strong></p><div class="table-container"><table><thead><tr><th>失效原因</th><th>解决方案</th></tr></thead><tbody><tr><td><code>LIKE &#39;%XXX&#39;</code></td><td>改为 <code>LIKE &#39;XXX%&#39;</code>，或使用 <code>FULLTEXT</code> 索引</td></tr><tr><td><code>OR</code></td><td>使用 <code>UNION ALL</code></td></tr><tr><td><code>NOT IN</code></td><td>使用 <code>NOT EXISTS</code></td></tr><tr><td>索引列计算</td><td>直接在 <code>WHERE</code> 子句中使用索引列</td></tr><tr><td>索引列使用函数</td><td>避免 <code>LEFT(phone, 3)</code>，改用 <code>LIKE &#39;XXX%&#39;</code></td></tr><tr><td>数据类型不匹配</td><td>查询参数类型与索引列类型一致</td></tr><tr><td>范围查询 (<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>)</td><td>让等值查询 (<code>=</code>) 在前</td></tr><tr><td><code>ORDER BY</code> + <code>LIMIT</code></td><td>使用覆盖索引或子查询优化</td></tr></tbody></table></div><p>在某些情况下，可以通过 <code>FORCE INDEX</code> 强制 MySQL 使用特定的索引，避免优化器选择全表扫描。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees FORCE INDEX (idx_department)</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：强制使用索引需要谨慎，因为优化器通常会选择最优的执行计划。如果强制使用不合适的索引，可能会适得其反</li></ul><p><strong>覆盖索引</strong></p><p>如果查询的所有列都包含在一个索引中，可以通过创建覆盖索引来避免回表操作，从而提高查询效率。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>假设查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure><p>可以创建以下覆盖索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_dept_salary <span class="keyword">ON</span> employees(department, salary);</span><br></pre></td></tr></table></figure><p>由于查询所需的所有列都在索引中，MySQL 可以直接通过索引返回结果，无需访问数据表(不需要回标)。</p><p><strong>前缀索引</strong></p><ul><li><strong>前缀索引</strong>是指对列中值的前 N 个字符或字节创建索引，而不是对整个列值进行索引。</li><li>这种方法特别适用于 <code>VARCHAR</code>、<code>TEXT</code> 和 <code>BLOB</code> 类型的列，这些列通常包含较长的数据。</li></ul><p>前缀索引（Prefix Index）是 MySQL 中一种特殊的索引类型，它允许你为列的值的前缀创建索引，而不是整个列的值。这种索引对于那些存储较长字符串的列特别有用，因为它可以显著减少索引的大小，同时仍然提供良好的查询性能</p><p>假设有一个博客系统，其中的文章标题可能很长，并且我们希望根据标题的部分内容进行搜索：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    content TEXT,</span><br><span class="line">    INDEX idx_title (title(<span class="number">50</span>))  <span class="comment">-- 对标题的前50个字符创建索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于存储长文本数据的列，除了前缀索引外，还可以考虑使用<strong>全文索引</strong>（Full-Text Index）。全文索引专门用于支持复杂的文本搜索功能，如自然语言查询和布尔查询。</p><p><strong>(1) 适用场景</strong></p><ul><li><strong>前缀索引</strong>：适合于简单的前缀匹配查询（如 <code>LIKE &#39;prefix%&#39;</code>）。</li><li><strong>全文索引</strong>：适合于复杂的文本搜索需求（如 <code>MATCH ... AGAINST</code>）。</li></ul><p><strong>(2) 性能对比</strong></p><ul><li>前缀索引更适合于快速定位具有特定前缀的记录，但在处理复杂的文本搜索时不如全文索引高效。</li><li>全文索引虽然功能强大，但构建和维护成本较高，尤其是在数据量较大的情况下。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/86OFTKqeLhJwMxY.png" alt="image-20250330133609570"></p><p><img data-src="https://s2.loli.net/2025/03/30/xTDM5wFYCa4g1rU.png" alt="image-20250330134534828"></p><p><img data-src="https://s2.loli.net/2025/03/30/VrLeJvdSgTYf79C.png" alt="image-20250330134512802"></p><h3 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图/存储过程/触发器"></a>视图/存储过程/触发器</h3><h4 id="视图-Views"><a href="#视图-Views" class="headerlink" title="视图 (Views)"></a>视图 (Views)</h4><p><strong>视图</strong>是基于SQL语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实表中的字段</p><ul><li><strong>虚拟表</strong>：视图并不在数据库中以存储的数据值集形式存在；行和列数据来自于定义视图的查询所引用的基本表，并且是在访问视图时动态生成的。</li><li><strong>简化复杂查询</strong>：可以将复杂的查询封装进视图中，使用户可以通过简单的查询来访问这些数据。</li><li><strong>安全性</strong>：通过视图限制对基础表的访问，从而提高安全性。例如，<strong>只允许用户通过视图查看特定的列或行</strong>。</li><li><strong>更新限制</strong>：并非所有视图都可以被更新。对于包含聚合函数、DISTINCT关键字、GROUP BY、HAVING等的视图，通常不能直接进行更新操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="存储过程-Stored-Procedures"><a href="#存储过程-Stored-Procedures" class="headerlink" title="存储过程 (Stored Procedures)"></a>存储过程 (Stored Procedures)</h3><p>定义</p><ul><li><strong>存储过程</strong>是一组为了完成特定功能的SQL语句集，经过编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</li></ul><p>特点与重点</p><ul><li><strong>性能优化</strong>：由于存储过程在创建时就已经进行了编译，因此在执行时速度更快。</li><li><strong>模块化编程</strong>：可以将复杂的业务逻辑封装到存储过程中，提高代码的重用性和可维护性。</li><li><strong>减少网络流量</strong>：通过将一系列操作封装在一个存储过程中，可以减少客户端与服务器之间的通信量。</li><li><strong>安全控制</strong>：可以为存储过程设置权限，从而控制谁可以执行哪些操作。</li></ul><p>创建示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- SQL statements here</span></span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="触发器-Triggers"><a href="#触发器-Triggers" class="headerlink" title="触发器 (Triggers)"></a>触发器 (Triggers)</h3><p>定义</p><ul><li><strong>触发器</strong>是一种特殊的存储过程，它不能被显式地调用，而是当一个与其关联的操作发生的时候自动触发执行。这些操作包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等。</li></ul><p>特点与重点</p><ul><li><strong>自动执行</strong>：无需人工干预即可自动执行，用于确保某些规则或流程的一致性。</li><li><strong>事务支持</strong>：触发器会参与到同一个事务中，这意味着如果触发器中的操作失败，则整个事务都会回滚。</li><li><strong>事件驱动</strong>：可以根据表上的插入、更新或删除操作来触发相应的逻辑。</li><li><strong>注意性能影响</strong>：虽然触发器提供了强大的功能，但不恰当地使用可能会导致性能问题，尤其是在高并发环境下。</li></ul><p>创建示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span>UPDATE<span class="operator">/</span><span class="keyword">DELETE</span> <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Trigger logic here</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>视图</strong>主要用于简化查询、增强安全性和提供抽象层。</li><li><strong>存储过程</strong>则侧重于执行效率、模块化编程和减少网络负载。</li><li><strong>触发器</strong>适用于需要在数据库层面自动响应特定事件的情况，如保持数据一致性或记录审计信息。</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁（Locking）是确保数据一致性和事务隔离级别的核心机制。通过锁定数据库中的资源，可以防止多个用户或进程同时对相同的数据进行修改而导致的数据不一致性问题。</p><p><strong>全局锁</strong> </p><p>全局读锁允许在锁定期间进行读操作，但阻止写操作。全局读锁通常用于备份操作或其他需要读取整个数据库的场景。通常使用 <code>FLUSH TABLES WITH READ LOCK</code> 语句来获取全局读锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line">mysqldump db <span class="operator">&gt;</span> xx.sql;</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p><strong>表级锁</strong>:锁定整个表，适用于高并发写入较少的场景。</p><p>表锁</p><p><code>LOCK TABLES</code> 语句用于在事务或会话中显式地锁定一张或多张表。锁定的表会根据需要加共享锁或排它锁，直到 <code>UNLOCK TABLES</code> 被调用。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES table_name READ;  <span class="comment">-- 给表加共享锁</span></span><br><span class="line">LOCK TABLES table_name WRITE;  <span class="comment">-- 给表加排它锁</span></span><br></pre></td></tr></table></figure><p><code>UNLOCK TABLES</code> 用于释放之前使用 <code>LOCK TABLES</code> 锁定的所有表。此命令会解除锁定，允许其他事务访问这些表。</p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p><strong>共享锁（S Lock 读锁）</strong></p><p>共享锁允许多个事务同时读取表中的数据，但阻止写操作。也就是说，多个事务可以同时持有共享锁并执行读取操作，但不能修改表中的数据。</p><ul><li><strong>共享锁的特点</strong>：<ul><li>允许多个事务并发读取同一个表的数据。</li><li>其他事务无法修改表中的数据，但可以进行读取操作。</li></ul></li></ul><p><strong>排它锁（X Lock 写锁）</strong></p><p>排它锁是一种更强的锁类型，当一个事务对某一表加了排它锁时，其他事务既不能读取也不能修改这个表中的数据。</p><ul><li><strong>排它锁的特点</strong>：<ul><li>只有持有排它锁的事务可以对表进行修改。</li><li>其他事务无法读取或修改这个表。</li></ul></li></ul><p>元数据锁</p><p>用于保护数据库元数据的一种锁机制。元数据指的是描述数据库结构的信息，比如表、索引、列、外键等数据库对象的定义。元数据锁的主要作用是<strong>防止在某些操作（如修改表结构）期间，其他操作对相同数据库对象的访问或修改</strong>，以保证元数据的一致性和完整性。</p><p><img data-src="https://s2.loli.net/2025/03/30/gA2pIsEbMSnZ3vc.png" alt="image-20250330141448484"></p><p>意向锁</p><p>意向锁是一种<strong>表级锁</strong>，它的作用并不是直接控制对数据的访问，而是<strong>表明某个事务希望对表中的某些行加锁</strong>，从而避免在加行级锁时与其他事务产生冲突。</p><p>当一个事务打算<strong>在某个表中对某些行加行级锁时，必须首先获取意向锁（IS 或 IX）来表明它的意图</strong>。这些意向锁会被 <strong>自动加上</strong>，因此，事务无需手动显式地设置意向锁。</p><ul><li><strong>意向共享锁（Intention Shared Lock, IS 锁）</strong>：<ul><li>表示事务打算在某些行上加共享锁（S 锁）。</li><li>其他事务仍然可以对该表加意向共享锁或意向排他锁，但不能加排他锁（X 锁）。</li></ul></li><li><strong>意向排他锁（Intention Exclusive Lock, IX 锁）</strong>：<ul><li>表示事务打算在某些行上加排他锁（X 锁）。</li><li>其他事务不能对该表加任何类型的锁（包括共享锁和排他锁），但可以加意向排他锁。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>当前锁 \ 请求锁</th><th>IS 锁</th><th>IX 锁</th><th>S 锁</th><th>X 锁</th></tr></thead><tbody><tr><td><strong>IS 锁</strong></td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>IX 锁</strong></td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td><strong>S 锁</strong></td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>X 锁</strong></td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table></div><p><strong>1. 使用 <code>SELECT ... FOR UPDATE</code> 触发意向排它锁（IX）</strong></p><p><code>SELECT ... FOR UPDATE</code> 语句会在查询的行上加上 <strong>排它锁（X）</strong>，同时在表级别加上 <strong>意向排它锁（IX）</strong>，表示这个事务打算对该表中的一些行加排它锁。这样做是为了避免多个事务在同一表上进行行级锁时产生冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 开始一个事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 对表中的某行数据加排它锁，并在表上加意向排它锁（IX）</span><br><span class="line">SELECT * FROM your_table WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>SELECT ... LOCK IN SHARE MODE</code> 触发意向共享锁（IS）</strong></p><p><code>SELECT ... LOCK IN SHARE MODE</code> 语句会在查询的行上加上 <strong>共享锁（S）</strong>，同时在表级别加上 <strong>意向共享锁（IS）</strong>，表示这个事务打算对该表中的一些行加共享锁。意向锁表明了事务打算进行共享锁操作，而不直接锁定整个表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 开始一个事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 对表中的某行数据加共享锁，并在表上加意向共享锁（IS）</span><br><span class="line">SELECT * FROM your_table WHERE id = 1 LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p><strong>行级锁</strong>:锁定特定的行，适用于高并发写入较多的场景，能提供更高的并发性能。</p><p><strong>记录锁（Record Locks）</strong></p><ul><li><strong>定义</strong>：记录锁是对索引记录加的锁。即使表没有定义索引，MySQL也会使用隐藏的主键索引来执行记录锁。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/dILW1GOJw7h5UAu.png" alt="image-20250330143657554"></p><p><img data-src="https://s2.loli.net/2025/03/30/3B4fXRhOl1Zqgoe.png" alt="image-20250330143737180"></p><p><img data-src="https://s2.loli.net/2025/03/30/P2bx8Qfzch4Wgsq.png" alt="image-20250330151445124"></p><p><strong>间隙锁（Gap Locks）</strong></p><p>用于锁定索引记录之间的间隙，或者锁定第一个索引记录之前或最后一个索引记录之后的空间。间隙锁主要用于防止其他事务在这个间隙中插入新的记录，从而避免幻读问题（Phantom Reads）。它通常在可重复读（Repeatable Read）隔离级别下工作</p><ul><li><strong>定义</strong>：间隙锁锁定的是索引记录之间的间隙，或者锁定第一个索引记录之前或最后一个索引记录之后的空间。主要用于防止幻读现象。</li><li><strong>适用范围</strong>：仅在可重复读（Repeatable Read）隔离级别下有效。</li></ul><p><strong>Next-Key Locks</strong></p><ul><li><strong>定义</strong>：Next-Key Locks 是记录锁与间隙锁的组合，锁定的是索引记录本身以及它之前的间隙。这种锁机制有效地解决了幻读问题</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/G7SjImNUFL8g1un.png" alt="image-20250330151930245"></p><p><img data-src="https://s2.loli.net/2025/03/30/FajEoXNZCSVrk3H.png" alt="image-20250330152702028"></p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p><strong>(1) 定义</strong></p><ul><li><strong>错误日志</strong>记录了 MySQL 服务器启动、运行或停止过程中遇到的问题，包括启动失败、崩溃以及一些警告信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variable like &#x27;%log_error%&#x27;</span><br></pre></td></tr></table></figure><p><strong>(2) 配置</strong></p><ul><li><p>默认情况下，错误日志通常位于数据目录下，文件名为 <code>hostname.err</code>(windows)。</p></li><li><p>可以通过修改配置文件my.cnf或my.ini来指定错误日志的位置和是否启用：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error=/path/<span class="keyword">to</span>/<span class="keyword">error</span>.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 二进制日志（Binary Log）</strong></p><p><strong>(1) 定义</strong></p><ul><li><strong>二进制日志</strong>记录了所有更改数据库内容的事件（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等），主要用于数据恢复和主从复制。</li></ul><p><strong>(2) 配置</strong></p><ul><li><p>启用二进制日志：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">log-bin</span>=/path/to/bin-log</span><br></pre></td></tr></table></figure></li><li><p>可以设置过期时间自动清理旧的日志文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expire_logs_days</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variable like &#x27;%log_bin%&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><img data-src="https://s2.loli.net/2025/03/30/wAtkHS1Z5zXsBpy.png" alt="image-20250330153408013"></p><p><img data-src="https://s2.loli.net/2025/03/30/idITAkyWSDp6m5M.png" alt="image-20250330153726345"></p><p><img data-src="https://s2.loli.net/2025/03/30/CRmDU9XvnuzKfbj.png" alt="image-20250330154122177"></p><p><strong>查询日志（General Query Log）</strong></p><p><strong>(1) 定义</strong></p><ul><li><strong>查询日志</strong>记录了所有客户端连接和执行的所有 SQL 语句，这对于调试和审计非常有用。</li></ul><p><strong>(2) 配置</strong></p><ul><li><p>可以通过以下方式启用查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>或者在配置文件中设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/path/to/query.log</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 使用场景</strong></p><ul><li>调试：当需要了解应用程序如何与数据库交互时，查询日志是一个很好的工具。</li><li>性能分析：虽然查询日志对性能有一定影响，但它可以用来识别慢查询或频繁执行的查询。</li></ul><p><strong>3. 慢查询日志（Slow Query Log）</strong></p><p><strong>(1) 定义</strong></p><ul><li><strong>慢查询日志</strong>记录了执行时间超过指定阈值的查询，有助于识别性能瓶颈。</li></ul><p><strong>(2) 配置</strong></p><ul><li><p>启用慢查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>设置慢查询的时间阈值（单位为秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 记录执行时间超过2秒的查询</span></span><br></pre></td></tr></table></figure><p>在配置文件中也可以进行相应的设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=/path/to/slow-query.log</span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 使用场景</strong></p><ul><li>性能优化：通过分析慢查询日志，可以找到执行效率低下的查询并进行优化。</li><li>监控：持续监控慢查询日志可以帮助及时发现性能问题。</li></ul><p><img data-src="https://s2.loli.net/2025/03/30/afxo4iHyzStjgPR.png" alt="image-20250330155227205"></p><h3 id="Join连接"><a href="#Join连接" class="headerlink" title="Join连接"></a>Join连接</h3><p>join连接两个表</p><ul><li><strong>INNER JOIN</strong>：仅返回两个表中满足连接条件的记录。</li><li><strong>LEFT JOIN</strong>（或LEFT OUTER JOIN）：返回左表中的所有记录，以及右表中满足连接条件的记录。若右表无匹配记录则填充NULL。</li><li><strong>RIGHT JOIN</strong>（或RIGHT OUTER JOIN）：返回右表中的所有记录，以及左表中满足连接条件的记录。若左表无匹配记录则填充NULL。</li><li><strong>FULL JOIN</strong>（或FULL OUTER JOIN）：返回两个表中的所有记录，任何表中无匹配记录的部分用NULL填充。（注意：MySQL不直接支持此语法）</li><li><strong>CROSS JOIN</strong>：产生两个表的笛卡尔积。</li><li><strong>SELF JOIN</strong>：一个表与自身的连接，适用于查询具有层次结构的数据。</li></ul><p><code>%</code> 可以匹配任意长度的字符串（包括空字符串），而 <code>_</code> 总是代表一个单一字符.在SQL中，默认情况下并没有一个预设的转义字符用于 <code>LIKE</code> 查询中的通配符（如 <code>%</code> 和 <code>_</code>）转义。这意味着，如果你需要转义这些特殊字符，你必须明确指定一个转义字符，并通过 <code>ESCAPE</code> 关键字来定义它。</p><p>尽管没有默认的转义字符，但你可以选择一个不会出现在目标字符串中的字符作为转义字符。常用的转义字符包括反斜杠 <code>\</code> 或者感叹号 <code>!</code> 等。下面是如何使用 <code>ESCAPE</code> 来定义转义字符的例子：</p><p>如果想查找包含实际百分比符号 <code>%</code> 的记录，可以这样做：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;%\%%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>\%</code> 表示实际的百分号字符 <code>%</code> 而不是通配符。</li><li><code>ESCAPE &#39;\&#39;</code> 告诉数据库 <code>\</code> 是转义字符。</li></ul><h2 id="PostgresSQL"><a href="#PostgresSQL" class="headerlink" title="PostgresSQL"></a>PostgresSQL</h2><p><a href="https://www.postgresql.org/">PostgreSQL: The world’s most advanced open source database</a></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/docs/guides/">Start with Guides - Start with Guides</a></p><h1 id="持久层框架"><a href="#持久层框架" class="headerlink" title="持久层框架"></a>持久层框架</h1><h2 id="Mybatis✨"><a href="#Mybatis✨" class="headerlink" title="Mybatis✨"></a>Mybatis✨</h2><p><a href="https://mybatis.org/mybatis-3/zh_CN/index.html">MyBatis 3 | 简介 – mybatis</a></p><p><a href="https://www.bilibili.com/video/BV1VP4y1c7j7/">【尚硅谷】MyBatis零基础入门教程（细致全面，快速上手mybatis）_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1JP4y1Z73S/">MyBatis视频零基础入门到进阶，MyBatis全套视频教程源码级深入详解_哔哩哔哩_bilibili</a></p><p>持久层框架,简化JDBC开发,负责数据库的读写.</p><p>JDBC问题:硬编码 操作繁琐</p><h3 id="查询单表数据整体流程"><a href="#查询单表数据整体流程" class="headerlink" title="查询单表数据整体流程"></a>查询单表数据整体流程</h3><ol><li>创建表,插入数据</li><li>创建模块,导入maven</li><li>编写mybatis核心配置文件(替换连接信息,解决硬编码)</li><li>编写sql映射文件(统一管理sql语句)</li><li>编码: 定义POJO类  加载核心配置文件,获取sqlsessionfactory对象,执行sql语句</li></ol><h3 id="使用Mapper代理开发"><a href="#使用Mapper代理开发" class="headerlink" title="使用Mapper代理开发"></a>使用Mapper代理开发</h3><blockquote><p>创建mapper类,该类名称与命名空间相同,方法申明与mapper映射xml文件相同</p></blockquote><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——<strong>使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png" alt="image-20250309134454871"></p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TypeAliases"><a href="#TypeAliases" class="headerlink" title="TypeAliases"></a>TypeAliases</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean,<strong>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</strong>。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typehandlers"><a href="#typehandlers" class="headerlink" title="typehandlers"></a>typehandlers</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p><h3 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  <span class="keyword">type</span>= Executor.class,</span><br><span class="line">  method = <span class="string">&quot;update&quot;</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,<span class="built_in">Object</span>.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="title">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">Object</span> intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    <span class="built_in">Object</span> returnObject = invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">setProperties</span>(<span class="params">Properties properties</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。</p><h3 id="xml映射器"><a href="#xml映射器" class="headerlink" title="xml映射器"></a>xml映射器</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 该命名空间的缓存配置。</li><li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li><li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li><del><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del></li><li><code>sql</code> – 可被其它语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><p>常用属性</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>parameterType</code></td><td>将会传入这条语句的参数的类全限定名或别名。<strong>这个属性是可选的，因为 MyBatis 可以根据语句中实际传入的参数计算出应该使用的类型处理器</strong>（TypeHandler），默认值为未设置（unset）。</td></tr><tr><td><del>parameterMap</del></td><td><del>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</del></td></tr><tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，<strong>如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型</strong>。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>resultMap</code></td><td><strong>对外部 resultMap 的命名引用</strong>。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr></tbody></table></div><p> 特殊字符处理,转义或CDATA区  </p><p>参数占位符:#{} ${}    </p><h3 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h3><p>​     鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。</p><p><img data-src="https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png" alt="image-20250310172440304"></p><p><img data-src="https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png" alt="image-20250310182221930"></p><p><strong>不需要使用 <code>@Param</code> 的情况</strong></p><ol><li><p><strong>单个参数</strong>：如果你的 Mapper 方法只接受一个参数，那么你不需要使用 <code>@Param</code> 注解。MyBatis 会自动将这个参数映射到 SQL 语句中的占位符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUserByUserName</span><span class="params">(String username)</span></span>;</span><br></pre></td></tr></table></figure><p>在对应的 XML 映射文件中可以直接引用该参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Java Bean 参数</strong>：如果你直接传递一个 Java Bean 对象作为参数，MyBatis 可以通过 OGNL 表达式访问 Bean 的属性，因此也不需要使用 <code>@Param</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUserByCondition</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在 XML 文件中可以通过点符号访问属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125; AND age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>需要使用 <code>@Param</code> 的情况</strong></p><ol><li><p><strong>多个简单类型参数</strong>：如果 Mapper 方法接受多个简单类型的参数（如 <code>int</code>, <code>String</code> 等），你需要使用 <code>@Param</code> 来为每个参数指定一个名称，以便在 SQL 语句中引用它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUsersByAgeAndUsername</span><span class="params">(<span class="meta">@Param(&quot;age&quot;)</span> <span class="keyword">int</span> age, <span class="meta">@Param(&quot;username&quot;)</span> String username)</span></span>;</span><br></pre></td></tr></table></figure><p>在 XML 文件中可以这样引用这些参数：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUsersByAgeAndUsername&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = #&#123;age&#125; <span class="keyword">AND</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>为了提高代码可读性</strong>：即使只有一个参数，有时候为了增加代码的可读性和明确性，也可以选择使用 <code>@Param</code> 注解来命名参数。</p></li><li><p><strong>Map 类型参数</strong>：当使用 Map 传递参数时，通常也需要指定键名来访问值。在这种情况下，虽然不强制要求使用 <code>@Param</code>，但你可以通过 Map 的键来访问值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; selectUsersByConditions(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; params);</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUsersByConditions&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = #&#123;age&#125; <span class="keyword">AND</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li>如果是单个参数或者传递的是 Java Bean，则通常不需要使用 <code>@Param</code>。</li><li>当方法有多个简单类型参数时，必须使用 <code>@Param</code> 来为每个参数指定名称，以便在 SQL 语句中引用。</li><li>使用 <code>@Param</code> 还有助于提高代码的可读性和维护性，尤其是在参数较多或逻辑较为复杂的情况下。</li></ul><blockquote><p>Java Bean 是一种符合特定规范的 Java 类，主要用于封装数据。它是 Java 中的一种标准，旨在使对象更容易被复用和管理，尤其是在可视化开发工具中。一个典型的 Java Bean 通常具有以下特征：</p><p><strong>特征</strong></p><ol><li><strong>私有属性</strong>：类中的成员变量应该是私有的（<code>private</code>），这意味着它们不能直接从类外部访问。</li><li><strong>无参构造器</strong>：必须提供一个公共的无参构造函数（默认构造器），以便能够实例化对象而不需要传递任何参数。这是为了确保可以通过反射机制创建对象实例，比如在框架内部（如Spring, MyBatis）。</li><li><strong>getter 和 setter 方法</strong>：对于每个私有属性，应该提供公共的 getter（获取值）和 setter（设置值）方法。这允许外部代码安全地访问和修改这些属性的值。</li><li><strong>可序列化</strong>（可选）：如果需要在网络上传输对象或者保存到文件中，那么这个类应该实现 <code>Serializable</code> 接口。</li></ol></blockquote><p><img data-src="https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png" alt="image-20250310110128114"></p><h3 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h3><p>返回结果如果包含多个值,可以使用map.</p><p>如果使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.someapp.model;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getHashedPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashedPassword</span><span class="params">(String hashedPassword)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashedPassword = hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。</p><p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.someapp.model.User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.someapp.model.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL 映射 XML 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这些情况下，<strong>MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上</strong>。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as &quot;id&quot;,</span><br><span class="line">    user_name           as &quot;userName&quot;,</span><br><span class="line">    hashed_password     as &quot;hashedPassword&quot;</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 <code>ResultMap</code>。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">  select user_id, user_name, hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>sql元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sometable&quot;</span>&gt;</span></span><br><span class="line">  $&#123;prefix&#125;Table</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;someinclude&quot;</span>&gt;</span></span><br><span class="line">  from</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;$&#123;include_target&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    field1, field2, field3</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;someinclude&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Some&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;include_target&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sometable&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在INSERT和UPDATE时,可以获取自增的字段值.设置useGeneratedKeys和<code>keyProperty</code></p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>useGeneratedKeys</code></td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr></tbody></table></div><ul><li><strong><code>&lt;insert&gt;</code></strong>：用于插入新记录，返回受影响的行数或通过配置获取自增主键。</li><li><strong><code>&lt;update&gt;</code></strong>：用于更新现有记录，返回受影响的行数。</li><li><strong><code>&lt;delete&gt;</code></strong>：用于删除记录，返回受影响的行数。</li></ul><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><p><img data-src="https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png" alt="image-20250310114956563"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值</p><blockquote><p>可以使用mybatisx插件提升开发效率</p></blockquote><p><strong>相关视频</strong></p><ol><li><a href="https://www.bilibili.com/video/BV1MT4y1k7wZ/">黑马mybatis教程全套视频教程，2天Mybatis框架从入门到精通_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1G5411H7F8">快速上手mybatis</a></li><li><a href="https://www.bilibili.com/video/BV1VP4y1c7j7">MyBatis零基础入门教程</a></li></ol><h3 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h3><p>MyBatis-Plus 是一个 MyBatis 的增强工具，旨在简化开发、减少工作量。它不仅<strong>封装了 CRUD 操作，还提供了代码生成器、分页插件</strong>等实用功能。</p><p>MyBatis-Plus 提供了 <code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 两个主要的条件构造器，用于进行复杂查询和更新操作。</p><p><strong>QueryWrapper</strong></p><p><code>QueryWrapper</code> 用于查询条件的构造，支持链式调用。</p><ul><li><strong>等值查询</strong>：<code>eq(&quot;name&quot;, &quot;Tom&quot;)</code></li><li><strong>范围查询</strong>：<code>between(&quot;age&quot;, 18, 30)</code></li><li><strong>模糊查询</strong>：<code>like(&quot;name&quot;, &quot;Tom&quot;)</code></li><li><strong>排序</strong>：<code>orderByAsc(&quot;age&quot;)</code>，<code>orderByDesc(&quot;age&quot;)</code></li><li><strong>分组查询</strong>：<code>groupBy(&quot;age&quot;)</code></li><li><strong>限制查询数量</strong>：<code>last(&quot;limit 10&quot;)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>).gt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; users = userService.list(queryWrapper);</span><br></pre></td></tr></table></figure><p><strong>UpdateWrapper</strong></p><p><code>UpdateWrapper</code> 用于更新操作，支持条件和修改字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">updateWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>).set(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">userService.update(<span class="keyword">null</span>, updateWrapper);</span><br></pre></td></tr></table></figure><p><strong>分页操作</strong></p><p><strong>分页查询</strong></p><p>MyBatis-Plus 提供了 <code>Page</code> 类用于分页查询。</p><ul><li><p><strong><code>page(Page&lt;T&gt; page)</code></strong>: 分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditPage&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);  <span class="comment">// 页码和每页条数</span></span><br><span class="line">Page&lt;User&gt; userPage = userService.page(page);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>page(Page&lt;T&gt; page, QueryWrapper&lt;T&gt; queryWrapper)</code></strong>: 带条件的分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">Page&lt;User&gt; userPage = userService.page(page, queryWrapper);</span><br></pre></td></tr></table></figure></li></ul><p>链式调用是一种非常方便的查询方式，它允许开发者通过流式 API 构建复杂的查询条件</p><div class="table-container"><table><thead><tr><th>类型</th><th>示例方法</th><th>功能描述</th></tr></thead><tbody><tr><td><strong>查询</strong></td><td><code>query()</code>, <code>lambdaQuery()</code></td><td>构建查询条件并获取结果</td></tr><tr><td><strong>更新</strong></td><td><code>update()</code>, <code>lambdaUpdate()</code></td><td>构建更新条件并执行更新</td></tr><tr><td><strong>删除</strong></td><td><code>remove()</code>, <code>lambdaRemove()</code></td><td>构建删除条件并执行删除</td></tr><tr><td><strong>条件组合</strong></td><td><code>and()</code>, <code>or()</code>, <code>nested()</code></td><td>支持复杂条件组合</td></tr><tr><td><strong>排序与分组</strong></td><td><code>orderByAsc()</code>, <code>orderByDesc()</code>, <code>groupBy()</code></td><td>支持排序、分组等操作</td></tr></tbody></table></div><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p><a href="https://www.geeksforgeeks.org/hibernate-native-sql/?ref=next_article_top">Hibernate - Native SQL - GeeksforGeeks</a></p><p><a href="https://docs.jboss.org/hibernate/orm/6.5/quickstart/html_single/#hibernate-gsg-tutorial-annotations-entity">Getting Started with Hibernate</a></p><p><strong>maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.6.10.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>配置文件hibernate.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Database connection settings</span></span><br><span class="line"><span class="meta">hibernate.connection.url</span>=<span class="string">jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1</span></span><br><span class="line"><span class="meta">hibernate.connection.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">hibernate.connection.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Echo all executed SQL to console</span></span><br><span class="line"><span class="meta">hibernate.show_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.format_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.highlight_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Automatically export the schema</span></span><br><span class="line"><span class="meta">hibernate.hbm2ddl.auto</span>=<span class="string">create</span></span><br></pre></td></tr></table></figure><p><strong>创建注解实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>   </span><br><span class="line"><span class="meta">@Table(name = &quot;Events&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span>   </span><br><span class="line"><span class="meta">@GeneratedValue</span>   </span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;eventDate&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> LocalDateTime date;</span><br><span class="line">    <span class="comment">//实体其他字段默认被认为是持久的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用sessionFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A SessionFactory is set up once for an application!</span></span><br><span class="line">    <span class="keyword">final</span> StandardServiceRegistry registry =</span><br><span class="line">            <span class="keyword">new</span> StandardServiceRegistryBuilder()</span><br><span class="line">                    .build();     </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sessionFactory =</span><br><span class="line">                <span class="keyword">new</span> MetadataSources(registry)             </span><br><span class="line">                        .addAnnotatedClass(Event.class)   </span><br><span class="line">                        .buildMetadata()                  </span><br><span class="line">                        .buildSessionFactory();           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// The registry would be destroyed by the SessionFactory, but we</span></span><br><span class="line">        <span class="comment">// had trouble building the SessionFactory so destroy it manually.</span></span><br><span class="line">        StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory.inTransaction(session -&gt; &#123;   </span><br><span class="line">    session.persist(<span class="keyword">new</span> Event(<span class="string">&quot;Our very first event!&quot;</span>, now()));   </span><br><span class="line">    session.persist(<span class="keyword">new</span> Event(<span class="string">&quot;A follow up event&quot;</span>, now()));</span><br><span class="line">&#125;);</span><br><span class="line">    sessionFactory.inTransaction(session -&gt; &#123;</span><br><span class="line">    session.createSelectionQuery(<span class="string">&quot;from Event&quot;</span>, Event.class)   </span><br><span class="line">            .getResultList()   </span><br><span class="line">            .forEach(event -&gt; out.println(<span class="string">&quot;Event (&quot;</span> + event.getDate() + <span class="string">&quot;) : &quot;</span> + event.getTitle()));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是native hibernate APIs</p><p>此外还可以使用JPA标准APIs</p><blockquote><p>5.x版本的hibernate使用cfg和hbm提供映射,但新版本已经不用了.</p></blockquote><p>&gt;</p><blockquote><p>JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。</p><p>需要注意的是JPA统一了Java应用程序访问ORM框架的规范</p><p><strong>JPA为我们提供了以下规范：</strong></p><ol><li>ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中</li><li>JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了</li><li>JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</li></ol></blockquote><h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><blockquote><p>Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p><p>Spring Data JPA是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。</p></blockquote><p><a href="https://docs.spring.io/spring-data/jpa/reference/repositories/core-concepts.html">Core concepts :: Spring Data JPA</a></p><p>Spring Data JPA往往搭配Spring以及SpringBoot使用.</p><p><strong>使用注解创建POJO类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>声明仓库接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">save</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;Person&gt; <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用仓库</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增加自定义的CRUD方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>; <span class="comment">// 根据名字查找用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照相关规范生成相应JPQL查询.</p><p>基本原则</p><ol><li><strong>实体属性作为基础</strong>：查询方法通常基于实体类中的属性名称构建。例如，如果你有一个 <code>User</code> 实体，并且这个实体有一个 <code>name</code> 属性，你可以创建一个以 <code>findByName</code> 开头的方法来查找具有特定名称的所有用户。</li><li><strong>关键词用于指定操作</strong>：在方法名中使用特定的关键字可以指定你想要执行的操作类型（如查找、计数等）以及查询条件（如等于、包含等）。</li></ol><p>对于更复杂的查询需求，如果方法名约定不能满足要求，可以使用 <code>@Query</code> 注解直接定义JPQL或原生SQL查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用原生SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)</span></span><br><span class="line"><span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="消息组件"><a href="#消息组件" class="headerlink" title="消息组件"></a>消息组件</h1><h2 id="Redis✨"><a href="#Redis✨" class="headerlink" title="Redis✨"></a>Redis✨</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>Redis 的主要特性</strong></p><ul><li><strong>高性能</strong>：所有数据都存储在内存中，读写速度非常快。</li><li><strong>持久化</strong>：支持 RDB 和 AOF 两种方式将内存中的数据保存到硬盘上，以防止数据丢失。</li><li><strong>复制功能</strong>：支持主从复制，可以提高系统的可用性和扩展性。</li><li><strong>事务支持</strong>：通过 MULTI, EXEC, DISCARD 和 WATCH 等命令实现简单的事务管理。</li><li><strong>发布订阅模式</strong>：支持 Pub/Sub 消息传递模式。</li><li><strong>Lua 脚本支持</strong>：允许用户执行自定义逻辑，保证原子性。</li><li><strong>键过期时间</strong>：可以为每个键设置生存时间，过期后自动删除。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis 主要支持以下几种数据类型：</p><ul><li><strong>string（字符串）:</strong> 基本的数据存储单元，可以存储字符串、整数或者浮点数。</li><li><strong>hash（哈希）:</strong>一个键值对集合，可以存储多个字段。</li><li><strong>list（列表）:</strong>一个简单的列表，可以存储一系列的字符串元素。</li><li><strong>set（集合）:</strong>一个无序集合，可以存储不重复的字符串元素。</li><li><strong>zset(sorted set：有序集合):</strong> 类似于集合，但是每个元素都有一个分数（score）与之关联。</li><li><strong>位图（Bitmaps）：</strong>基于字符串类型，可以对每个位进行操作。</li><li><strong>超日志（HyperLogLogs）：</strong>用于基数统计，可以估算集合中的唯一元素数量。</li><li><strong>地理空间（Geospatial）：</strong>用于存储地理位置信息。</li><li><strong>发布/订阅（Pub/Sub）：</strong>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。</li><li><strong>流（Streams）：</strong>用于消息队列和日志存储，支持消息的持久化和时间排序。</li><li><strong>模块（Modules）：</strong>Redis 支持动态加载模块，可以扩展 Redis 的功能。</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>基本编码方式是RAW,基于简单动态字符串实现. 存储上限512MB.</p><p>如果存储的SDS长度小于44字节,则会采用EMBSTR,此时object head与SDSS是连续空间.</p><p>如果是整数值,并且在LONG_MAX之内,采用INT编码.不需要SDS部分,ptr直接指向整数.</p><p><img data-src="https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png" alt="image-20250326102935636"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object encoding key <span class="comment"># 查询编码方式</span></span><br></pre></td></tr></table></figure><h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><p>从首、尾操作元素的列表</p><p><img data-src="https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png" alt="image-20250326103337835"></p><p><img data-src="https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png" alt="image-20250326104058671"></p><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><p>单列集合,不保证有序性,保证元素唯一,求交集、并集和差集.</p><p>set采用HT编码(Dict),key用来存储元素,value统一为null.</p><p>当存储的所有数据为整数,并且元素数量不超过set-max-intset-entries时,Set会采用IntSet编码,节省内存.</p><p><img data-src="https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png" alt="image-20250326105453513"></p><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>每个元素指定一个score值</p><p><img data-src="https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png" alt="image-20250326111021533"></p><p><img data-src="https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png" alt="image-20250326111516132"></p><p><img data-src="https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png" alt="image-20250326112849287"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><img data-src="https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png" alt="image-20250326113333031"></p><p><img data-src="https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png" alt="image-20250326113448318"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓冲中和数据库中都不存在,这样缓存永远不会起作用,这些请求直接访问数据库.</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>对于查询结果为空的数据，也可以将其缓存起来（通常设置较短的过期时间），这样当同样的请求再次到来时，可以直接从缓存中获取结果而不需要访问数据库。</p><p><img data-src="https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png" alt="image-20250325171102410"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存获取数据</span></span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果缓存未命中，则尝试从数据库获取</span></span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对于不存在的数据也进行缓存，但设置较短的过期时间</span></span><br><span class="line">        cache.put(key, <span class="string">&quot;NULL&quot;</span>, SHORT_EXPIRE_TIME);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点:实现简单,维护方便</p><p>缺点:额外的内存消耗,可能造成短期的不一致</p><h4 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h4><p>使用布隆过滤器可以在内存中高效地判断一个元素是否在一个集合中。它通过多个哈希函数将元素映射到位数组中的几个点，设置这些点为1。查询时，只要有一个对应的位不是1，就可以确定该元素不在集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例伪代码</span></span><br><span class="line">BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), expectedInsertions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载所有可能存在的key到布隆过滤器中</span></span><br><span class="line"><span class="keyword">for</span> (String key : allPossibleKeys) &#123;</span><br><span class="line">    bloomFilter.put(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bloomFilter.mightContain(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png" alt="image-20250325173115631"></p><p>在实际应用中，你可以在查询之前先用布隆过滤器检查是否存在该键，只有当布隆过滤器认为该键可能存在时，才去数据库查询并更新缓存。</p><ul><li><strong>优点</strong>：节省空间且查询速度快。</li><li><strong>缺点</strong>：有一定的误判率，即可能存在某些元素实际上不在集合中却被认为存在的假阳性情况，但对于缓存穿透问题来说，这通常是可接受的。</li></ul><p>其他方法</p><p> <strong>接口限流与用户行为分析</strong></p><p><strong>合理的缓存策略设计</strong></p><p><img data-src="https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png" alt="image-20250325175340534"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某个时间段内，<strong>大量的缓存数据同时过期失效，导致大量请求直接打到后端数据库或其他数据源上</strong>，造成服务器负载急剧增加，甚至可能导致系统崩溃的现象。这种情况通常发生在缓存层突然不可用或者缓存策略设计不合理时。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><strong>设置不同的缓存过期时间</strong></li></ol><p>随机化过期时间,为避免大量缓存同时过期，可以在设定缓存的有效期时加入一定的随机性。例如，原本所有缓存的有效期都是1小时，现在可以设置成1小时±5分钟，这样可以分散缓存失效的时间点。</p><ol><li><strong>双缓存机制</strong></li></ol><p>实现两个级别的缓存，一级缓存用于快速响应请求，二级缓存则在一级缓存失效时提供支持。当一级缓存中的数据过期后，仍然可以从二级缓存中获取数据，从而减轻对数据库的压力。</p><p><strong>其他</strong></p><p>利用Redis集群提高服务可用性</p><p>给缓存业务添加降级限流策略</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指一个非常热门的key，在缓存失效的瞬间，大量的请求同时访问这个key，由于此时缓存中没有该数据（已经过期或被删除），这些请求会直接打到数据库上，导致数据库压力骤增。这种情况类似于“击穿”了缓存层，直接冲击后端存储。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>1,  互斥锁</p><p>使用互斥锁可以在缓存失效时只允许一个线程去查询数据库并更新缓存，其他线程等待该线程完成后再从缓存中读取数据。这种方法能有效避免大量线程同时访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String lockKey = <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 缓存未命中</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey.intern()) &#123; <span class="comment">// 使用字符串内部池作为锁对象</span></span><br><span class="line">            value = cache.get(key); <span class="comment">// 再次检查缓存，防止其他线程已经填充了缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                value = db.query(key); <span class="comment">// 查询数据库</span></span><br><span class="line">                cache.put(key, value); <span class="comment">// 更新缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png" alt="image-20250325205849705"></p><p>利用<code>setnx</code>实现互斥逻辑.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> solvePassthrough(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 查询缓存是否存在</span></span><br><span class="line">    <span class="keyword">String</span> s = redisTemplate.opsForValue().<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在直接返回</span></span><br><span class="line">        <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不存在 s==null,表示不存在</span></span><br><span class="line">        <span class="comment">// 2. 缓存不存在，尝试拿锁</span></span><br><span class="line">        Boolean b = tryLock(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="comment">//3. 拿到锁，查询数据库</span></span><br><span class="line">            <span class="comment">//&quot;select * from table where key = &quot; + key;</span></span><br><span class="line">            <span class="keyword">String</span> result = <span class="string">&quot;result&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据库查询 没找到数据</span></span><br><span class="line">                <span class="comment">// 设置空缓存对象 避免缓存穿透</span></span><br><span class="line">                redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">key</span>, <span class="string">&quot;&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                unlock(<span class="built_in">key</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 查询数据库后，将数据放入缓存</span></span><br><span class="line">            redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">key</span>, result, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//5. 释放锁</span></span><br><span class="line">            unlock(<span class="built_in">key</span>);</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4. 没有拿到锁,等待重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> solvePassthrough(<span class="built_in">key</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(<span class="built_in">key</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Boolean tryLock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Boolean b = redisTemplate.opsForValue().setIfAbsent(<span class="built_in">key</span>, <span class="string">&quot;1&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    redisTemplate.delete(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.逻辑过期</p><p>对于一些极其重要的热点数据，可以考虑将其缓存设置为永不过期。但是这种方式需要配合后台异步任务定期刷新缓存中的数据，以确保数据的时效性。</p><p><img data-src="https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png" alt="image-20250325205936982"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个后台任务定期执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshHotData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String hotKey = <span class="string">&quot;hot_data&quot;</span>;</span><br><span class="line">    Object newValue = db.query(hotKey); <span class="comment">// 从数据库获取最新数据</span></span><br><span class="line">    cache.put(hotKey, newValue); <span class="comment">// 更新缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务逻辑中获取数据时，直接从缓存读取即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getHotData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(<span class="string">&quot;hot_data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以增加过期时间,在业务层进行判断,如果实际已经过期(此时Redis中仍有数据,因为没有超过TTL). 则创建线程更新数据并写入缓存(加锁),原本线程返回过期数据.</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png" alt="image-20250325182959630"></p><h3 id="内存持久化"><a href="#内存持久化" class="headerlink" title="内存持久化"></a>内存持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份</p><p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。</p><p>basave会fork主进程得到子进程,子进程共享主进程的内存数据,完成fork后读取内存数据写入RDB文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING </span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png" alt="image-20250325220031131"></p><p><img data-src="https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png" alt="image-20250325220501005"></p><p><img data-src="https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png" alt="image-20250325220624058"></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>APPEND ONLY  MODE</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span> APPEND ONLY MODE <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line">appendonly <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png" alt="image-20250325221116370"></p><p>使用<code>bgrewriteaof</code>节省AOF文件,因为记录的AOF命令可能多余(比如后面的更新了前面的值)</p><p><img data-src="https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png" alt="image-20250325222257850"></p><p><img data-src="https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png" alt="image-20250325222328632"></p><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 提供了一种简单的事务机制，它<strong>允许用户将多个命令打包成一个事务进行执行</strong>。与传统数据库中的事务不同<strong>，Redis 的事务并不支持回滚（rollback）操作</strong>。</p><p>Redis 事务的关键命令</p><ul><li><strong>MULTI</strong>：标记一个事务块的开始。一旦调用了 <code>MULTI</code> 命令，客户端会进入事务模式，在这种模式下所有的后续命令都会被放入队列中等待执行，而不是立即执行。</li><li><strong>EXEC</strong>：执行所有在 <code>MULTI</code> 和 <code>EXEC</code> 之间的命令。当调用 <code>EXEC</code> 时，Redis 会顺序地执行事务队列中的每个命令，并返回每个命令的结果。</li><li><strong>DISCARD</strong>：取消事务，放弃执行事务队列中的所有命令并退出事务模式。</li><li><p><strong>WATCH</strong>：用于监控一个或多个键，如果这些键在事务执行之前被其他客户端修改了，则事务会被中断，<code>EXEC</code> 返回 <code>nil</code> 表示事务未成功执行。这为 Redis 提供了一种乐观锁机制。</p></li><li><p><strong>原子性</strong>：虽然 Redis 的事务保证了命令序列要么全部执行，要么一个都不执行，但是 Redis 并不支持回滚功能。这意味着如果有任何命令执行失败，其余命令仍将继续执行。</p></li><li><strong>乐观锁</strong>：通过 <code>WATCH</code> 命令实现的乐观锁机制可以在一定程度上解决并发修改的问题。例如，在对某个键进行修改前先 <code>WATCH</code> 它，然后执行一系列的操作，最后通过 <code>EXEC</code> 提交事务。如果在这期间有其他客户端修改了该键，则当前事务将被中断，<code>EXEC</code> 将返回 <code>nil</code>。</li></ul><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">... <span class="comment"># 其他客户端可能在此期间修改了 mykey</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey newValue</span><br><span class="line">EXEC <span class="comment"># 如果 mykey 在 WATCH 后被修改过，EXEC 将返回 nil</span></span><br></pre></td></tr></table></figure><h2 id="RabbitMQ✨"><a href="#RabbitMQ✨" class="headerlink" title="RabbitMQ✨"></a>RabbitMQ✨</h2><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ol><li><strong>Topic（主题）</strong></li></ol><ul><li>Kafka 中的 Topic 类似于数据库中的表，用于对消息进行分类。每个消息都会被发布到一个特定的 Topic 下。</li></ul><ol><li><strong>Partition（分区）</strong></li></ol><ul><li>每个 Topic 可以被划分为多个 Partition，Partition 是 Kafka 中数据的基本存储单元。每个 Partition 内部的消息是有序的。</li></ul><ol><li><strong>Producer（生产者）</strong></li></ol><ul><li>Producer 是向 Kafka 中发布消息的客户端应用程序。它将消息发送到指定的 Topic。<a href="https://kafka.apachecn.org/1/?utm_source=chatgpt.com">kafka.apachecn.org+1support.huaweicloud.com+1</a></li></ul><ol><li><strong>Consumer（消费者）</strong></li></ol><ul><li>Consumer 是从 Kafka 中订阅并消费消息的客户端应用程序。它从指定的 Topic 中读取消息。</li></ul><ol><li><strong>Consumer Group（消费者组）</strong></li></ol><ul><li>Consumer Group 是一组 Consumer 的集合，Kafka 会将一个 Topic 的消息分发给 Consumer Group 中的各个 Consumer，每个消息只会被 Consumer Group 中的一个 Consumer 消费。<a href="https://www.cnblogs.com/zjdxr-up/p/15000181.html?utm_source=chatgpt.com">博客园</a></li></ul><ol><li><strong>Broker（代理）</strong></li></ol><ul><li>Broker 是 Kafka 集群中的一个节点，负责接收、存储和转发消息。一个 Kafka 集群由多个 Broker 组成。<a href="https://www.cnblogs.com/zjdxr-up/p/15000181.html?utm_source=chatgpt.com">博客园</a></li></ul><ol><li><strong>Cluster（集群）</strong></li></ol><ul><li>Kafka 集群由多个 Broker 组成，提供高可用性和水平扩展能力。每个 Broker 都可以处理消息的读写请求。<a href="https://blog.csdn.net/weixin_37693463/article/details/144621118?utm_source=chatgpt.com">CSDN+1CSDN+1</a></li></ul><ol><li><strong>Zookeeper</strong></li></ol><ul><li>Zookeeper 是 Kafka 的协调服务，用于管理和协调 Kafka 集群中的 Broker 元数据。Kafka 2.8.0 以后，Kafka 引入了 KRaft 模式，逐步减少对 Zookeeper 的依赖。</li></ul><ol><li><strong>Offset（偏移量）</strong></li></ol><ul><li>Offset 是 Kafka 中每条消息在 Partition 中的唯一标识符。Consumer 通过 Offset 来追踪已消费的消息。</li></ul><ol><li><strong>Replication（副本）</strong></li></ol><ul><li>Kafka 支持对 Topic 的 Partition 进行副本复制，以提高数据的可靠性和容错能力。每个 Partition 可以有多个副本，其中一个副本为 Leader，其他为 Follower。</li></ul><ol><li><strong>Retention（消息保留）</strong></li></ol><ul><li>Kafka 允许设置消息的保留策略，可以根据时间（如 7 天）或空间（如 1 GB）来控制消息的保留期限。超过保留期限的消息会被删除。</li></ul><ol><li><strong>Consumer Lag（消费者滞后）</strong></li></ol><ul><li>Consumer Lag 是指 Consumer 当前消费的 Offset 与 Partition 中最新消息的 Offset 之间的差距。较大的 Consumer Lag 可能意味着 Consumer 的消费速度跟不上生产者的生产速度。</li></ul><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h1 id="网络编程框架"><a href="#网络编程框架" class="headerlink" title="网络编程框架"></a>网络编程框架</h1><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。它简化了网络编程的复杂性，使得开发者能够专注于业务逻辑而非底层细节。以下是 Netty 的一些重要概念、经典例子以及在使用时需要注意的地方。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ol><li><strong>Channel</strong>：表示一个打开的连接，可以是TCP/IP连接、UDP连接等。每个Channel都关联了一个ChannelPipeline，用于处理入站和出站事件。</li><li><strong>EventLoop</strong>：负责处理Channel上的I/O操作。每个EventLoop通常绑定到单个线程上，并且管理多个Channel实例。</li><li><strong>ChannelHandler</strong>：实现对Channel中数据的处理逻辑。它可以是入站处理器（如解码器）或出站处理器（如编码器）。ChannelHandler可以通过ChannelPipeline链式地组织起来。</li><li><strong>ChannelPipeline</strong>：为每个Channel提供一个ChannelHandler实例的链表结构，用于处理通道中的事件流。你可以根据需要添加、删除或替换这些处理器。</li><li><strong>Bootstrap 和 ServerBootstrap</strong>：分别用于配置客户端和服务端的启动参数。它们提供了简单的方法来设置各种属性，比如通道类型、事件循环组等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(<span class="number">8080</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started and listening on &quot;</span> + f.channel().localAddress());</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server received: &quot;</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring家族✨"><a href="#Spring家族✨" class="headerlink" title="Spring家族✨"></a>Spring家族✨</h1><p>Spring提供依赖注入(DI),控制反转(IOC),面向切面编程等,为Java开发提供便利.而SpringMVC提供了比纯Servlet更好的开发体验.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.MyServlets;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 2025/3/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By proanimer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Servlet实现web请求响应</span></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: workspace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: org.example.MyServlets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: MyServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/10 20:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;MyServlet&quot;, urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = resp.getWriter()) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;title&gt;MyServlet&lt;/title&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h1&gt;MyServlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p><a href="https://spring.io/quickstart">Spring | Quickstart</a></p><p><a href="https://www.cainiaojc.com/spring/spring-tutorial.html">Spring 教程 - Spring教程 - 菜鸟教程</a></p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><blockquote><p>依赖注入（DI）是 IoC 的一种特殊形式，其中对象仅通过构造函数参数、工厂方法参数或在对象实例构建或从工厂方法返回后设置的属性来定义其依赖（即它们与之一起工作的其他对象）。IoC 容器在创建 bean 时注入这些依赖。这个过程本质上是 bean 本身通过直接构建类或如Service Locator pattern等机制控制其依赖的实例化或位置的反向（因此得名，控制反转）。</p></blockquote><p>Spring 框架支持多种配置方式，包括<strong>基于 XML 的配置</strong>、<strong>基于注解的配置</strong>以及<strong>基于 Java 配置类</strong>的配置。</p><blockquote><p>spring6.x版本官方文档已经不再详细说xml配置,主流是java配置类.</p></blockquote><ul><li><strong>XML 配置</strong>：适用于传统的 Spring 应用程序，提供了对 Spring 容器的详细控制。</li><li><strong>注解配置</strong>：减少了 XML 配置的需求，使得代码更加简洁，但可能不如 XML 配置那样直观地看到整个应用程序的结构。</li><li><strong>Java 配置类</strong>：提供了一种类型安全的方式来配置 Spring 应用程序，尤其适合新的项目或微服务架构。</li></ul><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基石。 <code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。</p><blockquote><p>Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，比如<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p></blockquote><p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li>更容易与 Spring 的 AOP 功能集成</li><li>消息资源处理（用于国际化）</li><li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集</p><p><strong>ApplicationContext容器实现类</strong>：</p><div class="table-container"><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td><strong>ClassPathXmlApplicationContext</strong></td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td><strong>AnnotationConfigApplicationContext</strong></td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table></div><p>IoC 容器的基本职责包括：</p><ul><li>实例化 Bean。</li><li>设置 Bean 的属性值和生命周期回调。</li><li>管理 Bean 之间的依赖关系。</li><li>控制 Bean 的作用域（如 singleton, prototype 等）。</li></ul><p>Spring 提供了两种类型的 IoC 容器：</p><ul><li><strong>BeanFactory</strong>：提供了基础的功能来管理和操作 Bean，适合资源受限的环境。</li><li><strong>ApplicationContext</strong>：扩展了 <code>BeanFactory</code>，增加了事件发布、国际化支持、AOP 集成等功能，适用于大多数应用场合。</li></ul><p>通常情况下，开发者更倾向于使用 <code>ApplicationContext</code>，因为它提供了更多的功能和便利性。</p><p><strong>2. ApplicationContext 的实现类</strong></p><p>Spring 提供了几种 <code>ApplicationContext</code> 的实现类，每种都有其特定的应用场景：</p><ul><li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的 XML 文件加载 Bean 定义。</li><li><strong>FileSystemXmlApplicationContext</strong>：从文件系统中指定位置的 XML 文件加载 Bean 定义。</li><li><strong>AnnotationConfigApplicationContext</strong>：用于基于 Java 注解的配置，不依赖于 XML 文件。</li><li><strong>WebApplicationContext</strong>：专为 Web 应用设计，支持 Servlet 上下文，并且可以方便地集成到 Web 应用程序中。</li></ul><p><strong>3. Bean 定义</strong></p><p>在 Spring 中，Bean 定义是描述如何创建一个 Bean 的元数据。可以通过以下方式定义 Bean：</p><ul><li><strong>XML 配置文件</strong>：传统方式，通过 XML 文件定义 Bean 及其依赖关系。</li><li><strong>注解</strong>：例如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等，配合 <code>@Autowired</code> 或构造函数注入。</li><li><strong>Java 配置类</strong>：使用 <code>@Configuration</code> 和 <code>@Bean</code> 注解定义 Bean。</li></ul><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;constructor-arg&gt;</code> 标签用于在 XML 配置文件中定义构造函数注入所需的参数。通过该标签，你可以指定将哪些值或 Bean 注入到目标类的构造函数中。<code>&lt;constructor-arg&gt;</code> 支持多个属性来帮助精确地匹配和注入依赖，主要包括 <code>name</code>, <code>value</code>, <code>index</code>, 和 <code>type</code> 等属性。下面详细介绍这些属性的意义：</p><ol><li><code>name</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的名字。</p></li><li><p><strong>适用场景</strong>：当目标类的构造函数使用命名参数时，可以通过 <code>name</code> 属性明确指定要注入哪个参数。不过需要注意的是，Spring 在早期版本中并不直接支持按名称注入构造参数，而是根据类型和顺序（索引）进行匹配。从 Spring 3.0 开始，如果使用 CGLIB 来增强字节码，则可以支持基于名称的构造函数注入。</p></li><li><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;paramName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;someValue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>value</code></li></ol><ul><li><p><strong>用途</strong>：直接为基本数据类型或 String 类型的构造函数参数提供值。</p></li><li><p><strong>适用场景</strong>：适用于需要传递简单类型的值作为构造函数参数的情况。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, World!&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里”Hello, World!”将被作为第一个参数传递给ExampleClass的构造函数。</p></li></ul><ol><li><code>index</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的位置索引，以确定向哪个参数注入值。</p></li><li><p><strong>适用场景</strong>：当你有多个构造函数参数并且想要精确控制哪个参数接收哪个值时非常有用。</p></li><li><p><strong>注意事项</strong>：索引是从 0 开始的。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;First Argument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>type</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的数据类型，帮助 Spring 容器更准确地选择合适的构造函数（特别是在存在重载构造函数的情况下）。</p></li><li><p><strong>适用场景</strong>：当你有多个同名但不同类型的构造函数参数时，或者你需要确保特定类型的值被注入时使用。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;String Argument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>Java配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRepository <span class="title">myRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRepositoryImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl(myRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ClientService&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>利用工厂类的静态方法</p><h4 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h4><p>利用工厂的实例方法</p><p>首先定义工厂 Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ServiceFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后，使用这个工厂 Bean 的方法来创建目标 Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;serviceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里假设 <code>ServiceFactory</code> 类中有一个名为 <code>createClientServiceInstance</code> 的方法，用于创建并返回一个新的 <code>ClientService</code> 实例。</p><p><strong>注解方式创建工厂Bean</strong></p><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ZoneId</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String zone = <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZoneId <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p><p><strong>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了</strong>。</p><h4 id="实例化后设置属性"><a href="#实例化后设置属性" class="headerlink" title="实例化后设置属性"></a>实例化后设置属性</h4><p>这是最常见的 Bean 实例化方式之一，在 Bean 被实例化之后，通过 setter 方法设置其属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;property1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;property2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ExampleBean</code> 有两个属性 <code>property1</code> 和 <code>property2</code>，它们分别通过 <code>set</code> 方法被赋值</p><h4 id="注解Annotation配置"><a href="#注解Annotation配置" class="headerlink" title="注解Annotation配置"></a>注解Annotation配置</h4><p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p><p>可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p><p><code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p><h4 id="使用Java配置类"><a href="#使用Java配置类" class="headerlink" title="使用Java配置类"></a>使用Java配置类</h4><h4 id="Bean的声明周期管理"><a href="#Bean的声明周期管理" class="headerlink" title="Bean的声明周期管理"></a>Bean的声明周期管理</h4><p><strong>Bean 生命周期的基本流程</strong></p><p>一个典型的 Spring Bean 生命周期包括以下几个步骤：</p><ol><li><strong>实例化</strong>：根据配置元数据（如 XML 配置、Java 注解或 Java 配置类），Spring 容器首先实例化 Bean。</li><li><strong>设置属性值</strong>：将 Bean 实例化后，Spring 会为该 Bean 设置属性值和其他依赖注入。</li><li><strong>初始化前</strong>：如果实现了 <code>Aware</code> 系列接口（例如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>），则调用这些接口的方法，让 Bean 能够感知其环境信息。</li><li><strong>BeanPostProcessor 前处理</strong>：如果存在实现了 <code>BeanPostProcessor</code> 接口的 Bean，则调用其 <code>postProcessBeforeInitialization</code> 方法。这是对所有 Bean 都适用的一个扩展点。</li><li><strong>初始化</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，则调用 <code>afterPropertiesSet()</code> 方法。</li><li>如果指定了 <code>&lt;bean&gt;</code> 元素的 <code>init-method</code> 属性或使用了 <code>@PostConstruct</code> 注解，则调用指定的初始化方法。</li></ul></li><li><strong>BeanPostProcessor 后处理</strong>：接着再次调用实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization</code> 方法。</li><li><strong>使用阶段</strong>：此时 Bean 已经准备好并可以被应用程序使用了。</li><li><strong>销毁阶段</strong>：<ul><li>当容器关闭时，如果 Bean 实现了 <code>DisposableBean</code> 接口，则调用 <code>destroy()</code> 方法。</li><li>如果指定了 <code>&lt;bean&gt;</code> 元素的 <code>destroy-method</code> 属性或使用了 <code>@PreDestroy</code> 注解，则调用指定的销毁方法。</li></ul></li></ol><p><strong>2. 控制 Bean 生命周期的关键接口和注解</strong></p><ul><li><strong><code>Aware</code> 系列接口</strong>：用于让 Bean 感知到容器的一些信息。<ul><li><code>BeanNameAware</code>: 获取 Bean 的名称。</li><li><code>BeanFactoryAware</code>: 获取 BeanFactory。</li><li><code>ApplicationContextAware</code>: 获取 ApplicationContext。</li></ul></li><li><strong><code>BeanPostProcessor</code> 接口</strong>：提供两个方法用于前后处理 Bean 初始化逻辑。<ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code> 在初始化之前调用。</li><li><code>postProcessAfterInitialization(Object bean, String beanName)</code> 在初始化之后调用。</li></ul></li><li><strong><code>InitializingBean</code> 接口</strong>：提供 <code>afterPropertiesSet()</code> 方法，在所有属性设置完成后执行自定义初始化逻辑。</li><li><strong><code>DisposableBean</code> 掀口</strong>：提供 <code>destroy()</code> 方法，在容器关闭时执行清理工作。</li><li><strong>注解支持</strong>：<ul><li><code>@PostConstruct</code>：标注在方法上，表示这是一个初始化方法。</li><li><code>@PreDestroy</code>：标注在方法上，表示这是一个销毁方法。</li></ul></li></ul><p>在 Spring 框架中，Bean 的作用域（Scope）决定了 Bean 实例的作用范围和生命周期。Spring 提供了多种内置的作用域类型，每种类型适用于不同的场景。理解这些作用域可以帮助你更好地控制 Bean 的行为，确保它们在应用程序中的正确使用。</p><blockquote><ol><li><strong>实例化（Instantiation）</strong>：<ul><li>Spring容器根据Bean定义的信息创建Bean的实例。</li></ul></li><li><strong>属性赋值（Populate）</strong>：<ul><li>Spring容器将配置文件中的属性值或者依赖注入到Bean实例中。这一步通常通过setter方法完成，也可以通过构造函数注入。</li></ul></li><li><strong>设置其他属性</strong>：<ul><li>如果Bean实现了<code>BeanNameAware</code>接口，Spring会调用<code>setBeanName(String name)</code>方法，传入Bean的名字。</li><li>如果Bean实现了<code>BeanFactoryAware</code>接口，Spring会调用<code>setBeanFactory(BeanFactory beanFactory)</code>方法，传入BeanFactory的实例。</li><li>如果Bean实现了<code>ApplicationContextAware</code>接口，Spring会调用<code>setApplicationContext(ApplicationContext applicationContext)</code>方法，传入ApplicationContext的实例。</li></ul></li><li><strong>初始化前处理（Initialization Before Processing）</strong>：<ul><li>如果有实现<code>BeanPostProcessor</code>接口的后处理器，它们的<code>postProcessBeforeInitialization(Object bean, String beanName)</code>方法会被调用。</li></ul></li><li><strong>初始化（Initialization）</strong>：<ul><li>如果Bean实现了<code>InitializingBean</code>接口，Spring会调用其<code>afterPropertiesSet()</code>方法。</li><li>如果在XML配置中指定了<code>init-method</code>属性，那么对应的自定义初始化方法也会被调用。</li><li>也可以使用<code>@PostConstruct</code>注解来指定初始化方法。</li></ul></li><li><strong>初始化后处理（Initialization After Processing）</strong>：<ul><li>如果有实现<code>BeanPostProcessor</code>接口的后处理器，它们的<code>postProcessAfterInitialization(Object bean, String beanName)</code>方法会被调用。</li></ul></li><li><strong>使用Bean</strong>：<ul><li>此时Bean已经完全初始化，可以正常使用了。</li></ul></li><li><strong>销毁前处理（Destruction Before Processing）</strong>：<ul><li>当容器关闭时，如果Bean实现了<code>DisposableBean</code>接口，Spring会调用其<code>destroy()</code>方法。</li><li>如果在XML配置中指定了<code>destroy-method</code>属性，那么对应的自定义销毁方法也会被调用。</li><li>同样可以使用<code>@PreDestroy</code>注解来指定销毁方法。</li></ul></li></ol></blockquote><p><strong>1. 常见的 Bean 作用域</strong></p><p><strong>(1) Singleton（单例）</strong></p><ul><li><strong>默认作用域</strong>：如果未指定作用域，默认为 <code>singleton</code>。</li><li><strong>行为</strong>：Spring 容器在整个应用上下文中只会创建一个该类型的 Bean 实例，并且所有对该 Bean 的请求都会返回这个唯一的实例。</li><li><strong>适用场景</strong>：大多数情况下，特别是对于无状态的服务类，如服务层、数据访问层等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或通过注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) Prototype（原型）</strong></p><ul><li><strong>行为</strong>：每次对 Bean 的请求都会创建一个新的实例。</li><li><strong>适用场景</strong>：当需要每次获取到的是一个新的对象实例时使用，例如命令对象、Web 控制器等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或通过注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有Request,Session和Application等作用域.</p><h4 id="选择性实例化Bean"><a href="#选择性实例化Bean" class="headerlink" title="选择性实例化Bean"></a>选择性实例化Bean</h4><p>选择性实例化 Bean 是指根据某些条件动态决定是否创建某个 Bean 实例。Spring 提供了多种机制来实现这种功能，例如使用注解、配置文件或编程方式</p><p><strong>使用 <code>@Conditional</code> 注解</strong></p><p><code>@Conditional</code> 是 Spring 中的一个核心注解，用于根据特定条件决定是否加载某个 Bean。</p><p><strong>(1) 工作原理</strong></p><ul><li><code>@Conditional</code> 接受一个实现了 <code>Condition</code> 接口的类作为参数。</li><li>在运行时，Spring 会调用 <code>Condition</code> 的 <code>matches()</code> 方法，如果返回 <code>true</code>，则加载该 Bean；否则跳过。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义条件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查系统属性 &quot;my.condition&quot; 是否为 true</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.parseBoolean(System.getProperty(<span class="string">&quot;my.condition&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加载 MyBean</span></span><br><span class="line">java -jar app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 MyBean</span></span><br><span class="line">java -Dmy.condition=<span class="literal">true</span> -jar app.jar</span><br></pre></td></tr></table></figure><p><code>@Profile</code> 是 Spring 中的一种更简单的条件加载机制，它根据当前激活的环境（profile）来决定是否加载某个 Bean。</p><p><strong>(1) 工作原理</strong></p><ul><li>每个 <code>@Profile</code> 注解可以指定一个或多个 profile 名称。</li><li>只有当这些 profile 被激活时，对应的 Bean 才会被加载。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">devBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">&quot;Development Environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">prodBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">&quot;Production Environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 测试</strong></p><p>启动程序时，可以通过指定激活的 profile 来加载不同的 Bean：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活开发环境</span></span><br><span class="line">java -Dspring.profiles.active=dev -jar app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活生产环境</span></span><br><span class="line">java -Dspring.profiles.active=prod -jar app.jar</span><br></pre></td></tr></table></figure><p><strong>使用 FactoryBean 动态创建 Bean</strong></p><p><code>FactoryBean</code> 是 Spring 提供的一种接口，用于动态创建 Bean 实例。</p><p><strong>(1) 工作原理</strong></p><ul><li>实现 <code>FactoryBean</code> 接口，并重写 <code>getObject()</code> 方法。</li><li>在运行时，Spring 会调用 <code>getObject()</code> 方法来获取实际的 Bean 实例。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">MyBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactory</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Bean creation is disabled!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyBean.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBeanFactory <span class="title">myBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanFactory(Boolean.getBoolean(<span class="string">&quot;factory.bean.enabled&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>版本</th><th>Bean 自动覆盖行为</th></tr></thead><tbody><tr><td><strong>Spring Boot 2.0</strong></td><td>允许用户定义相同类型的 Bean，Spring Boot 预置 Bean 被跳过。</td></tr><tr><td><strong>Spring Boot 2.1+</strong></td><td>Spring Boot 检测到多个相同类型 Bean 时，可能会有警告。</td></tr><tr><td><strong>Spring Boot 2.4+</strong></td><td><strong>默认不允许手动定义的 Bean 覆盖自动配置的 Bean</strong>（可通过 <code>spring.main.allow-bean-definition-overriding=true</code> 启用）。</td></tr><tr><td><strong>Spring Boot 3.0+</strong></td><td>仍然默认不允许覆盖 Bean，除非手动启用 <code>allow-bean-definition-overriding</code>。</td></tr></tbody></table></div><h3 id="如何实现依赖注入"><a href="#如何实现依赖注入" class="headerlink" title="如何实现依赖注入"></a>如何实现依赖注入</h3><p>依赖注入是 IoC 的一种实现方式，允许对象定义其依赖关系而不必自行创建或查找依赖的对象。Spring 支持三种依赖注入类型：</p><ul><li><strong>构造器注入</strong>：通过构造函数参数注入依赖。</li><li><strong>Setter 方法注入</strong>：通过 setter 方法注入依赖。</li><li><strong>字段注入</strong>：直接在字段上使用 <code>@Autowired</code> 注解进行注入。</li></ul><p>当 Spring 应用启动时，IoC 容器会根据 <code>@Autowired</code> 注解的信息去寻找相应的 Bean 并将其注入到目标对象中。以下是几种常见的注入方式：</p><ol><li><strong>构造函数注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自 Spring 4.3 起可以省略，如果只有一个构造函数的话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceUser</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，Spring 将会查找类型为 <code>MyService</code> 的 Bean，并将其注入到 <code>ServiceUser</code> 类的构造函数中。</li></ul><ol><li><strong>字段注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService; <span class="comment">// 直接注入 MyService 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段注入是最简单的形式，但它可能会导致难以进行单元测试，因为它绕过了类的构造函数。</li></ul><ol><li><strong>Setter 方法注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Setter 方法注入适合于那些可选依赖或希望在运行时更改依赖的情况</li></ul><p><strong>Bean 查找规则</strong></p><p>Spring 容器按照以下顺序尝试解析依赖：</p><ol><li><strong>类型匹配</strong>：首先<strong>基于参数类型</strong>查找匹配的 Bean。</li><li><strong>名称匹配</strong>：如果<strong>有多个相同类型的 Bean 存在，则根据参数名作为 Bean 名称进行匹配</strong>。</li><li><strong>限定符（Qualifiers）</strong>：当存在多个相同类型的 Bean 且名称也不足以区分时，可以使用 <code>@Qualifier</code> 注解指定确切的 Bean 名称</li></ol><p>如果你希望给 Bean 指定一个不同于方法名的名称，可以通过 <code>@Bean</code> 注解的 <code>name</code> 属性来实现或者 <code>@Qualifier</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;zoneZ&quot;)</span></span><br><span class="line"><span class="function">ZoneId <span class="title">createZoneOfZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;zoneUTC8&quot;)</span></span><br><span class="line"><span class="function">ZoneId <span class="title">createZoneOfUTC8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Autowired</code> 标记的构造函数、字段或方法会被 Spring 容器扫描，并尝试找到匹配的 Bean 来注入。如果找到多个匹配的 Bean，则可能需要通过 <code>@Qualifier</code> 注解来指定具体的 Bean。</p><p>Spring 提供了多种注解用于实现依赖注入。以下是常用的注入注解及其用途：</p><p><strong>1. 核心注入注解</strong></p><p><strong>(1) <code>@Autowired</code></strong></p><ul><li><strong>作用</strong>：自动注入依赖对象。</li><li>位置:<ul><li>构造器</li><li>方法（如 setter 方法）</li><li>字段</li><li>参数</li></ul></li><li>特点<ul><li><strong>默认按类型（byType）</strong>进行匹配。</li><li>如果有多个相同类型的 Bean，则会抛出异常，需要结合 <code>@Qualifier</code> 使用。 注解用在构造器,setter,属性上和方法参数上</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入 UserRepository</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) <code>@Qualifier</code></strong></p><ul><li><strong>作用</strong>：当存在多个相同类型的 Bean 时，指定要注入的具体 Bean。</li><li><strong>配合</strong>：通常与 <code>@Autowired</code> 配合使用。</li><li><strong>特点</strong>：<strong>通过名称（byName）</strong>来限定注入的 Bean。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userRepositoryV1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV1</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;userRepositoryV2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userRepositoryV1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 注入 UserRepositoryV1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) <code>@Primary</code></strong></p><ul><li><strong>作用</strong>：<strong>标记一个 Bean 为首选 Bean，当有多个相同类型的 Bean 时优先注入该 Bean</strong>。</li><li><strong>特点</strong>：无需显式使用 <code>@Qualifier</code>，简化配置。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV1</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入 UserRepositoryV1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) <code>@Resource</code></strong></p><ul><li><strong>作用</strong>：JSR-250 规范提供的注解，用于注入依赖。</li><li>特点<ul><li><strong>默认按名称（byName）</strong>进行匹配。</li><li><strong>如果未找到匹配的名称，则按类型（byType）匹配</strong>。</li></ul></li><li><strong>区别</strong>：<code>@Resource</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。(推荐Resource而不是Autowired)  注解用在属性上和setter上.</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userRepository&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 按名称注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(5) <code>@Inject</code></strong></p><ul><li><strong>作用</strong>：JSR-330 规范提供的注解，功能类似于 <code>@Autowired</code>。</li><li>特点:<ul><li>默认按类型（byType）进行匹配。</li><li>需要引入 <code>javax.inject</code> 包。</li></ul></li><li><strong>区别</strong>：<code>@Inject</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 高级注入注解</strong></p><p><strong>(6) <code>@Value</code></strong></p><ul><li><strong>作用</strong>：注入简单的值（如字符串、数字）、系统属性或配置文件中的值。</li><li><strong>特点</strong>：支持占位符 <code>$&#123;&#125;</code> 和 SpEL 表达式 <code>#&#123;&#125;</code>。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName; <span class="comment">// 注入配置文件中的 app.name</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;2 + 3&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum; <span class="comment">// 注入表达式的计算结果 (2 + 3 = 5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(7) <code>@ConfigurationProperties</code></strong></p><ul><li><strong>作用</strong>：批量注入配置文件中的属性到一个 Java 对象中。</li><li><strong>特点</strong>：适合处理复杂的配置结构。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件 (<code>application.properties</code>)：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.version</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p><strong>(8) <code>@Lookup</code></strong></p><ul><li><strong>作用</strong>：用于方法注入，每次调用方法时都会返回一个新的 Bean 实例。</li><li><strong>场景</strong>：适用于原型（Prototype）作用域的 Bean。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeBean</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PrototypeBean <span class="title">getPrototypeBean</span><span class="params">()</span></span>; <span class="comment">// 每次调用返回新的实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 其他相关注解</strong></p><p><strong>(9) <code>@Required</code></strong></p><ul><li><strong>作用</strong>：标记某个 setter 方法必须注入值，否则抛出异常。</li><li><strong>注意</strong>：从 Spring 5 开始已被废弃，推荐使用构造器注入或 <code>@Autowired(required = true)</code>。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(10) <code>@Lazy</code></strong></p><ul><li><strong>作用</strong>：延迟加载 Bean，只有在第一次使用时才会被创建。</li><li><strong>特点</strong>：可以减少启动时间，适用于不常用的功能。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBean</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LazyBean lazyBean; <span class="comment">// 延迟加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><div class="table-container"><table><thead><tr><th>注解</th><th>功能描述</th><th>特点</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td>自动注入依赖，按类型匹配</td><td>默认按类型，支持配合 <code>@Qualifier</code> 使用</td></tr><tr><td><code>@Qualifier</code></td><td>指定要注入的 Bean 名称</td><td>按名称匹配</td></tr><tr><td><code>@Primary</code></td><td>标记首选 Bean</td><td>简化多 Bean 场景下的注入</td></tr><tr><td><code>@Resource</code></td><td>按名称或类型注入</td><td>JSR-250 标准注解</td></tr><tr><td><code>@Inject</code></td><td>按类型注入</td><td>JSR-330 标准注解</td></tr><tr><td><code>@Value</code></td><td>注入简单值或配置文件中的值</td><td>支持占位符和 SpEL</td></tr><tr><td><code>@ConfigurationProperties</code></td><td>批量注入配置文件中的属性</td><td>适合复杂配置</td></tr><tr><td><code>@Lookup</code></td><td>方法注入，每次返回新实例</td><td>适用于原型作用域</td></tr><tr><td><code>@Required</code></td><td>强制要求注入</td><td>已废弃，推荐使用其他方式</td></tr><tr><td><code>@Lazy</code></td><td>延迟加载 Bean</td><td>减少启动时间</td></tr></tbody></table></div><h3 id="AOP的底层原理"><a href="#AOP的底层原理" class="headerlink" title="AOP的底层原理"></a>AOP的底层原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p><p> AOP 的几个核心概念：</p><h4 id="AOP七大术语"><a href="#AOP七大术语" class="headerlink" title="AOP七大术语"></a>AOP七大术语</h4><ul><li><strong>切面（Aspect）</strong>：一个模块化的关注点，例如日志记录、事务管理等。</li><li><strong>连接点（Join Point）</strong>：程序执行过程中的某个特定点，例如方法调用或异常抛出。</li><li><strong>通知（Advice）</strong>：在连接点执行的动作，分为前置通知、后置通知、环绕通知等。</li><li><strong>切入点（Pointcut）</strong>：定义哪些连接点会被通知。</li><li><strong>目标对象（Target Object）</strong>：被代理的对象。</li><li><strong>代理对象（Proxy Object）</strong>：由 AOP 框架创建的包装目标对象的对象。</li><li><strong>织入（Weaving）</strong>：织入是将切面与业务逻辑代码结合起来的过程。这个过程可以在编译时、类加载时或运行时完成</li></ul><p>如果<strong>目标对象实现了接口，Spring 默认使用 JDK 动态代理</strong>。JDK 动态代理<strong>通过反射机制创建代理对象，并拦截方法调用</strong>。</p><p>如果目标对象没有实现接口，Spring 使用 CGLIB 动态代理。<strong>CGLIB 通过继承目标类并重写其方法来创建代理对象</strong>。</p><ul><li>CGLIB 是一个基于字节码生成的库，它通过 ASM 库操作字节码生成子类。</li><li>子类会覆盖父类的方法，并在方法调用前后插入自定义逻辑。</li></ul><p>Spring AOP 封装了动态代理的细节，开发者只需关注切面和通知的定义。</p><p><strong>(1) 定义切面和通知</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging before method execution...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 配置 Spring AOP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 启用 AOP 支持</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        Service service = context.getBean(Service.class);</span><br><span class="line">        service.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring AOP 的底层依赖于动态代理技术。</li><li>如果目标对象实现了接口，则使用 JDK 动态代理。</li><li>如果目标对象未实现接口，则使用 CGLIB 动态代理。</li></ul><p>面向切面编程（Aspect-Oriented Programming, AOP）是一种编程范式，它旨在<strong>通过将横切关注点从核心业务逻辑中分离出来，来提高代码的模块化程度。横切关注点指的是那些影响多个模块的功能，如日志记录、事务管理、安全性等</strong>。AOP的核心思想是将这些功能从业务逻辑中抽离出来，形成独立的模块——即所谓的“切面”.</p><p>代码复用性强</p><p>代码易维护</p><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><p>切点表达式（Pointcut Expression）是Spring AOP中用于<strong>指定哪些连接点应当被通知（Advice）所影响的关键部分</strong>。它通过特定的语法来描述匹配条件，从而选择程序执行流程中的某些点作为切点。</p><p><code>execution</code>是最常用的切点指示器，用来匹配方法执行的连接点。</p><ul><li><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><code>execution(public * com.example.service.*.*(..))</code>：匹配<code>com.example.service</code>包下所有公共方法的执行。</li><li><code>execution(* com.example.service.UserServiceImpl.*(..))</code>：匹配<code>UserServiceImpl</code>类中所有方法的执行。</li></ul></li></ul><p><strong>访问控制权限符</strong>: 可选项,没写就是四个权限都包括.写public方法就表示只包括公开的方法.</p><p><strong>返回值类型</strong>: 必填项 *表示返回值类型任意</p><p><strong>全限定类名</strong>:可选项 两个点”..”代表当前包及子包下的所有类</p><p>省略时表示所有的类</p><p><strong>方法名</strong>: 必填项 *表示所有方法</p><p><strong>形式参数列表</strong>:必填项 ()表示没有参数的方法,(..)参数类型和个数随意的方法,(*)只有一个参数的方法</p><p><code>within</code>用来限定匹配特定类型内的连接点。</p><ul><li><p>语法格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(type-pattern)</span></span></span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><code>within(com.example.service.*)</code>：匹配<code>com.example.service</code>包内所有类的方法。</li><li><code>within(com.example.service..*)</code>：匹配<code>com.example.service</code>包及其子包内所有类的方法。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">logDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交叉业务</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sekyoro.tutorAOP.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sekyoro.tutorAOP.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知类型</p><ol><li><p><strong>@Before</strong> - 前置通知，在目标方法执行之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行前执行的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@After (或 @AfterReturning)</strong> - 后置通知，在目标方法成功执行之后执行（即使方法抛出异常，也会执行）。</p><ul><li>如果你只关心方法正常返回的情况，可以使用 <code>@AfterReturning</code>，它可以访问到返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;execution(* com.example.service..*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行后执行的逻辑，并且可以访问返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@AfterThrowing</strong> - 异常通知，在目标方法抛出异常后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.service..*(..))&quot;, throwing = &quot;error&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(Exception error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法抛出异常后执行的逻辑，并且可以访问异常对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Around</strong> - 环绕通知，可以在目标方法执行前后自定义行为，甚至控制是否执行目标方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 在目标方法执行前的逻辑</span></span><br><span class="line">    Object proceed = joinPoint.proceed(); <span class="comment">// 执行目标方法</span></span><br><span class="line">    <span class="comment">// 在目标方法执行后的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@After</strong> - 最终通知，在任何情况下（无论方法正常返回还是抛出异常）都会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无论目标方法正常返回还是抛出异常都会执行的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@Order</code> 注解是 Spring 框架提供的一个用于定义组件加载顺序的注解。它可以在类、方法或接口上使用，主要用于控制 Bean 的加载顺序、切面的执行顺序以及组件的处理顺序 </p><p>定义和作用</p><p><code>@Order</code> 注解可以指定一个整数值作为参数，该值表示加载顺序，数值越小优先级越高。这意味着拥有较小 <code>@Order</code> 值的 Bean 将被优先加载 </p><p>需要注意的是，<strong>这个注解并不影响 Bean 的实例化顺序，而是决定了 Bean 在集合中的排序或者是在自动装配时的顺序</strong>。</p><p>使用场景</p><ol><li><p>多个拦截器的执行顺序</p><p>在 Spring MVC 中，如果有多个拦截器，可以使用@Order来确保它们按照特定顺序执行</p></li><li><p>切面的执行顺序</p><p>在 AOP 编程中，如果存在多个切面，可以通过@Order确定它们执行的顺序</p></li><li><p>事件监听器的执行顺序：当有多个事件监听器监听同一事件时，可以使用@Order来定义它们的执行顺序</p></li><li><p>定时任务的执行顺序：在 Spring 中，如果有多个定时任务，可以使用@Order来指定它们的执行顺序</p></li></ol><p><strong>通用切点</strong></p><p>用切点指的是可以被多个通知（Advice）或者多个切面（Aspect）所共享的切点定义。通过将切点逻辑集中到一个地方来定义，可以在不同的通知或切面中复用这个切点表达式，从而减少重复代码并提高维护性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">logDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义通用切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sekyoro.tutorAOP.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交叉业务</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonPointcuts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个名为 allServiceMethods 的公共切点，</span></span><br><span class="line"><span class="comment">     * 该切点匹配 com.example.service 包及其子包下所有服务类中的任意方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allServiceMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空方法体，因为 Pointcut 注解已经定义了切点逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设我们已经有了上面定义的 CommonPointcuts 类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;com.example.CommonPointcuts.allServiceMethods()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logServiceAccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成了服务方法调用，结果是: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何管理事务"><a href="#如何管理事务" class="headerlink" title="如何管理事务"></a>如何管理事务</h3><p>事务是一组数据库操作的逻辑单元，这些操作要么全部成功执行（提交），要么全部不执行（回滚）。事务通常用于保证数据在并发访问或异常情况下的完整性和一致性。</p><p>事务的核心特性可以用 ACID 来概括：</p><ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不完成，不允许部分执行。例如，转账操作中扣款和存款必须同时成功。</li><li><strong>一致性（Consistency）</strong>：事务执行前后，数据库必须从一个一致状态转换到另一个一致状态。例如，转账后账户余额总和不变。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务。通常通过隔离级别来控制。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，其结果必须永久保存在数据库中，即使系统崩溃也能恢复。</li></ul><p><strong>开始事务（Begin Transaction）</strong>：标记事务的起点。</p><p><strong>提交（Commit）</strong>：确认所有操作成功，将结果持久化。</p><p><strong>回滚（Rollback）</strong>：如果发生错误或异常，撤销所有操作，恢复到事务开始前的状态。</p><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><ul><li><p>编程式</p></li><li><p>声明式</p></li></ul><p>​    -  基于注解</p><p>​        -  基于xml</p><p>Spring声明式事务管理是<strong>通过面向切面编程（AOP）机制实现</strong>的。当Spring容器启动时，如果发现有<code>@EnableTransactionManagement</code>注解存在，那么会拦截所有Bean的创建过程，扫描是否有<code>@Transactional</code>注解的存在。如果有，Spring会通过AOP的方式给Bean生成代理对象，代理对象中会增加一个拦截器，该拦截器会在方法执行之前启动事务，在方法执行完毕之后提交或回滚事务</p><h4 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h4><p><strong>（1）传播行为（Propagation）</strong></p><p><code>propagation</code> 属性决定<strong>当前事务方法执行时，是否新建事务或加入已有事务</strong>。</p><div class="table-container"><table><thead><tr><th>传播行为</th><th>说明</th></tr></thead><tbody><tr><td><code>REQUIRED</code>（默认）</td><td>如果有事务，则加入；否则创建新事务。</td></tr><tr><td><code>REQUIRES_NEW</code></td><td>无论是否已有事务，都创建新事务，暂停旧事务。</td></tr><tr><td><code>SUPPORTS</code></td><td>如果有事务，则加入；如果没有，则以非事务方式运行。</td></tr><tr><td><code>NOT_SUPPORTED</code></td><td>始终以非事务方式运行，若有事务则挂起。</td></tr><tr><td><code>MANDATORY</code></td><td>必须在已有事务中运行，否则抛异常。</td></tr><tr><td><code>NEVER</code></td><td>不能在事务中运行，否则抛异常。</td></tr><tr><td><code>NESTED</code></td><td>在当前事务中嵌套一个子事务，子事务可以单独回滚。</td></tr></tbody></table></div><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法无论是否存在事务，都会新建一个事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）隔离级别（Isolation）</strong></p><p><code>isolation</code> 属性决定多个事务并发时，数据的可见性。通常数据库提供以下隔离级别：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>说明</th><th>可能问题</th></tr></thead><tbody><tr><td><code>DEFAULT</code></td><td>使用数据库默认隔离级别</td><td>-</td></tr><tr><td><code>READ_UNCOMMITTED</code></td><td>允许读取未提交数据</td><td>脏读、不可重复读、幻读</td></tr><tr><td><code>READ_COMMITTED</code></td><td>只能读取已提交数据</td><td>可能出现不可重复读、幻读</td></tr><tr><td><code>REPEATABLE_READ</code></td><td>事务内多次查询，结果一致</td><td>可能出现幻读</td></tr><tr><td><code>SERIALIZABLE</code></td><td>串行化访问数据，最高隔离级别</td><td>性能开销大</td></tr></tbody></table></div><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务中多次查询结果保持一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读事务（Read-Only）</strong></p><p><code>readOnly = true</code> 表示事务仅用于查询，不允许数据修改，数据库可能进行优化。<strong>适用于 <code>SELECT</code> 语句，提高性能</strong>。</p><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：某些数据库（如 MySQL）会对 <code>readOnly=true</code> 进行优化，但仍需手动确保没有写操作。</p><p><strong>回滚规则（Rollback Rules）</strong></p><p><code>rollbackFor</code> 和 <code>noRollbackFor</code> 控制事务回滚条件：</p><ul><li><code>rollbackFor = Exception.class</code>：遇到指定异常回滚（默认只回滚 <code>RuntimeException</code>）。</li><li><code>noRollbackFor = CustomException.class</code>：遇到指定异常不回滚。</li></ul><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTransaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 遇到任何 Exception（包括 Checked Exception）都会回滚</span></span><br><span class="line">&#125;</span><br><span class="line">javaCopyEdit<span class="meta">@Transactional(noRollbackFor = IllegalArgumentException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWithoutRollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遇到 IllegalArgumentException 不回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>超时（Timeout）</strong></p><p><code>timeout</code> 指定事务的最大执行时间（秒），超时后事务会回滚。默认值 <code>-1</code>（无限制）。</p><p>🔹 <strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEdit<span class="meta">@Transactional(timeout = 5)</span> <span class="comment">// 事务最多执行 5 秒，否则回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">slowTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务执行超过 5 秒，会自动回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时时间记录的是直到最后一条DML语句执行完成的时间.</p><p>Spring 的事务管理通过动态代理实现，默认使用 <strong>JDK 动态代理</strong> 或 <strong>CGLIB 代理</strong> 来为目标对象创建一个代理对象。事务拦截器会在代理对象上调用方法时生效，从而开启或管理事务。</p><p><strong>关键点：</strong></p><ul><li>当你在目标对象内部直接调用另一个方法时，调用并不会经过代理对象，而是直接在目标对象本身上执行。</li><li>因此，事务拦截器无法介入，事务也就不会生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自调用 methodB</span></span><br><span class="line">        methodB(); <span class="comment">// 不会触发事务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li><code>methodA()</code> 调用了 <code>methodB()</code>。</li><li>由于 <code>methodB()</code> 是目标对象内部的方法调用，调用不会经过代理对象，因此事务拦截器不会对 <code>methodB()</code> 生效。</li></ol><p>为了确保事务在自调用时也能生效，可以采取以下几种解决方法：</p><p><strong>(1) 使用 AOP 代理对象显式调用</strong></p><p>通过获取当前类的代理对象来调用目标方法，从而确保事务拦截器生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        MyService proxy = applicationContext.getBean(MyService.class);</span><br><span class="line">        proxy.methodB(); <span class="comment">// 通过代理对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 使用 <code>AopContext.currentProxy()</code></strong></p><p>通过 <code>AopContext.currentProxy()</code> 获取当前代理对象，并调用目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前代理对象</span></span><br><span class="line">        MyService proxy = (MyService) AopContext.currentProxy();</span><br><span class="line">        proxy.methodB(); <span class="comment">// 通过代理对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 <code>AopContext.currentProxy()</code> 时，需要在 Spring 配置中启用暴露代理对象的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></td></tr></table></figure><p><strong>(3) 将方法拆分到不同的类中</strong></p><p>将需要事务管理的方法拆分到另一个服务类中，这样可以通过代理对象调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnotherService anotherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        anotherService.methodB(); <span class="comment">// 调用另一个类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式利用了不同类之间的调用，确保事务管理能够正常工作。</p><div class="table-container"><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>自调用（不推荐）</strong></td><td>简单直接</td><td>事务不生效</td></tr><tr><td><strong>通过 <code>ApplicationContext</code> 获取代理对象</strong></td><td>灵活，适用于复杂的场景</td><td>需要注入 <code>ApplicationContext</code>，稍显冗长</td></tr><tr><td><strong>使用 <code>AopContext.currentProxy()</code></strong></td><td>简洁，避免额外的依赖</td><td>需要启用 <code>exposeProxy</code> 配置</td></tr><tr><td><strong>拆分到不同的类中</strong></td><td>符合单一职责原则，结构清晰</td><td>可能增加类的数量</td></tr></tbody></table></div><h3 id="如何处理循环依赖"><a href="#如何处理循环依赖" class="headerlink" title="如何处理循环依赖"></a>如何处理循环依赖</h3><p>在 Spring 中，<strong>循环依赖</strong>是指两个或多个 Bean 在初始化过程中相互依赖。例如：</p><ul><li><strong>Bean A</strong> 依赖于 <strong>Bean B</strong>；</li><li><strong>Bean B</strong> 又依赖于 <strong>Bean A</strong>。</li></ul><p>Spring 容器通过一些机制来处理循环依赖问题，但并不是所有类型的循环依赖都能被解决</p><p>循环依赖可以分为以下几种情况：</p><p><strong>(1) 构造函数注入的循环依赖</strong></p><p>当两个 Bean 使用构造函数注入时，如果它们之间存在循环依赖，则 Spring 无法解决这种循环依赖，会抛出 <code>BeanCurrentlyInCreationException</code> 异常。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanB</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring 无法创建任何一个 Bean，因为它们互相依赖且都需要完全初始化后才能使用</p><p><strong>(2) Setter 方法或字段注入的循环依赖</strong></p><p>当两个 Bean 使用 setter 方法或字段注入时，Spring 可以解决这种循环依赖。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 能够通过提前暴露未完全初始化的 Bean 来解决这种循环依赖。</p><p><strong>Spring 处理循环依赖的机制</strong></p><p>Spring 容器通过三级缓存（singleton caches）和提前暴露未完全初始化的 Bean 来解决循环依赖问题。</p><p><strong>(1) 单例 Bean 的三级缓存</strong></p><p>Spring 容器维护了三个缓存来管理单例 Bean 的生命周期：</p><ol><li>一级缓存（singletonObjects）<ul><li>存储已经完全初始化完成的 Bean。</li><li>当 Bean 完全初始化后，会从二级缓存移动到一级缓存。</li></ul></li><li>二级缓存（earlySingletonObjects）<ul><li>存储未完全初始化但已经被提前暴露的 Bean。</li><li>当一个 Bean 正在初始化但还未完成时，Spring 会将其放入二级缓存中，以便其他 Bean 可以引用它。</li></ul></li><li>三级缓存（singletonFactories）<ul><li>存储 Bean 的工厂对象（ObjectFactory），用于动态生成未完全初始化的 Bean。</li><li>当需要提前暴露一个 Bean 时，Spring 会先将其工厂对象放入三级缓存。</li></ul></li></ol><p><strong>(2) 提前暴露未完全初始化的 Bean</strong></p><p>当 Spring 发现一个 Bean 正在初始化且有其他 Bean 需要引用它时，Spring 会提前暴露该 Bean 的实例（即使它还未完全初始化）。这通过以下步骤实现：</p><ol><li>创建 Bean 实例（调用构造函数）。</li><li>将 Bean 实例的工厂对象放入三级缓存。</li><li>如果需要提前暴露，将工厂对象生成的 Bean 放入二级缓存。</li><li>其他 Bean 可以从二级缓存中获取该未完全初始化的 Bean。</li><li>当 Bean 完全初始化后，将其移入一级缓存。</li></ol><p>这种方式适用于基于 setter 方法或字段注入的循环依赖。</p><p><strong>3. 为什么构造函数注入的循环依赖无法解决？</strong></p><p>构造函数注入要求 Bean 必须在完全初始化后才能被使用。因此，当两个 Bean 通过构造函数相互依赖时，Spring 无法满足它们的初始化顺序要求。以下是具体原因：</p><ol><li><strong>Bean A</strong> 需要 <strong>Bean B</strong> 的完全初始化实例。</li><li><strong>Bean B</strong> 需要 <strong>Bean A</strong> 的完全初始化实例。</li><li>由于两者都处于“正在初始化”状态，Spring 无法完成任意一方的初始化。</li></ol><p>一个 Bean 被认为是<strong>完全初始化</strong>的，当它已经通过了所有的初始化步骤，并且可以安全地用于应用程序中。这些步骤通常包括：</p><ul><li><strong>实例化</strong>：创建 Bean 的实例。</li><li><strong>属性填充</strong>：为 Bean 的属性设置值或注入依赖（通过构造函数、setter 方法或字段注入）。</li><li><strong>Aware 接口回调</strong>：如果 Bean 实现了特定的 <code>Aware</code> 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code> 等），Spring 会调用相应的方法，让 Bean 能够访问到容器的相关信息。</li><li><strong>初始化方法调用</strong>：如果有定义初始化方法（通过 <code>@PostConstruct</code> 注解或 <code>&lt;bean&gt;</code> 元素中的 <code>init-method</code> 属性），Spring 会在该阶段调用这些方法。</li></ul><p>​    一旦所有这些步骤都完成了，这个 Bean 就被认为是完全初始化的，并被放入 Spring 容器的一级缓存（singletonObjects）中，供其他组件使用。</p><p>一个 Bean 被认为是<strong>未完全初始化</strong>的，是指它正处于初始化过程中的某个中间状态。例如，在某些情况下，Bean 已经被实例化并注入了一些依赖，但尚未完成所有的初始化步骤（比如还没有调用初始化方法）。这种状态下，Bean 还不能完全满足其契约要求，因此可能不适合直接使用。</p><p>​    在处理循环依赖时，Spring 使用一种称为“提前暴露”的机制来解决 Setter 或字段注入引起的循环依赖问题。具体来说，当 Spring 正在初始化一个 Bean A 时，如果发现另一个 Bean B 需要引用 Bean A，而此时 Bean A 尚未完全初始化，Spring 会将 Bean A 提前暴露出来，尽管它还未经过全部的初始化步骤。这种提前暴露的 Bean 只完成了实例化和部分依赖注入，但尚未执行 Aware 接口回调、初始化方法等后续步骤。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>静态代理</strong></p><p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityCheckBookService</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BookService target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityCheckBookService</span><span class="params">(BookService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">securityCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>在内存中动态生成字节码代理类</p><p>JDK动态代理技术:只能代理接口.这是Java标准库提供的一种代理方式，要求被代理的目标对象必须实现了接口。Spring会在目标对象实现了接口时默认使用这种代理方式。JDK动态代理主要通过<code>java.lang.reflect.Proxy</code>类来创建代理对象，并通过<code>InvocationHandler</code>接口来处理代理对象的方法调用。</p><p>CGLIB:当目标对象没有实现任何接口时，Spring会使用CGLIB（Code Generation Library）来为该类创建子类，并覆盖其方法以实现代理。CGLIB通过继承的方式进行代理，因此不能对final类或final方法进行代理。与JDK动态代理相比，CGLIB代理不需要目标对象实现接口，但是性能上可能会稍逊一筹。</p><blockquote><p>从Spring 4.0开始，默认情况下即使目标对象实现了多个接口，Spring也会尝试使用CGLIB代理，除非特别配置了只使用JDK动态代理</p></blockquote><p>JDK动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding user: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态代理处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 被代理的目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法调用前执行逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在方法调用后执行逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        UserService proxyInstance = (UserService) Proxy.newProxyInstance(</span><br><span class="line">                userService.getClass().getClassLoader(),</span><br><span class="line">                userService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> MyInvocationHandler(userService)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyInstance.addUser(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CGLIB动态代理</strong></p><p>CGLIB（Code Generation Library）是一个强大的、高性能的代码生成库，它允许在运行时扩展Java类和实现接口。CGLIB动态代理主要通过继承的方式来实现代理对象，而不是像JDK动态代理那样基于接口。以下是关于CGLIB动态代理的关键点：</p><p><strong>工作原理</strong></p><ul><li>CGLIB通过字节码技术为代理对象创建一个子类，并在子类中重写父类中的非final方法。</li><li>在调用这些重写的方法时，会先经过用户自定义的拦截器（<code>MethodInterceptor</code>），然后可以选择性地调用父类的方法。</li></ul><p><strong>使用场景</strong></p><ul><li>当目标对象没有实现任何接口时，可以使用CGLIB来创建代理对象。</li><li>对于那些需要对现有类进行功能增强，而不想修改原始类的情况下，CGLIB也是一个不错的选择。</li></ul><p><strong>与JDK动态代理的区别</strong></p><ul><li><strong>依赖</strong>：JDK动态代理要求被代理类必须实现至少一个接口；CGLIB则不需要，它可以代理普通的类。</li><li><strong>性能</strong>：CGLIB代理的执行速度通常比JDK动态代理快，因为它直接生成了目标类的子类，而JDK动态代理是基于反射机制的。</li><li><strong>限制</strong>：CGLIB不能代理final类或final方法，因为子类无法覆盖它们</li></ul><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><blockquote><p>拦截器</p><p>过滤器</p></blockquote><p><a href="https://springdoc.cn/spring-mvc-tutorial/">Spring MVC 教程 - spring 中文网</a></p><p>Spring 框架中处理模型（Model）- 视图（View）- 控制器（Controller）或 MVC 模式的一个模块。它结合了 MVC 模式的所有优点和 Spring 的便利性。</p><p>Spring 使用其 <code>DispatcherServlet</code> 前控制器模式实现 MVC。</p><p>简而言之，<code>DispatcherServlet</code> 是将请求路由到预定目的地的主要控制器。Model 只是应用的数据，而视图则由各种模板引擎来表示。</p><p>包含spring的依赖同时使用servlet等实现MVC架构的Web开发.</p><p>servlet如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springmvc的示例代码如下.</p><p>要通过 Java 配置类启用 Spring MVC 支持，只需添加 <code>@EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      InternalResourceViewResolver bean = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//bean.setViewClass(JstlView.class); in older version</span></span><br><span class="line">      bean.setPrefix(<span class="string">&quot;/WEB-INF/view/&quot;</span>);</span><br><span class="line">      bean.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将设置 MVC 项目所需的基本支持，如注册处理器、映射器、类型转换器、验证支持、消息转换器和异常处理。本例中注册了一个 <code>ViewResolver</code> Bean，它从 <code>/WEB-INF/view</code> 目录返回 <code>.jsp</code> 视图。可以注册视图控制器（ViewController），使用 <code>ViewControllerRegistry</code> 在 URL 和视图名称之间创建直接映射。这样，两者之间就不需要任何 Controller 了。</p><p>如果想自定义扫描 Controller 类，可以使用 <code>@ComponentScan</code> 注解，并指定包含 Controller 的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123; &quot;com.baeldung.web.controller&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了引导应用加载该配置，还需要一个 Initializer 类：</p><blockquote><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(<span class="keyword">final</span> ServletContext sc)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigWebApplicationContext root = </span><br><span class="line">          <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        </span><br><span class="line">        root.scan(<span class="string">&quot;com.baeldung&quot;</span>);</span><br><span class="line">        sc.addListener(<span class="keyword">new</span> ContextLoaderListener(root));</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic appServlet = </span><br><span class="line">          sc.addServlet(<span class="string">&quot;mvc&quot;</span>, <span class="keyword">new</span> DispatcherServlet(<span class="keyword">new</span> GenericWebApplicationContext()));</span><br><span class="line">        appServlet.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        appServlet.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回应用级别的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回与 DispatcherServlet 相关的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">// 设置 DispatcherServlet 的 URL 映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个基本的 Controller 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sample&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sample&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的 JSP 资源是 <code>sample.jsp</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the body of the sample view<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于 <code>JSP</code> 的视图文件位于项目的 <code>/WEB-INF</code> 文件夹下，因此只有 Spring 才能访问它们，而不能直接通过 URL 访问。</p><p>也可以使用纯 XML 配置来代替上述 Java 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baeldung.web.controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/view/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想使用纯 XML 配置，还需要添加一个 <code>web.xml</code> 文件来引导应用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/dispatcher-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><p><a href="https://springdoc.cn/spring-boot/">Spring Boot 中文文档</a></p><p><a href="https://spring.io/">Spring | Home</a></p><p>Spring Boot 是对 Spring 平台的补充，它能让你轻松上手并创建独立的生产级应用。Spring Boot 的目的不是取代 Spring，而是让使用 Spring 变得更快、更简单。</p><p><strong>pring Boot Starter</strong></p><p>Spring Boot 提供了便捷的 Starter 依赖，这是一种依赖描述符，可以为特定功能引入所有必要的技术。</p><p>这样做的好处是，不再需要为每个依赖项指定版本，而是让 Starter 管理依赖。</p><p>最快捷的入门方法是在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-parent</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就能解决依赖管理问题。</p><p><strong>Spring Boot 入口点</strong></p><p>使用 Spring Boot 构建的每个应用都需定义 main 入口点。</p><p>这通常是一个 Java 类，带有 main 方法，并用 <code>@SpringBootApplication</code> 进行注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解添加了以下其他注解：</p><ul><li><code>@Configuration</code> 将类标记为 bean 定义的来源。</li><li><code>@EnableAutoConfiguration</code> 会告诉框架根据 classpath 上的依赖自动添加 Bean。</li><li><code>@ComponentScan</code> 会扫描与 Application 类相同包或其子包中的其他配置和 Bean。</li></ul><p>有了 Spring Boot，就可以使用 Thymeleaf 或 JSP 设置前端，而无需使用定义的 <code>ViewResolver</code>。在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-thymeleaf</code> 依赖后，Thymeleaf 就会启用，无需额外配置。</p><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><p>这是Spring Boot默认的配置文件，它采用<a href="https://yaml.org/">YAML</a>格式而不是<code>.properties</code>格式，文件名必须是<code>application.yml</code>而不是其他名称。</p><p>YAML格式比<code>key=value</code>格式的<code>.properties</code>文件更易读。比较一下两者的写法：</p><p>使用<code>.properties</code>格式：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.hikari.auto-commit</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.validation-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.max-lifetime</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p>使用YAML格式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可见，YAML是一种层级格式，它和<code>.properties</code>很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。</p><h3 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h3><p>在配置文件中，我们经常使用如下的格式对某个key进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;DB_HOST:localhost&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;DB_USER:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;DB_PASSWORD:password&#125;</span></span><br></pre></td></tr></table></figure><p>这种<code>$&#123;DB_HOST:localhost&#125;</code>意思是，首先从环境变量查找<code>DB_HOST</code>，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值<code>localhost</code>。</p><p>这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可</p><h3 id="logback-spring-xml"><a href="#logback-spring-xml" class="headerlink" title="logback-spring.xml"></a>logback-spring.xml</h3><p>这是Spring Boot的logback配置文件名称（也可以使用<code>logback.xml</code>），一个标准的写法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;APP_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>app.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;APP_LOG&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它主要通过<code>&lt;include resource=&quot;...&quot; /&gt;</code>引入了Spring Boot的一个缺省配置，这样我们就可以引用类似<code>$&#123;CONSOLE_LOG_PATTERN&#125;</code>这样的变量。上述配置定义了一个控制台输出和文件输出，可根据需要修改。</p><p><code>static</code>是静态文件目录，<code>templates</code>是模板文件目录，注意它们不再存放在<code>src/main/webapp</code>下，而是直接放到<code>src/main/resources</code>这个classpath目录，因为在Spring Boot中已经不需要专门的webapp目录了。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><h4 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h4><p>在 Spring MVC 中，如果你不明确地为控制器方法的参数添加注解，Spring 会根据参数类型以及请求的上下文来自动处理这些参数。以下是默认行为的一些关键点：</p><p><strong>默认行为概述</strong></p><ol><li><strong>基本类型和简单对象（如 <code>String</code>, <code>Integer</code> 等）</strong>：<ul><li>如果没有使用任何注解，默认情况下 Spring 尝试从 URL 路径变量、请求参数或请求体中匹配数据。</li><li>特别是对于 RESTful 风格的 API，如果方法参数名与路径变量名相同，则可以自动绑定到路径变量上。</li></ul></li><li><strong>复杂对象（POJO 类）</strong>：<ul><li>对于复杂对象，Spring 会尝试将请求参数（通常是表单数据或者查询参数）自动绑定到对象的属性上。这类似于使用了 <code>@ModelAttribute</code> 注解的效果。</li><li>若要通过请求体传递 JSON 或 XML 数据并将其转换为对象，必须使用 <code>@RequestBody</code> 注解，否则 Spring 不知道如何解析请求体中的数据。</li></ul></li></ol><ul><li>使用 <code>@RequestParam</code> 当：<ul><li>处理GET请求的查询参数</li><li>处理表单提交(application/x-www-form-urlencoded)</li><li>需要获取少量简单参数</li></ul></li><li>使用 <code>@RequestBody</code> 当：<ul><li>处理JSON/XML等结构化数据</li><li>需要接收复杂对象</li><li>构建RESTful API时</li></ul></li></ul><p><strong><code>@RequestBody</code> 适用场景</strong>:</p><ul><li>RESTful API设计</li><li>前端发送JSON/XML数据</li><li>复杂嵌套对象结构</li><li>需要完整对象替换更新的操作</li></ul><p><strong><code>@ModelAttribute</code> 适用场景</strong>:</p><ul><li>传统表单提交</li><li>多步骤表单处理</li><li>需要部分更新对象的场景</li><li>需要从URL参数绑定的情况</li></ul><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>使用<code>@Validated</code>和<code>@Valid</code>用于验证对象,帮助开发者确保传入的数据满足预定义的约束条件.</p><p><code>@Valid</code> 注解是 Java Bean Validation API（JSR 303/JSR 380）的一部分，通常用于触发<strong>对类实例或方法参数</strong>的验证。当你在一个方法参数、方法返回值或者字段上标记了 <code>@Valid</code>，Spring 会尝试根据该对象上的验证注解（如 <code>@NotNull</code>, <code>@Size</code> 等）来验证数据的有效性。如果验证失败，则抛出 <code>MethodArgumentNotValidException</code> 或者 <code>ConstraintViolationException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;Name cannot be null&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理用户创建逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="string">&quot;User created successfully&quot;</span>, HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnCreate</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnUpdate</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(groups = OnCreate.class, message = &quot;Name is required on create&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = OnUpdate.class, message = &quot;ID is required on update&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在服务层使用 <code>@Validated</code> 来指定验证组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Validated(OnCreate.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建用户的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Validated(OnUpdate.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(<span class="meta">@Valid</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新用户的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>createUser</code> 方法只会验证那些标记了 <code>OnCreate</code> 分组的约束条件，而 <code>updateUser</code> 方法则只会验证那些标记了 <code>OnUpdate</code> 分组的约束条件。</p><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p><code>HttpSession</code> 是 Java Servlet 技术中用于在服务器端存储特定于用户的会话信息的重要机制。它允许<strong>开发者在多个请求之间保持用户的状态，这对于需要跟踪用户活动（如登录状态、购物车内容等）</strong>的 Web 应用程序来说是非常重要的。</p><p>如何在 Controller 方法中使用 HttpSession</p><p><strong>直接声明 HttpSession 参数</strong></p><p>Spring Boot 会自动将当前请求的 <code>HttpSession</code> 注入到控制器方法中。你只需要在方法参数列表中声明 <code>HttpSession</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setSessionAttribute</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储数据到会话中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session attribute &#x27;username&#x27; has been set.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSessionAttribute</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从会话中获取数据</span></span><br><span class="line">        String username = (String) session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Username from session: &quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/invalidate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invalidateSession</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 销毁会话</span></span><br><span class="line">        session.invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Session has been invalidated.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>测试流程</strong></p><ul><li>访问 <code>/session/set</code>：设置会话属性 <code>username</code>。</li><li>访问 <code>/session/get</code>：从会话中获取 <code>username</code>。</li><li>访问 <code>/session/invalidate</code>：销毁会话。</li></ul><p><strong>3. HttpSession 的常用方法</strong></p><p>以下是一些常用的 <code>HttpSession</code> 方法：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>setAttribute(String name, Object value)</code></td><td>将指定的属性存储到会话中。</td></tr><tr><td><code>getAttribute(String name)</code></td><td>根据属性名称从会话中获取值。如果属性不存在，则返回 <code>null</code>。</td></tr><tr><td><code>removeAttribute(String name)</code></td><td>从会话中移除指定的属性。</td></tr><tr><td><code>invalidate()</code></td><td>使当前会话失效，并清除所有会话数据。</td></tr><tr><td><code>setMaxInactiveInterval(int interval)</code></td><td>设置会话的最大不活动时间（以秒为单位）。</td></tr><tr><td><code>getId()</code></td><td>获取当前会话的唯一标识符（Session ID）。</td></tr></tbody></table></div><p><strong>4. 使用场景</strong></p><p>(1) <strong>用户登录状态管理</strong></p><p>通过 <code>HttpSession</code>，可以存储用户的登录状态或用户信息，避免每次请求都需要重新验证身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpSession session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, username); <span class="comment">// 存储登录信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Login successful!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Invalid credentials!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dashboard</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    String user = (String) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Please login first!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Welcome to the dashboard, &quot;</span> + user + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    session.invalidate(); <span class="comment">// 销毁会话</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Logged out successfully!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>购物车功能</strong></p><p>在电商系统中，可以使用 <code>HttpSession</code> 来存储用户的购物车数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/addToCart&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addToCart</span><span class="params">(String item, HttpSession session)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; cart = (List&lt;String&gt;) session.getAttribute(<span class="string">&quot;cart&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cart == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cart = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    cart.add(item);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;cart&quot;</span>, cart);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Item added to cart!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/viewCart&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">viewCart</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; cart = (List&lt;String&gt;) session.getAttribute(<span class="string">&quot;cart&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cart == <span class="keyword">null</span> || cart.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Your cart is empty!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Cart items: &quot;</span> + String.join(<span class="string">&quot;, &quot;</span>, cart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 注意事项</strong></p><p>(1) <strong>会话超时</strong></p><p>默认情况下，<code>HttpSession</code> 的超时时间为 30 分钟（由服务器配置决定）。你可以通过以下方式修改超时时间：</p><ul><li><p>在<code>application.properties</code>中设置properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.servlet.session.timeout</span>=<span class="number">15</span>m</span><br></pre></td></tr></table></figure><p>或者在代码中动态设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="number">900</span>); <span class="comment">// 超时时间为 15 分钟（900 秒）</span></span><br></pre></td></tr></table></figure></li></ul><p>(2) <strong>内存消耗</strong></p><p>每个会话都会占用服务器的内存资源。如果会话数量过多，可能会导致性能问题。因此，尽量只存储必要的数据，并及时清理不再需要的会话。</p><p>(3) <strong>分布式环境</strong></p><p>在分布式环境中（如微服务架构），<code>HttpSession</code> 默认是存储在单个服务器上的。如果用户请求被负载均衡器分发到不同的服务器，可能导致会话丢失。解决方法包括：</p><ul><li>使用粘性会话（Sticky Session）。</li><li>使用外部化的会话存储（如 Redis）。</li></ul><p><strong>6. 替代方案</strong></p><p>在某些场景下，<code>HttpSession</code> 可能不是最佳选择。以下是一些替代方案：</p><p>(1) <strong>JWT（JSON Web Token）</strong></p><p>对于无状态的 RESTful API，可以使用 JWT 来代替 <code>HttpSession</code>。JWT 将用户信息存储在客户端（通常是 HTTP 请求头中），服务器无需维护会话状态。</p><p>(2) <strong>Spring Security</strong></p><p>Spring Security 提供了更强大的会话管理和认证机制，建议在需要复杂权限控制的场景下使用。</p><p>(3) <strong>数据库存储</strong></p><p>如果会话数据需要长期保存，可以考虑将数据存储在数据库中，而不是依赖 <code>HttpSession</code>。</p><p><code>HttpSession</code> 的核心实现原理可以总结为以下几点：</p><ol><li><strong>会话ID</strong>：唯一标识每个用户的会话。</li><li><strong>客户端与服务器的关联</strong>：通过 Cookie 或 URL 重写传递会话ID。</li><li><strong>服务器端存储</strong>：将以会话ID为键的会话数据存储在服务器端。</li><li><strong>超时机制</strong>：定期清理长时间未使用的会话。</li><li><strong>线程安全</strong>：注意并发访问会话数据时的线程安全问题。</li></ol><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><code>@RestController</code> 是一个复合注解，它结合了 <code>@Controller</code> 和 <code>@ResponseBody</code>。</p><ul><li><code>@Controller</code>：声明该类是一个控制器。</li><li><code>@ResponseBody</code>：表示方法的返回值会直接写入 HTTP 响应体中，而不是解析为视图名称</li></ul><p><code>@ResponseBody</code> 注解的作用是将方法的返回值直接写入 HTTP 响应体中，而不是解析为视图名称。<strong>如果返回值是一个对象，Spring 会自动将其序列化为 JSON 或 XML 格式</strong>（默认是 JSON），然后将序列化后的结果作为响应内容返回给客户端。</p><p>如果使用的是 <code>@ResponseBody</code> 注解，则所有方法默认都会将返回值作为响应体的一部分，并根据返回值的类型推断 <code>Content-Type</code>。</p><p><strong>默认推断规则</strong></p><ul><li><strong>String 类型</strong>：默认返回 <code>text/plain</code>。</li><li><strong>POJO 类型</strong>：默认返回 <code>application/json</code>。</li><li><strong>其他类型</strong>：可能需要手动指定 <code>produces</code> 或使用 <code>ResponseEntity</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回纯文本</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/text&quot;, produces = &quot;text/plain&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is plain text.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 JSON 数据</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/json&quot;, produces = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 HTML 内容</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/html&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;This is an HTML response&lt;/h1&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>produces</code> 属性用于指定返回内容的 <code>Content-Type</code>。</li><li>如果省略 <code>produces</code>，Spring 会根据返回值类型自动推断 <code>Content-Type</code>。</li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong><code>@ResponseBody</code> + <code>produces</code></strong></td><td>易于使用，支持自动推断 <code>Content-Type</code>。</td><td>API 开发（JSON、文本等）。</td></tr><tr><td><strong><code>ResponseEntity</code></strong></td><td>提供对状态码、头部信息和内容的完全控制。</td><td>需要动态生成响应的场景。</td></tr><tr><td><strong><code>@RestController</code> 默认行为</strong></td><td>自动推断 <code>Content-Type</code>，无需额外配置。</td><td>简单的 RESTful API 开发。</td></tr><tr><td><strong><code>HttpServletResponse</code></strong></td><td>完全手动控制响应内容和头部信息。</td><td>需要低级别的控制（如自定义格式）。</td></tr><tr><td><strong>视图解析器</strong></td><td>结合模板引擎（如 Thymeleaf、JSP）返回完整的 HTML 页面。</td><td>动态网页开发。</td></tr></tbody></table></div><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>在 Spring MVC 或 Spring Boot 应用程序中，拦截器（Interceptor）是一种用于<strong>在请求处理的不同阶段执行代码的机制。它们允许你在请求到达控制器之前或响应返回客户端之前对请求和响应进行预处理或后处理</strong>。拦截器非常适合用于日志记录、性能监控、安全检查、登录认证等场景。</p><p><strong>1. 拦截器的工作原理</strong></p><p>拦截器基于 Java 的 Servlet 规范实现，通过实现 <code>HandlerInterceptor</code> 接口或者继承 <code>HandlerInterceptorAdapter</code> 类来定义自己的拦截逻辑。Spring MVC 提供了三个主要的方法来控制请求的生命周期：</p><ul><li><strong><code>preHandle()</code></strong>：在处理器方法（Controller 方法）执行之前被调用。如果此方法返回 <code>false</code>，则请求将不再继续执行，可以用来做权限验证等。</li><li><strong><code>postHandle()</code></strong>：在处理器方法执行之后但在视图渲染之前被调用。可以在此方法中修改模型数据或视图名称。</li><li><strong><code>afterCompletion()</code></strong>：在整个请求完成之后被调用，通常用于资源清理工作。</li></ul><p><strong>2. 创建一个简单的拦截器</strong></p><p>首先，你需要创建一个类实现 <code>HandlerInterceptor</code> 接口，并重写上述提到的方法之一或全部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在请求处理之前进行调用（Controller方法调用之前）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Pre-handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 如果返回false，则请求不会继续到下一个拦截器或处理器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 请求处理之后，视图渲染之前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Post-handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在整个请求结束之后被调用，也就是在视图渲染完成之后，通常用于资源清理工作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After completion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 注册拦截器</strong></p><p>创建好拦截器后，需要将其注册到 Spring MVC 的配置中。可以通过实现 <code>WebMvcConfigurer</code> 接口并覆盖 <code>addInterceptors</code> 方法来注册自定义的拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)  <span class="comment">// 指定拦截的路径模式</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>); <span class="comment">// 排除某些路径不被拦截</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 使用场景示例</strong></p><p>(1) <strong>日志记录</strong></p><p>可以在 <code>preHandle</code> 和 <code>afterCompletion</code> 方法中添加日志记录功能，以追踪每个请求的开始和结束时间。</p><p>(2) <strong>权限验证</strong></p><p>在 <code>preHandle</code> 方法中根据用户的身份信息决定是否允许访问目标资源。</p><p>(3) <strong>性能监控</strong></p><p>计算从 <code>preHandle</code> 到 <code>afterCompletion</code> 之间的时间差，以此来衡量请求处理的耗时情况。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>一般都是用mybatis,mybatis-plus.</p><p>MyBatis 的使用流程可以总结为以下几个步骤：</p><ol><li>引入依赖。</li><li>配置 MyBatis（XML 或 Spring Boot）。</li><li>创建实体类。</li><li>定义 Mapper 接口（注解或 XML）。</li><li>使用 MyBatis 执行 SQL。</li></ol><p><strong>1. 引入依赖</strong></p><p>在项目中引入 MyBatis 和数据库驱动相关的依赖。如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p><p>xml</p><p>深色版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis 核心依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库驱动（以 MySQL 为例） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果使用 Spring Boot，可以引入 MyBatis-Spring-Boot-Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 配置 MyBatis</strong></p><p>(1) <strong>XML 配置方式</strong></p><p>创建一个 <code>mybatis-config.xml</code> 文件，用于配置 MyBatis 的全局设置，例如数据源、事务管理器等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 全局设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 下划线转驼峰 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据源配置（可选，通常由 Spring 管理） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/example/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2) <strong>Spring Boot 配置方式</strong></p><p>如果使用 Spring Boot，可以直接在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 MyBatis 和数据库连接信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># MyBatis 配置</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><strong>3. 创建实体类</strong></p><p>定义与数据库表对应的实体类（也称为 POJO 类）。例如，假设有一张 <code>user</code> 表：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters 和 Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 创建 Mapper 接口</strong></p><p>定义一个接口，用于声明 SQL 操作方法。MyBatis 会通过动态代理机制实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user(username, email) VALUES(#&#123;username&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 编写 SQL 映射文件（可选）</strong></p><p>如果你不想使用注解，也可以将 SQL 写在 XML 文件中。例如，创建一个 <code>UserMapper.xml</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user(username, email) VALUES(#&#123;username&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6. 使用 MyBatis 执行 SQL</strong></p><p>(1) <strong>非 Spring 环境</strong></p><p>手动创建 <code>SqlSessionFactory</code> 并获取 <code>SqlSession</code> 来执行 SQL。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MyBatisExample &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        // 加载 MyBatis 配置文件</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="built_in">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        // 获取 SqlSession</span><br><span class="line">        try (SqlSession <span class="keyword">session</span> = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            UserMapper mapper = <span class="keyword">session</span>.getMapper(UserMapper.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">User</span> <span class="keyword">user</span> = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">user</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <strong>Spring 或 Spring Boot 环境</strong></p><p>在 Spring 或 Spring Boot 中，直接注入 <code>Mapper</code> 接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h2><h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="lombok✨"><a href="#lombok✨" class="headerlink" title="lombok✨"></a>lombok✨</h2><ol><li><strong>@Getter 和 @Setter</strong></li></ol><ul><li>自动生成所有字段的 getter 和 setter 方法。</li><li>可以指定在类级别上使用，这样会为所有非静态字段生成 getter 和 setter 方法；也可以单独用于某个字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@ToString</strong></li></ol><ul><li>自动生成 <code>toString()</code> 方法，默认包含所有字段。</li><li>可以通过 <code>exclude</code> 参数排除某些字段，或者通过 <code>callSuper</code> 参数控制是否调用父类的 <code>toString()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;password&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@EqualsAndHashCode</strong></li></ol><ul><li>自动生成 <code>equals(Object other)</code> 和 <code>hashCode()</code> 方法。</li><li>类似于 <code>@ToString</code>，可以通过 <code>exclude</code> 排除特定字段，或通过 <code>callSuper</code> 控制是否考虑父类字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EqualsAndHashCode(exclude = &quot;timestamp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</strong></li></ol><ul><li>自动生成构造函数：<ul><li><code>@NoArgsConstructor</code>: 无参构造函数。</li><li><code>@RequiredArgsConstructor</code>: 使用所有 <code>final</code> 或 <code>@NonNull</code> 注解标注的字段作为参数的构造函数。</li><li><code>@AllArgsConstructor</code>: 包含所有字段的构造函数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Data</strong></li></ol><ul><li>组合了 <code>@Getter</code>, <code>@Setter</code>, <code>@ToString</code>, <code>@EqualsAndHashCode</code>, 和 <code>@RequiredArgsConstructor</code> 的功能。</li><li>非常适合用于简单的数据持有类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Builder</strong></li></ol><ul><li>提供了一个流畅的构建器 API，非常适合创建不可变对象或复杂对象的实例化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">User user = User.builder().username(<span class="string">&quot;Alice&quot;</span>).email(<span class="string">&quot;alice@example.com&quot;</span>).build();</span><br></pre></td></tr></table></figure><ol><li><strong>@Slf4j</strong></li></ol><ul><li>自动生成一个 SLF4J Logger 实例，简化日志记录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;User &#123;&#125; is logging in.&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Cleanup</strong></li></ol><ul><li>自动管理资源，确保在方法退出时关闭资源（如文件流、数据库连接等）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Cleanup;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;path/to/file&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理输入流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@SneakyThrows</strong></li></ol><ul><li>简化异常处理，允许直接抛出受检异常而不必显式声明它们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;path/to/file&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理文件读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>@Value</strong></li></ol><ul><li>创建不可变类（所有字段默认是私有的，并且带有 <code>final</code> 关键字），同时提供 <code>@Data</code> 的大部分功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Value;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hutool✨"><a href="#hutool✨" class="headerlink" title="hutool✨"></a>hutool✨</h2><h2 id="slf4j✨"><a href="#slf4j✨" class="headerlink" title="slf4j✨"></a>slf4j✨</h2><p><a href="https://logback.qos.ch/apidocs/index.html">Overview (Logback-Parent 1.5.15 API)</a></p><p>SLF4J为各种日志框架（例如 java.util.logging、logback、log4j）提供了一个简单的门面或抽象，允许用户在部署时插入所需的日志框架。</p><h2 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h2><p><a href="https://logback.qos.ch/">Logback Home</a></p><p>Logback 旨在作为流行的 log4j 项目的继任者，从 log4j 1.x 停止的地方继续发展。</p><p>Logback 的架构相当通用，以便在不同情况下应用。目前，logback 分为三个模块，分别是 logback-core、logback-classic 和 logback-access。</p><p>logback -core模块为其他两个模块奠定了基础。logback-classic模块可以看作是 log4j 1.x 的改进版本。此外，logback-classic模块原生实现了 SLF4J API，因此您可以轻松地在logaback和其他日志框架（如 log4j 1.x 或 java.util.logging（JUL））之间切换。</p><h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p><a href="https://logging.apache.org/log4j/2.12.x/">Log4j – Apache Log4j 2 - Apache Log4j 2</a></p><p>Apache Log4j 2 是 Log4j 的升级版本，在性能上对前一代 Log4j 1.x 进行了显著提升，并提供了许多 Logback 中的改进，同时修复了 Logback 架构中的一些固有缺陷。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般可以使用slf4j-api接口加上logback-classic(或者slf4j-simple)实现.</p><h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><ol><li><strong>类（Class）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式（UpperCamelCase）</strong>，首字母大写，每个单词首字母大写。</li><li><strong>特点</strong>：通常是名词或名词短语，表示一个实体或概念。</li><li>示例<ul><li>User</li><li>OrderService</li><li>HttpRequestHandler</li></ul></li><li>注意<ul><li>接口命名与类类似，但通常反映其功能或角色，例如 Runnable、Serializable。</li><li>抽象类可以以 Abstract 开头，例如 AbstractFactory。</li></ul></li></ul><ol><li><strong>接口（Interface）命名</strong></li></ol><ul><li><strong>规则</strong>：同样使用<strong>大写驼峰式</strong>，通常是形容词或表示能力的名词。</li><li><strong>特点</strong>：突出功能或契约。</li><li>示例<ul><li>Comparable</li><li>Iterable</li><li>UserService</li></ul></li><li><strong>注意</strong>：避免使用 I 前缀（如 IUserService），这是 C# 的习惯，Java 中不推荐。</li></ul><ol><li><strong>方法（Method）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>小写驼峰式（lowerCamelCase）</strong>，首字母小写，后续单词首字母大写。</li><li><strong>特点</strong>：通常是动词或动词短语，表示行为或操作。</li><li>示例<ul><li>getName</li><li>calculateTotalPrice</li><li>isValid</li></ul></li><li>约定<ul><li>Getter 方法以 get 开头（返回布尔值时用 is），例如 getAge、isActive。</li><li>Setter 方法以 set 开头，例如 setName。</li><li>操作方法通常以动词开头，例如 saveUser、deleteRecord。</li></ul></li></ul><ol><li><strong>变量（Variable）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>小写驼峰式</strong>。</li><li><strong>特点</strong>：简洁、有意义，反映变量的作用。</li><li>示例<ul><li>userName</li><li>orderList</li><li>totalAmount</li></ul></li><li>约定<ul><li>局部变量：短而明确，例如 i（循环计数器）、temp。</li><li>成员变量（字段）：避免无意义的缩写，例如 firstName 而不是 fName。</li><li>布尔变量：通常以 is、has 等开头，例如 isFinished、hasPermission。</li></ul></li></ul><ol><li><strong>常量（Constant）命名</strong></li></ol><ul><li><strong>规则</strong>：全部<strong>大写</strong>，单词间用下划线 _ 分隔。</li><li><strong>特点</strong>：用于 static final 修饰的常量。</li><li>示例<ul><li>MAX_VALUE</li><li>DEFAULT_TIMEOUT</li><li>PI</li></ul></li><li><strong>注意</strong>：通常定义在类或接口中，表示不可变的值。</li></ul><ol><li><strong>包（Package）命名</strong></li></ol><ul><li><strong>规则</strong>：全部<strong>小写</strong>，使用点号 . 分隔，通常基于域名倒写。</li><li><strong>特点</strong>：层次清晰，避免关键字。</li><li>示例<ul><li>com.example.util</li><li>org.springframework.context</li></ul></li><li>约定<ul><li>避免使用连字符或下划线。</li><li>通常以公司或组织域名开头，避免命名冲突。</li></ul></li></ul><ol><li><strong>枚举（Enum）命名</strong></li></ol><ul><li><p><strong>规则</strong>：类名使用<strong>大写驼峰式</strong>，枚举值使用<strong>全大写</strong>（类似常量）。</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> </span>&#123;   </span><br><span class="line">    ACTIVE,    INACTIVE,    PENDING &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>异常（Exception）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式</strong>，以 Exception 或 Error 结尾。</li><li>示例<ul><li>FileNotFoundException</li><li>NullPointerException</li><li>CustomValidationError</li></ul></li></ul><ol><li><strong>注解（Annotation）命名</strong></li></ol><ul><li><strong>规则</strong>：使用<strong>大写驼峰式</strong>，通常反映用途。</li><li>示例<ul><li>@Autowired</li><li>@RestController</li><li>@MyCustomAnnotation</li></ul></li></ul><ol><li><strong>测试类和方法命名</strong></li></ol><ul><li><p>规则</p><ul><li>测试类以 Test 结尾，命名反映被测试的类，例如 UserServiceTest。</li><li>测试方法以 test 开头，描述测试行为，使用小写驼峰式。</li></ul></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveUser</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// 测试代码    &#125; </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>其他约定</strong></li></ol><ul><li><p><strong>避免缩写</strong>：除非是广为人知的缩写（如 URL、HTTP），否则使用完整单词，例如 userIdentifier 而不是 userId。</p></li><li><p><strong>语义清晰</strong>：命名应反映用途，避免过于泛泛的名称，如 data、process。</p></li><li><p>单复数</p><p>：</p><ul><li>集合使用复数，例如 users、orderList。</li><li>单个对象使用单数，例如 user、order。</li></ul></li></ul><ol><li><strong>Spring 中的特殊命名</strong></li></ol><ul><li>Bean 名称<ul><li>默认是类名首字母小写，例如 UserServiceImpl 的 Bean 名是 userServiceImpl。</li><li>可通过注解指定，例如 @Service(“customName”)。</li></ul></li><li>接口与实现类<ul><li>接口：UserService。</li><li>实现类：UserServiceImpl（以 Impl 结尾是常见约定）。</li></ul></li></ul><ol><li><strong>POJO (Plain Old Java Object)</strong></li></ol><ul><li><strong>含义</strong>：普通的 Java 对象，指不依赖特定框架、不继承特定类或实现特定接口的简单 Java 类。</li><li>特点<ul><li>只包含属性（字段）、getter/setter 方法，可能有简单的业务逻辑。</li><li>不受外部框架约束，例如不继承 Servlet 或实现 Serializable（除非业务需要）。</li></ul></li><li><strong>用途</strong>：作为基础数据载体，广泛用于各种场景</li></ul><ol><li><strong>VO (Value Object)</strong></li></ol><ul><li><strong>含义</strong>：值对象，通常用于表示不可变的数据结构，强调值的语义。</li><li>特点<ul><li>通常是不可变的（Immutable），创建后属性不可修改。</li><li>常用于传递数据，关注数据的完整性和一致性。</li><li>在某些场景下，也被用作视图对象（View Object），表示展示层的数据。</li></ul></li><li><strong>用途</strong>：在业务逻辑中传递数据，或在前端展示时封装数据。</li></ul><ol><li><strong>PO (Persistent Object)</strong></li></ol><ul><li><strong>含义</strong>：持久化对象，表示与数据库表直接映射的对象，通常用于 ORM（对象关系映射）框架（如 Hibernate、MyBatis）。</li><li>特点<ul><li>属性与数据库表的字段一一对应。</li><li>通常包含主键（如 id）和其他表字段。</li><li>可能有注解（如 @Entity、@Table）来映射数据库。</li></ul></li><li><strong>用途</strong>：用于数据持久化层，与数据库交互</li></ul><ol><li><strong>DAO (Data Access Object)</strong></li></ol><ul><li><p><strong>含义</strong>：数据访问对象，负责封装数据库操作的逻辑。</p></li><li><p>特点</p><p>：</p><ul><li>提供 CRUD（增删改查）方法，与数据库交互。</li><li>屏蔽底层数据访问细节（如 JDBC、ORM 的具体实现）。</li><li>通常与 PO 配合使用。</li></ul></li><li><p><strong>用途</strong>：隔离业务逻辑与数据访问逻辑。</p></li></ul><ol><li><strong>DTO (Data Transfer Object)</strong></li></ol><ul><li><p><strong>含义</strong>：数据传输对象，用于在不同层（如服务层与表现层）或系统之间传递数据。</p></li><li><p>特点</p><p>：</p><ul><li>不直接映射数据库表，属性根据传输需求设计。</li><li>通常是简单的数据容器，不含复杂业务逻辑。</li><li>常用于减少网络传输中的数据冗余或适配前端需求。</li></ul></li><li><p><strong>用途</strong>：跨层或跨系统的数据交换。</p></li></ul><ol><li><strong>BO (Business Object)</strong></li></ol><ul><li><strong>含义</strong>：业务对象，封装业务逻辑或表示业务实体的对象。</li><li>特点<ul><li>包含业务数据和相关操作方法。</li><li>通常聚合多个 PO 或 DTO，表示更高层次的业务概念。</li></ul></li><li><strong>用途</strong>：在业务逻辑层处理复杂的业务规则。</li></ul><p><strong>对比总结</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>全称</th><th>主要用途</th><th>与数据库关系</th><th>是否含业务逻辑</th></tr></thead><tbody><tr><td>POJO</td><td>Plain Old Java Object</td><td>通用简单对象</td><td>无特定关系</td><td>可能有简单逻辑</td></tr><tr><td>VO</td><td>Value Object</td><td>数据传递或视图展示</td><td>无直接关系</td><td>通常无</td></tr><tr><td>PO</td><td>Persistent Object</td><td>数据库表映射</td><td>直接映射</td><td>通常无</td></tr><tr><td>DAO</td><td>Data Access Object</td><td>数据访问逻辑</td><td>与数据库交互</td><td>数据操作逻辑</td></tr><tr><td>DTO</td><td>Data Transfer Object</td><td>层间或系统间数据传输</td><td>无直接关系</td><td>通常无</td></tr><tr><td>BO</td><td>Business Object</td><td>业务逻辑处理</td><td>间接（聚合 PO/DTO）</td><td>包含业务逻辑</td></tr></tbody></table></div><p><strong>典型使用场景</strong></p><p>在一个 Spring 项目中，这些对象可能这样协作：</p><ol><li><strong>PO</strong>：UserPO 用于与数据库表 users 映射，由 ORM（如 JPA）管理。</li><li><strong>DAO</strong>：UserDAO 提供对 UserPO 的增删改查操作。</li><li><strong>DTO</strong>：UserDTO 从 UserPO 转换而来，传递给服务层或前端。</li><li><strong>BO</strong>：OrderBO 聚合多个 UserDTO 和订单信息，执行业务计算。</li><li><strong>VO</strong>：UserVO 用于返回给前端的不可变视图数据。</li><li><strong>POJO</strong>：任何简单的 Java 类都可以是 POJO，可能用作上述某种对象的基类。</li></ol><p>数据库连接池</p><div class="table-container"><table><thead><tr><th>特性</th><th>DriverManagerDataSource</th><th>HikariCP</th></tr></thead><tbody><tr><td><strong>连接池支持</strong></td><td>无，每次创建新连接</td><td>有，高效连接池管理</td></tr><tr><td><strong>性能</strong></td><td>低，适合低并发</td><td>高，优化了并发和资源复用</td></tr><tr><td><strong>使用场景</strong></td><td>开发、测试、小型应用</td><td>生产环境、高并发应用</td></tr><tr><td><strong>配置复杂度</strong></td><td>简单，仅基本连接信息</td><td>支持丰富配置（如池大小、超时等）</td></tr><tr><td><strong>依赖</strong></td><td>Spring 自带，无需额外库</td><td>需引入 HikariCP 依赖</td></tr><tr><td><strong>Spring Boot 默认</strong></td><td>否</td><td>是（2.x 和 3.x 默认使用）</td></tr><tr><td><strong>连接管理</strong></td><td>每次获取连接都新建，关闭即销毁</td><td>池化管理，连接复用</td></tr></tbody></table></div><p>HikariCP 是 Spring Boot 默认连接池，性能极高，但无内置监控。</p><p>Druid 提供强大监控功能（如 SQL 执行时间、连接状态），适合需要实时分析连接池状态的场景。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习很潮很流行的Java以及相关框架.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux网络编程入门</title>
    <link href="https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-27T07:01:15.000Z</published>
    <updated>2025-05-02T06:03:41.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).<br><span id="more"></span></p><h2 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h2><h3 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h3><blockquote><p><strong>PF_INET</strong>：指的是协议族（Protocol Family），强调的是协议相关的概念。</p><p><strong>AF_INET</strong>：指的是地址族（Address Family），关注的是地址格式。</p><p>虽然在许多实现中 <code>PF_INET</code> 和 <code>AF_INET</code> 可以互换使用，但理论上它们代表不同的概念。为了保持代码的清晰性和一致性，推荐的做法是在创建套接字时使用 <code>AF_INET</code> 来指代地址族，而保留 <code>PF_INET</code> 用于协议族相关的上下文。不过，由于历史原因和广泛接受的习惯，这种区别在实践中往往被忽略。</p></blockquote><p>在进行网络编程时，<code>sockaddr_in</code>、<code>sockaddr</code> 和 <code>addrinfo</code> 是三个不同的数据结构，它们各自有不同的用途和特点。</p><p><strong>sockaddr</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 地址族（如AF_INET, AF_INET6）</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">// 地址信息，具体格式取决于地址族</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>用途</strong>：</p><ul><li>这是一个<strong>通用的套接字地址结构体</strong>，用于表示任何类型的套接字地址。它不特定于任何一种协议或地址家族。</li><li>它通常作为函数参数传递，以便支持多种不同类型的地址族（例如IPv4、IPv6等）。</li></ul></li><li><p><strong>局限性</strong>：</p><ul><li>因为它的<code>sa_data</code>字段是固定大小的字符数组，所以在处理复杂或长度不定的地址信息时不够灵活。</li></ul></li></ul><p><strong>sockaddr_in</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">// 地址族，必须设置为AF_INET</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">// 端口号（使用htons()转换为网络字节序）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IPv4地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>]; <span class="comment">// 填充0以使结构体大小与sockaddr相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr; <span class="comment">// 32位IPv4地址（网络字节序）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>用途</strong>：</p><ul><li><strong>专门用于IPv4地址的套接字地址结构体</strong>。</li><li>提供了明确的字段来存储端口号和IP地址，使得处理IPv4地址更加直观和方便。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>相较于<code>sockaddr</code>，它提供了更具体的字段，便于操作IPv4地址和端口信息。</li></ul></li></ul><p><strong>sockaddr_in6</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;<span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;<span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>addrinfo</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>              ai_flags;     <span class="comment">// AI_PASSIVE, AI_CANONNAME, etc.</span></span><br><span class="line">    <span class="keyword">int</span>              ai_family;    <span class="comment">// AF_INET, AF_INET6, AF_UNSPEC</span></span><br><span class="line">    <span class="keyword">int</span>              ai_socktype;  <span class="comment">// SOCK_STREAM, SOCK_DGRAM</span></span><br><span class="line">    <span class="keyword">int</span>              ai_protocol;  <span class="comment">// 使用的协议</span></span><br><span class="line">    <span class="keyword">socklen_t</span>        ai_addrlen;   <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">// 地址信息</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">// 主机规范名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">// 下一个addrinfo结构指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png" alt="image-20250227150905975"></p></li><li><p><strong>用途</strong>：</p><ul><li><code>addrinfo</code> 结构体由 <code>getaddrinfo()</code> 函数返回，旨在<strong>提供一个统一的方式来处理不同类型的地址信息（包括IPv4和IPv6），并简化了主机名和服务名解析的过程</strong>。</li><li>它可以包含多个结果（通过<code>ai_next</code>链表连接），允许应用程序选择最适合其需求的结果。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>支持现代互联网中常见的IPv4和IPv6地址。</li><li>能够处理复杂的配置需求，如指定被动监听（AI_PASSIVE）、获取规范主机名等。</li><li>更加灵活和强大，适合需要跨平台兼容性和灵活性的应用程序。</li></ul></li></ul><p><strong>sockaddr_storage</strong></p><p><code>sockaddr_storage</code> 是一个在 <code>&lt;netinet/in.h&gt;</code> 或 <code>&lt;sys/socket.h&gt;</code> 头文件中定义的数据结构，旨在提供一个足够大的缓冲区来存储任何类型的套接字地址（包括 IPv4、IPv6 等）。它解决了由于不同协议族的地址结构大小不一致所带来的问题，例如 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别用于 IPv4 和 IPv6 地址，它们有不同的大小。</p><p><strong>定义与用途</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> ss_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="comment">// 其余字段未指定，实现定义以确保足够的空间和对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>ss_family</strong>：这是唯一标准化的字段，表示地址族（如 <code>AF_INET</code> 对应 IPv4，<code>AF_INET6</code> 对应 IPv6）。</li><li><strong>其他字段</strong>：这些字段的具体定义依赖于实现，主要是为了确保 <code>sockaddr_storage</code> 能够容纳所有可能的套接字地址类型，并且保持正确的内存对齐。这意味着它的大小至少要能容纳最大的套接字地址结构（比如 <code>sockaddr_in6</code>）。</li></ul><p><strong>主要特点</strong></p><ol><li><strong>统一性</strong>：通过使用 <code>sockaddr_storage</code>,可以编写更加通用的代码，避免直接处理特定于协议的地址结构（如 <code>sockaddr_in</code> 或 <code>sockaddr_in6</code>），从而提高代码的可移植性和灵活性。</li><li><strong>大小保证</strong>：<code>sockaddr_storage</code> 的大小被设计为足以容纳系统支持的所有套接字地址结构，这使得它可以安全地转换为任何特定的套接字地址类型。</li><li><strong>对齐要求</strong>：除了大小之外，<code>sockaddr_storage</code> 还满足了所有套接字地址结构的对齐要求，这对于高效访问数据至关重要。</li></ol><p><strong>总结</strong></p><ul><li><strong><code>sockaddr</code></strong>：是一个通用的套接字地址结构体，适用于所有地址族。由于其设计较为通用，实际应用中常被特定于某种地址族的结构体替代，如<code>sockaddr_in</code>。</li><li><strong><code>sockaddr_in</code></strong>：专用于IPv4地址，提供了对IPv4地址和端口的具体支持，易于理解和使用。</li><li><strong><code>addrinfo</code></strong>：提供了一个更高级别的抽象，能够处理IPv4和IPv6地址，并且支持更多的选项和灵活性。它是推荐的方式来进行现代网络编程中的地址解析和套接字创建，特别是当你需要同时支持IPv4和IPv6时。</li></ul><p><strong>socketpair</strong></p><p><code>socketpair</code> 是一个用于创建一对互联的套接字描述符的系统调用，它允许在同一主机上的两个进程之间进行双向通信。通常，这些套接字被用于父子进程间的通信，但它们也可以用于任何需要双向（全双工）通信通道的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>domain</code>：指定协议族，通常是 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>（本地通信），但在某些实现中也可能支持其他域如 <code>AF_INET</code>。</li><li><code>type</code>：指定套接字类型，常见的有 <code>SOCK_STREAM</code>（提供有序、可靠、双向的连接）和 <code>SOCK_DGRAM</code>（数据报套接字）。</li><li><code>protocol</code>：指定使用的协议，通常为 <code>0</code>，表示使用默认协议。</li><li><code>sv</code>：指向一个包含两个整数元素的数组，这两个整数将作为返回的套接字描述符。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功时，返回 <code>0</code> 并在 <code>sv</code> 数组中填充两个有效的套接字描述符。</li><li>失败时，返回 <code>-1</code> 并设置 <code>errno</code>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sv[<span class="number">2</span>]; <span class="comment">// 存储两个套接字描述符</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MSG_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一对套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sv) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">0</span>]); <span class="comment">// 关闭不需要的套接字端</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">&quot;Hello from child process!&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(sv[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg) + <span class="number">1</span>); <span class="comment">// 发送消息给父进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">1</span>]); <span class="comment">// 关闭不需要的套接字端</span></span><br><span class="line">        <span class="keyword">ssize_t</span> bytes_read = <span class="built_in">read</span>(sv[<span class="number">0</span>], buffer, MSG_SIZE); <span class="comment">// 从子进程接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message from child: %s\n&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址二进制与点分十进制转换"><a href="#地址二进制与点分十进制转换" class="headerlink" title="地址二进制与点分十进制转换"></a>地址二进制与点分十进制转换</h3><p>在网络编程中，有时需要将点分十进制表示的IPv4地址（如<code>&quot;192.168.1.1&quot;</code>）转换成32位无符号整数形式以便于处理或计算。在C语言中，可以使用以下函数来实现这种转换：</p><ul><li><strong><code>inet_addr</code></strong>: 这是一个简单的函数，用于将点分十进制格式的IPv4地址转换为网络字节序的32位长整型值。然而，<strong>它不支持IPv6，并且如果输入无效，则返回<code>INADDR_NONE</code></strong></li><li><strong><code>inet_aton</code></strong>: 此函数不仅将点分十进制的IPv4地址转换为二进制形式，还会检查输入的有效性。它接受一个指向<code>in_addr</code>结构的指针作为第二个参数，并在此结构中填充相应的数值。<strong>如果转换成功，返回非零值；否则返回0</strong></li><li><strong><code>inet_pton</code></strong>: 这是一个更为现代和推荐使用的函数，支持IPv4和IPv6地址的转换。对于IPv4，它的第二个参数是一个指向<code>struct in_addr</code>类型的指针，对于IPv6，则是指向<code>struct in6_addr</code>类型的指针<strong>。如果转换成功，返回1</strong>；如果输入格式不正确，则返回0；如果遇到系统错误，则返回-1。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th><code>inet_addr</code></th><th><code>inet_aton</code></th></tr></thead><tbody><tr><td><strong>输入格式</strong></td><td>点分十进制字符串</td><td>点分十进制字符串</td></tr><tr><td><strong>输出格式</strong></td><td>返回 <code>in_addr_t</code>（32 位整数）</td><td>填充 <code>struct in_addr</code> 结构体</td></tr><tr><td><strong>错误处理</strong></td><td>错误时返回 <code>INADDR_NONE</code></td><td>错误时返回 <code>0</code></td></tr><tr><td><strong>线程安全性</strong></td><td>安全</td><td>安全</td></tr><tr><td><strong>推荐程度</strong></td><td>不推荐（已过时）</td><td>推荐</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数名</th><th>输入格式</th><th>输出格式</th><th>支持的地址类型</th><th>线程安全性</th></tr></thead><tbody><tr><td><code>inet_pton</code></td><td>字符串</td><td>二进制</td><td>IPv4 和 IPv6</td><td>安全</td></tr><tr><td><code>inet_aton</code></td><td>字符串</td><td>二进制</td><td>仅 IPv4</td><td>安全</td></tr><tr><td><code>inet_ntop</code></td><td>二进制</td><td>字符串</td><td>IPv4 和 IPv6</td><td>安全</td></tr><tr><td><code>inet_ntoa</code></td><td>二进制</td><td>字符串</td><td>仅 IPv4</td><td>不安全</td></tr></tbody></table></div><h3 id="端口字节序转换"><a href="#端口字节序转换" class="headerlink" title="端口字节序转换"></a>端口字节序转换</h3><p>在网络编程中，处理不同系统间的数据传输时，经常需要将数据在主机字节序（Host Byte Order）和网络字节序（Network Byte Order）之间进行转换。这是因为不同的计算机架构可能使用不同的字节序来存储多字节数据类型，如整数。为了确保数据在网络上传输的一致性，通常采用大端字节序（Big Endian），也被称作网络字节序</p><p>针对这种需求，有几组常用的函数用于在主机字节序和网络字节序之间进行转换：</p><ol><li><strong><code>htonl</code> 和 <code>htons</code></strong>：这两个函数分别用于将32位整型（<code>long</code>）和16位整型（<code>short</code>）从主机字节序转换为网络字节序。<ul><li><code>htonl(uint32_t hostlong)</code>: Host to Network Long</li><li><code>htons(uint16_t hostshort)</code>: Host to Network Short</li></ul></li><li><strong><code>ntohl</code> 和 <code>ntohs</code></strong>：与上述相反，这两个函数用于将32位和16位整型从网络字节序转换为主机字节序。<ul><li><code>ntohl(uint32_t netlong)</code>: Network to Host Long</li><li><code>ntohs(uint16_t netshort)</code>: Network to Host Short</li></ul></li></ol><p>为了保证网络通信的兼容性，通常采用大端字节序（Big Endian），也称为网络字节序，来表示跨网络传输的数据。</p><p><strong>需要转换为网络字节序的数据类型</strong></p><ol><li><strong>端口号</strong>：端口号通常是16位的整数，在发送之前应该从主机字节序转换为网络字节序。</li><li><strong>IP地址</strong>：虽然IP地址通常以字符串形式表示（例如“192.168.0.1”），但在某些情况下，你可能会处理32位整型的IPv4地址或128位的IPv6地址。对于这些情况，如果需要直接操作整型值，则应确保它们是网络字节序。</li><li><strong>序列号、确认号等TCP头部字段</strong>：这些字段都是32位的整数，用于TCP协议中的状态跟踪和数据流控制，因此也需要转换为网络字节序。</li><li><strong>其他自定义协议中的多字节字段</strong>：如果你设计了一个自定义的应用层协议，并且该协议包含多字节整数字段（如长度指示符、版本号等），那么这些字段也应该按照网络字节序进行编码。</li></ol><h3 id="设置套接字等选项"><a href="#设置套接字等选项" class="headerlink" title="设置套接字等选项"></a>设置套接字等选项</h3><p><code>setsockopt</code> 是一个用于设置套接字选项的函数，它允许开发者对套接字的行为进行精细控制。通过 <code>setsockopt</code>，可以调整套接字的各种属性，例如<strong>地址复用</strong>、<strong>接收/发送缓冲区大小</strong>、超时时间等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><strong><code>sockfd</code></strong>:<ul><li>套接字描述符。</li><li>指定要设置选项的目标套接字。</li></ul></li><li><strong><code>level</code></strong>:<ul><li>选项所属的协议层。</li><li>常见值包括：<ul><li><code>SOL_SOCKET</code>: 套接字通用选项（如地址复用、广播等）。</li><li><code>IPPROTO_TCP</code>: TCP 协议相关选项。</li><li><code>IPPROTO_IP</code>: IP 协议相关选项。</li><li><code>IPPROTO_IPV6</code>: IPv6 相关选项。</li></ul></li></ul></li><li><strong><code>optname</code></strong>:<ul><li>具体的选项名称。</li><li>根据 <code>level</code> 的不同，可以选择不同的选项。</li></ul></li><li><strong><code>optval</code></strong>:<ul><li>指向选项值的指针。</li><li>选项值的具体类型和格式取决于 <code>optname</code>。</li></ul></li><li><strong><code>optlen</code></strong>:<ul><li><code>optval</code> 缓冲区的大小（以字节为单位）</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><ol><li><strong><code>SO_REUSEADDR</code></strong></li></ol><ul><li><strong>作用</strong>: 允许绑定到已被占用的地址和端口。</li><li><strong>场景</strong>: 通常用于避免因端口被占用而导致服务器无法启动的问题。</li></ul><p><strong>2. <code>SO_REUSEPORT</code></strong></p><ul><li><strong>作用</strong>: 允许多个进程或线程绑定到同一个端口。</li><li><strong>场景</strong>: 适用于多线程或多进程服务器模型。</li><li><strong>注意</strong>: 需要与 <code>SO_REUSEADDR</code> 配合使用</li></ul><p><strong>3. <code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code></strong></p><ul><li><p>作用</p><p>:</p><ul><li><code>SO_RCVBUF</code>: 设置接收缓冲区大小。</li><li><code>SO_SNDBUF</code>: 设置发送缓冲区大小。</li></ul></li></ul><p><strong>4. <code>SO_BROADCAST</code></strong></p><ul><li><strong>作用</strong>: 启用广播功能。</li><li><strong>场景</strong>: 用于 UDP 广播通信</li></ul><p><strong>5. <code>SO_KEEPALIVE</code></strong></p><ul><li><strong>作用</strong>: 启用 TCP 的保活机制。</li><li><strong>场景</strong>: 检测长时间空闲的连接是否仍然有效。</li></ul><p><strong>6. <code>SO_LINGER</code></strong></p><ul><li><strong>作用</strong>: 控制关闭套接字时的行为。</li><li><strong>场景</strong>: 当需要确保所有数据在关闭前被发送时。</li></ul><p><strong>7. <code>TCP_NODELAY</code></strong></p><ul><li><strong>作用</strong>: 禁用 Nagle 算法，减少小数据包的延迟。</li><li><strong>场景</strong>: 对于实时性要求较高的应用（如在线游戏、实时聊天）。</li></ul><h3 id="设置文件描述符选项"><a href="#设置文件描述符选项" class="headerlink" title="设置文件描述符选项"></a>设置文件描述符选项</h3><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>fd</code></strong>：目标文件描述符。</p></li><li><p><code>cmd</code></p><p>：指定要执行的操作类型，常见的命令包括：</p><ul><li><strong><code>F_GETFL</code></strong>：获取文件描述符的状态标志。</li><li><strong><code>F_SETFL</code></strong>：设置文件描述符的状态标志。</li><li><strong><code>F_GETFD</code></strong>：获取文件描述符的文件描述符标志。</li><li><strong><code>F_SETFD</code></strong>：设置文件描述符的文件描述符标志。</li><li><strong><code>F_DUPFD</code></strong>：复制文件描述符。</li><li><strong><code>F_DUPFD_CLOEXEC</code></strong>：复制文件描述符并设置 <code>FD_CLOEXEC</code> 标志。</li></ul></li><li><p><strong><code>arg</code></strong>：可选参数，具体取决于 <code>cmd</code> 的值。例如，在使用 <code>F_SETFL</code> 时，<code>arg</code> 是新的状态标志</p></li></ul><p>在网络编程中，将套接字设置为非阻塞模式是一种常见的优化手段。非阻塞模式允许在尝试读取或写入数据时立即返回，而不会阻塞进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符设置为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取当前文件描述符的标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_GETFL failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 O_NONBLOCK 标志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_SETFL failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非阻塞模式下：</p><ul><li>如果没有数据可读，<code>read()</code> 或 <code>recv()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li><li>如果无法立即写入数据，<code>write()</code> 或 <code>send()</code> 也会返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li></ul><p>文件状态标志可以通过 <code>fcntl(fd, F_GETFL)</code> 获取当前设置，并通过 <code>fcntl(fd, F_SETFL, flags)</code> 修改。</p><ul><li><strong><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></strong>：打开文件的模式（只读、只写、读写），通常在打开文件时确定，不能通过 <code>F_SETFL</code> 修改。</li><li><strong><code>O_APPEND</code></strong>：每次写入时将数据追加到文件末尾。</li><li><strong><code>O_NONBLOCK</code></strong>：设置非阻塞模式。对于文件或设备，这意味着尝试的操作（如读取或写入）如果无法立即完成，则会立即返回而不是阻塞等待。在网络编程中，这通常用于套接字以实现异步I/O。</li><li><strong><code>O_ASYNC</code></strong>：当I/O可用时发送信号（通常是 <code>SIGIO</code>）给进程。此功能允许进程异步地处理I/O事件。</li><li><strong><code>O_DSYNC</code> 和 <code>O_SYNC</code></strong>：要求同步写入。<code>O_DSYNC</code> 确保数据同步写入磁盘，而 <code>O_SYNC</code> 还包括文件元数据的同步写入。</li></ul><blockquote><p>在 TCP 套接字中，<code>read()</code> 和 <code>recv()</code> 都无法保证一次调用就能读取完整的数据包。可能需要循环读取，直到接收到完整的数据。</p><p>如果套接字是非阻塞模式，且没有数据可读，<code>read()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><ul><li>如果套接字是阻塞模式，且没有数据可读，<code>read()</code> 会阻塞，直到有数据到达或发生错误。</li><li><code>read()</code> 不区分消息边界（特别是在 TCP 套接字中）。它只是简单地从流中读取尽可能多的数据。</li></ul><p><strong>非阻塞模式</strong></p><ul><li>在非阻塞模式下，如果没有数据可读，<code>read()</code> 和 <code>recv()</code> 都会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li><li>在这种情况下，通常需要结合事件通知机制（如 <code>select()</code>、<code>poll()</code> 或 <code>epoll()</code>）来监听可读事件。</li></ul><p><strong>错误处理</strong></p><ul><li>处理 <code>EINTR</code>（信号中断）：如果 <code>read()</code> 或 <code>recv()</code> 返回 <code>-1</code> 并且 <code>errno</code> 为 <code>EINTR</code>，通常需要重试。</li><li>处理 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>：说明当前没有更多数据可读，等待下次事件通知即可。</li></ul></blockquote><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><p>信号是操作系统向进程发送的一种异步通知机制，用于告知进程某个事件已经发生。信号可以被视为一种软件中断，它会打断进程的正常执行流程。</p><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p><strong><code>signal()</code> 函数</strong></p><p>这是最基本的信号处理函数，用于设置对指定信号的处理方式。然而，它不如 <code>sigaction</code> 灵活和可靠。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>signum</code>：要捕获或忽略的信号编号。</li><li><code>handler</code>：信号处理函数指针，或者 <code>SIG_DFL</code>（默认处理）、<code>SIG_IGN</code>（忽略）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_sigint</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 SIGINT (Ctrl+C) 的处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, handle_sigint) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Unable to set handler for SIGINT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Process running...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 定义了许多标准信号，例如：</p><ul><li><code>SIGINT</code>（2）：由用户按下 <code>Ctrl+C</code> 触发，通常用于终止进程。</li><li><code>SIGTERM</code>（15）：请求终止进程的信号。</li><li><code>SIGKILL</code>（9）：强制终止进程的信号，无法被捕获或忽略。</li><li><code>SIGSEGV</code>（11）：段错误（访问非法内存地址）。</li><li><code>SIGCHLD</code>（17）：子进程状态改变时发送给父进程的信号。</li><li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>：用户自定义信号。</li></ul><p>信号可以通过以下几种方式触发：</p><p><strong>(1) 用户输入</strong></p><ul><li>按下 <code>Ctrl+C</code> 会向当前前台进程发送 <code>SIGINT</code> 信号。</li><li>按下 <code>Ctrl+\</code> 会向当前前台进程发送 <code>SIGQUIT</code> 信号。</li></ul><p><strong>(2) 系统调用</strong></p><p>通过系统调用 <code>kill</code> 或 <code>raise</code> 可以向进程发送信号：</p><ul><li><code>kill(pid_t pid, int sig)</code>：向指定进程 ID 的进程发送信号。</li><li><code>raise(int sig)</code>：向当前进程自身发送信号。</li></ul><p><strong>(3) 硬件异常</strong></p><p>当进程访问非法内存地址时，操作系统会发送 <code>SIGSEGV</code> 信号；当进行非法指令操作时，可能会发送 <code>SIGILL</code> 信号。</p><p><strong>(4) 软件触发</strong></p><p>通过调用 <code>alarm</code> 函数可以设置定时器，超时时会向进程发送 <code>SIGALRM</code> 信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, handler); <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>); <span class="comment">// 设置 3 秒后发送 SIGALRM 信号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for the alarm signal...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pause</span>(); <span class="comment">// 挂起进程，等待信号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p><code>sigaction</code> 是 POSIX 标准定义的一种机制，用于定义进程对特定信号的响应行为。它提供了一种比 <code>signal()</code> 更加灵活和强大的方式来处理信号。<code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。</p><p><code>sigaction</code> 提供了比 <code>signal()</code> 更加精细和强大的信号处理功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><code>signum</code>：信号编号。</li><li><code>act</code>：指向包含新动作的 <code>struct sigaction</code> 结构体的指针。</li><li><code>oldact</code>：如果非空，则保存旧的动作。</li></ul></li></ul><p><strong><code>struct sigaction</code> 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_handler)(<span class="keyword">int</span>);             <span class="comment">// 信号处理函数</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">// 用于带有附加信息的信号处理函数</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;                       <span class="comment">// 在执行信号处理器期间需要阻塞的信号集合</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;                      <span class="comment">// 控制信号处理的行为标志</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_restorer)(<span class="keyword">void</span>);           <span class="comment">// 已废弃，不应使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。</p><p><strong>字段说明</strong></p><ul><li><strong><code>sa_handler</code></strong>：<ul><li>这是一个指向信号处理函数的指针，或者可以设置为 <code>SIG_DFL</code>（默认信号处理）或 <code>SIG_IGN</code>（忽略信号）。</li></ul></li><li><strong><code>sa_sigaction</code></strong>：<ul><li>当 <code>sa_flags</code> 中设置了 <code>SA_SIGINFO</code> 标志时，此字段将作为信号处理函数使用。与 <code>sa_handler</code> 不同，<code>sa_sigaction</code> 可以接收更多信息，包括一个指向 <code>siginfo_t</code> 结构的指针（包含有关信号的详细信息）和一个指向处理器上下文的指针（通常不使用）。</li></ul></li><li><strong><code>sa_mask</code></strong>：<ul><li>定义了一个信号集，在调用信号处理程序之前，这些信号会被加入到当前的信号屏蔽字中。这意味着在执行信号处理程序期间，这些信号会被暂时阻塞。</li></ul></li><li><strong><code>sa_flags</code></strong>：<ul><li>控制信号处理的行为。常见的标志包括：<ul><li><strong><code>SA_RESTART</code></strong>：如果信号中断了某个系统调用，则自动重启该系统调用（而不是返回错误）。</li><li><strong><code>SA_NOCLDSTOP</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，如果设置了此标志，则子进程停止或恢复时不会发送 <code>SIGCHLD</code> 信号给父进程。</li><li><strong><code>SA_NOCLDWAIT</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，阻止创建僵尸进程。</li><li><strong><code>SA_SIGINFO</code></strong>：指示使用 <code>sa_sigaction</code> 字段中的信号处理函数，而非 <code>sa_handler</code>。这允许访问扩展的信号信息。</li></ul></li></ul></li><li><strong><code>sa_restorer</code></strong>：<ul><li>这个字段已废弃，不应该被使用。</li></ul></li></ul><p><strong>使用示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, signum);</span><br><span class="line">    <span class="comment">// 打印更多关于信号的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal code: %d\n&quot;</span>, info-&gt;si_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构体</span></span><br><span class="line">    act.sa_sigaction = handler;</span><br><span class="line">    act.sa_flags = SA_SIGINFO; <span class="comment">// 使用带有额外参数的信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充信号掩码，这里我们不限制任何额外的信号</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SIGINT 的信号处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT (Ctrl+C)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起进程，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pause</span>(); <span class="comment">// 等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p><code>stat</code> 函数是 Unix 和类 Unix 操作系统（如 Linux）中的一个系统调用，用于获取文件或文件系统对象的相关信息。它通过填充一个 <code>struct stat</code> 结构体来提供文件的元数据，包括文件大小、权限、创建时间等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>pathname</code>：要查询的文件或目录的路径。</li><li><code>statbuf</code>：指向一个 <code>struct stat</code> 结构体的指针，该结构体将被用来存储文件的状态信息。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功时返回 <code>0</code>。</li><li>失败时返回 <code>-1</code> 并设置 <code>errno</code> 来指示错误类型。</li></ul></li></ul><p>除了 <code>stat</code>，还有其他几个类似的函数可以用于不同的场景：</p><ul><li><p><strong><code>fstat</code></strong>：与 <code>stat</code> 类似，但它接受一个文件描述符而不是路径名作为第一个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>lstat</code></strong>：与 <code>stat</code> 类似，但如果目标是一个符号链接（symlink），它会返回符号链接本身的信息，而不是它指向的目标文件的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>struct stat</code> 包含了大量的关于文件的信息。以下是一些常用的字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">// 文件所在设备的标识符</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">// inode 编号</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">// 文件类型和访问权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">// 硬链接数量</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">// 文件所有者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">// 文件所有者的组 ID</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">// 如果文件是一个设备文件，则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">// 文件系统的 I/O 块大小</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">// 分配给文件的块数</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_atime;       <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_mtime;       <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_ctime;       <span class="comment">// 最后状态改变时间（在 Unix 中通常为元数据更改时间）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>struct stat</code> 的 <code>st_mode</code> 字段中，文件类型和权限信息被编码在一起。可以通过位操作提取这些信息：</p><ul><li><strong>文件类型</strong>：<ul><li><code>S_IFMT</code>：文件类型的掩码。</li><li><code>S_IFDIR</code>：目录。</li><li><code>S_IFCHR</code>：字符设备。</li><li><code>S_IFBLK</code>：块设备。</li><li><code>S_IFREG</code>：普通文件。</li><li><code>S_IFIFO</code>：命名管道（FIFO）。</li><li><code>S_IFLNK</code>：符号链接。</li><li><code>S_IFSOCK</code>：套接字。</li></ul></li><li><strong>权限</strong>：<ul><li><code>S_IRUSR</code>, <code>S_IWUSR</code>, <code>S_IXUSR</code>：用户（拥有者）的读、写、执行权限。</li><li><code>S_IRGRP</code>, <code>S_IWGRP</code>, <code>S_IXGRP</code>：组的读、写、执行权限。</li><li><code>S_IROTH</code>, <code>S_IWOTH</code>, <code>S_IXOTH</code>：其他人的读、写、执行权限。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sb.st_mode &amp; S_IFMT) == S_IFREG &amp;&amp; (sb.st_mode &amp; S_IRUSR)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a regular file with read permission for the owner.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>mmap</code> 是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，用于<strong>将文件或设备的内存映射到进程的地址空间</strong>。这种机制允许程序以类似于访问内存的方式访问文件内容，从而简化了文件操作，并且可以提高性能，特别是在处理大文件时。</p><ul><li><strong>文件映射</strong>：将文件的内容映射到进程的虚拟内存中，使得可以通过指针直接访问文件的数据，而不需要通过常规的文件 I/O 操作（如 <code>read</code> 和 <code>write</code>）。</li><li><strong>共享内存</strong>：允许多个进程共享同一块内存区域，实现高效的进程间通信（IPC）。</li><li><strong>匿名映射</strong>：创建不与任何文件关联的内存映射，适用于需要动态分配大块内存的情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>addr</code>：建议的映射起始地址（通常设为 <code>NULL</code>，让系统选择合适的地址）。</li><li><code>length</code>：映射区域的大小（字节数）。</li><li>prot：指定映射区域的保护标志（如可读、可写、可执行等）。<ul><li><code>PROT_READ</code>：映射区域可读。</li><li><code>PROT_WRITE</code>：映射区域可写。</li><li><code>PROT_EXEC</code>：映射区域可执行。</li></ul></li><li>flags：控制映射区域的行为。<ul><li><code>MAP_SHARED</code>：映射区域会被多个进程共享，修改会反映到文件中。</li><li><code>MAP_PRIVATE</code>：创建私有副本，修改不会影响原文件。</li><li><code>MAP_ANONYMOUS</code>：映射匿名内存（不与文件关联）。</li></ul></li><li><code>fd</code>：要映射的文件描述符（对于匿名映射，应设置为 <code>-1</code>）。</li><li><code>offset</code>：从文件开头开始的偏移量（必须是页面大小的倍数）。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时返回指向映射区域的指针。</li><li>失败时返回 <code>MAP_FAILED</code>（通常定义为 <code>(void *) -1</code>），并设置 <code>errno</code>。</li></ul></li><li><p><strong><code>munmap</code></strong>：解除内存映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>msync</code></strong>：同步内存映射区域到文件或设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解析传入参数"><a href="#解析传入参数" class="headerlink" title="解析传入参数"></a>解析传入参数</h2><p>Linux中<code>getopt</code> 是一个用于解析命令行选项的标准 C 库函数。它使得程序能够处理以短格式（如 <code>-a</code>, <code>-b value</code>）提供的命令行参数。<code>getopt</code> 函数及其扩展版本 <code>getopt_long</code> 为开发者提供了便捷的方式来解析和处理命令行选项。</p><h4 id="get-opt函数"><a href="#get-opt函数" class="headerlink" title="get_opt函数"></a>get_opt函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><code>argc</code> 和 <code>argv</code>：分别是从 <code>main</code> 函数传递过来的参数计数和参数数组。</li><li><code>optstring</code>：包含程序所支持的选项字符组成的字符串。如果某个选项需要参数，则在该选项字符后加上冒号（<code>:</code>），表示该选项需要一个值。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时，返回下一个选项字符。</li><li>当所有选项都已处理完毕，返回 <code>-1</code>。</li><li>如果遇到无效选项或缺少必需的参数，返回 <code>?</code> 并设置 <code>optopt</code> 变量为无效选项字符。</li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><code>optind</code>：指向下一个要处理的 <code>argv</code> 元素的索引。</li><li><code>optarg</code>：<strong>指向当前选项的参数</strong>（如果有）。</li><li><code>opterr</code>：控制 <code>getopt</code> 是否打印错误消息，默认为 1（开启）。</li><li><code>optopt</code>：存储无效选项字符或缺失参数的选项字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;ab:c&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -a\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -b with value %s\n&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -c\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (optopt == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Option -b requires an argument.\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Unknown option character `\\x%x&#x27;.\n&quot;</span>, optopt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理非选项参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = optind; index &lt; argc; index++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non-option argument: %s\n&quot;</span>, argv[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="getopt-long-函数"><a href="#getopt-long-函数" class="headerlink" title="getopt_long 函数"></a><code>getopt_long</code> 函数</h4><p>对于支持长格式选项（如 <code>--option</code>, <code>--option=value</code>）的应用程序，可以使用 <code>getopt_long</code> 函数。</p><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><strong>函数原型</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *shortopts, <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><p><code>shortopts</code>：与 <code>getopt</code> 相同，定义短格式选项。</p></li><li><p>longopts指向描述长格式选项的struct option</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 长格式选项名</span></span><br><span class="line">    <span class="keyword">int</span>         has_arg; <span class="comment">// 是否需要参数，可能值：no_argument, required_argument, optional_argument</span></span><br><span class="line">    <span class="keyword">int</span>        *flag;    <span class="comment">// 若不为 NULL，函数将此指针指向的变量设为 val；若为 NULL，函数返回 val</span></span><br><span class="line">    <span class="keyword">int</span>         val;     <span class="comment">// 返回给 `getopt_long` 的值或设置到 `flag` 指向的变量中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>longindex</code>：如果非 <code>NULL</code>，则指向一个变量，该变量接收匹配的长选项在 <code>longopts</code> 数组中的索引。</p></li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时，返回匹配选项的字符（对于短选项）或 <code>val</code> 字段的值（对于长选项）。</li><li>当所有选项都已处理完毕，返回 <code>-1</code>。</li><li>对于无效选项或缺少必需的参数，返回 <code>?</code>。</li></ul></li><li><p><strong><code>getopt</code></strong>：适用于处理短格式选项的简单场景。通过指定一个选项字符串来定义允许的选项及是否需要参数。</p></li><li><strong><code>getopt_long</code></strong>：扩展了 <code>getopt</code>，支持长格式选项，并允许更灵活地配置每个选项的行为（是否需要参数、如何处理等）。</li></ul><h2 id="分散-聚集IO"><a href="#分散-聚集IO" class="headerlink" title="分散/聚集IO"></a>分散/聚集IO</h2><p>分散/聚集 I/O（Scatter/Gather I/O）是一种<strong>允许在单次系统调用中处理多个数据缓冲区的技术</strong>。它特别适用于需要处理多个不连续的数据块的应用场景，如网络通信、数据库操作等。通过分散/聚集 I/O，可以减少系统调用的次数，提高性能和效率。</p><h4 id="分散-I-O（Scatter-I-O）"><a href="#分散-I-O（Scatter-I-O）" class="headerlink" title="分散 I/O（Scatter I/O）"></a>分散 I/O（Scatter I/O）</h4><p>分散读取（Scatter Read）指的是从一个输入源（例如文件或套接字）读取数据，并将这些数据分散到多个缓冲区中。这种技术通常用于接收长度未知的数据流，并将其分割成多个部分存储在不同的缓冲区中。</p><h4 id="聚集-I-O（Gather-I-O）"><a href="#聚集-I-O（Gather-I-O）" class="headerlink" title="聚集 I/O（Gather I/O）"></a>聚集 I/O（Gather I/O）</h4><p>聚集写入（Gather Write）则是指将多个缓冲区中的数据收集起来，然后一次性写入到输出目标（例如文件或套接字）。这种方法可以简化编程模型，并且通过减少系统调用的数量来提高性能。</p><p>在 Unix 和类 Unix 系统（如 Linux）中，分散/聚集 I/O 主要通过 <code>readv</code> 和 <code>writev</code> 系统调用来实现。</p><p><strong><code>readv</code> 和 <code>writev</code> 函数</strong></p><ul><li><strong><code>readv</code></strong>：从文件描述符读取数据并分散到多个缓冲区。</li><li><strong><code>writev</code></strong>：从多个缓冲区收集数据并写入到文件描述符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>  *iov_base;    <span class="comment">// 指向缓冲区的指针</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">// 缓冲区长度（字节数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">6</span>]; <span class="comment">// 存储 &quot;Hello,&quot;</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">8</span>]; <span class="comment">// 存储 &quot; World!\n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf1);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> read_bytes = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;readv&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf1[<span class="built_in"><span class="keyword">sizeof</span></span>(buf1)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保 buf1 是以 null 结尾的字符串</span></span><br><span class="line">    buf2[<span class="built_in"><span class="keyword">sizeof</span></span>(buf2)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保 buf2 是以 null 结尾的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: &#x27;%s&#x27; and &#x27;%s&#x27;\n&quot;</span>, read_bytes, buf1, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP流程"><a href="#TCP流程" class="headerlink" title="TCP流程"></a>TCP流程</h2><p><strong>TCP Server</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (struct sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="keyword">if</span> ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (<span class="keyword">socklen_t</span> *)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端数据</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(new_socket, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    send(new_socket, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response sent to client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(new_socket);</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TCP Client</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP流程"><a href="#UDP流程" class="headerlink" title="UDP流程"></a>UDP流程</h2><p><strong>UDP Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  sockaddr_in servaddr, cliaddr;</span><br><span class="line">  <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">  <span class="comment">// 创建套接字 SOCK_DGRAM</span></span><br><span class="line">  <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  <span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定地址和端口</span></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端绑定套接字后 直接开始读了</span></span><br><span class="line">  <span class="comment">// 接收客户端数据</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">recvfrom</span>(sockfd, (<span class="keyword">char</span> *)buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">  buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送响应</span></span><br><span class="line">  <span class="built_in">sendto</span>(sockfd, (<span class="keyword">const</span> <span class="keyword">char</span> *)response, <span class="built_in">strlen</span>(response), <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">const</span> struct sockaddr *)&amp;cliaddr, len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Response sent to client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP Client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建套接字</span></span><br><span class="line">  <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置服务器地址</span></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建套接字 后直接发送消息 需要连接的地址,不需要connect</span></span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="built_in">sendto</span>(sockfd, (<span class="keyword">const</span> <span class="keyword">char</span> *)message, <span class="built_in">strlen</span>(message), <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收响应</span></span><br><span class="line">  <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">recvfrom</span>(sockfd, (<span class="keyword">char</span> *)buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;servaddr, &amp;len);</span><br><span class="line">  buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步IO机制"><a href="#异步IO机制" class="headerlink" title="异步IO机制"></a>异步IO机制</h2><p><img data-src="https://pic1.zhimg.com/v2-25903c3b11d19c9bbbc2f414665a435e_1440w.jpg" alt="img"></p><p><a href="https://arthurchiao.art/blog/intro-to-io-uring-zh/#24-三种工作模式">[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）</a></p><p><a href="https://www.cnblogs.com/schips/p/12575933.html">Linux 网络编程的5种IO模型：异步IO模型 - schips - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/577599879">一篇文章彻底搞懂linux的异步IO - 知乎</a></p><h3 id="POSIX异步IO"><a href="#POSIX异步IO" class="headerlink" title="POSIX异步IO"></a>POSIX异步IO</h3><p>POSIX异步I/O提供了一种机制，允许应用程序在执行I/O操作时不会被阻塞，这意味着程序可以在I/O操作完成的同时继续执行其他任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Asynchronous I/O control block.  */</span><br><span class="line">struct aiocb</span><br><span class="line">&#123;</span><br><span class="line">  int aio_fildes;/* File descriptor.  */</span><br><span class="line">  int aio_lio_opcode;/* Operation to be performed.  */</span><br><span class="line">  int aio_reqprio;/* Request priority offset.  */</span><br><span class="line">  volatile void *aio_buf;/* Location of buffer.  */</span><br><span class="line">  size_t aio_nbytes;/* Length of transfer.  */</span><br><span class="line">  struct sigevent aio_sigevent;/* Signal number and value.  */</span><br><span class="line"></span><br><span class="line">  /* Internal members.  */</span><br><span class="line">  struct aiocb *__next_prio;</span><br><span class="line">  int __abs_prio;</span><br><span class="line">  int __policy;</span><br><span class="line">  int __error_code;</span><br><span class="line">  __ssize_t __return_value;</span><br><span class="line"></span><br><span class="line">#ifndef __USE_FILE_OFFSET64</span><br><span class="line">  __off_t aio_offset;/* File offset.  */</span><br><span class="line">  char __pad[sizeof (__off64_t) - sizeof (__off_t)];</span><br><span class="line">#else</span><br><span class="line">  __off64_t aio_offset;/* File offset.  */</span><br><span class="line">#endif</span><br><span class="line">  char __glibc_reserved[32];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>struct aiocb</code></strong>：这是异步I/O控制块，包含了关于异步I/O操作的所有信息。包括但不限于<strong>文件描述符、缓冲区地址、请求的状态</strong>等。</p><p>通知方式有<strong>不通知</strong>,<strong>信号通知</strong>,在新线程中<strong>调用指定函数</strong>等</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">__sigval_t</span> sigev_value;</span><br><span class="line">    <span class="keyword">int</span> sigev_signo;</span><br><span class="line">    <span class="keyword">int</span> sigev_notify;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="keyword">int</span> _pad[__SIGEV_PAD_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the</span></span><br><span class="line"><span class="comment">   thread to receive the signal.  */</span></span><br><span class="line"><span class="keyword">__pid_t</span> _tid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*_function) (<span class="keyword">__sigval_t</span>);<span class="comment">/* Function to start.  */</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> *_attribute;<span class="comment">/* Thread attributes.  */</span></span><br><span class="line">  &#125; _sigev_thread;</span><br><span class="line">      &#125; _sigev_un;</span><br><span class="line">  &#125; <span class="keyword">sigevent_t</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>sigev_notify</code></strong>：指定通知的方式。常见的选项包括：</p><ul><li><code>SIGEV_NONE</code>：不发送任何通知。</li><li><code>SIGEV_SIGNAL</code>：当异步事件发生时，向进程发送指定的信号。</li><li><code>SIGEV_THREAD</code>：当异步事件发生时，在新线程中调用指定的函数。</li><li><code>SIGEV_THREAD_ID</code>：特定于Linux的一个扩展，允许向特定线程发送信号。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SIGEV_SIGNAL = <span class="number">0</span>,<span class="comment">/* Notify via signal.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGEV_SIGNALSIGEV_SIGNAL</span></span><br><span class="line">  SIGEV_NONE,<span class="comment">/* Other notification: meaningless.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGEV_NONESIGEV_NONE</span></span><br><span class="line">  SIGEV_THREAD,<span class="comment">/* Deliver via thread creation.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIGEV_THREADSIGEV_THREAD</span></span><br><span class="line"></span><br><span class="line">  SIGEV_THREAD_ID = <span class="number">4</span><span class="comment">/* Send signal to specific thread.</span></span><br><span class="line"><span class="comment">   This is a Linux extension.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGEV_THREAD_IDSIGEV_THREAD_ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong><code>sigev_signo</code></strong>：如果选择了 <code>SIGEV_SIGNAL</code> 作为通知方式，则此字段应设置为希望发送的信号编号（例如 <code>SIGIO</code>）。</p></li><li><p><strong><code>sigev_value</code></strong>：这是一个联合体，可用于将数据传递给信号处理器或回调函数。这可以是任意数据，通常用于标识哪个异步I/O操作触发了通知。</p></li><li><p><strong><code>sigev_notify_function</code></strong>：当选择 <code>SIGEV_THREAD</code> 作为通知方式时，此字段应指向一个函数，该函数将在新线程中被调用来处理事件。</p></li><li><p><strong><code>sigev_notify_attributes</code></strong>：如果选择了 <code>SIGEV_THREAD</code> 作为通知方式，可以通过此字段提供线程属性对象，以定制创建的新线程的特性。</p></li></ul><ol><li><strong><code>aio_read()</code></strong><ul><li>发起一个异步读操作。它接受一个指向 <code>aiocb</code> 结构的指针作为参数，并返回一个整数值。如果成功，则返回0；如果失败，则返回-1，并设置相应的错误码。</li></ul></li><li><strong><code>aio_write()</code></strong><ul><li>发起一个异步写操作。与 <code>aio_read()</code> 类似，它也接受一个指向 <code>aiocb</code> 结构的指针，并根据是否成功返回0或-1。</li></ul></li><li><strong><code>aio_error()</code></strong><ul><li>检查指定的异步I/O操作的状态。如果操作还在进行中，它将返回 <code>EINPROGRESS</code>；如果操作已经完成，但发生了错误，它会返回相应的错误码；如果操作成功完成，它会返回0。</li></ul></li><li><strong><code>aio_return()</code></strong><ul><li>获取已完成的异步I/O操作的返回状态。只有当 <code>aio_error()</code> 对特定的 <code>aiocb</code> 结构返回除了 <code>EINPROGRESS</code> 之外的值时，调用 <code>aio_return()</code> 才有意义。</li></ul></li><li><strong><code>aio_cancel()</code></strong><ul><li>尝试取消一个或多个尚未完成的异步I/O请求。可以针对特定的 <code>aiocb</code> 取消，也可以尝试取消某个文件描述符上的所有异步I/O请求。</li></ul></li><li><strong><code>aio_suspend()</code></strong><ul><li>挂起调用进程或线程，直到指定的一个或多个异步I/O请求完成或者发生超时（如果提供了超时参数）。这对于等待一组异步I/O操作完成特别有用。</li></ul></li><li><strong><code>lio_listio()</code></strong><ul><li>同时发起一系列的读写操作。这可以是一个列表的读操作、写操作或是两者的组合。此函数支持两种模式：同步和异步。在异步模式下，即使I/O操作未完成，该函数也会立即返回。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="keyword">int</span> MAX_LSIT = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">siginfo_t</span> *si, <span class="keyword">void</span> *unused)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Async I/O completed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">cb</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd, ret, counter;</span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;open file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="comment">// 设置信号处理</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">  sa.sa_flags = SA_SIGINFO;</span><br><span class="line">  sa.sa_sigaction = handler;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置异步I/O控制块</span></span><br><span class="line">  cb.aio_fildes = fd;</span><br><span class="line">  cb.aio_lio_opcode = LIO_READ;</span><br><span class="line">  cb.aio_buf = buf;</span><br><span class="line">  cb.aio_nbytes = BUFFER_SIZE;</span><br><span class="line">  cb.aio_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//   设置通知方式</span></span><br><span class="line">  cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;</span><br><span class="line">  <span class="comment">//   当使用信号通知,设置信号值等参数</span></span><br><span class="line">  cb.aio_sigevent.sigev_signo = SIGUSR1;</span><br><span class="line">  <span class="comment">//   如果使用在SIGEV_THREAD 作为通知方式时，此字段应指向一个函数</span></span><br><span class="line"><span class="comment">//   cb.aio_sigevent.sigev_notify_function = NULL;</span></span><br><span class="line">  <span class="comment">// 传递字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">aio_read</span>(&amp;cb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;aio_read error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;aio_read&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> couter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">aio_error</span>(&amp;cb) == EINPROGRESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d次\n&quot;</span>,++couter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> bytesRead = <span class="built_in">aio_return</span>(&amp;cb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes\n&quot;</span>, bytesRead);</span><br><span class="line">  std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">my_aiocb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配缓冲区</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = <span class="number">4096</span>; <span class="comment">// 假设缓冲区大小为 4KB</span></span><br><span class="line">    <span class="keyword">char</span> *buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(buffer_size);</span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, buffer_size); <span class="comment">// 初始化缓冲区内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 aiocb 结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;my_aiocb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct aiocb));</span><br><span class="line">    my_aiocb.aio_fildes = fd;              <span class="comment">// 文件描述符</span></span><br><span class="line">    my_aiocb.aio_buf = buffer;             <span class="comment">// 缓冲区指针</span></span><br><span class="line">    my_aiocb.aio_nbytes = buffer_size;     <span class="comment">// 写入的字节数</span></span><br><span class="line">    my_aiocb.aio_offset = <span class="number">0</span>;               <span class="comment">// 写入的偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起异步写操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">aio_write</span>(&amp;my_aiocb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;aio_write&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(buffer); <span class="comment">// 释放缓冲区</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous write operation initiated.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">while</span> ((err = <span class="built_in">aio_error</span>(&amp;my_aiocb)) == EINPROGRESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write operation still in progress...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 等待一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查异步操作的状态</span></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> bytes_written = <span class="built_in">aio_return</span>(&amp;my_aiocb);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous write completed successfully. Bytes written: %zd\n&quot;</span>, bytes_written);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Asynchronous write failed with error: %s\n&quot;</span>, <span class="built_in">strerror</span>(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述aio其实是<strong>用户层使用线程模拟的异步io</strong>，缺点是占用线程资源而且受可用线程的数量限制。Linux2.6版本后有了libaio，这完全是内核级别的异步IO，IO请求完全由底层自由调度</p><h3 id="Linux原生AIO"><a href="#Linux原生AIO" class="headerlink" title="Linux原生AIO"></a>Linux原生AIO</h3><blockquote><p>Linux Native AIO 是 Linux 支持的原生 AIO，为什么要加原生这个词呢？因为Linux存在很多第三方的异步 IO 库，如 libeio 和 glibc AIO。所以为了加以区别，Linux 的内核提供的异步 IO 就称为原生异步 IO。很多第三方的异步 IO 库都不是真正的异步 IO，而是使用多线程来模拟异步 IO，如 libeio 就是使用多线程来模拟异步 IO 的。</p></blockquote><p>一般来说，使用 Linux 原生 AIO 需要 3 个步骤：</p><ul><li>1) 调用 io_setup 函数创建一个一般 IO 上下文。</li><li>2) 调用 io_submit 函数向内核提交一个异步 IO 操作。</li><li>3) 调用 io_getevents 函数获取异步 IO 操作结果。</li></ul><blockquote><p>可以通过libaio库调用原生系统调用</p></blockquote><ol><li><strong><code>io_setup()</code></strong><ul><li>初始化一个AIO上下文，返回一个上下文标识符供后续操作使用。</li></ul></li><li><strong><code>io_submit()</code></strong><ul><li>提交一个或多个异步I/O请求到指定的AIO上下文中。</li></ul></li><li><strong><code>io_getevents()</code></strong><ul><li>获取已完成的异步I/O操作的结果。可以通过此函数查询已提交的I/O请求的状态。</li></ul></li><li><strong><code>io_destroy()</code></strong><ul><li>销毁一个AIO上下文，释放相关资源。</li></ul></li><li><strong><code>struct iocb</code></strong><ul><li>这个结构用于描述单个I/O操作的信息，包括操作类型（读、写等）、文件描述符、缓冲区地址及大小等。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> &#123;</span></span><br><span class="line"><span class="built_in">PADDEDptr</span>(<span class="keyword">void</span> *data, __pad1);<span class="comment">/* Return in the io completion event */</span></span><br><span class="line"><span class="comment">/* key: For use in identifying io requests */</span></span><br><span class="line"><span class="comment">/* aio_rw_flags: RWF_* flags (such as RWF_NOWAIT) */</span></span><br><span class="line"><span class="built_in">PADDED</span>(<span class="keyword">unsigned</span> key, aio_rw_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span>aio_lio_opcode;</span><br><span class="line"><span class="keyword">short</span>aio_reqprio;</span><br><span class="line"><span class="keyword">int</span>aio_fildes;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_common</span><span class="title">c</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_vector</span><span class="title">v</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_poll</span><span class="title">poll</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_iocb_sockaddr</span><span class="title">saddr</span>;</span></span><br><span class="line">&#125; u;</span><br><span class="line">&#125;; <span class="comment">//描述一个异步 I/O 请求</span></span><br></pre></td></tr></table></figure><ul><li><code>data</code>：用户可以设置一个指针，用于在回调或完成事件中标识这个请求。</li><li><code>aio_lio_opcode</code>：指定操作类型，例如读取 (<code>IO_CMD_PREAD</code>) 或写入 (<code>IO_CMD_PWRITE</code>)。</li><li><code>aio_fildes</code>：目标文件的文件描述符。</li><li><code>u.c</code>：包含具体操作的参数（如缓冲区地址、偏移量、字节数等）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> &#123;</span></span><br><span class="line"><span class="built_in">PADDEDptr</span>(<span class="keyword">void</span> *data, __pad1);</span><br><span class="line"><span class="built_in">PADDEDptr</span>(struct iocb *obj,  __pad2);</span><br><span class="line"><span class="built_in">PADDEDul</span>(res,  __pad3);</span><br><span class="line"><span class="built_in">PADDEDul</span>(res2, __pad4);</span><br><span class="line">&#125;; <span class="comment">//描述一个已完成的异步 I/O 操作的结果</span></span><br></pre></td></tr></table></figure><ul><li><code>data</code> 和 <code>obj</code>：用于匹配完成事件和原始请求。</li><li><code>res</code>：表示操作的结果。如果大于等于 0，则表示成功完成的字节数；如果小于 0，则表示发生错误，其值为负的错误码（如 <code>-EIO</code>）。</li><li><code>res2</code>：通常不使用，但在某些情况下可能包含额外的信息。</li></ul><p><strong><code>`io_context_t</code></strong></p><ul><li><p><strong>作用</strong>：表示一个异步 I/O 上下文，用于管理一组异步 I/O 请求。</p></li><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context_t</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>说明</p><ul><li>一个 <code>io_context_t</code> 可以管理多个异步 I/O 请求。</li></ul></li></ul><p>注意添加链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libaio-dev </span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(linux_aio</span><br><span class="line">    PRIVATE</span><br><span class="line">    -laio</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">io_context_t</span> ctx;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">cbs</span>[1];</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> buf[] = <span class="string">&quot;Hello,world&quot;</span>;</span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>, O_RDWR | O_CREAT | O_DIRECT, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;open:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">io_context_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   io事件的初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_setup</span>(<span class="number">1</span>, &amp;ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_setup:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交io事件</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct iocb));</span><br><span class="line">  cb.aio_fildes = fd;</span><br><span class="line">  cb.aio_lio_opcode = IO_CMD_PWRITE;</span><br><span class="line">  <span class="keyword">char</span> msg[] = <span class="string">&quot;aio query&quot;</span>;</span><br><span class="line">  cb.data = msg;</span><br><span class="line">  cb.u.c.buf = buf;</span><br><span class="line">  cb.u.c.nbytes = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  cb.u.c.offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cbs[<span class="number">0</span>] = &amp;cb;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_submit</span>(ctx, <span class="number">1</span>, cbs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_submit:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_getevents</span>(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_getevents:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (events[<span class="number">0</span>].res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_getevents:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aio getevents:&quot;</span> &lt;&lt; (<span class="keyword">char</span> *)events[<span class="number">0</span>].data &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aio getevents:&quot;</span> &lt;&lt; events[<span class="number">0</span>].res &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aio getevents:&quot;</span> &lt;&lt; events[<span class="number">0</span>].res2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">io_destroy</span>(ctx);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意,如果使用<code>O_DIRECT</code>标志打开有限制.<code>O_DIRECT</code> 是一种特殊的文件打开模式，它绕过操作系统的页缓存，直接与磁盘设备交互。</p><p><strong>(1) 缓冲区对齐</strong></p><ul><li><strong>地址对齐</strong>：缓冲区的起始地址必须是对齐的，通常是硬件块大小的倍数（通常是 512 字节或 4KB）。</li><li><strong>大小对齐</strong>：缓冲区的大小也必须是硬件块大小的倍数。</li><li><strong>偏移量对齐</strong>：文件读写的偏移量也必须是对齐的。</li></ul><p>如果不满足这些对齐要求，<code>open()</code> 或 <code>read()</code>/<code>write()</code> 调用可能会失败。</p><p><strong>(2) 文件系统支持</strong></p><ul><li>并非所有文件系统都支持 <code>O_DIRECT</code>。例如，某些网络文件系统（如 NFS）可能不支持直接 I/O。</li></ul><p><strong>(3) 性能权衡</strong></p><ul><li>直接 I/O 绕过了页缓存，因此对于小文件或频繁的小 I/O 操作，性能可能不如普通缓存 I/O。</li></ul><p><strong>关键修改点</strong></p><p><strong>(1) 使用 <code>posix_memalign()</code> 分配对齐内存</strong></p><p>posix_memalign()</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">if</span> (posix_memali<span class="meta">gn(</span><span class="variable">&amp;buffer</span>, 4096, BUFFER_SIZE)) &#123;</span><br><span class="line">    perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">    <span class="meta">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二个参数指定对齐边界（这里是 4KB）。</li><li>第三个参数指定分配的大小。</li></ul><blockquote><p><code>posix_memalign</code> 是一个 POSIX 标准的函数，用于分配对齐的内存。它允许用户指定内存块的起始地址对齐边界.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">posix_memalign</span><span class="params">(<span class="keyword">void</span> **memptr, <span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><code>memptr</code><ul><li>输出参数，指向一个指针变量。</li><li>如果分配成功，<code>*memptr</code> 将存储分配的内存块的地址。</li></ul></li><li><code>alignment</code><ul><li>内存块的对齐边界，以字节为单位。</li><li>必须是 2 的幂次方，并且至少为 <code>sizeof(void *)</code>（通常是 8 字节或更大）。</li></ul></li><li><code>size</code><ul><li>要分配的内存大小，以字节为单位。</li></ul></li></ul></blockquote><p><strong>(2) 添加 <code>O_DIRECT</code> 标志</strong></p><ul><li><p>在open()中添加<code>O_DIRECT</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC | O_DIRECT, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>(3) 确保缓冲区大小和偏移量对齐</strong></p><ul><li>缓冲区大小设置为 4KB（<code>BUFFER_SIZE</code>）。</li><li>文件偏移量设置为 0（默认对齐）</li></ul><p><a href="https://www.quora.com/Why-does-O_DIRECT-require-I-O-to-be-512-byte-aligned">Why does O_DIRECT require I/O to be 512-byte aligned? - Quora</a></p><p>要求缓存大小和对齐都需要512及其倍数字节.</p><p>libaio的缺点是，(1)想要使用该种方式的文件必须支持以O_DIRECT标志打开，然而并不是所有的文件系统都支持。如果你没有使用O_DIRECT打开文件，它可能仍然“工作”，但它可能不是异步完成的，而是变为了阻塞的。</p><p>(2)仍然可能被阻塞。即使应用层主观上，希望系统层采用异步 IO，但是客观上，有时候还是可能会被阻塞。</p><p>(3) 拷贝开销大。每个 IO 提交需要拷贝 64+8 字节，每个 IO 完成需要拷贝 32 字节，总共 104 字节的拷贝。这个拷贝开销是否可以承受，和单次 IO 大小有关：如果需要发送的 IO 本身就很大，相较之下，这点消耗可以忽略，而在大量小 IO 的场景下，这样的拷贝影响比较大。<img data-src="https://pic4.zhimg.com/v2-c886c75a94b559d44aecfc17b97d898d_1440w.jpg" alt="img"></p><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/389978597">存储大师班 | Linux IO 模式之 io_uring - 知乎</a></li><li><a href="https://blog.csdn.net/crazymakercircle/article/details/129190222">（图解+史上最全）_iouring-CSDN博客</a></li><li><a href="https://cuterwrite.top/p/efficient-liburing/">高性能异步 I/O 框架：io_uring</a></li></ul><p><code>io_uring</code> 是 Linux 内核5.1版本引入的一种高性能异步I/O框架。与传统的 POSIX AIO 相比，<code>io_uring</code> 提供了更高效的零拷贝I/O操作，减少了上下文切换和系统调用开销。</p><blockquote><p>io_uring 围绕高效进行设计，其设计了一对共享的 ring buffer 用于应用和内核之间的通信，通过该设计实现了如下的三个好处：</p><p>（1）避免在提交和完成事件中存在内存拷贝；</p><p>（2）避免了 libaio 中在提交和完成任务的时候系统调用过程；</p><p>（3）该队列采用了无锁的访问模式，通过内存屏障减少了竞争；</p><p>在共享的 ring buffer 设计中，针对提交队列（SQ），应用是 IO 提交的生产者（producer），内核是消费者（consumer）；反过来，针对完成队列（CQ），内核是完成事件的生产者，应用是消费者。</p><p>另外，io_uring 还存在如下的优势：</p><p>（1）提交和完成不需要经过系统调用，而且减少了对用户态线程的阻塞；该部分的支持主要通过共享的 ring buffer 和设置 polling 模式来实现。</p><p>（2）支持 Block 层的 polling 模式</p><p>（3）支持 buffered IO，充分利用缓存，减少数据碰盘产生的系统延迟；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install liburing-dev</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(io_uring</span><br><span class="line">    -luring</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>liburing 是一个基于 io_uring 接口的用户空间库，它是 Linux 内核开发者 Axboe 于 2019 年发布的一个开源项目。io_uring 是一种新的 Linux 异步 I/O 接口，<strong>它通过使用一对环形缓冲区（ring buffer）来实现用户空间和内核空间之间的通信，从而避免了传统异步 I/O 接口（如 AIO）所需的系统调用、信号、回调等机制。</strong>这样，用户空间可以直接向内核提交 I/O 请求，并从内核获取 I/O 结果，而无需等待或切换上下文。这大大提高了异步 I/O 操作的效率和性能。</p></blockquote><p><img data-src="https://cloud.cuterwrite.fun/blog/20230802172119.webp" alt="20230802172119"></p><p>每个 io_uring 实例都有两个环形队列(称为 ring)，在内核和应用程序之间共享：</p><ol><li>提交队列：submission queue( SQ )</li><li>完成队列：completion queue( CQ )</li></ol><p>这两个队列：</p><ol><li>都是单生产者、单消费者的队列，size 为 2 的幂次方。</li><li>提供无锁接口，内部使用内存屏障来进行同步。</li></ol><p>请求时：</p><ol><li>应用创建 SQ Entries (SQE)，更新 SQ tail</li><li>内核消费 SQE，更新 SQ head</li></ol><p>完成后：</p><ol><li>内核为完成的一个或多个请求创建 CQ Entries (CQE)，更新 CQ tail</li><li>应用消费 CQE，更新 CQ head</li><li>完成事件可能以任意顺序到达，到总是与特定的 SQE 相关联的</li><li>消费 CQE 过程无需切换内核态</li></ol><p>这样做的好处在于：</p><ol><li>原本需要多次系统调用，现在变成批处理一次提交</li><li>此外，io_uring 使异步 I/O 的使用场景也不再仅限于数据库应用， 普通的非数据库应用也能用</li></ol><p>io_uring 的三种工作模式：</p><ol><li>中断驱动模式 (interrupt-driven)<ul><li>默认模式, 可通过 io_uring_enter()提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。</li></ul></li><li>轮询模式 (polling)<ul><li>Busy waiting for I/O completion，而不是通过异步 IRQ(Interrupt Request)来接收通知</li><li>这种模式需要文件系统和块设备支持轮询功能。相比中断驱动模式，这种方式延迟更低，但是 CPU 占用率可能会更高。</li><li>目前，只有指定了 O_DIRECT 标志打开的文件描述符才能使用这种模式。当一个读或写请求提交给轮询上下文之后，应用必须调用 io_uring_enter()来轮询 CQ 队列，判断请求是否完成。</li><li>对于一个 io_uring 实例来说，不支持混合使用轮询和非轮询模式。</li></ul></li><li>内核轮询模式 (kernel polling)<ul><li>这种模式会创建一个内核线程来执行 SQ 的轮询工作。</li><li>使用这种模式的 io_uring 实例，应用无需切到内核态就能触发 I/O 操作。通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O。</li><li>如果内核线程的空闲事件超过了用户的配置值，它会通知应用，然后进入 idle 状态。这种情况下，应用必须调用 io_uring_enter()来唤醒内核线程。如果 I/O 一直很繁忙，内核线程是不会 sleep 的。</li></ul></li></ol><p>（1）io_uring_setup：初始化一个新的 io_uring 上下文，内核通过一块和用户共享的内存区域进行消息的传递。</p><p>（2）io_uring_enter：提交任务以及收割任务。</p><p>（3）io_uring_register：注册用户态和内核态的共享 buffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing/io_uring.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">4096</span>;</span><br><span class="line">  <span class="comment">// 初始化io_uring实例</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_uring_queue_init</span>(<span class="number">8</span>, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, BUFFER_SIZE); <span class="comment">// 填充缓冲区为字符 &#x27;A&#x27;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">  <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_get_sqe&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 准备写入请求</span></span><br><span class="line">  <span class="built_in">io_uring_prep_write</span>(sqe, fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">  sqe-&gt;user_data = <span class="number">1</span>; <span class="comment">// 设置用户数据</span></span><br><span class="line">  <span class="comment">// 提交请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_uring_submit</span>(&amp;ring) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous write operation initiated.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: %s\n&quot;</span>, <span class="built_in">strerror</span>(-cqe-&gt;res));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Write completed successfully.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, cqe); <span class="comment">// 标记完成事件为已处理</span></span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="built_in">io_uring_queue_exit</span>(&amp;ring); <span class="comment">// 清理io_uring实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 每一个io_uring实例，都会被分配一个fd，该过程是通过io_uring_setup()系统调用实现的。</p><p>io_uring_setup()调用会根据用户提供的参数，分配一块共享内存。</p><p>这块共享内存中，包含了一个SQ（提交队列）、一个CQ（完成队列）和一个SQE（提交实体）数组。</p><p>其中，SQ和CQ是两个环形队列，队列中的元素是SQE在SQE数组中的偏移量，使用这种方式可以使得提交实体能够被随机访问，提高灵活性。</p><p>io_uring_setup()调用返回的fd，该内存可以通过mmap()的方式映射到用户态</p><p>用户从CQ的头部获取SEQ，将想要执行的操作（如文件的读写）初始化到其中，并添加到SQ队列的尾部，然后使用io_uring_enter()系统调用来进行提交队列的处理。</p><p>用户态和内核态共享 提交队列（submission queue）和 完成队列（completion queue），这两条队列通过mmap共享，高效且安全。</p><p>提交队列（SQ）给内核源源不断的布置任务，然后从另外一条队列完成队列（CQ）获取结果；</p><p>内核则按需进行 epoll()，并在一个线程池中执行就绪的任务。</p><p>用户态支持Polling模式，不会发生中断，也就没有系统调用，通过轮询即可消费事件；</p><p>内核态也支持Polling模式，同样不会发生上下文切换。</p><p>可以看出关键的设计在于，内核通过一块和用户共享的内存区域进行消息的传递，可以绕过Linux 的 syscall 机制。</p><p>内核会从SQ中依次取出对应的io request 提交实体，并根据io request 提交实体中定义的动作来执行对应的操作。由于用户只操作SQ尾部，而内核只操作头部，因此两者对于共享队列的访问并不会产生冲突，节省了锁的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> <span class="title">sq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cq</span> <span class="title">cq</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> flags;</span><br><span class="line"><span class="keyword">int</span> ring_fd; <span class="comment">// id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> features;</span><br><span class="line"><span class="keyword">unsigned</span> pad[<span class="number">3</span>];</span><br><span class="line">&#125;; <span class="comment">// io_uring结构</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> &#123;</span> <span class="comment">// 提交队列</span></span><br><span class="line"><span class="keyword">unsigned</span> *khead;</span><br><span class="line"><span class="keyword">unsigned</span> *ktail;</span><br><span class="line"><span class="keyword">unsigned</span> *kring_mask;</span><br><span class="line"><span class="keyword">unsigned</span> *kring_entries;</span><br><span class="line"><span class="keyword">unsigned</span> *kflags;</span><br><span class="line"><span class="keyword">unsigned</span> *kdropped;</span><br><span class="line"><span class="keyword">unsigned</span> *array;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> sqe_head;</span><br><span class="line"><span class="keyword">unsigned</span> sqe_tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> ring_sz;</span><br><span class="line"><span class="keyword">void</span> *ring_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> pad[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span> <span class="comment">// 提交队列entry</span></span><br><span class="line">__u8opcode;<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">__u8flags;<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">__u16ioprio;<span class="comment">/* ioprio for the request */</span></span><br><span class="line">__s32fd;<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64off;<span class="comment">/* offset into file */</span></span><br><span class="line">__u64addr2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64addr;<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">__u64splice_off_in;</span><br><span class="line">&#125;;</span><br><span class="line">__u32len;<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_rwf_t</span>rw_flags;</span><br><span class="line">__u32fsync_flags;</span><br><span class="line">__u16poll_events;<span class="comment">/* compatibility */</span></span><br><span class="line">__u32poll32_events;<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">__u32sync_range_flags;</span><br><span class="line">__u32msg_flags;</span><br><span class="line">__u32timeout_flags;</span><br><span class="line">__u32accept_flags;</span><br><span class="line">__u32cancel_flags;</span><br><span class="line">__u32open_flags;</span><br><span class="line">__u32statx_flags;</span><br><span class="line">__u32fadvise_advice;</span><br><span class="line">__u32splice_flags;</span><br><span class="line">__u32rename_flags;</span><br><span class="line">__u32unlink_flags;</span><br><span class="line">__u32hardlink_flags;</span><br><span class="line">&#125;;</span><br><span class="line">__u64user_data;<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line"><span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">__u16buf_index;</span><br><span class="line"><span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">__u16buf_group;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"><span class="comment">/* personality to use, if used */</span></span><br><span class="line">__u16personality;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__s32splice_fd_in;</span><br><span class="line">__u32file_index;</span><br><span class="line">&#125;;</span><br><span class="line">__u64__pad2[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Epoll事件的Channel类"><a href="#Epoll事件的Channel类" class="headerlink" title="Epoll事件的Channel类"></a>Epoll事件的Channel类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure><p>epoll时间和数据如上,events为要监听的事件,比如EPOLLIN,EPOLLLT等.</p><p>绪状态。<code>enum EPOLL_EVENTS</code> 定义了一系列的标志位，用于指定感兴趣的事件类型或报告发生的事件。下面是一些常用的 <code>EPOLL_EVENTS</code> 常量及其用途：</p><ul><li><strong><code>EPOLLIN (0x001)</code></strong>：表示对应的文件描述符可以读取（即有数据可读）。</li><li><strong><code>EPOLLOUT (0x004)</code></strong>：表示对应的文件描述符可以写入（即准备好接受数据写入）。</li><li><strong><code>EPOLLPRI (0x002)</code></strong>：表示对应文件描述符有紧急数据可读（带外数据）。这在处理 TCP 紧急指针时有用。</li><li><strong><code>EPOLLERR (0x008)</code></strong>：表示对应的文件描述符发生了错误。这个事件总是会被监控，无需显式地将其加入到感兴趣的事件集合中。</li><li><strong><code>EPOLLHUP (0x010)</code></strong>：表示对应的文件描述符被挂起（即连接被关闭）。与 <code>EPOLLERR</code> 类似，此事件也会自动被监控。</li><li><strong><code>EPOLLRDHUP (0x2000)</code></strong>：自 Linux 2.6.17 起可用，表示对端关闭了连接或者关闭了写入一半的连接。这对于检测对等方关闭连接特别有用。</li></ul><p>此外，还有一些不太常用但同样重要的事件：</p><ul><li><strong><code>EPOLLET (1u &lt;&lt; 31)</code></strong>：设置边缘触发模式。默认情况下，<code>epoll</code> 使用水平触发模式；当启用边缘触发模式后，只有在文件描述符的状态发生变化时才会触发事件通知，而不是每次轮询都可能返回就绪状态。</li><li><strong><code>EPOLLONESHOT (1u &lt;&lt; 30)</code></strong>：一旦被指定的文件描述符上的事件发生并被处理后，相应的文件描述符将不再处于监听状态。要再次监听该文件描述符上的事件，需要重新添加到 <code>epoll</code> 实例中。</li><li><strong><code>EPOLLEXCLUSIVE (1u &lt;&lt; 28)</code></strong>：从 Linux 内核 4.5 开始支持，允许多个 <code>epoll</code> 实例独立地监听同一个文件描述符。这样可以避免多个进程同时收到相同的事件通知，从而减少竞争条件。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EPOLL_EVENTS</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    EPOLLIN = <span class="number">0x001</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLIN EPOLLIN</span></span><br><span class="line">    EPOLLPRI = <span class="number">0x002</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLPRI EPOLLPRI</span></span><br><span class="line">    EPOLLOUT = <span class="number">0x004</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLOUT EPOLLOUT</span></span><br><span class="line">    EPOLLRDNORM = <span class="number">0x040</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLRDNORM EPOLLRDNORM</span></span><br><span class="line">    EPOLLRDBAND = <span class="number">0x080</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLRDBAND EPOLLRDBAND</span></span><br><span class="line">    EPOLLWRNORM = <span class="number">0x100</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLWRNORM EPOLLWRNORM</span></span><br><span class="line">    EPOLLWRBAND = <span class="number">0x200</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLWRBAND EPOLLWRBAND</span></span><br><span class="line">    EPOLLMSG = <span class="number">0x400</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLMSG EPOLLMSG</span></span><br><span class="line">    EPOLLERR = <span class="number">0x008</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLERR EPOLLERR</span></span><br><span class="line">    EPOLLHUP = <span class="number">0x010</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLHUP EPOLLHUP</span></span><br><span class="line">    EPOLLRDHUP = <span class="number">0x2000</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLRDHUP EPOLLRDHUP</span></span><br><span class="line">    EPOLLEXCLUSIVE = <span class="number">1u</span> &lt;&lt; <span class="number">28</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEXCLUSIVE EPOLLEXCLUSIVE</span></span><br><span class="line">    EPOLLWAKEUP = <span class="number">1u</span> &lt;&lt; <span class="number">29</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLWAKEUP EPOLLWAKEUP</span></span><br><span class="line">    EPOLLONESHOT = <span class="number">1u</span> &lt;&lt; <span class="number">30</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLONESHOT EPOLLONESHOT</span></span><br><span class="line">    EPOLLET = <span class="number">1u</span> &lt;&lt; <span class="number">31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLET EPOLLET</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然可以传一个void*指针,那么可以设计一个Channel类,这个类可以包含监听的fd以及对应的事件等信息. 同时可以设计回调方法,对于server_fd,回调方法可以为接收客户端fd,客户端channel回调方法为读取数据.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Epoll *ep;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> events;</span><br><span class="line">    <span class="keyword">uint32_t</span> revents;</span><br><span class="line">    <span class="keyword">bool</span> inEpoll;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>显然每个文件描述符会被分发到一个<code>Epoll</code>类，用一个<code>ep</code>指针来指向。类中还有这个<code>Channel</code>负责的文件描述符。另外是两个事件变量，<code>events</code>表示希望监听这个文件描述符的哪些事件，因为不同事件的处理方式不一样。<code>revents</code>表示在<code>epoll</code>返回该<code>Channel</code>时文件描述符正在发生的事件。<code>inEpoll</code>表示当前<code>Channel</code>是否已经在<code>epoll</code>红黑树中，为了注册<code>Channel</code>的时候方便区分使用<code>EPOLL_CTL_ADD</code>还是<code>EPOLL_CTL_MOD</code>。</p></blockquote><h2 id="服务器与事件驱动核心类"><a href="#服务器与事件驱动核心类" class="headerlink" title="服务器与事件驱动核心类"></a>服务器与事件驱动核心类</h2><p><a href="https://github.com/yuesong-feng/30dayMakeCppServer/blob/main/day06-服务器与事件驱动核心类登场.md">30dayMakeCppServer/day06-服务器与事件驱动核心类登场.md at main · yuesong-feng/30dayMakeCppServer</a></p><blockquote><p>目前从新建socket、接受客户端连接到处理客户端事件，整个程序结构是顺序化、流程化的，我们甚至可以使用一个单一的流程图来表示整个程序。而流程化程序设计的缺点之一是不够抽象，<strong>当我们的服务器结构越来越庞大、功能越来越复杂、模块越来越多，这种顺序程序设计的思想显然是不能满足需求的。</strong></p><p>对于服务器开发，我们需要用到更抽象的设计模式。从代码中我们可以看到，不管是接受客户端连接还是处理客户端事件，都是围绕epoll来编程，可以说epoll是整个程序的核心，服务器做的事情就是监听epoll上的事件，然后对不同事件类型进行不同的处理。这种以事件为核心的模式又叫事件驱动，事实上几乎所有的现代服务器都是事件驱动的。和传统的请求驱动模型有很大不同，事件的捕获、通信、处理和持久保留是解决方案的核心结构。libevent就是一个著名的C语言事件驱动库。</p></blockquote><p><img data-src="https://s2.loli.net/2025/04/26/Z5JHSabqlVtiUCG.png" alt="image-20250426144343174"></p><h3 id="Acceptor类"><a href="#Acceptor类" class="headerlink" title="Acceptor类"></a>Acceptor类</h3><p>当server socket监听到事件时,需要做的就是通过accept函数创建新连接,这需要server的socket. </p><blockquote><p>对于每一个事件，不管提供什么样的服务，首先需要做的事都是调用<code>accept()</code>函数接受这个TCP连接，然后将socket文件描述符添加到epoll。当这个IO口有事件发生的时候，再对此TCP连接提供相应的服务。</p></blockquote><p>Acceptor可以设置回调函数.在Server中设置Acceptor回调函数为接收客户端连接并将fd加入epoll中,并设置相关回调函数.</p><p>Acceptor设置回调函数就是为channel设置回调</p><p><code>Acceptor</code>类最主要的三个特点：</p><ul><li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor</li><li>类中的socket fd就是服务器监听的socket fd，每一个Acceptor对应一个socket fd</li><li>这个类也通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Acceptor中的接受连接函数来新建一个TCP连接</li></ul><h3 id="Connection连接类"><a href="#Connection连接类" class="headerlink" title="Connection连接类"></a>Connection连接类</h3><p>对于TCP协议，三次握手新建连接后，这个连接将会一直存在，直到我们四次挥手断开连接。因此，我们也可以把TCP连接抽象成一个<code>Connection</code>类，这个类也有以下几个特点：</p><ul><li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor</li><li>类中的socket fd就是客户端的socket fd，每一个Connection对应一个socket fd</li><li>每一个类的实例通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Connection中的事件处理函数来响应客户端请求</li></ul><p>可以看到，<code>Connection</code>类和<code>Acceptor</code>类是平行关系、十分相似，他们都直接由<code>Server</code>管理，由一个<code>Channel</code>分发到epoll，通过回调函数处理相应事件。唯一的不同在于，<code>Acceptor</code>类的处理事件函数（也就是新建连接功能）被放到了<code>Server</code>类中，而<code>Connection</code>类则没有必要这么做，处理事件的逻辑应该由<code>Connection</code>类本身来完成。</p><h3 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h3><p>之前的读数据部分,都是读取之后立即写入.但是在ET模式下,当errno=EAGAIN才表示没有数据可读取,这时将之间读取的数据进行写入.<br>可以封装一个buffer类,每次读取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">c_str</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123; buffer.<span class="built_in">append</span>(data, size); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> std::string &amp;buf, <span class="keyword">size_t</span> size)</span> </span>&#123; buffer.<span class="built_in">append</span>(buf); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; buffer.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123; buffer.<span class="built_in">resize</span>(size); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="增加线程池"><a href="#增加线程池" class="headerlink" title="增加线程池"></a>增加线程池</h3><blockquote><p>观察当前的服务器架构，不难发现我们的Reactor模型少了最关键、最重要的一个模块：线程池。当发现socket fd有事件时，我们应该分发给一个工作线程，由这个工作线程处理fd上面的事件。而当前我们的代码是单线程模式，所有fd上的事件都由主线程（也就是EventLoop线程）处理，这是大错特错的，试想如果每一个事件相应需要1秒时间，那么当1000个事件同时到来，EventLoop线程将会至少花费1000秒来传输数据，还有函数调用等其他开销，服务器将直接宕机。</p></blockquote><p>线程池需要一个任务队列,工作线程,以及线程同步机制.</p><p>任务队列是一个生产者-消费者队列,通过mutex,condition_variable进行线程同步与通信. 工作线程不断地从队列中取出任务并执行.</p><p>这个线程池只是为了满足我们的需要构建出的最简单的线程池，存在很多问题。比如，<strong>由于任务队列的添加、取出都存在拷贝操作，线程池不会有太好的性能</strong>，只能用来学习，正确做法是<strong>使用右值移动、完美转发等阻止拷贝</strong>。另外线程池只能接受<code>std::function&lt;void()&gt;</code>类型的参数，所以函数参数需要事先使用<code>std::bind()</code>，并且<strong>无法得到返回值</strong>。</p><p>对于<code>Acceptor</code>，接受连接的处理时间较短、报文数据极小，并且一般不会有特别多的新连接在同一时间到达，所以<code>Acceptor</code>没有必要采用epoll ET模式，也没有必要用线程池。由于不会成为性能瓶颈，为了简单最好使用阻塞式socket，故今天的源代码中做了以下改变：</p><ol><li>Acceptor socket fd（服务器监听socket）使用阻塞式</li><li>Acceptor使用LT模式，建立好连接后处理事件fd读写用ET模式</li><li>Acceptor建立连接不使用线程池，建立好连接后处理事件用线程池</li></ol><h3 id="多线程Reactor模式"><a href="#多线程Reactor模式" class="headerlink" title="多线程Reactor模式"></a>多线程Reactor模式</h3><p><img data-src="https://s2.loli.net/2025/04/27/7iDBW3cvdCEsyao.png" alt="image-20250427174511232"></p><h3 id="主从Reactor多线程模式"><a href="#主从Reactor多线程模式" class="headerlink" title="主从Reactor多线程模式"></a>主从Reactor多线程模式</h3><p><img data-src="https://s2.loli.net/2025/04/27/IcbnHVp9faBzWmP.png" alt="image-20250427225106232"></p><h3 id="增加多平台支持"><a href="#增加多平台支持" class="headerlink" title="增加多平台支持"></a>增加多平台支持</h3><p>BSD系列操作系统提供了<code>kqueue</code>. <code>kqueue</code> 是一种高性能的事件通知接口，主要用于 BSD 系列操作系统（如 FreeBSD、macOS 和 OpenBSD）中。它提供了一种机制来高效地监视多个文件描述符上的 I/O 事件（例如可读、可写等），以及异步 I/O 操作的状态变化。</p><ul><li><strong>kqueue</strong>：核心对象，用于注册感兴趣的事件，并从内核获取事件通知。</li><li><p><strong>kevent</strong>：表示一个事件或事件类型。可以用来指定你感兴趣的事件（如文件描述符变为可读），也可以用来报告已发生的事件。</p><p>主要用途</p></li></ul><p><strong>(1) 监视文件描述符</strong></p><ul><li>可以监视文件描述符上的各种事件，比如：<ul><li>文件描述符是否可读 (<code>EVFILT_READ</code>)</li><li>文件描述符是否可写 (<code>EVFILT_WRITE</code>)</li><li>文件元数据改变 (<code>EVFILT_VNODE</code>)</li><li>进程信号 (<code>EVFILT_PROC</code>)</li></ul></li></ul><p><strong>(2) 异步 I/O 通知</strong></p><ul><li>支持异步 I/O 操作的通知机制，允许应用程序在非阻塞模式下更高效地管理大量并发连接。</li></ul><p><strong>(3) 高效的事件分发</strong></p><ul><li>对比传统的轮询方式（如 <code>select()</code> 和 <code>poll()</code>），<code>kqueue</code> 提供了更高的性能和更好的扩展性，特别是在处理大量的文件描述符时。</li></ul><p><strong>(1) 创建 kqueue</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> kq = kqueue();</span><br><span class="line"><span class="keyword">if</span> (kq == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;kqueue&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 设置 kevent</strong></p><p>定义感兴趣的事件，并将其添加到 <code>kqueue</code> 中。例如，监视一个套接字是否可读：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> <span class="title">change</span>;</span></span><br><span class="line">EV_SET(&amp;change, sockfd, EVFILT_READ, EV_ADD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kevent(kq, &amp;change, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;kevent register&quot;</span>);</span><br><span class="line">    close(kq);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 等待事件发生</strong></p><p>调用 <code>kevent()</code> 来等待事件的发生并处理它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="keyword">int</span> nev = kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;event, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (nev == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;kevent wait&quot;</span>);</span><br><span class="line">    close(kq);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nev &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.filter == EVFILT_READ) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决Connection生命周期问题"><a href="#解决Connection生命周期问题" class="headerlink" title="解决Connection生命周期问题"></a>解决Connection生命周期问题</h3><p>当在处理connection连接关闭时,会在回调中移除connnection,这样会调用对应析构函数,但此时仍然在connection的channel的<code>handleEvent</code>方法中.</p><blockquote><p>在当前状态下，在创建<code>TcpConnection</code>会将其加入到<code>connectionsMap_</code>使其引用计数变成了<code>1</code>，之后当<code>TcpConnection</code>处理<code>HandleEvent</code>受到关闭信号时，会直接调用<code>HandleClose</code>，这时会将<code>TcpConnection</code>从<code>connectionsMaps_</code>释放，引用计数变成<code>0</code>，直接销毁，但是<code>HandleEvent</code>并没有处理结束，从而导致了内存泄漏。</p></blockquote><p>增加的两点处理: 在处理事件之前,增加connection的引用计数,这样即使在connectionMap中移除连接,也不会直接释放内存. 此外在每次轮询epoll并处理完事件之后,统一执行一系列回调方法,这样就保证在channel的方法之外进行处理. 在handclose时向eventloop的toDoList中添加一个后处理方法,方法中可以将fd从epoll中移除</p><p>除了解决上面析构的生命周期、内存问题,此外如果mainReactor正要加入connection,而此时相同的eventloop中另一个连接要断开. 由于此时线程不同,存在不同线程读写问题,std::map不安全. 可以考虑在增删时加锁,或者将移除操作放在mainReactor的eventloop的toDoList中,相当于将移除connectionMap操作放在了最后.  如果处理的线程与mainReactor相同(主线程),就可以直接移除.</p><p>另外存在一个问题,由于移除连接交给了mainReacotr(避免connectionMap线程冲突操作),当有多个连接关闭任务放在mainReacotor的toDoList时,如果其阻塞在epoll_wait就会对性能造成影响,因此可以使用<code>eventfd</code>进行事件通知,类似一个文件描述符,可以加入epoll中并进行读写操作,这可以实现异步唤醒. 每当有Connection进行关闭时,由mainReactor执行,将回调加入toDoList后同时向mainReactor的对应eventfd写入,此时主线程(监听serverfd的EventLoop)就会执行eventfd的channel设置的都操作进行唤醒,然后执行toDoList.</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p><a href="https://zhuanlan.zhihu.com/p/611847234">网络I/O库总结（libevent,libuv,libev,libeio） - 知乎</a></p><ul><li><a href="https://github.com/libuv/libuv">libuv/libuv: Cross-platform asynchronous I/O</a><a href="https://github.com/enki/libev">enki/libev: Full-featured high-performance event loop loosely modelled after libevent</a></li><li><a href="https://github.com/libevent/libevent">libevent/libevent: Event notification library</a></li><li><a href="https://think-async.com/Asio/">Asio C++ Library</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="在windows上的异步I-O机制"><a href="#在windows上的异步I-O机制" class="headerlink" title="在windows上的异步I/O机制"></a>在windows上的异步I/O机制</h3><p>异步 I/O（Asynchronous I/O）是一种高效的机制，用于处理文件、网络套接字等设备的输入输出操作.Windows 提供了多种实现异步 I/O 的方式，包括 <strong>Overlapped I/O</strong> 和 <strong>I/O Completion Ports (IOCP)</strong>。</p><h4 id="Overlapped-I-O"><a href="#Overlapped-I-O" class="headerlink" title="Overlapped I/O"></a><strong>Overlapped I/O</strong></h4><p><strong>概述</strong></p><p>Overlapped I/O 是 Windows 提供的一种异步 I/O 机制，它通过使用 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。这种机制适用于文件操作和套接字通信。</p><ul><li>如果一个文件句柄或套接字是以重叠（Overlapped）模式打开的，则可以对其进行异步操作。</li><li>异步操作完成后，可以通过以下方式通知应用程序：<ul><li>使用事件对象（Event Object）。</li><li>调用回调函数（Completion Routine）。</li><li>使用 I/O 完成端口（IOCP）。</li></ul></li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读写文件或套接字。</li><li><strong><code>GetOverlappedResult</code></strong>：检查异步操作的状态。</li><li><strong><code>CancelIoEx</code></strong>：取消挂起的异步 I/O 操作。</li></ul><p><strong>示例代码</strong></p><p>以下是一个使用 Overlapped I/O 进行异步文件读取的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                  <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,                   <span class="comment">// 打开文件用于读取</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                  <span class="comment">// 打开已存在的文件</span></span><br><span class="line">        FILE_FLAG_OVERLAPPED,           <span class="comment">// 启用 Overlapped I/O</span></span><br><span class="line">        <span class="literal">NULL</span>                            <span class="comment">// 无模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    OVERLAPPED overlapped = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    overlapped.hEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>); <span class="comment">// 创建事件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, buffer, <span class="keyword">sizeof</span>(buffer), <span class="literal">NULL</span>, &amp;overlapped)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() != ERROR_IO_PENDING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            CloseHandle(overlapped.hEvent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    WaitForSingleObject(overlapped.hEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    <span class="keyword">if</span> (GetOverlappedResult(hFile, &amp;overlapped, &amp;bytesRead, FALSE)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, bytesRead, bytesRead, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetOverlappedResult failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(overlapped.hEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileRead();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Overlapped I/O 是 Windows 中最基础的异步 I/O 实现方式之一。它通过 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。</li><li>当使用重叠模式打开文件或套接字时，可以发起异步操作，并且在操作完成前继续执行其他代码。</li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>CreateFile</code></strong>：创建或打开文件时指定 <code>FILE_FLAG_OVERLAPPED</code> 标志以启用重叠模式。</li><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读取或写入数据。对于异步操作，最后一个参数应指向一个有效的 <code>OVERLAPPED</code> 结构体。</li><li><strong><code>GetOverlappedResult</code></strong>：获取异步操作的结果。</li><li><strong><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></strong>：等待异步操作完成。</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在 Windows 中，回调函数通常通过 <code>ReadFileEx</code> 或 <code>WriteFileEx</code> 函数注册，而不是直接使用 <code>ReadFile</code> 或 <code>WriteFile</code>。</p><p>回调函数的原型必须符合以下格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">CompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,       <span class="comment">// 错误码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered, <span class="comment">// 转移的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped        <span class="comment">// OVERLAPPED 结构体指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 注册回调函数</strong></p><ul><li><code>ReadFileEx</code> 和 <code>WriteFileEx</code> 是专门用于异步 I/O 并支持回调函数的 API。</li><li>它们需要一个有效的 <code>OVERLAPPED</code> 结构体，并且文件句柄必须以重叠模式打开（即带有 <code>FILE_FLAG_OVERLAPPED</code> 标志）。</li><li><p>异步操作完成后，操作系统会调用指定的回调函数。</p></li><li><p>回调函数是一种轻量级的异步 I/O 处理方式，通过 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 函数注册回调函数，在操作完成后自动调用。</p></li><li>这种方式要求线程进入可提醒等待状态（Alertable Wait State），例如使用 <code>SleepEx</code> 函数。</li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>ReadFileEx</code> / <code>WriteFileEx</code></strong>：用于启动异步 I/O 操作并注册回调函数。</li><li><strong><code>SleepEx</code></strong>：使当前线程进入可提醒等待状态，以便能够接收异步通知。</li></ul><p><strong>3. 示例代码</strong></p><p>以下是一个使用回调函数处理异步文件读取的完整示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数定义</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">FileIOCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwErrorCode == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous read completed successfully.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Number of bytes read: %d\n&quot;</span>, dwNumberOfBytesTransfered);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous read failed with error code: %d\n&quot;</span>, dwErrorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileReadWithCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                  <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,                   <span class="comment">// 打开文件用于读取</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                  <span class="comment">// 打开已存在的文件</span></span><br><span class="line">        FILE_FLAG_OVERLAPPED,           <span class="comment">// 启用 Overlapped I/O</span></span><br><span class="line">        <span class="literal">NULL</span>                            <span class="comment">// 无模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    OVERLAPPED overlapped = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动异步读取操作</span></span><br><span class="line">    BOOL result = ReadFileEx(</span><br><span class="line">        hFile,                          <span class="comment">// 文件句柄</span></span><br><span class="line">        buffer,                         <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="keyword">sizeof</span>(buffer),                 <span class="comment">// 要读取的字节数</span></span><br><span class="line">        &amp;overlapped,                    <span class="comment">// OVERLAPPED 结构体</span></span><br><span class="line">        FileIOCompletionRoutine         <span class="comment">// 回调函数</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ReadFileEx failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    SleepEx(INFINITE, TRUE); <span class="comment">// 进入可提醒等待状态，使回调函数得以执行</span></span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileReadWithCallback();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="I-O-Completion-Ports-IOCP"><a href="#I-O-Completion-Ports-IOCP" class="headerlink" title="I/O Completion Ports (IOCP)"></a>I/O Completion Ports (IOCP)</h4><p><strong>概述</strong></p><p>I/O Completion Ports（简称 IOCP）是 Windows 提供的一种高性能的异步 I/O 机制，特别适合于需要处理大量并发连接的服务器程序。IOCP 的核心思想是<strong>将多个 I/O 操作绑定到一个完成端口,并由一个线程池来处理完成的通知</strong>。</p><ul><li>IOCP 的优点：<ul><li>高效地管理多个并发 I/O 操作。</li><li>自动负载均衡，多个工作线程可以高效协作。</li><li>支持大规模并发连接。</li></ul></li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建或关联一个完成端口。</li><li><strong><code>PostQueuedCompletionStatus</code></strong>：向完成端口队列提交自定义的完成包。</li><li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中获取完成通知。</li></ul><p><strong>示例代码</strong></p><p>以下是一个简单的 IOCP 示例，展示如何使用 IOCP 处理异步文件读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OVERLAPPED overlapped;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">&#125; IO_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    HANDLE hCompletionPort = (HANDLE)lpParam;</span><br><span class="line">    DWORD bytesTransferred;</span><br><span class="line">    ULONG_PTR completionKey;</span><br><span class="line">    LPOVERLAPPED pOverlapped;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BOOL result = GetQueuedCompletionStatus(</span><br><span class="line">            hCompletionPort, &amp;bytesTransferred, &amp;completionKey, &amp;pOverlapped, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result || bytesTransferred == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Operation failed or completed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IO_CONTEXT *context = (IO_CONTEXT *)pOverlapped;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, bytesTransferred, bytesTransferred, context-&gt;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileReadWithIOCP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,</span><br><span class="line">        GENERIC_READ,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hCompletionPort) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create completion port. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CreateIoCompletionPort(hFile, hCompletionPort, (ULONG_PTR)hFile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, hCompletionPort, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create worker thread. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        CloseHandle(hCompletionPort);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IO_CONTEXT context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    context.overlapped.Offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, context.buffer, <span class="keyword">sizeof</span>(context.buffer), <span class="literal">NULL</span>, &amp;context.overlapped)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() != ERROR_IO_PENDING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            CloseHandle(hCompletionPort);</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hCompletionPort);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileReadWithIOCP();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键函数</strong></p><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建一个新的完成端口或将其与现有句柄关联。</li><li><strong><code>PostQueuedCompletionStatus</code></strong>：手动向完成端口队列中添加状态信息。</li><li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中检索下一个已完成的操作的状态。</li></ul><p><strong>3. 对比 Overlapped I/O 和 IOCP</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>Overlapped I/O</th><th>IOCP</th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>小规模异步操作</td><td>大规模并发 I/O 操作</td></tr><tr><td><strong>性能</strong></td><td>较低</td><td>更高</td></tr><tr><td><strong>复杂度</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>线程管理</strong></td><td>需要手动管理线程</td><td>自动管理线程池</td></tr><tr><td><strong>扩展性</strong></td><td>有限</td><td>非常强</td></tr></tbody></table></div><p><strong>4. 总结</strong></p><ul><li><strong>Overlapped I/O</strong>：适合小型应用或需要简单异步 I/O 的场景，易于实现但扩展性较差。</li><li><p><strong>IOCP</strong>：适合高性能服务器程序，支持大规模并发连接，具有更高的效率和扩展性，但实现起来更复杂。</p></li><li><p><strong>简单场景</strong>：如果您的应用只需要简单的异步 I/O 操作，Overlapped I/O 可能是最容易实现的选择。</p></li><li><strong>高并发场景</strong>：如果您正在开发一个需要处理大量并发连接的应用程序（如 Web 服务器），那么 IOCP 是最佳选择，因为它提供了更好的性能和扩展性。</li><li><strong>轻量级需求</strong>：如果希望避免复杂的线程管理并且对性能的要求不是极高，可以考虑使用回调函数的方式。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
    <category term="Linux网络编程" scheme="https://www.sekyoro.top/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>learn opengl(3)</title>
    <link href="https://www.sekyoro.top/2025/01/26/learn-opengl-3/"/>
    <id>https://www.sekyoro.top/2025/01/26/learn-opengl-3/</id>
    <published>2025-01-26T13:44:23.000Z</published>
    <updated>2025-02-07T14:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>高级光照<br><span id="more"></span></p><h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p>之前使用的光照模型是普通Phong模型,在计算镜面光时通过反射光向量和观察向量的夹角确定镜面光强度. 当角度大于90°时取0. 但这样可能会噪声在90°边缘出现明显断层.</p><p><img data-src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_phong_limit.png" alt="img"></p><p>当物体的反光度非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了. 也就是说,当pow()中的幂律比较小的时候,当反射光与观察向量夹角比较小的时候镜面光就非常强,在夹角接近90°时就接近0了,会出现这种尖锐的断层.</p><p>James F. Blinn在风氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与风氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p><p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</p><p>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与风氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</p><p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了,镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> lightDir   = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> viewDir    = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), shininess);</span><br><span class="line"><span class="type">vec3</span> specular = lightColor * spec;</span><br></pre></td></tr></table></figure><p>Blinn-Phong与风氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而风氏模型测量的是观察方向与反射向量间的夹角。除此之外，风氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和风氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择风氏着色时反光度分量的2到4倍。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(blinn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">16.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h2><p>一旦我们计算出场景的最终像素颜色，我们便需要在显示器上显示它们。在数字成像的早期，大多数显示器都是阴极射线管（CRT）显示器。这些显示器具有一个物理特性，即输入电压加倍并不会导致亮度加倍。输入电压加倍会导致亮度等于大约 2.2 的指数关系，这被称为显示器的gamma。巧合的是，这也与人测量亮度的方法非常接近，因为亮度也是以类似的（倒数）功率关系显示的。</p><p>因为人眼更习惯看暗色的变化,相同的变化在亮色中对于人眼来说不那么明显(非线性的增长)，所以显示器（至今仍）使用功率关系来显示输出颜色，以便将原始的物理亮度颜色映射到顶部刻度中的非线性亮度颜色</p><p>这种显示器非线性映射确实为我们眼睛提供了更令人满意的亮度结果，但在渲染图形时存在一个问题：我们在应用程序中配置的所有颜色和亮度选项都是基于我们从显示器上感知到的，因此所有选项实际上都是非线性亮度/颜色选项</p><p><img data-src="https://learnopengl.com/img/advanced-lighting/gamma_correction_gamma_curves.png" alt="Gamme curves"></p><p>点线表示线性空间中的颜色/光值，实线表示显示器显示的颜色空间。如果我们在线性空间中加倍一个颜色，其结果确实是值的两倍。例如，取一个光的颜色向量（0.5，0.0，0.0），它代表半暗红色光。如果我们在线性空间中加倍这种光，它就会变成（1.0，0.0，0.0），如图所示。然而，原始颜色在显示器上显示为（0.218，0.0，0.0），如图所示。问题从这里开始出现：一旦我们在线性空间中加倍深红色光，它在显示器上的亮度实际上会超过 4.5 倍</p><p>我们一直假设我们在线性空间中工作，<strong>但实际上我们一直在监视器的输出空间中工作，所以我们配置的所有颜色和光照变量都不是物理上正确的，而只是在我们的显示器上看起来（某种程度上）正确</strong>。因此，我们通常将光照值设置得比应有的要亮得多（因为显示器会使其变暗），这导致大多数线性空间计算都是不正确的。请注意，显示器（CRT）和线性图表都是从同一位置开始和结束的；是显示过程中变暗的中间值。因为颜色是根据显示器的输出配置的，所以在线性空间中的所有中间（照明）计算在物理上都是不正确的。随着更先进的照明算法的实施，这一点变得更加明显</p><p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p><p>场景应用伽玛校正有两种方法：</p><ul><li>通过使用 OpenGL 内置的 sRGB 帧缓冲区支持。</li><li>通过在片段着色器中自行进行gamma校正。</li></ul><p>第一个选项可能是最简单的，但也给了你更少的控制。通过启用 GL_FRAMEBUFFER_SRGB，你告诉 OpenGL 每个后续的绘制命令应该在将颜色存储在颜色缓冲区之前，首先对颜色进行伽玛校正（从 sRGB 颜色空间）。sRGB 是一种颜色空间，大致对应于 2.2 的伽玛值，并且是大多数设备的标准。启用 GL_FRAMEBUFFER_SRGB 后，OpenGL 会在每次片段着色器运行后自动对所有后续帧缓冲区执行伽玛校正，包括默认帧缓冲区</p><p>开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_FRAMEBUFFER_SRGB);</span><br></pre></td></tr></table></figure><p>从现在起，您的渲染图像将进行伽玛校正,这是通过硬件完成的。在使用这种方法（以及另一种方法）时，您应该记住的是，伽玛校正（同样）将颜色从线性空间转换为非线性空间，因此您只应在最后和最终步骤进行伽玛校正非常重要。如果您在最终输出之前对颜色进行伽玛校正，所有后续对这些颜色的操作都将基于错误值。例如，如果您使用多个帧缓冲区，您可能希望中间结果在帧缓冲区之间保持在线性空间中，并且只有最后一个帧缓冲区在发送到显示器之前应用伽玛校正。</p><p>第二种方法需要做更多的工作，但同时也让我们完全控制伽玛操作。我们在每个相关片段着色器运行结束时应用伽玛校正，以确保最终颜色在发送到显示器之前得到伽玛校正：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do super fancy lighting in linear space</span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// apply gamma correction</span></span><br><span class="line">    <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    FragColor.rgb = <span class="built_in">pow</span>(fragColor.rgb, <span class="type">vec3</span>(<span class="number">1.0</span>/gamma));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的问题在于，为了保持一致性，你必须对每个对最终输出有贡献的片段着色器应用伽玛校正。如果你有十几个用于多个对象的片段着色器，你必须将这些伽玛校正代码添加到每个着色器中。一个更简单的解决方案是在你的渲染循环中引入一个后处理阶段，并在后处理的四边形上作为最后一步应用伽玛校正，你只需做一次。</p><h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><p>一些纹理创作者基于屏幕/monitor修改颜色,这种颜色就是在非线性空间sRGB下被gamma2.2修改过的,如果对这些纹理进行gamma矫正就可能会导致过亮. 所以必须确保纹理的颜色空间和最终需要的颜色空间一致.</p><p>个解决方案是重校，或把这些sRGB纹理在进行任何颜色值的计算前变回线性空间。我们可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">vec3 diffuseColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(diffuse, texCoords).rgb, <span class="built_in">vec3</span>(gamma));</span><br></pre></td></tr></table></figure><p>为每个sRGB空间的纹理做这件事非常烦人。幸好，OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是GL_SRGB和GL_SRGB_ALPHA内部纹理格式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_SRGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure><p>如果还打算在你的纹理中引入alpha元素，必究必须将纹理的内部格式指定为GL_SRGB_ALPHA。</p><p><strong>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。</strong>比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。<strong>而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了</strong>。指定sRGB纹理时要当心。</p><p>将diffuse纹理定义为sRGB纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次gamma校正</p><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (distance * distance);</span><br></pre></td></tr></table></figure><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0</span> / distance;</span><br></pre></td></tr></table></figure><p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果</p><p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance2)2.2(1.0/distance2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)2.2=1.0/distance2.2(1.0/distance)2.2=1.0/distance2.2。这和物理公式是很相似的。双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。</p><blockquote><p>在基础光照教程中讨论的更高级的那个衰减方程在有gamma校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行gamma校正的场景中当然需要不同的参数）。</p></blockquote><p>总而言之<strong>，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数(使用线性)的原因</strong></p><h2 id="阴影映射"><a href="#阴影映射" class="headerlink" title="阴影映射"></a>阴影映射</h2><p>阴影是由于遮挡导致的光的缺失。当光源的光线因为被其他物体遮挡而没有照射到物体上时，该物体处于阴影中。<strong>阴影为有光照的场景增添了极大的真实感，并使观众更容易观察物体之间的空间关系</strong>。它们为我们场景和物体提供了更深的立体感。</p><p>大多数视频游戏使用的一种既有效又易于实现的技术是阴影映射。阴影映射不难理解，对性能的影响不大，并且很容易扩展到更高级的算法(如全向阴影映射和级联阴影映射)</p><p>阴影映射背后的思想非常简单：我们从光源的角度渲染场景，从光源的角度看到的一切都是被照亮的，而我们看不到的一切都必须处于阴影中。想象一个地板部分和光源之间有一个大箱子的情况。由于光源在朝这个方向看时会看到这个箱子而不是地板部分，所以那个特定的地板部分应该处于阴影中</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;高级光照&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>入门vscode插件开发</title>
    <link href="https://www.sekyoro.top/2025/01/20/%E5%85%A5%E9%97%A8vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://www.sekyoro.top/2025/01/20/%E5%85%A5%E9%97%A8vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2025-01-19T16:16:29.000Z</published>
    <updated>2025-02-07T14:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在插件开发上,有Chorme浏览器插件,有开发工具插件. 在开发工具插件中,有visual studio,jetbrains以及vscode,其中vscode插件开发也是非常流行.这里简单入门介绍一下.<br><span id="more"></span></p><h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx --package yo --package generator-code -- yo code</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>yeoman是创建应用的脚手架,generator-code是vscode项目生成器. 有了这两者开发vscode插件就非常方便了.</p><h2 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h2><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest | Visual Studio Code Extension API</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mini-news&quot;</span>,</span><br><span class="line">  <span class="string">&quot;displayName&quot;</span>: <span class="string">&quot;mini-news&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;engines&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;vscode&quot;</span>: <span class="string">&quot;^1.96.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;categories&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Other&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;activationEvents&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./extension.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;contributes&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;command&quot;</span>: <span class="string">&quot;mini-news.hihi&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;mini-news:info&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint .&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pretest&quot;</span>: <span class="string">&quot;npm run lint&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;vscode-test&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@types/vscode&quot;</span>: <span class="string">&quot;^1.96.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/mocha&quot;</span>: <span class="string">&quot;^10.0.10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/node&quot;</span>: <span class="string">&quot;20.x&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint&quot;</span>: <span class="string">&quot;^9.16.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vscode/test-cli&quot;</span>: <span class="string">&quot;^0.0.10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vscode/test-electron&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于插件的配置,重要的属性比如<code>name</code>,<code>displayname</code>,<code>publisher</code>等,目前版本(&gt;1.74.0)<code>activationEvents</code>不需要额外配置,此外还有<code>contributions</code>用于配置扩展功能<a href="https://code.visualstudio.com/api/references/contribution-points">Contribution Points | Visual Studio Code Extension API</a></p><p>contribution包括commands,menus,configuration,keybinds等等</p><h3 id="extension-js"><a href="#extension-js" class="headerlink" title="extension.js"></a>extension.js</h3><p>扩展入口文件,暴露<code>activate</code>和<code>deactivate</code>.<code>activate</code> 在您注册的激活事件发生时执行。 <code>deactivate</code> 在您的扩展被停用之前给您一个清理的机会。对于许多扩展，可能不需要显式清理，并且可以删除 <code>deactivate</code> 方法。然而，如果扩展需要在 VS Code 关闭或扩展被禁用或卸载时执行操作使用<code>deactivate</code>.</p><p>通过<code>context.subscriptions.push</code>添加功能,通过vscode.xx.registerxx注册功能并在contribution中指定.</p><h2 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义注释内容</span></span><br><span class="line"><span class="keyword">const</span> COMMENT = <span class="string">&#x27;// This is a comment added by the extension\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册命令</span></span><br><span class="line">    <span class="keyword">const</span> disposable = vscode.commands.registerCommand(<span class="string">&#x27;extension.toggleComment&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line">        <span class="keyword">if</span> (!editor) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 没有活动的编辑器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">document</span> = editor.document;</span><br><span class="line">        <span class="keyword">const</span> firstLine = <span class="built_in">document</span>.lineAt(<span class="number">0</span>); <span class="comment">// 获取第一行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查第一行是否已经是注释</span></span><br><span class="line">        <span class="keyword">if</span> (firstLine.text === COMMENT.trim()) &#123;</span><br><span class="line">            <span class="comment">// 如果是注释，则删除</span></span><br><span class="line">            editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> range = <span class="keyword">new</span> vscode.Range(firstLine.range.start, firstLine.range.end);</span><br><span class="line">                editBuilder.delete(range);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是注释，则添加</span></span><br><span class="line">            editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                editBuilder.insert(firstLine.range.start, COMMENT);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;contributes&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;commands&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;extension.toggleComment&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Toggle Comment&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;keybindings&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;extension.toggleComment&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;ctrl+alt+c&quot;</span>, <span class="comment">// 自定义快捷键</span></span><br><span class="line">                <span class="attr">&quot;mac&quot;</span>: <span class="string">&quot;cmd+alt+c&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-hello-world.html">VSCode插件开发全攻略（二）HelloWord - 我是小茗同学 - 博客园</a></li><li><a href="https://code.visualstudio.com/api/get-started/your-first-extension">Your First Extension | Visual Studio Code Extension API</a></li><li><a href="https://github.com/microsoft/vscode-extension-samples/tree/main">microsoft/vscode-extension-samples: Sample code illustrating the VS Code extension API.</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-common-api.html">VSCode插件开发全攻略（九）常用API总结 - 我是小茗同学 - 博客园</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在插件开发上,有Chorme浏览器插件,有开发工具插件. 在开发工具插件中,有visual studio,jetbrains以及vscode,其中vscode插件开发也是非常流行.这里简单入门介绍一下.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Lua给neovim写插件</title>
    <link href="https://www.sekyoro.top/2025/01/18/%E7%BB%99neovim%E5%86%99%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.sekyoro.top/2025/01/18/%E7%BB%99neovim%E5%86%99%E6%8F%92%E4%BB%B6/</id>
    <published>2025-01-18T09:32:40.000Z</published>
    <updated>2025-02-07T14:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在使用neovim和LazyVim配置写代码,感觉很不错. 得益于neovim简单的功能和强大的第三方生态,可以很简单的写出一个插件. 这里根据官方文档搭配lazyvim等资料写一个简单插件.<br><span id="more"></span></p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>lua语法本身并不复杂,参考教程</p><ul><li><a href="https://learnxinyminutes.com/lua/">Learn Lua in Y Minutes</a></li><li><a href="http://lua-users.org/">lua-users.org</a></li><li><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></li><li><a href="https://w3schools.tech/tutorial/lua/index">Welcome to Lua: Your First Step into Programming - Lua Tutorial - W3schools</a></li><li><a href="https://www.lua.org/pil/contents.html#contents">Programming in Lua (first edition)</a></li></ul><p>相关项目</p><ul><li><a href="https://github.com/uhub/awesome-lua">uhub/awesome-lua: A curated list of awesome Lua frameworks, libraries and software.</a></li><li><a href="https://amd-nick.github.io/awesome-lua/">All In One Simple List | awesome lua</a></li><li><a href="https://love2d.org/">LÖVE - Free 2D Game Engine</a> 2D游戏引擎</li></ul><h4 id="表与模块"><a href="#表与模块" class="headerlink" title="表与模块"></a>表与模块</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">l1 = &#123;a=<span class="number">2</span>,b=<span class="number">4</span>&#125;</span><br><span class="line">l2 = &#123;a=<span class="number">2</span>,b=<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(l1,&#123;<span class="built_in">__add</span>=<span class="function"><span class="keyword">function</span><span class="params">(f1,f2)</span></span> </span><br><span class="line">        sum = &#123;&#125;</span><br><span class="line">        sum.a = f1.a + f2.a</span><br><span class="line">        sum.b = f1.b + f2.b</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">-- Values of __index,add, .. are called metamethods.</span></span><br><span class="line"><span class="comment">-- Full list. Here a is a table with the metamethod.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- __add(a, b)                     for a + b</span></span><br><span class="line"><span class="comment">-- __sub(a, b)                     for a - b</span></span><br><span class="line"><span class="comment">-- __mul(a, b)                     for a * b</span></span><br><span class="line"><span class="comment">-- __div(a, b)                     for a / b</span></span><br><span class="line"><span class="comment">-- __mod(a, b)                     for a % b</span></span><br><span class="line"><span class="comment">-- __pow(a, b)                     for a ^ b</span></span><br><span class="line"><span class="comment">-- __unm(a)                        for -a</span></span><br><span class="line"><span class="comment">-- __concat(a, b)                  for a .. b</span></span><br><span class="line"><span class="comment">-- __len(a)                        for #a</span></span><br><span class="line"><span class="comment">-- __eq(a, b)                      for a == b</span></span><br><span class="line"><span class="comment">-- __lt(a, b)                      for a &lt; b</span></span><br><span class="line"><span class="comment">-- __le(a, b)                      for a &lt;= b</span></span><br><span class="line"><span class="comment">-- __index(a, b)  &lt;fn or a table&gt;  for a.b</span></span><br><span class="line"><span class="comment">-- __newindex(a, b, c)             for a.b = c</span></span><br><span class="line"><span class="comment">-- __call(a, ...)                  for a(...)</span></span><br><span class="line"><span class="keyword">local</span> Dog = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:new</span><span class="params">()</span></span></span><br><span class="line">    newObj = &#123;name=<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(newObj,<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:makeSound</span><span class="params">()</span></span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;I say &#x27;</span> .. <span class="built_in">self</span>.sound)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">LoudDog = Dog:new()                          </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoudDog:makeSound</span><span class="params">()</span></span></span><br><span class="line">  s = <span class="built_in">self</span>.sound .. <span class="string">&#x27; &#x27;</span>                      </span><br><span class="line">  <span class="built_in">print</span>(s .. s .. s)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Suppose the file mod.lua looks like this:</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hrunkner&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.sayHello</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Why hello there&#x27;</span>)</span><br><span class="line">  sayMyName()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Another file can use mod.lua&#x27;s functionality:</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span>(<span class="string">&#x27;mod&#x27;</span>)</span><br><span class="line"><span class="comment">-- require&#x27;s return values are cached so a file is</span></span><br><span class="line"><span class="comment">-- run at most once, even when require&#x27;d many times.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Suppose mod2.lua contains &quot;print(&#x27;Hi!&#x27;)&quot;.</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="built_in">require</span>(<span class="string">&#x27;mod2&#x27;</span>)  <span class="comment">-- Prints Hi!</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="built_in">require</span>(<span class="string">&#x27;mod2&#x27;</span>)  <span class="comment">-- Doesn&#x27;t print; a=b.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- dofile is like require without caching:</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">--&gt; Hi!</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">--&gt; Hi! (runs it again)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- loadfile loads a lua file but doesn&#x27;t run it yet.</span></span><br><span class="line">f = <span class="built_in">loadfile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">-- Call f() to run it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- load is loadfile for strings.</span></span><br><span class="line"><span class="comment">-- (loadstring is deprecated, use load instead)</span></span><br><span class="line">g = <span class="built_in">loadstring</span>(<span class="string">&#x27;print(343)&#x27;</span>)  <span class="comment">-- Returns a function.</span></span><br><span class="line">g()  <span class="comment">-- Prints out 343; nothing printed before now.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h4><p>重要的库: io,string.os,table,math</p><div class="table-container"><table><thead><tr><th>库</th><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>string</td><td>string.upper(s)</td><td>Converts s to uppercase</td></tr><tr><td></td><td>string.lower(s)</td><td>Converts s to lowercase</td></tr><tr><td></td><td>string.len(s)</td><td>Returns the length of s</td></tr><tr><td>math</td><td>math.max(x, …)</td><td>Returns the maximum value among its arguments</td></tr><tr><td></td><td>math.min(x, …)</td><td>Returns the minimum value among its arguments</td></tr><tr><td></td><td>math.random([m [, n]])</td><td>Generates a random number</td></tr><tr><td>table</td><td>table.insert(t, [pos,] value)</td><td>Inserts value into t at position pos</td></tr><tr><td></td><td>table.remove(t [, pos])</td><td>Removes from t the element at position pos</td></tr><tr><td></td><td>table.sort(t [, comp])</td><td>Sorts table elements in a given order</td></tr></tbody></table></div><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>在 Lua 中，<code>require</code> 函数用于加载和初始化模块。它会按照一定的顺序搜索指定的模块，并根据配置从不同的目录中加载模块文件。具体来说，<code>require</code> 的查找路径由 <code>package.path</code> 和 <code>package.cpath</code> 两个变量定义。</p><p> <code>package.path</code></p><ul><li><p><strong>用途</strong>：用于指定 Lua 模块（<code>.lua</code> 文件）的搜索路径。</p></li><li><p><strong>默认值</strong>：在不同平台和 Lua 版本上，默认值可能有所不同，但通常类似于以下格式：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package.path = &#x27;<span class="string">./</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span> -- 当前目录下的 <span class="string">.lua</span> 文件</span><br><span class="line">               &#x27;<span class="string">./</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span> -- 当前目录下的子目录中的 init.lua 文件</span><br><span class="line">               &#x27;<span class="string">/usr/local/share/lua/5.4/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/share/lua/5.4/</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">./lua/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">./lua/</span>?<span class="string">/init.lua</span>&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式说明</strong>：</p><ul><li><code>?</code> 是一个占位符，代表模块名。</li><li><code>?/init.lua</code> 表示如果模块名是目录，则尝试加载该目录下的 <code>init.lua</code> 文件。</li></ul></li></ul><ol><li><code>package.cpath</code></li></ol><ul><li><p><strong>用途</strong>：用于指定 C 模块（即使用 C 或 C++ 编写的模块，通常是 <code>.so</code> 或 <code>.dll</code> 文件）的搜索路径。</p></li><li><p><strong>默认值</strong>：同样地，这取决于平台和 Lua 版本，但一般包括如下路径：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package.cpath = &#x27;<span class="string">./</span>?<span class="string">.so</span>;&#x27; <span class="string">..</span> -- 当前目录下的共享库文件</span><br><span class="line">              &#x27;<span class="string">./</span>?<span class="string">.dll</span>;&#x27; <span class="string">..</span> -- Windows 上的动态链接库文件</span><br><span class="line">              &#x27;<span class="string">./loadall.so</span>;&#x27; <span class="string">..</span> -- 加载所有符号的共享库</span><br><span class="line">              &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">.so</span>;&#x27; <span class="string">..</span></span><br><span class="line">              &#x27;<span class="string">/usr/local/lib/lua/5.4/loadall.so</span>;&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式说明</strong>：</p><ul><li><code>?</code> 同样作为模块名的占位符。</li><li>其他部分指定了操作系统特定的库文件扩展名。</li></ul></li></ul><ol><li><code>package.preload</code></li></ol><p>除了上述路径外，<code>require</code> 还会在 <code>package.preload</code> 表中查找是否已经预加载了相应的模块。如果找到了匹配项，则直接返回对应的函数而不进行文件系统搜索</p><h2 id="Neovim的基本功能"><a href="#Neovim的基本功能" class="headerlink" title="Neovim的基本功能"></a>Neovim的基本功能</h2><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p><img data-src="https://s2.loli.net/2025/01/18/bfXs3tq7xK8vAWL.png" alt="image-20250118174705262" style="zoom:50%;" /></p><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>Nvim 支持使用 init.vim 或 init.lua 作为配置文件，但不能同时使用这两个文件。 该文件应放在config目录中、<br>对于 Linux、BSD 或 macOS，该目录通常为 ~/.config/nvim，而对于<br>/AppData/Local/nvim/（Windows）。 请注意，可以在 init.vim 中使用 Lua<br>中使用 Lua，在 init.lua 中使用 Vimscript。 如果想在启动时自动运行任何其他 Lua 脚本，那么<br>只需将其放入运行时路径中的 plugin/。</p><h3 id="nvim中的lua"><a href="#nvim中的lua" class="headerlink" title="nvim中的lua"></a>nvim中的lua</h3><p><a href="https://neovim.io/doc/user/lua-guide.html">Lua-guide - Neovim docs</a></p><h4 id="vim-g"><a href="#vim-g" class="headerlink" title="vim.g"></a>vim.g</h4><p><code>vim.g</code> 是一个 Lua 表，它提供了对全局变量的访问。通过 <code>vim.g</code>，你可以设置或读取任何定义在全局命名空间中的变量。这对于配置插件或共享状态信息非常有用，因为全局变量可以在整个会话期间保持不变，并且可以在不同的脚本之间传递数据。</p><h4 id="vim-cmd"><a href="#vim-cmd" class="headerlink" title="vim.cmd"></a>vim.cmd</h4><p>执行vimscript</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim.cmd(<span class="string">&#x27;echo 42&#x27;</span>)</span><br><span class="line">vim.cmd(<span class="string">[[</span></span><br><span class="line"><span class="string">  augroup My_group</span></span><br><span class="line"><span class="string">    autocmd!</span></span><br><span class="line"><span class="string">    autocmd FileType c setlocal cindent</span></span><br><span class="line"><span class="string">  augroup END</span></span><br><span class="line"><span class="string">]]</span>)</span><br><span class="line"><span class="comment">-- Ex command :echo &quot;foo&quot;</span></span><br><span class="line"><span class="comment">-- Note string literals need to be double quoted.</span></span><br><span class="line">vim.cmd(<span class="string">&#x27;echo &quot;foo&quot;&#x27;</span>)</span><br><span class="line">vim.cmd &#123; cmd = <span class="string">&#x27;echo&#x27;</span>, args = &#123; <span class="string">&#x27;&quot;foo&quot;&#x27;</span> &#125; &#125;</span><br><span class="line">vim.cmd.echo(&#123; args = &#123; <span class="string">&#x27;&quot;foo&quot;&#x27;</span> &#125; &#125;)</span><br><span class="line">vim.cmd.echo(<span class="string">&#x27;&quot;foo&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="vim-opt"><a href="#vim-opt" class="headerlink" title="vim.opt"></a>vim.opt</h4><p><code>vim.opt</code> 是另一个 Lua 表，但它专注于编辑器的选项配置。它允许用户以一种结构化的方式设置和查询 Vim/Neovim 的各种行为参数。与传统的 <code>:set</code> 命令相比，<code>vim.opt</code> 提供了一个更加直观和易于维护的方式来管理和调整编辑器的行为.可以指定选项的作用范围，比如 <code>vim.o</code> 对于全局选项，<code>vim.bo</code> 对于缓冲区特定选项，<code>vim.wo</code> 对于窗口特定选项</p><blockquote><p>一个特殊的接口 vim.opt，可以方便地与 Lua 中的列表和映射样式选项进行交互：它允许以 Lua 表格的形式访问它们，并提供面向对象的方法来添加和删除条目</p></blockquote><p>In Lua using <code>vim.o</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.o.wildignore = <span class="string">&#x27;*.o,*.a,__pycache__&#x27;</span></span><br></pre></td></tr></table></figure><p>In Lua using <code>vim.opt</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.opt.wildignore = &#123; <span class="string">&#x27;*.o&#x27;</span>, <span class="string">&#x27;*.a&#x27;</span>, <span class="string">&#x27;__pycache__&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="vim-api"><a href="#vim-api" class="headerlink" title="vim.api"></a>vim.api</h4><p><a href="https://neovim.io/doc/user/lua.html#vim.api">vim.api</a></p><p>vim.api.{func}(<code>&#123;...&#125;</code>)<br>调用带有参数 {…} 的 Nvim API 函数 {func}。 示例：调用 “nvim_get_current_line()” API 函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(vim.api.nvim_get_current_line()))</span><br></pre></td></tr></table></figure><h4 id="vim-fn"><a href="#vim-fn" class="headerlink" title="vim.fn"></a>vim.fn</h4><p><code>vim.fn</code> 是一个特别设计用来桥接 Vimscript 和 Lua 的接口。它使得开发者能够在 Lua 脚本中调用所有可用的 Vim 内置函数。</p><ul><li>执行系统命令并捕获输出：<code>local output = vim.fn.system(&#39;uname -a&#39;)</code></li><li>获取当前文件名：<code>local filename = vim.fn.expand(&#39;%&#39;)</code></li><li>访问环境变量：<code>local path = vim.fn.getenv(&#39;PATH&#39;)</code></li></ul><p>Neovim会默认从某个目录中加载<code>init.lua</code>,路径如下</p><div class="table-container"><table><thead><tr><th>OS</th><th>PATH</th></tr></thead><tbody><tr><td>Linux, MacOS</td><td><code>$XDG_CONFIG_HOME/nvim</code>, <code>~/.config/nvim</code></td></tr><tr><td>Windows (cmd)</td><td><code>%localappdata%\nvim\</code></td></tr><tr><td>Windows (powershell)</td><td><code>$env:LOCALAPPDATA\nvim\</code></td></tr></tbody></table></div><h4 id="vim-system"><a href="#vim-system" class="headerlink" title="vim.system"></a>vim.system</h4><p>vim.system({cmd}, {opts}, {on_exit})<br> 运行系统命令，如果 {cmd} 无法运行，则抛出错误信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> on_exit = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span></span><br><span class="line">      <span class="built_in">print</span>(obj.code)</span><br><span class="line">      <span class="built_in">print</span>(obj.signal)</span><br><span class="line">      <span class="built_in">print</span>(obj.<span class="built_in">stdout</span>)</span><br><span class="line">      <span class="built_in">print</span>(obj.<span class="built_in">stderr</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Runs asynchronously:</span></span><br><span class="line">    vim.system(&#123;<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;, &#123; text = <span class="literal">true</span> &#125;, on_exit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Runs synchronously:</span></span><br><span class="line">    <span class="keyword">local</span> obj = vim.system(&#123;<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;, &#123; text = <span class="literal">true</span> &#125;):wait()</span><br><span class="line">    <span class="comment">-- &#123; code = 0, signal = 0, stdout = &#x27;hello&#x27;, stderr = &#x27;&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="vim-uv-vim-loop"><a href="#vim-uv-vim-loop" class="headerlink" title="vim.uv vim.loop"></a>vim.uv vim.loop</h4><p>vim.uv暴露 Nvim 用于网络、文件系统和进程管理的 libUV 库的 “luv” Lua 绑定.</p><p><code>vim.uv</code> 是 Neovim 提供的一个接口，它封装了 libuv 库的功能。libuv 是一个用于异步 I/O 的多平台支持库，最初为 Node.js 开发，但因其高效性和跨平台特性而被广泛采用。通过 <code>vim.uv</code>，Neovim 用户和插件开发者可以直接访问底层的文件系统、网络和其他系统操作功能，从而实现更复杂的应用逻辑或优化性能关键部分</p><h4 id="vim-env"><a href="#vim-env" class="headerlink" title="vim.env"></a>vim.env</h4><p>编辑器会话中定义的环境变量</p><h4 id="vim-schedule"><a href="#vim-schedule" class="headerlink" title="vim.schedule"></a>vim.schedule</h4><p>通过事件循环执行函数,避免阻塞</p><h4 id="vim-lsp"><a href="#vim-lsp" class="headerlink" title="vim.lsp"></a>vim.lsp</h4><p>Nvim 支持语言服务器协议 （LSP），这意味着它充当 LSP 服务器的客户端，并包含一个 Lua 框架 <code>vim.lsp</code> 用于构建增强的 LSP 工具</p><h4 id="vim-tbl-deep-extend"><a href="#vim-tbl-deep-extend" class="headerlink" title="vim.tbl_deep_extend"></a>vim.tbl_deep_extend</h4><p>Neovim 提供的一个用于深度合并 Lua 表的函数。它允许你将一个或多个表的内容递归地合并到目标表中，而不会简单地覆盖原有的键值对。这对于配置管理、插件开发以及其他需要合并多层级数据结构的场景非常有用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tbl<span class="constructor">_deep_extend(<span class="params">strategy</span>, <span class="params">target</span>, <span class="params">source1</span>, <span class="params">source2</span>, <span class="operator">...</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>strategy</p><p>：指定合并策略，可以是以下之一：</p><ul><li><code>&quot;force&quot;</code>：强制覆盖目标表中的现有键值。</li><li><code>&quot;keep&quot;</code>：保留目标表中的现有键值，不被源表覆盖。</li><li><code>&quot;error&quot;</code>：如果遇到冲突（即同一个键存在于目标和源表中），则抛出错误。</li></ul></li><li><p><strong>target</strong>：目标表，即将要接收合并结果的表。</p></li><li><p><strong>source1, source2, …</strong>：一个或多个源表，它们的内容将被合并到目标表中。</p></li></ul><h2 id="kickstart"><a href="#kickstart" class="headerlink" title="kickstart"></a>kickstart</h2><p>kickstart是配置nvim很好的一个参考.  <strong>要点</strong>:勤用<code>:help</code>,<code>:help lua-guide</code>,可以查阅neovim提供的lua函数</p><h4 id="配置全局变量与选项-vim-g-amp-amp-vim-opt"><a href="#配置全局变量与选项-vim-g-amp-amp-vim-opt" class="headerlink" title="配置全局变量与选项(vim.g&amp;&amp;vim.opt)"></a>配置全局变量与选项(vim.g&amp;&amp;vim.opt)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Set &lt;space&gt; as the leader key</span></span><br><span class="line"><span class="comment">-- See `:help mapleader`</span></span><br><span class="line"><span class="comment">--  <span class="doctag">NOTE:</span> Must happen before plugins are loaded (otherwise wrong leader will be used)</span></span><br><span class="line">vim.g.mapleader = <span class="string">&#x27; &#x27;</span></span><br><span class="line">vim.g.maplocalleader = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set to true if you have a Nerd Font installed and selected in the terminal</span></span><br><span class="line">vim.g.have_nerd_font = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- [[ Setting options ]]</span></span><br><span class="line"><span class="comment">-- See `:help vim.opt`</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> You can change these options as you wish!</span></span><br><span class="line"><span class="comment">--  For more options, you can see `:help option-list`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Make line numbers default</span></span><br><span class="line">vim.opt.number = <span class="literal">true</span></span><br><span class="line"><span class="comment">-- You can also add relative line numbers, to help with jumping.</span></span><br><span class="line"><span class="comment">--  Experiment for yourself to see if you like it!</span></span><br><span class="line"><span class="comment">-- vim.opt.relativenumber = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Enable mouse mode, can be useful for resizing splits for example!</span></span><br><span class="line">vim.opt.mouse = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Don&#x27;t show the mode, since it&#x27;s already in the status line</span></span><br><span class="line">vim.opt.showmode = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/01/18/1Awh4k7BIx63Cq2.png" alt="image-20250118233131109" style="zoom:50%;" /></p><h4 id="快捷键-keymap"><a href="#快捷键-keymap" class="headerlink" title="快捷键(keymap)"></a>快捷键(keymap)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Basic Keymaps ]]</span></span><br><span class="line"><span class="comment">--  See `:help vim.keymap.set()`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Clear highlights on search when pressing &lt;Esc&gt; in normal mode</span></span><br><span class="line"><span class="comment">--  See `:help hlsearch`</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;nohlsearch&lt;CR&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Diagnostic keymaps</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;leader&gt;q&#x27;</span>, vim.diagnostic.setloclist, &#123; desc = <span class="string">&#x27;Open diagnostic [Q]uickfix list&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exit terminal mode in the builtin terminal with a shortcut that is a bit easier</span></span><br><span class="line"><span class="comment">-- for people to discover. Otherwise, you normally need to press &lt;C-\&gt;&lt;C-n&gt;, which</span></span><br><span class="line"><span class="comment">-- is not what someone will guess without a bit more experience.</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> This won&#x27;t work in all terminal emulators/tmux/etc. Try your own mapping</span></span><br><span class="line"><span class="comment">-- or just use &lt;C-\&gt;&lt;C-n&gt; to exit terminal mode</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;&lt;Esc&gt;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;C-\\&gt;&lt;C-n&gt;&#x27;</span>, &#123; desc = <span class="string">&#x27;Exit terminal mode&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TIP: Disable arrow keys in normal mode</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;left&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use h to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;right&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use l to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;up&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use k to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;down&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use j to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="指令执行-autocmd"><a href="#指令执行-autocmd" class="headerlink" title="指令执行(autocmd)"></a>指令执行(autocmd)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Basic Autocommands ]]</span></span><br><span class="line"><span class="comment">--  See `:help lua-guide-autocommands`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Highlight when yanking (copying) text</span></span><br><span class="line"><span class="comment">--  Try it with `yap` in normal mode</span></span><br><span class="line"><span class="comment">--  See `:help vim.highlight.on_yank()`</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&#x27;TextYankPost&#x27;</span>, &#123;</span><br><span class="line">  desc = <span class="string">&#x27;Highlight when yanking (copying) text&#x27;</span>,</span><br><span class="line">  group = vim.api.nvim_create_augroup(<span class="string">&#x27;kickstart-highlight-yank&#x27;</span>, &#123; clear = <span class="literal">true</span> &#125;),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.highlight.on_yank()</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  command = <span class="string">&quot;echo &#x27;Entering a C or C++ file&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Same autocommand written with a Lua function instead</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;Entering a C or C++ file&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- User event triggered by MyPlugin</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;User&quot;</span>, &#123;</span><br><span class="line">  pattern = <span class="string">&quot;MyPlugin&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;My Plugin Works!&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>自动命令是 Vim 命令或 Lua 函数，每当触发一个或多个事件触发时自动执行的 Vim 命令或 Lua 函数。<br>读取或写入文件，或创建窗口时自动执行。 可以通过Lua使用Nvim API 访问。</p><h4 id="安装包管理器"><a href="#安装包管理器" class="headerlink" title="安装包管理器"></a>安装包管理器</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Install `lazy.nvim` plugin manager ]]</span></span><br><span class="line"><span class="comment">--    See `:help lazy.nvim.txt` or https://github.com/folke/lazy.nvim for more info</span></span><br><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath <span class="string">&#x27;data&#x27;</span> .. <span class="string">&#x27;/lazy/lazy.nvim&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (vim.uv <span class="keyword">or</span> vim.loop).fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> lazyrepo = <span class="string">&#x27;https://github.com/folke/lazy.nvim.git&#x27;</span></span><br><span class="line">  <span class="keyword">local</span> out = vim.fn.system &#123; <span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--filter=blob:none&#x27;</span>, <span class="string">&#x27;--branch=stable&#x27;</span>, lazyrepo, lazypath &#125;</span><br><span class="line">  <span class="keyword">if</span> vim.v.shell_error ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&#x27;Error cloning lazy.nvim:\n&#x27;</span> .. out)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">---@diagnostic disable-next-line: undefined-field</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br></pre></td></tr></table></figure><p><code>vim.fn.stdpath</code> 用于获取标准路径的绝对路径。它可以帮助你轻松找到配置文件、数据文件或缓存文件所在的目录，这对于编写可移植的脚本和插件非常有用。</p><p><strong>kind</strong>：指定要查询的标准路径类型，可以是以下字符串之一：</p><ul><li><code>&quot;config&quot;</code>：配置文件的位置。通常对应于 <code>$XDG_CONFIG_HOME/nvim</code> 或 <code>$HOME/.config/nvim</code>。</li><li><code>&quot;data&quot;</code>：用户特定的数据文件位置。通常对应于 <code>$XDG_DATA_HOME/nvim</code> 或 <code>$HOME/.local/share/nvim</code>。</li><li><code>&quot;cache&quot;</code>：缓存文件的位置。通常对应于 <code>$XDG_CACHE_HOME/nvim</code> 或 <code>$HOME/.cache/nvim</code>。</li><li><code>&quot;state&quot;</code>：状态文件的位置（如 swap 文件、undo 文件等）。通常与 <code>data</code> 目录相同，但在某些情况下可能会有所不同</li></ul><p>v:shell_error最后一条 shell 命令的结果。  非零时，表示最后一条shell 命令出错。 当为零时，表示没有问题。只有当 shell 向 Vim 返回错误代码时才会起作用。当命令无法执行时，通常使用 -1。 执行。  只读。</p><p>Vim/Neovim 使用 <code>rtp</code> 来定位各种类型的文件，如：</p><ul><li>插件 (<code>plugin/*.vim</code>)</li><li>脚本 (<code>autoload/*.vim</code>, <code>ftplugin/*.vim</code>)</li><li>语法定义 (<code>syntax/*.vim</code>)</li><li>颜色方案 (<code>colors/*.vim</code>)</li><li>文档 (<code>doc/*.txt</code>)</li><li><p>其他配置文件</p></li><li><p><strong>加载顺序</strong>：当有多个相同名称的文件存在于不同的目录中时，会按照 <code>rtp</code> 中列出的顺序依次查找并加载第一个找到的文件。这意味着较早出现在 <code>rtp</code> 中的目录具有更高的优先级。</p></li></ul><p>配置插件管理</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Configure and install plugins ]]</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  To check the current status of your plugins, run</span></span><br><span class="line"><span class="comment">--    :Lazy</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  You can press `?` in this menu for help. Use `:q` to close the window</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  To update plugins you can run</span></span><br><span class="line"><span class="comment">--    :Lazy update</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> Here is where you install your plugins.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;lazy&#x27;</span>).setup(&#123;</span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can be added with a link (or for a github repo: &#x27;owner/repo&#x27; link).</span></span><br><span class="line">  <span class="string">&#x27;tpope/vim-sleuth&#x27;</span>, <span class="comment">-- Detect tabstop and shiftwidth automatically</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can also be added by using a table,</span></span><br><span class="line">  <span class="comment">-- with the first argument being the link and the following</span></span><br><span class="line">  <span class="comment">-- keys can be used to configure plugin behavior/loading/etc.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- Use `opts = &#123;&#125;` to force a plugin to be loaded.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Here is a more advanced example where we pass configuration</span></span><br><span class="line">  <span class="comment">-- options to `gitsigns.nvim`. This is equivalent to the following Lua:</span></span><br><span class="line">  <span class="comment">--    require(&#x27;gitsigns&#x27;).setup(&#123; ... &#125;)</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- See `:help gitsigns` to understand what the configuration keys do</span></span><br><span class="line">  &#123; <span class="comment">-- Adds git related signs to the gutter, as well as utilities for managing changes</span></span><br><span class="line">    <span class="string">&#x27;lewis6991/gitsigns.nvim&#x27;</span>,</span><br><span class="line">    opts = &#123;</span><br><span class="line">      signs = &#123;</span><br><span class="line">        add = &#123; text = <span class="string">&#x27;+&#x27;</span> &#125;,</span><br><span class="line">        change = &#123; text = <span class="string">&#x27;~&#x27;</span> &#125;,</span><br><span class="line">        delete = &#123; text = <span class="string">&#x27;_&#x27;</span> &#125;,</span><br><span class="line">        topdelete = &#123; text = <span class="string">&#x27;‾&#x27;</span> &#125;,</span><br><span class="line">        changedelete = &#123; text = <span class="string">&#x27;~&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can also be configured to run Lua code when they are loaded.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- This is often very useful to both group configuration, as well as handle</span></span><br><span class="line">  <span class="comment">-- lazy loading plugins that don&#x27;t need to be loaded immediately at startup.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- For example, in the following configuration, we use:</span></span><br><span class="line">  <span class="comment">--  event = &#x27;VimEnter&#x27;</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- which loads which-key before all the UI elements are loaded. Events can be</span></span><br><span class="line">  <span class="comment">-- normal autocommands events (`:help autocmd-events`).</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- Then, because we use the `opts` key (recommended), the configuration runs</span></span><br><span class="line">  <span class="comment">-- after the plugin has been loaded as `require(MODULE).setup(opts)`.</span></span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">-- Useful plugin to show you pending keybinds.</span></span><br><span class="line">    <span class="string">&#x27;folke/which-key.nvim&#x27;</span>,</span><br><span class="line">    event = <span class="string">&#x27;VimEnter&#x27;</span>, <span class="comment">-- Sets the loading event to &#x27;VimEnter&#x27;</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="comment">-- delay between pressing a key and opening which-key (milliseconds)</span></span><br><span class="line">      <span class="comment">-- this setting is independent of vim.opt.timeoutlen</span></span><br><span class="line">      delay = <span class="number">0</span>,</span><br><span class="line">      icons = &#123;</span><br><span class="line">        <span class="comment">-- set icon mappings to true if you have a Nerd Font</span></span><br><span class="line">        mappings = vim.g.have_nerd_font,</span><br><span class="line">        <span class="comment">-- If you are using a Nerd Font: set icons.keys to an empty table which will use the</span></span><br><span class="line">        <span class="comment">-- default which-key.nvim defined Nerd Font icons, otherwise define a string table</span></span><br><span class="line">        keys = vim.g.have_nerd_font <span class="keyword">and</span> &#123;&#125; <span class="keyword">or</span> &#123;</span><br><span class="line">          Up = <span class="string">&#x27;&lt;Up&gt; &#x27;</span>,</span><br><span class="line">          Down = <span class="string">&#x27;&lt;Down&gt; &#x27;</span>,</span><br><span class="line">          Left = <span class="string">&#x27;&lt;Left&gt; &#x27;</span>,</span><br><span class="line">          Right = <span class="string">&#x27;&lt;Right&gt; &#x27;</span>,</span><br><span class="line">          C = <span class="string">&#x27;&lt;C-…&gt; &#x27;</span>,</span><br><span class="line">          M = <span class="string">&#x27;&lt;M-…&gt; &#x27;</span>,</span><br><span class="line">          D = <span class="string">&#x27;&lt;D-…&gt; &#x27;</span>,</span><br><span class="line">          S = <span class="string">&#x27;&lt;S-…&gt; &#x27;</span>,</span><br><span class="line">          CR = <span class="string">&#x27;&lt;CR&gt; &#x27;</span>,</span><br><span class="line">          Esc = <span class="string">&#x27;&lt;Esc&gt; &#x27;</span>,</span><br><span class="line">          ScrollWheelDown = <span class="string">&#x27;&lt;ScrollWheelDown&gt; &#x27;</span>,</span><br><span class="line">          ScrollWheelUp = <span class="string">&#x27;&lt;ScrollWheelUp&gt; &#x27;</span>,</span><br><span class="line">          NL = <span class="string">&#x27;&lt;NL&gt; &#x27;</span>,</span><br><span class="line">          BS = <span class="string">&#x27;&lt;BS&gt; &#x27;</span>,</span><br><span class="line">          Space = <span class="string">&#x27;&lt;Space&gt; &#x27;</span>,</span><br><span class="line">          Tab = <span class="string">&#x27;&lt;Tab&gt; &#x27;</span>,</span><br><span class="line">          F1 = <span class="string">&#x27;&lt;F1&gt;&#x27;</span>,</span><br><span class="line">          F2 = <span class="string">&#x27;&lt;F2&gt;&#x27;</span>,</span><br><span class="line">          F3 = <span class="string">&#x27;&lt;F3&gt;&#x27;</span>,</span><br><span class="line">          F4 = <span class="string">&#x27;&lt;F4&gt;&#x27;</span>,</span><br><span class="line">          F5 = <span class="string">&#x27;&lt;F5&gt;&#x27;</span>,</span><br><span class="line">          F6 = <span class="string">&#x27;&lt;F6&gt;&#x27;</span>,</span><br><span class="line">          F7 = <span class="string">&#x27;&lt;F7&gt;&#x27;</span>,</span><br><span class="line">          F8 = <span class="string">&#x27;&lt;F8&gt;&#x27;</span>,</span><br><span class="line">          F9 = <span class="string">&#x27;&lt;F9&gt;&#x27;</span>,</span><br><span class="line">          F10 = <span class="string">&#x27;&lt;F10&gt;&#x27;</span>,</span><br><span class="line">          F11 = <span class="string">&#x27;&lt;F11&gt;&#x27;</span>,</span><br><span class="line">          F12 = <span class="string">&#x27;&lt;F12&gt;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Document existing key chains</span></span><br><span class="line">      spec = &#123;</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;c&#x27;</span>, group = <span class="string">&#x27;[C]ode&#x27;</span>, mode = &#123; <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;x&#x27;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;d&#x27;</span>, group = <span class="string">&#x27;[D]ocument&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;r&#x27;</span>, group = <span class="string">&#x27;[R]ename&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;s&#x27;</span>, group = <span class="string">&#x27;[S]earch&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;w&#x27;</span>, group = <span class="string">&#x27;[W]orkspace&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;t&#x27;</span>, group = <span class="string">&#x27;[T]oggle&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;h&#x27;</span>, group = <span class="string">&#x27;Git [H]unk&#x27;</span>, mode = &#123; <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;v&#x27;</span> &#125; &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="NvChad"><a href="#NvChad" class="headerlink" title="NvChad"></a>NvChad</h2><p>比kickstart更复杂一点,但也很容易上手. 其配置也是类似,首先包括全局变量、设置选项以及环境变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"><span class="keyword">local</span> o = vim.o</span><br><span class="line"><span class="keyword">local</span> g = vim.g</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------------------- options ------------------------------------------</span></span><br><span class="line">o.laststatus = <span class="number">3</span></span><br><span class="line">o.showmode = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">o.clipboard = <span class="string">&quot;unnamedplus&quot;</span></span><br><span class="line">o.cursorline = <span class="literal">true</span></span><br><span class="line">o.cursorlineopt = <span class="string">&quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Indenting</span></span><br><span class="line">o.expandtab = <span class="literal">true</span></span><br><span class="line">o.shiftwidth = <span class="number">2</span></span><br><span class="line">o.smartindent = <span class="literal">true</span></span><br><span class="line">o.tabstop = <span class="number">2</span></span><br><span class="line">o.softtabstop = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">opt.fillchars = &#123; eob = <span class="string">&quot; &quot;</span> &#125;</span><br><span class="line">o.ignorecase = <span class="literal">true</span></span><br><span class="line">o.smartcase = <span class="literal">true</span></span><br><span class="line">o.mouse = <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Numbers</span></span><br><span class="line">o.number = <span class="literal">true</span></span><br><span class="line">o.numberwidth = <span class="number">2</span></span><br><span class="line">o.ruler = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- disable nvim intro</span></span><br><span class="line">opt.shortmess:append <span class="string">&quot;sI&quot;</span></span><br><span class="line"></span><br><span class="line">o.signcolumn = <span class="string">&quot;yes&quot;</span></span><br><span class="line">o.splitbelow = <span class="literal">true</span></span><br><span class="line">o.splitright = <span class="literal">true</span></span><br><span class="line">o.timeoutlen = <span class="number">400</span></span><br><span class="line">o.undofile = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- interval for writing swap file to disk, also used by gitsigns</span></span><br><span class="line">o.updatetime = <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- go to previous/next line with h,l,left arrow and right arrow</span></span><br><span class="line"><span class="comment">-- when cursor reaches end/beginning of line</span></span><br><span class="line">opt.whichwrap:append <span class="string">&quot;&lt;&gt;[]hl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- disable some default providers</span></span><br><span class="line">g.loaded_node_provider = <span class="number">0</span></span><br><span class="line">g.loaded_python3_provider = <span class="number">0</span></span><br><span class="line">g.loaded_perl_provider = <span class="number">0</span></span><br><span class="line">g.loaded_ruby_provider = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- add binaries installed by mason.nvim to path</span></span><br><span class="line"><span class="keyword">local</span> is_windows = vim.fn.has <span class="string">&quot;win32&quot;</span> ~= <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> sep = is_windows <span class="keyword">and</span> <span class="string">&quot;\\&quot;</span> <span class="keyword">or</span> <span class="string">&quot;/&quot;</span></span><br><span class="line"><span class="keyword">local</span> delim = is_windows <span class="keyword">and</span> <span class="string">&quot;;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;:&quot;</span></span><br><span class="line">vim.env.PATH = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123; vim.fn.stdpath <span class="string">&quot;data&quot;</span>, <span class="string">&quot;mason&quot;</span>, <span class="string">&quot;bin&quot;</span> &#125;, sep) .. delim .. vim.env.PATH</span><br></pre></td></tr></table></figure><p>快捷键</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> map = vim.keymap.set</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-b&gt;&quot;</span>, <span class="string">&quot;&lt;ESC&gt;^i&quot;</span>, &#123; desc = <span class="string">&quot;move beginning of line&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-e&gt;&quot;</span>, <span class="string">&quot;&lt;End&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move end of line&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;Left&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move left&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;Right&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move right&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;Down&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;Up&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;h&quot;</span>, &#123; desc = <span class="string">&quot;switch window left&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;l&quot;</span>, &#123; desc = <span class="string">&quot;switch window right&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;j&quot;</span>, &#123; desc = <span class="string">&quot;switch window down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;k&quot;</span>, &#123; desc = <span class="string">&quot;switch window up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;Esc&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;noh&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general clear highlights&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-s&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;w&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general save file&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-c&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;%y+&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general copy whole file&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;n&quot;</span>, <span class="string">&quot;&lt;cmd&gt;set nu!&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle line number&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;rn&quot;</span>, <span class="string">&quot;&lt;cmd&gt;set rnu!&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle relative number&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ch&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvCheatsheet&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle nvcheatsheet&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fm&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;conform&quot;</span>).<span class="built_in">format</span> &#123; lsp_fallback = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;general format file&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- global lsp mappings</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ds&quot;</span>, vim.diagnostic.setloclist, &#123; desc = <span class="string">&quot;LSP diagnostic loclist&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- tabufline</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;enew&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;buffer new&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;tab&gt;&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer goto next&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-tab&gt;&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).prev()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer goto prev&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;x&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).close_buffer()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer close&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Comment</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="string">&quot;gcc&quot;</span>, &#123; desc = <span class="string">&quot;toggle comment&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="string">&quot;gc&quot;</span>, &#123; desc = <span class="string">&quot;toggle comment&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- nvimtree</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-n&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvimTreeToggle&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;nvimtree toggle window&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;e&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvimTreeFocus&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;nvimtree focus window&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- telescope</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fw&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope live_grep&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope live grep&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fb&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope buffers&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find buffers&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fh&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope help_tags&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope help page&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ma&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope marks&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find marks&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fo&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope oldfiles&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find oldfiles&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fz&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope current_buffer_fuzzy_find&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find in current buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;cm&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope git_commits&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope git commits&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;gt&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope git_status&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope git status&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;pt&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope terms&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope pick hidden term&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;th&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.themes&quot;</span>).<span class="built_in">open</span>()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;telescope nvchad themes&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ff&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope find_files&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find files&quot;</span> &#125;)</span><br><span class="line">map(</span><br><span class="line">  <span class="string">&quot;n&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;leader&gt;fa&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;cmd&gt;Telescope find_files follow=true no_ignore=true hidden=true&lt;CR&gt;&quot;</span>,</span><br><span class="line">  &#123; desc = <span class="string">&quot;telescope find all files&quot;</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- terminal</span></span><br><span class="line">map(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;&lt;C-x&gt;&quot;</span>, <span class="string">&quot;&lt;C-\\&gt;&lt;C-N&gt;&quot;</span>, &#123; desc = <span class="string">&quot;terminal escape terminal mode&quot;</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>autocmd</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> autocmd = vim.api.nvim_create_autocmd</span><br><span class="line"></span><br><span class="line"><span class="comment">-- user event that loads after UIEnter + only if file buf is there</span></span><br><span class="line">autocmd(&#123; <span class="string">&quot;UIEnter&quot;</span>, <span class="string">&quot;BufReadPost&quot;</span>, <span class="string">&quot;BufNewFile&quot;</span> &#125;, &#123;</span><br><span class="line">  group = vim.api.nvim_create_augroup(<span class="string">&quot;NvFilePost&quot;</span>, &#123; clear = <span class="literal">true</span> &#125;),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="keyword">local</span> file = vim.api.nvim_buf_get_name(args.buf)</span><br><span class="line">    <span class="keyword">local</span> buftype = vim.api.nvim_get_option_value(<span class="string">&quot;buftype&quot;</span>, &#123; buf = args.buf &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> vim.g.ui_entered <span class="keyword">and</span> args.event == <span class="string">&quot;UIEnter&quot;</span> <span class="keyword">then</span></span><br><span class="line">      vim.g.ui_entered = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> file ~= <span class="string">&quot;&quot;</span> <span class="keyword">and</span> buftype ~= <span class="string">&quot;nofile&quot;</span> <span class="keyword">and</span> vim.g.ui_entered <span class="keyword">then</span></span><br><span class="line">      vim.api.nvim_exec_autocmds(<span class="string">&quot;User&quot;</span>, &#123; pattern = <span class="string">&quot;FilePost&quot;</span>, modeline = <span class="literal">false</span> &#125;)</span><br><span class="line">      vim.api.nvim_del_augroup_by_name <span class="string">&quot;NvFilePost&quot;</span></span><br><span class="line"></span><br><span class="line">      vim.schedule(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        vim.api.nvim_exec_autocmds(<span class="string">&quot;FileType&quot;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> vim.g.editorconfig <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;editorconfig&quot;</span>).<span class="built_in">config</span>(args.buf)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="LazyVim"><a href="#LazyVim" class="headerlink" title="LazyVim"></a>LazyVim</h2><p>neovim的插件编写<a href="https://miguelcrespo.co/posts/how-to-write-a-neovim-plugin-in-lua">How to write a neovim plugin in lua</a>与使用lazyvim不同但有相似点</p><ul><li><a href="https://dev.to/iamgoncaloalves/how-i-developed-my-first-neovim-plugin-a-step-by-step-guide-1lcb#:~:text=Make changes to your plugin code. Save the,changes by running %3AHelloWorld or using the keymapping.">How I Developed My First Neovim Plugin: A Step-by-Step Guide - DEV Community</a></li><li><a href="https://dev.to/vonheikemen/lazynvim-plugin-configuration-3opi">Lazy.nvim: plugin configuration - DEV Community</a></li><li><a href="https://www.reddit.com/r/neovim/comments/z0ihuf/are_there_any_good_starter_templates_for_writing/"> r/neovim —- Are there any good starter templates for writing Neovim plugins? : r/neovim</a></li><li><a href="https://github.com/LazyVim/LazyVim/discussions/1129">LazyVim local development · LazyVim/LazyVim · Discussion #1129</a></li><li><a href="https://github.com/LazyVim/LazyVim/discussions/2202">Loading local plugins · LazyVim/LazyVim · Discussion #2202</a></li><li><a href="https://miguelcrespo.co/posts/how-to-write-a-neovim-plugin-in-lua">How to write a neovim plugin in lua</a></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── plugin</span><br><span class="line">│  └── plugin-<span class="keyword">file</span>.<span class="keyword">lua</span></span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│  └── main-<span class="keyword">file</span>.<span class="keyword">lua</span></span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>plugin和 lua 文件夹是特例，其含义如下：</p><ul><li>plugin 文件夹 该文件夹中的所有文件将在 Neovim 启动时立即执行，如果想设置keymap或autocmd而不管用户是否需要该插件</li><li>lua 文件夹 在大多数情况下，lua 文件夹是您的插件代码所在的文件夹，只有在用户明确需要您的插件时才会执行这些代码，例如 require(‘scratch-buffer’)</li></ul><h4 id="插件代码该放哪"><a href="#插件代码该放哪" class="headerlink" title="插件代码该放哪"></a>插件代码该放哪</h4><p>对于普通neovim插件,可以放在lua文件夹下,通过neovim加载配置路径中的<code>init.lua</code>通过<code>require</code>加载</p><p>而在lazyvim中,添加spec.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(&#123;</span><br><span class="line">  spec = &#123;</span><br><span class="line">    <span class="comment">-- add lazyvim and import its plugins</span></span><br><span class="line">    &#123; <span class="string">&quot;lazyvim/lazyvim&quot;</span>, import = <span class="string">&quot;lazyvim.plugins&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;coderunner&quot;</span>, dir = <span class="string">&quot;~/appdata/local/nvim/lua/plugins/coderunner&quot;</span>, dev = <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">-- import/override with your plugins</span></span><br><span class="line">    &#123; import = <span class="string">&quot;plugins&quot;</span> &#125;,</span><br><span class="line">    &#123; import = <span class="string">&quot;lazyvim.plugins.extras.linting.eslint&quot;</span> &#125;,</span><br><span class="line">    &#123; import = <span class="string">&quot;lazyvim.plugins.extras.formatting.prettier&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- by default, only lazyvim plugins will be lazy-loaded. your custom plugins will load during startup.</span></span><br><span class="line">    <span class="comment">-- if you know what you&#x27;re doing, you can set this to `true` to have all your custom plugins lazy-loaded by default.</span></span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- it&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your neovim install.</span></span><br><span class="line">    version = <span class="literal">false</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123; colorscheme = &#123; <span class="string">&quot;tokyonight&quot;</span>, <span class="string">&quot;habamax&quot;</span> &#125; &#125;,</span><br><span class="line">  checker = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>, <span class="comment">-- check for plugin updates periodically</span></span><br><span class="line">    notify = <span class="literal">false</span>, <span class="comment">-- notify on update</span></span><br><span class="line">  &#125;, <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">  performance = &#123;</span><br><span class="line">    rtp = &#123;</span><br><span class="line">      <span class="comment">-- disable some rtp plugins</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwplugin&quot;,</span></span><br><span class="line">        <span class="string">&quot;tarplugin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tohtml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tutor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zipplugin&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新启动 Neovim 或运行 :Lazy sync 来加载插件.有了这种设置，您就可以轻松迭代您的插件： 1.  更改插件代码。  2.  保存文件。  3.  在 Neovim 中运行 :Lazy reload plugin-name 重新加载插件。  4.  运行 :HelloWorld 或使用关键映射测试更改。   此工作流程可实现快速开发和测试，而无需不断重启 Neovim 或手动获取文件。</p><p>可以直接使用的nvim配置,lazyvim会自动加载预定义的autocmd,keymaps和options.<a href="https://lazy.folke.io/spec">🔌 Plugin Spec | lazy.nvim</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~/.config/nvim</span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── autocmds.<span class="keyword">lua</span></span><br><span class="line">│   │   ├── keymaps.<span class="keyword">lua</span></span><br><span class="line">│   │   ├── lazy.<span class="keyword">lua</span></span><br><span class="line">│   │   └── <span class="keyword">options</span>.<span class="keyword">lua</span></span><br><span class="line">│   └── plugins</span><br><span class="line">│       ├── spec1.<span class="keyword">lua</span></span><br><span class="line">│       ├── **</span><br><span class="line">│       └── spec2.<span class="keyword">lua</span></span><br><span class="line">└── init.<span class="keyword">lua</span></span><br></pre></td></tr></table></figure><p>写本地插件时直接在plugins目录中即可. 添加插件时可用的选项</p><p>Defaults merging rules:</p><ul><li>cmd：命令列表将使用您的自定义命令进行扩展</li><li>event：事件列表将使用您的自定义事件进行扩展</li><li>FT：文件类型列表将扩展为自定义文件类型</li><li>keys：键盘映射列表将使用您的自定义键盘映射进行扩展</li><li>opts：自定义 opts 将与默认 opts 合并</li><li>dependencies：依赖项列表将使用您的自定义依赖项进行扩展</li><li><strong>任何其他属性都将覆盖默认值</strong></li></ul><p>对于 <code>ft</code> ， <code>event</code> ， <code>keys</code> ， <code>cmd</code> 和 <code>opts</code> 您还可以指定一个 <code>values</code> 函数，该函数可以更改默认值，或返回要使用的新值.除此之外,还有init,config函数. Lua 插件遵循一个常见的约定，它们有一个名为 <code>setup</code> 的函数暴露的 Lua 模块。所以当使用 <code>opts</code> 时，是在告诉 lazy.nvim 该插件遵循该约定。因此，lazy.nvim 会将那个 <code>opts</code> 属性传递给插件的 <code>setup</code> 函数。</p><p>使用lazyvim写插件的debug方式<a href="https://lazy.folke.io/usage">🚀 Usage | lazy.nvim</a></p><h3 id="小案例-插件重载器"><a href="#小案例-插件重载器" class="headerlink" title="小案例 插件重载器"></a>小案例 插件重载器</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- init.lua</span></span><br><span class="line"><span class="keyword">local</span> utils = <span class="built_in">require</span>(<span class="string">&quot;utils&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPlugins</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> plugins = <span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).plugins()</span><br><span class="line">utils.createwin(plugins)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.setup</span><span class="params">(opts)</span></span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;Reload&quot;</span>, showPlugins, &#123;</span><br><span class="line">desc = <span class="string">&quot;Reload plugins&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- utils.lua</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.createwin</span><span class="params">(items)</span></span></span><br><span class="line"><span class="keyword">local</span> width = <span class="number">40</span></span><br><span class="line"><span class="keyword">local</span> height = #items + <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> row = <span class="built_in">math</span>.<span class="built_in">floor</span>(vim.o.<span class="built_in">lines</span> / <span class="number">2</span>) - <span class="built_in">math</span>.<span class="built_in">floor</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> col = <span class="built_in">math</span>.<span class="built_in">floor</span>(vim.o.columns / <span class="number">2</span>) - <span class="built_in">math</span>.<span class="built_in">floor</span>(width / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> bufnr = vim.api.nvim_create_buf(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;bufhidden&quot;</span>, <span class="string">&quot;wipe&quot;</span>, &#123; buf = bufnr &#125;)</span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">ipairs</span>(items) <span class="keyword">do</span></span><br><span class="line">vim.api.nvim_buf_set_lines(bufnr, i - <span class="number">1</span>, i, <span class="literal">false</span>, &#123; item.name &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;modifiable&quot;</span>, <span class="literal">false</span>, &#123; buf = bufnr &#125;)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;readonly&quot;</span>, <span class="literal">true</span>, &#123; buf = bufnr &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> win_id = vim.api.nvim_open_win(bufnr, <span class="literal">true</span>, &#123;</span><br><span class="line">relative = <span class="string">&quot;editor&quot;</span>,</span><br><span class="line">width = width,</span><br><span class="line">height = height,</span><br><span class="line">row = row,</span><br><span class="line">col = col,</span><br><span class="line">style = <span class="string">&quot;minimal&quot;</span>,</span><br><span class="line">border = <span class="string">&quot;rounded&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;winhl&quot;</span>, <span class="string">&quot;Normal:Normal,FloatBorder:FloatBorder&quot;</span>, &#123; win = win_id &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> current_line = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> ns_id = vim.api.nvim_create_namespace(<span class="string">&quot;highlight_current_line&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">highlight_and_move_cursor</span><span class="params">()</span></span></span><br><span class="line">vim.api.nvim_buf_clear_namespace(bufnr, ns_id, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> current_line &gt;= <span class="number">1</span> <span class="keyword">and</span> current_line &lt;= #items <span class="keyword">then</span></span><br><span class="line">vim.api.nvim_buf_add_highlight(bufnr, ns_id, <span class="string">&quot;Visual&quot;</span>, current_line - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">vim.api.nvim_win_set_cursor(win_id, &#123; current_line, <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">highlight_and_move_cursor()</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">handle_keys</span><span class="params">(key)</span></span></span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;k&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;&lt;Up&gt;&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> current_line &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">current_line = current_line - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> key == <span class="string">&quot;j&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;&lt;Down&gt;&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> current_line &lt; #items <span class="keyword">then</span></span><br><span class="line">current_line = current_line + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> key == <span class="string">&quot;CR&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> plugin_name = items[current_line].name</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;reload plugin:&quot;</span>, plugin_name)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy.core.loader&quot;</span>).reload(plugin_name)</span><br><span class="line"><span class="comment">-- 关闭窗口</span></span><br><span class="line">vim.api.nvim_win_close(win_id, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">highlight_and_move_cursor()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;CursorMoved&quot;</span> &#125;, &#123;</span><br><span class="line">buffer = bufnr,</span><br><span class="line">desc = <span class="string">&quot;highlight the line which cursor is on&quot;</span>,</span><br><span class="line">callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> cur_line = vim.api.nvim_win_get_cursor(win_id)[<span class="number">1</span>]</span><br><span class="line">vim.api.nvim_buf_add_highlight(bufnr, ns_id, <span class="string">&quot;Visual&quot;</span>, cur_line - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">current_line = cur_line</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 辅助函数用于设置按键映射</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">set_keymap</span><span class="params">(key, action)</span></span></span><br><span class="line">vim.keymap.set(<span class="string">&quot;n&quot;</span>, key, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">handle_keys(action)</span><br><span class="line"><span class="keyword">end</span>, &#123;</span><br><span class="line">buffer = bufnr,</span><br><span class="line">noremap = <span class="literal">true</span>,</span><br><span class="line">silent = <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 设置按键映射</span></span><br><span class="line">set_keymap(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;k&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;j&quot;</span>, <span class="string">&quot;j&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;Up&gt;&quot;</span>, <span class="string">&quot;Up&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;Down&gt;&quot;</span>, <span class="string">&quot;Down&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;CR&gt;&quot;</span>, <span class="string">&quot;CR&quot;</span>)</span><br><span class="line"><span class="comment">-- 允许用户通过 q 键关闭窗口，仅限于当前缓冲区</span></span><br><span class="line">vim.keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;&lt;Cmd&gt;close&lt;CR&gt;&quot;</span>, &#123; buffer = bufnr, noremap = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用neovim和LazyVim配置写代码,感觉很不错. 得益于neovim简单的功能和强大的第三方生态,可以很简单的写出一个插件. 这里根据官方文档搭配lazyvim等资料写一个简单插件.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>协同感知算法(四):大模型、多模态以及新趋势</title>
    <link href="https://www.sekyoro.top/2025/01/10/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E5%9B%9B-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%A5%E5%8F%8A%E6%96%B0%E8%B6%8B%E5%8A%BF/"/>
    <id>https://www.sekyoro.top/2025/01/10/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E5%9B%9B-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%A5%E5%8F%8A%E6%96%B0%E8%B6%8B%E5%8A%BF/</id>
    <published>2025-01-10T15:08:12.000Z</published>
    <updated>2025-06-06T07:29:34.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这半年要论AI哪些方向最火,那关键词必然包括多模态,AI Agent,RAG等等(事实上已经火了一轮开始冷饭热炒了),一些做之前基础大模型的公司基本开始转向做应用甚至其他方向了. 这里整理一些关于AI Agents的知识和相关基础框架,并结合多智能体协同感知看看有哪些能做的结合.<br><span id="more"></span></p><h2 id="视觉语言模型"><a href="#视觉语言模型" class="headerlink" title="视觉语言模型"></a>视觉语言模型</h2><p>引用lilianweng的博客,视觉语言模型可以粗略分为四类:<br>1.将图像转换为可以与标记嵌入联合训练的嵌入特征(将图像转为可以与语言编码的特征一起训练的特征)<br>2.学习作为冻结、预训练语言模型前缀的良好图像嵌入(训练图像特征作为冻结的预训练语言模型的输入前缀)<br>3.使用专门设计的交叉注意力机制将视觉信息融合到语言模型的层中(使用交叉注意力融合视觉信息到大模型中)<br>4.无需训练即可结合视觉和语言模型</p><h3 id="同时训练图像和文本"><a href="#同时训练图像和文本" class="headerlink" title="同时训练图像和文本"></a>同时训练图像和文本</h3><p>VisualBERT将文本输入和图像区域同时输入 BERT，使其能够<strong>通过自注意力机制发现图像和文本之间的内部对齐</strong>。<br>在训练时同时输入图像和文本,mask相关文本并加上图像的相关信息,任务是预测遮挡的信息同时提供两个标题区分哪个与图像相关.<br><img data-src="https://s2.loli.net/2025/01/11/rF7sJIdcoWnBZhv.png" alt="image-20250111165850291"><br>与 BERT 中的文本嵌入类似，VisualBERT 中的每个视觉嵌入也总结了三种类型的嵌入，即<strong>分词特征</strong>、<strong>分割嵌入</strong>和<strong>位置嵌入</strong>，具体来说：</p><ol><li><p>一种通过卷积神经网络计算出的图像边界区域的视觉特征向量</p></li><li><p>一个表示嵌入是否用于视觉而非文本的段嵌入</p></li><li><p>一种用于对齐边界区域顺序的位置嵌入</p></li></ol><p>SimVLM是一种简单的前缀语言模型，其中前缀序列的处理方式类似于 BERT 的双向注意力，但主要的文本输入序列只有因果注意力类似于 GPT。图像被编码为前缀标记，以便模型可以完全消耗视觉信息，然后以自回归方式生成相关文本。<br>SimVLM 将图像分割成更小的块，形成一个平铺的 1D 块序列。他们使用由 ResNet 的前 3 个块组成的卷积阶段来提取上下文化的块，这种设置被发现比简单的线性投影效果更好。<br>  这种方法的学习目标更像是通过视觉信息前缀,通过transformer结构进行自回归学习,这也是它与前者较大的差距.  因此通过图像编码器编码图像特征然后通过掩码语言建模(Masked Language Modeling)(类似完形填空)或自回归学习训练原本的大语言模型使其拥有视觉能力.</p><h3 id="学习图像嵌入"><a href="#学习图像嵌入" class="headerlink" title="学习图像嵌入"></a>学习图像嵌入</h3><p>如果不想在适应处理视觉信号时更改语言模型参数,那么可以学习一个与语言模型兼容的图像嵌入空间。<br>受前缀或提示调整的启发，Frozen和 ClipCap<strong>仅在训练期间更新视觉模块的参数</strong>，以生成可以与预训练的冻结语言模型一起工作的图像嵌入。两者都使用对齐的图像标题数据集进行训练，以根据图像和先前的文本标记生成下一个文本标记。通过冻结 LM 参数，保留了强大的语言能力。此外，尽管这种设置是在有限的图像标题数据上训练的，但它们在测试时也可以依赖语言模型的知识库。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/Frozen-arch.png" alt="img"></p><p>从框架图看来就是只是用了一个视觉编码器将得到的embedding与预训练固定参数的text encoder和大模型同时训练更新视觉编码器<br>ClipCap 依靠 CLIP 进行视觉编码，但它需要由光映射网络处理，以便将图像嵌入向量转换为与预训练 LM 相同的语义空间。该网络将 CLIP 嵌入向量映射到一系列嵌入向量中，每个向量与 GPT2 中的单词嵌入具有相同的维度。增加前缀大小有助于提高性能。CLIP 视觉编码器和 LM 在训练期间都会被冻结，并且只学习映射网络。<br>ClipCap学习的是一个映射网络,它同时利用了预训练的CLIP和大模型<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/ClipCap-arch.png" alt="img"></p><h3 id="交叉注意力混合视觉和文本信息"><a href="#交叉注意力混合视觉和文本信息" class="headerlink" title="交叉注意力混合视觉和文本信息"></a>交叉注意力混合视觉和文本信息</h3><p><strong>VisualGPT</strong>采用self-resurrecting的编码器-解码器注意力机制,用少量的域内图像文本数据快速适应预训练的LM<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/VisualGPT.png" alt="img" style="zoom:67%;" /><br>设I为视觉编码器的输入,H为LM解码器的隐藏状态. 引入激活单元通过两个互补门来控制预训练语言信息和视觉组件之间混合.</p><script type="math/tex; mode=display">\begin{array}{c}B^{\text {vs }} \otimes \operatorname{EncDecattn}(H, I)+B^{\text {in }} \otimes H \\\text { where } B^{\text {vs }}[i, j]=\sigma(H[i, j])[\sigma(H[i, j])>\tau] \\B^{\text {ban }}[i, j]=(1-\sigma(H[i, j])] \neq[1-\sigma(H[i, j])>\tau]\end{array}</script><p>每层decoder通过门控制单元混合不同的输入.<br><strong>VC-GPT</strong> 将预训练的视觉转换器(CLIP-ViT)作为视觉编码器和预训练的 LM 作为语言解码器相结合。CLIP-ViT 将一系列图像块作为输入和输出，并输出每个块的表示。为避免灾难性的遗忘，<strong>VC-GPT 不是将视觉信息直接注入 GPT2，而是在视觉编码器和语言解码器的输出之上引入了额外的交叉注意力层</strong>。然后， <em>一个自集成</em> 模块线性组合单模型语言解码器 logits h^G^和跨模型视觉语言融合模块 logitsh^fuse^ 自集成模块对于性能很重要<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/VC-GPT.png" alt="img"><br>MERLOT接受了 600 万个 YouTube 视频的训练，并转录了语音 （YT-Temporal-180M），以学习空间（帧级）和时间（视频级）目标，并在微调时在 VQA 和视觉推理任务上表现出强大的表现。每个视频被拆分为多个片段,每个片段从中间的图像帧和关联的单词。图像由学习的图像编码器编码，单词使用学习的嵌入进行编码。然后，两者在一个联合的vision-language transformer中一起编码。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/MERLOT.png" alt="img"></p><ol><li>遮罩语言建模(MLM)，因为在视频中有许多重复的关键字或填充词。</li><li>对比帧-标题匹配使用联合视觉-语言转换器中的纯语言部分。每个帧 I~t~和 caption w~t~ 的匹配表示形式被视为正面示例，而负面示例来自小批量中的所有其他帧-标题对。</li><li>时间重新排序学习时间推理:打乱随机i帧,并将段级位置嵌入替换为随机且唯一的位置嵌入。随机位置嵌入被学习,允许模型以正确排序的帧为条件取消这些 “’shuffled’” 帧。</li></ol><p>Flamingo （ Alayrac et al. 2022） 是一种视觉语言模型，它接受与图像/视频交错的文本并输出自由格式的文本。Flamingo 通过基于 transformer 的映射器连接预训练的 LM 和预训练的视觉编码器（即 CLIP 图像编码器）。为了更有效地整合视觉信号，Flamingo 采用基于 Perceiver 的架构，从大量视觉输入特征中生成数百个标记，然后使用与 LM 层交错的交叉注意力层将视觉信息融合到语言解码过程中。训练目标是自回归的 NLL 损失。Perceiver 重采样器从图像/视频输入的视觉编码器接收时空特征，以生成固定大小的视觉标记。冻结的 LM 配备了新初始化的交叉注意力层，这些层在预训练的 LM 层之间交错。因此LM 可以生成以上述视觉标记为条件的文本。</p><p>与 ClipCap 类似，两个预训练模型在训练期间都会被冻结，因此 Flamingo 仅经过训练才能将现有的强大语言和视觉模型和谐地连接在一起。ClipCap 和 Flamingo 的主要区别在于，前者将图像嵌入视为 LM 的简单前缀，而后者使用门控交叉注意力密集层来融合图像信息。此外，Flamingo 包含的训练数据比 ClipCap 多得多。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/Flamingo.png" alt="img"><br>为了轻松处理带有交错图像的文本，Flamingo 中的遮罩设计为文本标记仅交叉关注与最后一个前图像对应的视觉标记，从而大大减少了某个文本标记可以看到的视觉标记的数量。他们发现这比允许文本标记直接处理所有前面的图像效果更好。文本仍然可以处理所有以前的图像，因为文本编码器中存在因果自我注意依赖关系。此设计可以处理上下文中任意数量的图像。从互联网上抓取了 4300 万个网页，名为 MultiModal MassiveWeb （M3W) 数据集，其中包含带有交错图像的文本。此外，Flamingo 还在配对的图像/文本和视频/文本数据集上进行了训练，包括 ALIGN、LTIP 和 VTP。</p><p>CoCa捕捉到了对比学习和图像到标题生成的优点。它是一个联合训练的模型，在 CLIP 风格的表示上具有对比损失，在图像描述上具有生成损失，在各种多模态评估任务上实现了 SoTA 零样本转移。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/CoCa-arch.png" alt="img" style="zoom: 67%;" /><br>CoCa 是从头开始预训练的,使用 Web 规模的替代文本数据 ALIGN 和注释图像，将所有标签视为 JTB-3B 中的文本<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/CoCa.png" alt="img"></p><h3 id="无训练方法"><a href="#无训练方法" class="headerlink" title="无训练方法"></a>无训练方法</h3><p>可以通过将预训练的语言和视觉模型拼接在一起来解决视觉语言任务,而无需训练任何其他参数。</p><p>MAGiC 根据名为 magic score 的基于 CLIP 的分数进行引导解码，以对下一个标记进行采样，而无需微调。鼓励生成的文本与给定图像相关，同时仍与先前生成的文本保持一致.与其他无监督方法相比，MAGiC 具有不错的性能，但与有监督方法仍然存在很大差距. MAGiC核心就是更改了采样方式,第t步采样的token会通过基于CLIP的分数计算与图像编码相似的值.</p><p><img data-src="https://s2.loli.net/2025/01/12/Knk9qHblQgwALuv.png" alt="image-20250112122938693"></p><p>​    对于基于知识的 VQA 任务，PICa首先将图像转换为标题或标签，然后使用少数镜头示例提示 GPT3 提供答案。图像标题或标记由某些现有模型（例如 VinVL）或 Azure 标记 API 提取。GPT3 被认为是一个非结构化的隐式知识库. </p><p>​    苏格拉底模型是一个框架,通过语言(提示)将不同模态的多个预训练模型组合成一个模型，而无需进一步训练。在这里，语言被认为是不同模型可以交换信息的中间表示。关键思想是使用多模型多模态提示，其中非语言模型的输出入到语言提示中，然后用于 LM 进行推理. SM 可以生成图像字幕，首先使用 VLM 对不同的地点类别、对象类别、图像类型和人数进行零拍摄预测;然后将 VLM 填充的语言提示输入到因果 LM 中以生成候选字幕。Socratic 方法在图像字幕方面与 ClipCap 的性能仍然存在差距，但考虑到它不涉及任何培训，因此相当不错。 简单来说就是将不同模态模型,比如vision-language model,language model,audio-language model结合在一起,通过一种相对固定的prompt template通信,SM 可以生成图像字幕，首先使用 VLM 对不同的地点类别、对象类别、图像类型和人数进行零拍摄预测;然后将 VLM 填充的语言提示输入到因果 LM 中以生成候选字幕</p><p><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/SM-caption-example.png" alt="img"></p><h2 id="大模型驱动的Agents"><a href="#大模型驱动的Agents" class="headerlink" title="大模型驱动的Agents"></a>大模型驱动的Agents</h2><p>​    多个大模型之间协作增强输出并设计一些类似模仿一个系统中负责不同功能的组件组成Agent. 目前许多大模型公司在做应用时都是往这个方向发展.在 LLM 驱动的自主代理系统中，LLM 充当代理的大脑，并辅以几个关键组件：</p><p>​    <strong>规划</strong>:子目标和分解：智能体将大型任务分解为较小的、可管理的子目标，从而能够高效处理复杂任务。反思和完善：智能体可以对过去的行为进行自我批评和自我反省，从错误中吸取教训并为未来的步骤进行改进，从而提高最终结果的质量。(任务分解和完善行为)</p><p>​     <strong>记忆</strong>: 短期记忆：所有的上下文学习（参见提示工程）都是利用模型的短期记忆来学习的。长期记忆：这为代理提供了在较长时间内保留和调用（无限）信息的能力，通常是通过利用外部向量存储和快速检索。</p><p>   <strong>工具使用</strong>:智能体学习调用外部 API 以获取模型权重中缺少的额外信息（通常在预训练后很难更改），包括当前信息、代码执行能力、对专有信息源的访问等</p><p><img data-src="https://lilianweng.github.io/posts/2023-06-23-agent/agent-overview.png" alt="img"></p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><h4 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h4><p>Chain of Thoughts已成为提高模型在复杂任务上性能的标准提示技术。该模型被指示 “逐步思考”，以利用更多的测试时计算将困难的任务分解为更小、更简单的步骤。CoT 将大任务转化为多个可管理的任务，并阐明对模型思维过程的解释<br>Tree of Thoughts通过在每一步探索多种推理可能性来扩展 CoT。它首先<strong>将问题分解为多个思考步骤，每个步骤生成多个思考，从而创建一个树状结构。</strong>搜索过程可以是 BFS（广度优先搜索）或 DFS（深度优先搜索），每个状态都由分类器（通过提示）或多数投票进行评估。<br>任务分解可以通过以下方式完成：（1） 由 LLM 使用简单的提示，如 <code>&quot;Steps for XYZ.\n1.&quot;</code> ， <code>&quot;What are the subgoals for achieving XYZ?&quot;</code> ， （2） 通过使用特定于任务的指令;例如 <code>&quot;Write a story outline.&quot;</code> 用于写小说，或 （3）人工输入<br>另一种非常不同的方法 LLM+P （ Liu et al. 2023） 涉及依靠外部经典规划师进行长期规划。这种方法利用规划域定义语言 （PDDL） 作为中间接口来描述规划问题。在这个过程中， LLM （1） 将问题翻译成 “问题 PDDL”，然后 （2） 请求经典规划师基于现有的 “领域 PDDL” 生成 PDDL 计划，最后 （3） 将 PDDL 计划翻译回自然语言。从本质上讲，规划步骤外包给外部工具，假设特定领域的 PDDL 和合适的规划器可用，这在某些机器人设置中很常见，但在许多其他领域中并不常见</p><h4 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h4><p>自我反省允许自主智能体通过改进过去的行动决策和纠正以前的错误来迭代改进。它在不可避免地需要试错的实际任务中起着至关重要的作用。<br>    ReAct通过将动作空间扩展为特定于任务的离散动作和语言空间的组合，将推理和行动整合到 LLM 中。前者使 LLM 能够与环境交互（例如使用维基百科搜索 API），而后者则提示 LLM 以自然语言生成推理轨迹。<br>    Reflexion 是一个框架，用于为智能体提供动态记忆和自我反思能力，以提高推理技能。Reflexion具有标准的 RL 设置，其中奖励模型提供简单的二进制奖励，操作空间遵循ReAct中的设置，其中特定于任务的操作空间通过语言进行扩充，以支持复杂的推理步骤。在每个操作a~t~之后，智能体会计算启发式 h~t~,并且可以根据自我反思结果选择性地决定重置环境以开始新的试用。<br><img data-src="https://lilianweng.github.io/posts/2023-06-23-agent/reflexion.png" alt="img"><br>    启发式函数确定轨迹何时效率低下或包含幻觉，何时应停止。低效的规划是指花费太长时间而没有成功的轨迹。幻觉被定义为遇到一系列连续的相同动作，这些动作导致在环境中进行相同的观察。<br>    自我反思是通过向 LLM 展示两张照片的例子来创建的，每个例子都是一对（失败的轨迹，指导计划中未来变化的理想反思）。然后将反射添加到 agent 的工作内存中，最多三个，用作查询 LLM 的上下文。<br><strong>Chain of Hindsight</strong>鼓励模型通过明确呈现一系列过去的输出来改进自己的输出，每个输出都带有反馈注释.CoH 的理念是在上下文中呈现连续改进的产出的历史，并训练模型顺应趋势以产生更好的产出。算法蒸馏将相同的想法应用于强化学习任务中的跨集轨迹，其中算法被封装在一个长期受历史条件限制的策略中。考虑到代理与环境交互多次，并且每次代理都会变得更好，AD 会将此学习历史记录连接起来，并将其馈送到模型中。</p><h3 id="记忆模块"><a href="#记忆模块" class="headerlink" title="记忆模块"></a>记忆模块</h3><p>三种类型的记忆</p><ol><li>感官记忆：这是记忆的最早阶段，提供在原始刺激结束后保留感官信息（视觉、听觉等）印象的能力。感官记忆通常最多只持续几秒钟。子类别包括图标记忆（视觉）、回声记忆（听觉）和触觉记忆（触觉</li><li>短期记忆 （STM） 或工作记忆：它存储我们目前知道的和执行复杂认知任务（如学习和推理）所需的信息。短期记忆被认为具有大约 7 项的容量 （Miller 1956） 并持续 20-30 秒。</li><li>长期记忆 （LTM）：长期记忆可以存储信息非常长的时间，从几天到几十年不等，具有基本上无限的存储容量。LTM 有两种亚型：<br> 显性 / 陈述性记忆：这是对事实和事件的记忆，指的是那些可以被有意识地回忆起来的记忆，包括情景记忆（事件和经历）和语义记忆（事实和概念）<br> 内隐/程序记忆：这种类型的记忆是无意识的，涉及自动执行的技能和例程，例如骑自行车或在键盘上打字。<br> 感官记忆作为原始输入（包括文本、图像或其他模态）的学习嵌入表示;<br> 短期记忆作为上下文学习。它简短而有限，因为它受 Transformer 的有限上下文窗口长度的限制。<br> 长期内存作为代理在查询时可以处理的外部向量存储，可通过快速检索访问。<h4 id="最大内积搜索"><a href="#最大内积搜索" class="headerlink" title="最大内积搜索"></a>最大内积搜索</h4>​    外部存储器可以缓解有限注意力持续时间的限制。标准做法是将信息的嵌入表示保存到可以支持快速最大内积搜索 （MIPS） 的向量存储数据库中。为了优化检索速度，常见的选择是近似最近邻 （ANN） 算法，以返回大约 k 个前 k 个最近邻，以牺牲一点准确性损失来换取巨大的加速<br>​    LSH（Locality-Sensitive Hashing）：它引入了一个哈希函数，<strong>以便将相似的输入项以高概率映射到相同的存储桶</strong>，其中存储桶的数量远小于输入的数量<br>​    ANNOY （Approximate Nearest Neighbors Oh Yeah）：核心数据结构是随机投影树，这是一组二叉树，其中每个非叶节点代表一个将输入空间分成两半的超平面，每个叶子存储一个数据点。树是独立且随机构建的，因此在某种程度上，它模仿了哈希函数。ANNOY 搜索发生在所有树中，以迭代搜索最接近查询的一半，然后聚合结果。这个想法与 KD 树非常相关，但更具可扩展性。<br>​    HNSW（分层可导航小世界）：它的灵感来自小世界网络的思想，其中大多数节点可以在少量步骤内被任何其他节点到达;例如社交网络的“六度分离”功能。HNSW 构建了这些小世界图的分层，其中底层包含实际数据点。中间的图层创建快捷方式以加快搜索速度。在执行搜索时，HNSW 从顶层的随机节点开始，并导航到目标。当它无法更靠近时，它会向下移动到下一层，直到到达底层。上层的每次移动都可能覆盖数据空间中的很长一段距离，而下层的每一次移动都会提高搜索质量。<br><strong>FAISS</strong>（meta相似性搜索）：它的运行基于以下假设：在高维空间中，节点之间的距离遵循高斯分布，因此应该存在数据点的聚类。<strong>FAISS 通过将向量空间划分为多个聚类，然后在聚类内优化量化来应用向量量化。Search 首先查找具有粗略量化的候选集群，然后进一步查找具有更精细量化的每个集群。</strong></li></ol><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>工具的使用是人类的一个显著特征。我们创造、修改和利用外部物体来做超出我们身体和认知极限的事情。为 LLMs 配备外部工具可以显着扩展模型功能。<br>HuggingGPT 是一个以 ChatGPT 作为任务规划器的框架，根据模型描述选择 HuggingFace 平台中可用的模型，并根据执行结果总结响应. 系统调用包括任务规划,模型选择,任务执行,生成响应.<br>API-Bank 是评估工具增强 LLMs 性能的基准。它包含 53 个常用的 API 工具、一个完整的工具增强 LLM 工作流程，以及 264 个带注释的对话，涉及 568 个 API 调用。API 的选择非常多样化，包括搜索引擎、计算器、日历查询、智能家居控制、日程管理、健康数据管理、帐户身份验证工作流程等。因为 API 数量众多，所以 LLM 首先要有 API 搜索引擎，找到合适的 API 进行调用，然后用相应的文档进行调用。</p><h2 id="协同感知中的LLM"><a href="#协同感知中的LLM" class="headerlink" title="协同感知中的LLM"></a>协同感知中的LLM</h2><p>最近有一系列的工作使用LLM与协同感知、自动驾驶结合(也有使用VLM的,方法类似).这里简单介绍一些相关工作.</p><h3 id="V2V-LLM-Vehicle-to-Vehicle-Cooperative-Autonomous-Driving-with-Multi-Modal-Large-Language-Models"><a href="#V2V-LLM-Vehicle-to-Vehicle-Cooperative-Autonomous-Driving-with-Multi-Modal-Large-Language-Models" class="headerlink" title="V2V-LLM: Vehicle-to-Vehicle Cooperative Autonomous Driving with  Multi-Modal Large Language Models"></a>V2V-LLM: Vehicle-to-Vehicle Cooperative Autonomous Driving with  Multi-Modal Large Language Models</h3><p>当前的自动驾驶车辆主要依靠其单独的传感器来了解周围的场景并规划未来的轨迹，当传感器发生故障或被遮挡时可能是不可靠的。为了解决这个问题，通过车辆到车辆( Vehicle-to-Vehicle，V2V )通信的协作感知方法已经被提出，但<strong>它们往往侧重于检测和跟踪。这些方法如何有助于整体的协作规划性能仍未得到充分的研究</strong>。</p><p>受最近使用大语言模型( Large Language Models，LLMs )构建自动驾驶系统的进展的启发,提出了一种新的问题设置,将LLM集成到协作自动驾驶中，并提出了车对车问答( Vehicle-to- Vehicle Question-Answering，V2V-QA )数据集和基准测试集.</p><p>还提出了基线方法Vehicle-to-Vehicle Large Language Model ( V2V-LLM )，它使用一个LLM来融合来自多个连接的自动驾驶车辆( CAV )的感知信息，并回答与驾驶相关的问题：grounding,notable objected identification, and planning.</p><p>实验结果表明,提出的V2VLLM可以作为一个有前途的统一模型架构来执行协作自动驾驶中的各种任务，并且优于使用不同融合方法的其他基线方法。工作也开创了一个新的研究方向，可以提高未来自动驾驶系统的安全性。</p><p>无人驾驶车辆在日常运行中的感知和规划系统严格依赖于其本地的LiDAR传感器和相机来探测附近的显著目标并进行规划.<strong>当传感器被附近的大型物体遮挡时，这种方法可能会遇到安全问题</strong>。在这种情况下，自动驾驶车辆无法准确地检测到所有附近的显著目标，使得后续的轨迹规划结果不可靠。</p><p><img data-src="https://s2.loli.net/2025/03/01/b3Rwruo2Nqjl9Qc.png" alt="image-20250301190916782"></p><p>为了解决这个安全问题，最近的研究提出了通过车车通信( V2V )通信的协作感知算法。在协同驾驶场景中，多个邻近行驶的智能网联汽车( Connected Autonomous Vehicles，CAVs )通过V2V通信共享彼此的感知信息。然后将接收到的来自多个CAV的感知数据进行融合，以产生更好的整体检测结果。</p><p>所有CAV与LLM共享各自的感知信息。任何CAV都可以以自然语言的形式向LLM提问，以获取对驾驶安全有用的信息。</p><p>为了研究这个问题，首先创建了车辆到车辆问答( V2V-QA )数据集，该数据集基于V2V4Real的自动驾驶协作感知数据集。</p><p>车-车大语言模型( V2V-LLM )用于协同自动驾驶.每个CAV提取自己的感知特征，并与V2V-LLM共享。V2V-LLM融合场景级特征图和对象级特征向量，然后进行视觉和语言理解，为V2V-QA中输入的驾驶相关问题提供答案。</p><p>还将V2V - LLM与其他基线方法对应的不同特征融合方法：不融合、早期融合和中间融合进行了比较。结果表明，V2V - LLM在较重要的目标识别和规划任务中取得了最好的性能，在grounding任务中取得了次优的性能，</p><p><img data-src="https://s2.loli.net/2025/03/01/JaKvA2B4yOdxcSP.png" alt="image-20250301204106243"></p><p>对于V2V4Real数据集的每一帧，创建了5种不同类型的问答对，包括3种类型的背景问题，1种类型的显著对象识别问题和1种类型的规划问题。这些QAs是针对协同驾驶场景设计的。为了生成这些问答对的实例，使用V2V4Real 的ground-truth边界框注释、每个CAV的ground - truth轨迹和个体检测结果作为源信息。然后根据前述实体和文本模板之间的几何关系使用不同的手动设计的规则来生成的问答对</p><p>作者设计了几种不同类型的问答对作为数据集,这个数据集也是多模态数据集.</p><p><strong>Q1</strong> Grounding at a reference location</p><p>在这种类型的问题中，要求LLM来识别是否存在一个对象占据了特定的查询2D位置。如果是，则期望LLM提供物体的中心位置。否则，LLM应该表示在参考位置处没有任何信息。为了生成这类问答对的实例，我们使用背景-真值框的中心位置和每个CAV的单个检测结果框作为问题中的查询位置。这样，我们可以更专注于评估各个模型对潜在的假阳性和假阴性检测结果的协同接地能力。</p><p><strong>Q2</strong> Grounding behind a reference object at a location</p><p>当一个CAV的视场被一个邻近的大物体遮挡时，该CAV可能希望根据所有CAV的融合感知信息，请求中心化的LLM来判断遮挡大物体后面是否存在物体。如果是这样的话，LLM预计将返回对象的位置，询问CAV可能需要更多的防御性驾驶或调整其规划。否则，LLM应该表明参照对象背后没有任何东西。为了生成这类问答对的实例，使用每个检测结果框的中心位置作为这些问题中的查询位置。根据询问的CAV与参考物体的相对位姿画出一个扇形区域，并在该区域中选择距离最近的真实物体作为答案。</p><p><strong>Q3</strong> Grounding behind a reference object in a direction</p><p>进一步在语言和空间理解能力上对LLM提出了挑战，将Q2的参考2D位置替换为参考方向关键字。为了生成这类QA对的实例，首先在一个CAV的6个方向中各得到一个最接近的检测结果框作为参考对象。然后在Q2中遵循相同的数据生成方法，在相应的扇形区域中得到最接近的ground-truth box作为答案。</p><p><strong>Q4</strong> Notable object identification</p><p>前述的真值任务可以看作自动驾驶管道中的中间任务。自动驾驶车辆更关键的能力包括识别规划的未来轨迹附近的显著目标和调整未来规划以避免潜在的碰撞。在显著性物体识别问题中，从地面-真值轨迹中提取了6个未来3秒的路标点作为问题中的参考未来路标点。然后，在参考未来轨迹的10米范围内最多得到3个最近的地面真实物体作为答案。</p><p><strong>Q5</strong> 规划</p><p>与上述QA类型相比，规划是自动驾驶系统最重要的输出，因为自动驾驶汽车的最终目标是安全地通过复杂的环境，避免未来的任何潜在碰撞。为了生成规划QAs，我们从每个CAV的真实未来轨迹中提取6个均匀分布在未来3秒内的未来航路点作为答案。由于一些原因，V2V - QA的规划任务也比其他基于NuScenes的LLM驱动的相关工作更具有挑战性。首先，我们在协同驾驶场景中支持多辆CAV。LLM模型需要提供不同的答案，这取决于哪个CAV要求其建议的未来轨迹，而先前的工作只需要生成单个自动驾驶车辆的规划结果。其次，V2V-QA是基于V2V4Real的，它包括城市和高速公路两种驾驶场景。在这两种不同的环境中，车辆的运动模式有很大的不同。相反，基于Nu Scenes的LLM驾驶研究只需要考虑城市驾驶场景。</p><p><img data-src="https://s2.loli.net/2025/03/01/6Rit5JYmheqW82P.png" alt="image-20250301212424018"></p><h3 id="AGENTSCODRIVER-Large-Language-Model-Empowered-Collaborative-Driving-with-Lifelong-Learning"><a href="#AGENTSCODRIVER-Large-Language-Model-Empowered-Collaborative-Driving-with-Lifelong-Learning" class="headerlink" title="AGENTSCODRIVER: Large Language Model  Empowered Collaborative Driving with Lifelong  Learning"></a>AGENTSCODRIVER: Large Language Model  Empowered Collaborative Driving with Lifelong  Learning</h3><p>智能网联汽车和无人驾驶近来发展迅速。然而，目前的自动驾驶系统主要基于数据驱动的方法，<strong>在可解释性、泛化性和持续学习能力方面表现出明显的不足。此外，单车自动驾驶系统缺乏与其他车辆协作和协商的能力，这对驾驶安全和效率至关重要</strong>。为了有效地解决这些问题，利用大型语言模型( LLMs )开发了一个新的框架，称为AGENTSCODRIVER，以使多车辆能够进行协同驾驶。</p><p>AGENTSCODRIVER由5个模块组成：<strong>观察模块、推理引擎、认知记忆模块、强化反射模块和通信模块</strong>。它可以通过与驾驶环境的不断交互，随时间推移积累知识、教训和经验，从而使实现终身学习成为可能。此外，通过利用通信模块，不同智能体可以交换信息，实现复杂驾驶环境下的协商与协作。进行了大量的实验，并显示了AGENTSCODRIVER相对于现有方法的优越性。</p><p><img data-src="https://s2.loli.net/2025/03/01/U5HNZpuxPMXJIzd.png" alt="image-20250301212736505"></p><p>AGENTSCODRIVER的体系结构由5个模块组成：观测模块、推理引擎、存储模块、增强反射模块和通信模块。推理引擎、通信模块和增强反射模块利用LLMs生成消息和最终决策</p><p><strong>Observation Module</strong></p><p>为了使智能体能够进行协作，CAV感知其周围环境并提取必要的信息用于下游的高阶任务推理是很重要的，因此为智能体开发了一个观测模块来编码其周围的场景，并提取其有用的高层信息，如车道数和周围车辆的位置和速度。然后将这些观察结果输入到智能体的推理引擎中进行分析并做出决策。它们也被用来从记忆模块中回忆相关的记忆</p><p><strong>Reasoning Engine</strong></p><p>推理是人类最基本、最重要的能力之一，对于人类做出日常的、复杂的决策具有重要的意义。传统的数据驱动方法直接利用感知信息(例如,目标检测结果和语义分割结果)进行最终的驾驶决策(例如,左转或右转,加速和减速)，缺乏可解释性，无法处理复杂场景和长尾情况。受人类推理能力的启发，我们提出了一个CAV智能体的推理引擎，它由三个步骤组成：1 )提示生成，2 )推理过程，3 )运动规划。</p><p><strong>Memory Module</strong></p><p>记忆对于一个人来说是非常重要的。当一个人驾驶汽车时，他或她会使用常识，例如遵守交通规则和回忆过去的经验来做出决定。为了将这种能力灌输给智能体，我们提出了智能体的记忆模块，该模块由三部分组成：常识记忆、经验记忆和结构化文本存储的反思记忆。常识性记忆包含了驾驶的常识性知识，如交通规则等。经验记忆包含过去的驾驶场景和相应的决策。反射记忆包含反射模块的反馈。智能体可以从存储模块中检索相关的内存，使其可用于决策。</p><p><strong>Reinforcement Reflection</strong></p><p>一个人要想成为某一领域的专家，就必须从过去的经历中学习，这意味着他必须有能力反思自己过去的错误，并分析其背后的原因。对于智能体来说，拥有这样的反思能力对于保持正确的操作和安全驾驶也是至关重要的。基于这些观察，提出了强化反射，它有两个模块：一个评估器和一个反射器。评价者(记为E )像评判者一样对agent的输出进行打分，反射者(记为R )可以对agent的行为进行反思，并生成分析结果来改进agent的行为。</p><p><img data-src="https://s2.loli.net/2025/03/01/K8GL6CWQgoEzJXl.png" alt="image-20250301214528445"></p><p><strong>Communication Module</strong></p><p>协作Agent之间的有效通信是至关重要的。通过相互之间的通信，将扩大智能体的观测范围。分别考虑两个智能体的观测值o1和o2，如果两个智能体相互交换观测信息，则两个智能体的观测值将扩展到o1∪o2。此外，沟通对于代理人之间相互协商并做出更好的决策也是至关重要的。例如，考虑一个智能体正在驾驶一辆汽车，并且想要超越前车。如果智能体与前车进行通信，则前车的智能体学习到后方车辆的意图，进而可以做出更好的决策，避免潜在的碰撞。</p><h3 id="Towards-Interactive-and-Learnable-Cooperative-Driving-Automation-a-Large-Language-Model-Driven-Decision-Making-Framework"><a href="#Towards-Interactive-and-Learnable-Cooperative-Driving-Automation-a-Large-Language-Model-Driven-Decision-Making-Framework" class="headerlink" title="Towards Interactive and Learnable Cooperative Driving Automation: a Large Language Model-Driven Decision-Making Framework"></a>Towards Interactive and Learnable Cooperative Driving Automation: a Large Language Model-Driven Decision-Making Framework</h3><p>目前，智能网联汽车( Connected Autonomous Vehicles，CAVs )已经开始在世界各地进行开放道路测试，但其在复杂场景下的安全和效率表现仍不尽如人意。协同驾驶利用CAV的连通能力实现大于其部分之和的协同作用，使其成为提高复杂场景下CAV性能的一种有前途的方法。然而，缺乏交互和持续学习能力限制了当前的协同驾驶到单场景应用和特定的协同驾驶自动化( Cooperative Driving Automation，CDA )。</p><p>为了应对这些挑战，本文提出了一种可交互和学习的LLM驱动的协同驾驶框架CoDrivingLLM，以实现全场景和全CDA。</p><p><img data-src="https://s2.loli.net/2025/03/01/1IqhDjUavQlOLou.png" alt="image-20250301215707384"></p><p>首先，由于大语言模型( Large Language Models，LLMs )不擅长处理数学计算，<strong>引入环境模块，基于语义决策更新车辆位置，从而避免直接LLM控制车辆位置可能带来的误差</strong>。其次，基于SAE J3216标准定义的CDA的四个层次，提出了基于思维链( Chain-of- Thought，COT )的推理模块，包括<strong>状态感知、意图共享、协商和决策</strong>，增强了LLMs在多步推理任务中的稳定性。</p><p>然后，在推理过程中，通过冲突协调者来管理集中的冲突解决。最后，通过引入记忆模块和使用提取增强生成，赋予CAVs从过去经验中学习的能力。</p><p><img data-src="https://s2.loli.net/2025/03/01/GZoEUBPHJ4lnSMR.png" alt="image-20250301215538196"></p><p><img data-src="https://s2.loli.net/2025/03/01/7N1apvPSXFcDfOo.png" alt="image-20250301221105318"></p><h3 id="Is-Intermediate-Fusion-All-You-Need-for-UAV-based-Collaborative-Perception"><a href="#Is-Intermediate-Fusion-All-You-Need-for-UAV-based-Collaborative-Perception" class="headerlink" title="Is Intermediate Fusion All You Need for UAV-based Collaborative  Perception?"></a>Is Intermediate Fusion All You Need for UAV-based Collaborative  Perception?</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>协同感知通过Agent间通信增强环境感知，被认为是智能交通系统的一个有前途的解决方案。然而，现有的无人机协同方法<strong>忽略了无人机视角的独特特性，导致了大量的通信开销</strong>。为了解决这个问题，我们提出了一种新的<strong>基于后中间层融合的通信高效的协作感知框架</strong>，称为LIF。</p><p>其核心思想是<strong>交换信息量大且紧凑的检测结果，并将融合阶段转移到特征表示层面</strong>。特别地，<strong>利用视觉引导的位置嵌入( VPE )</strong>和<strong>基于框的虚拟增强特征( Bo BEV )来有效地整合来自不同代理的互补信息</strong>。此外，我们创新性地引入了一种<strong>不确定性驱动的通信机制，使用不确定性评估来选择高质量和可靠的共享区域</strong>。</p><p><img data-src="https://s2.loli.net/2025/05/19/LUCgmobRie6r4YA.png" alt="image-20250519201823979"></p><h3 id="TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE-COOPERATIVEPERCEPTION"><a href="#TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE-COOPERATIVEPERCEPTION" class="headerlink" title="TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE COOPERATIVEPERCEPTION"></a>TASK-ORIENTEDCOMMUNICATIONFORVEHICLE-TO-INFRASTRUCTURE COOPERATIVEPERCEPTION</h3><p>车辆与基础设施的通信( V2I )协作感知在自动驾驶场景中起着至关重要的作用。尽管其具有提高感知精度和鲁棒性的潜力，但大量的原始传感器数据不可避免地导致了较高的通信开销。为了缓解这个问题，我们提出了一种面向任务的V2I协作感知通信框架TOCOM - V2I，它<strong>通过只传输与任务相关的信息而不是原始数据流来感知周围环境，从而减少带宽消耗</strong>。</p><p>我们的贡献有三。首先，我们提出了基于空间关系和感知先验的空间感知特征选择模块来过滤掉不相关的信息。其次，我们引入了分层熵模型来利用特征内的冗余，以实现高效的压缩和传输。最后，我们利用一个缩放的点积注意力架构来融合车辆端和基础设施端特征，以提高感知性能</p><p>空间感知特征选择模块旨在从基础设施侧特征FI中识别出对车辆来说既具有感知意义又是必要的特征F ~ I。在目标检测的背景下，FI中包含目标的区域比背景区域更具有任务相关性。在协作过程中，这些物体可以通过恢复车辆视野中被遮挡或丢失的物体来帮助提高感知质量。此外，距离车辆越近的物体越容易被车辆自身检测到。虽然从基础设施的角度来看，这些对象在感知上很重要，但没有必要传输这些特征。</p><p><img data-src="https://s2.loli.net/2025/05/19/CjKxWzUFnSImG6Q.png" alt="image-20250519202216047"></p><h2 id="时延问题"><a href="#时延问题" class="headerlink" title="时延问题"></a>时延问题</h2><p>引入时间信息的编码</p><p>V2VNet</p><p><img data-src="https://s2.loli.net/2025/05/26/WYh3nLOkHo4DcbA.png" alt="image-20250526111749407"></p><p><img data-src="https://s2.loli.net/2025/05/26/zsyQwZC9VNhJruf.png" alt="image-20250526114903582"></p><p>V2X-ViT</p><p><img data-src="https://s2.loli.net/2025/05/28/YD1qVd5jlihTAuF.png" alt="image-20250528213454183"></p><p>增加时间编码</p><h3 id="Latency-Aware-Collaborative-Perception"><a href="#Latency-Aware-Collaborative-Perception" class="headerlink" title="Latency-Aware Collaborative Perception"></a>Latency-Aware Collaborative Perception</h3><p><img data-src="https://s2.loli.net/2025/05/26/zBJ1wDiRO6rTdqA.png" alt="image-20250526225952639"></p><p><img data-src="https://s2.loli.net/2025/05/27/Q2tnd7KxNgJH4Cl.png" alt="image-20250527102534252"></p><p><img data-src="https://s2.loli.net/2025/05/27/KPhjznkL9WQs2cX.png" alt="image-20250527180538143"></p><p><img data-src="https://s2.loli.net/2025/05/27/d8WJcQ3hzrxtF6g.png" alt="image-20250527200936722"></p><h3 id="Co-MTP-A-Cooperative-Trajectory-Prediction-Framework-with-Multi-Temporal-Fusion-for-Autonomous-Driving"><a href="#Co-MTP-A-Cooperative-Trajectory-Prediction-Framework-with-Multi-Temporal-Fusion-for-Autonomous-Driving" class="headerlink" title="Co-MTP: A Cooperative Trajectory Prediction Framework  with Multi-Temporal Fusion for Autonomous Driving"></a>Co-MTP: A Cooperative Trajectory Prediction Framework  with Multi-Temporal Fusion for Autonomous Driving</h3><p>​    车联网技术( V2X )已成为扩展感知范围、看穿遮挡物的理想范式。现有的研究主要集中在单帧协作感知，然而，<strong>如何利用V2X捕获帧与帧之间的时间线索，以促进预测任务甚至规划任务的进行，仍然缺乏研究</strong>。在本文中，介绍了Co - MTP，一种面向自动驾驶的多时态融合的通用协同轨迹预测框架，它利用V2X系统充分捕获历史和未来域中智能体之间的相互作用，从而有利于规划。</p><p>​    在历史域中，V2X可以对单车感知中不完整的历史轨迹进行补充，我们设计了一个异构的图变换来学习来自多个智能体的历史特征的融合，并捕获历史交互。此外，预测的目的是支持未来的规划。</p><p>​    </p><h3 id="Asynchrony-Robust-Collaborative-Perception-via-Bird’s-Eye-View-Flow"><a href="#Asynchrony-Robust-Collaborative-Perception-via-Bird’s-Eye-View-Flow" class="headerlink" title="Asynchrony-Robust Collaborative Perception via Bird’s Eye View Flow"></a>Asynchrony-Robust Collaborative Perception via Bird’s Eye View Flow</h3><p>作为一个新兴的领域，协作感知的研究有许多挑战需要解决，例如高质量的数据集，模型不可知和任务不可知的表述以及对错误的鲁棒性和对抗性攻击。然而绝大多数现有工作并没有认真考虑智能体之间实际通信的严酷现实，如拥塞、计算量大、中断和缺乏校准等。这些因素引入了延迟或失调，严重影响了Agent之间信息交换的可靠性和质量。一些先前的工作已经涉及到了通信延迟的问题。例如，<strong>V2VNet和V2XViT 将延迟时间作为特征补偿的输入</strong>。然而，它们只考虑了单一帧，没有利用历史帧，对于高速场景( 20m / s以上)或高延迟场景( 0.3 s以上)是不充分的。同时，<strong>SyncNet使用历史特征来预测完整的特征</strong></p><p>V2VNet利用卷积神经网络，通过将时间信息和相对位姿作为输入，学习如何补偿通信延迟；<strong>V2X-ViT设计了一个时延感知的位置编码模块来学习时延带来的影响，但是这些方法没有考虑历史时序信息进行补偿</strong>。SyncNet利用历史多帧信息，通过Conv - LSTM对当前时刻进行补偿，但其对整个特征图的补偿导致特征通道存在噪声，基于RNN的框架无法处理时间上的不规则输入。</p><p><img data-src="https://s2.loli.net/2025/05/26/KyiUGwp4s8xnMYR.png" alt="image-20250526144303233"></p><h3 id="Flow-Based-Feature-Fusion-for-Vehicle-Infrastructure-Cooperative-3D-Object-Detection"><a href="#Flow-Based-Feature-Fusion-for-Vehicle-Infrastructure-Cooperative-3D-Object-Detection" class="headerlink" title="Flow-Based Feature Fusion for Vehicle-Infrastructure Cooperative 3D Object Detection"></a>Flow-Based Feature Fusion for Vehicle-Infrastructure Cooperative 3D Object Detection</h3><p>特征流生成。采用特征流作为预测函数来描述未来基础设施特征随时间的变化。给定当前点云帧Pi ( ti )和基础设施特征提取器Fi ( · )，定义ti之后未来时刻t的特征流为</p><script type="math/tex; mode=display">\widetilde{F}_{i}(t)\ =F_{i}(P_{i}(t))_{,}\,t\ge\,t_{i}</script><h3 id="Vehicle-Infrastructure-Cooperative-3D-Object-Detection-via-Feature-Flow-Prediction"><a href="#Vehicle-Infrastructure-Cooperative-3D-Object-Detection-via-Feature-Flow-Prediction" class="headerlink" title="Vehicle-Infrastructure Cooperative 3D Object Detection via Feature Flow Prediction"></a>Vehicle-Infrastructure Cooperative 3D Object Detection via Feature Flow Prediction</h3><p><img data-src="https://s2.loli.net/2025/05/26/zyYZQMXmxW2EvST.png" alt="image-20250526221403766"></p><h3 id="V2XPnP-Vehicle-to-Everything-Spatio-Temporal-Fusion-for-Multi-Agent-Perception-and-Prediction"><a href="#V2XPnP-Vehicle-to-Everything-Spatio-Temporal-Fusion-for-Multi-Agent-Perception-and-Prediction" class="headerlink" title="V2XPnP: Vehicle-to-Everything Spatio-Temporal Fusion for Multi-Agent Perception and Prediction"></a>V2XPnP: Vehicle-to-Everything Spatio-Temporal Fusion for Multi-Agent Perception and Prediction</h3><p>车联网( V2X )技术提供了一个有前途的范例，以减轻单车辆系统中受限可观测性的限制。先前的工作主要集中在单帧合作感知，它<strong>融合了不同空间位置的智能体信息，但忽略了时间线索和时间任务</strong>(例如,时间知觉和预测)。</p><p>本文针对V2X场景下的时空融合问题，设计了一步式和多步式通信策略(何时传输)，并考察了其与早、晚、中3种融合策略(传输什么?)的融合情况，提供了11种融合模型(如何融合)的综合基准。进一步地，我们提出了V2XPnP，一种新颖的用于端到端感知和预测的一步通信中间层融合框架。我们的框架采用了基于Transformer的统一架构，有效地建模了跨多个代理、帧和高清地图的复杂时空关系。</p><p>自动驾驶系统需要准确感知周围道路用户并预测其未来轨迹，以确保安全和交互式驾驶。尽管最近在感知和预测方面取得了进展，但单车系统仍然面临有限的感知范围和遮挡问题，影响了驾驶性能和道路安全。因此，车联网( V2X )技术已经成为一种很有前途的范式,它使连接和自动化的车辆( CAVs )和基础设施能够共享互补信息并缓解遮挡，从而支持整体环境理解</p><p>尽管有它们的潜力，现有的工作集中在逐帧协作检测，它聚合了来自不同空间位置的代理的信息。然而，这些工作<strong>忽略了连续帧之间的时间线索，这对于定位以前可见但目前未被发现的对象</strong>和预测对象未来的轨迹很重要</p><h3 id="CoDynTrust-Robust-Asynchronous-Collaborative-Perception-via-Dynamic-Feature-Trust-Modulus"><a href="#CoDynTrust-Robust-Asynchronous-Collaborative-Perception-via-Dynamic-Feature-Trust-Modulus" class="headerlink" title="CoDynTrust: Robust Asynchronous Collaborative Perception via  Dynamic Feature Trust Modulus"></a>CoDynTrust: Robust Asynchronous Collaborative Perception via  Dynamic Feature Trust Modulus</h3><p>协同感知通过融合多个智能体的信息，可以扩展感知范围，从而提高感知性能。<strong>然而，在现实环境中，由于通信延迟、时钟失调或采样配置差异引起的时间异步会导致信息不匹配。</strong></p><p><strong>如果处理不当，那么协同性能就会参差不齐，更严重的可能会发生安全事故。为了应对这一挑战，我们提出了CoDynTrust，一种不确定性编码的异步融合感知框架，对时间不同步导致的信息不匹配具有鲁棒性。</strong></p><p>CoDynTrust通过对即兴和认知不确定性建模，选择性地抑制或保留单车辆特征，为每个感兴趣区域生成动态特征信任模( DFTM )，从而缓解信息不匹配问题。然后，我们设计了一个多尺度融合模块来处理DFTM处理后的多尺度特征图。</p><p>然后，我们设计了一个多尺度融合模块来处理DFTM处理后的多尺度特征图。与现有的考虑异步协同感知的工作相比，CoDynTrust在时间异步场景中对抗各种低质量信息，并允许不确定性传播到下游任务，如规划和控制。</p><h3 id="Leveraging-Temporal-Contexts-to-Enhance-Vehicle-Infrastructure-Cooperative-Perception"><a href="#Leveraging-Temporal-Contexts-to-Enhance-Vehicle-Infrastructure-Cooperative-Perception" class="headerlink" title="Leveraging Temporal Contexts to Enhance Vehicle-Infrastructure  Cooperative Perception"></a>Leveraging Temporal Contexts to Enhance Vehicle-Infrastructure  Cooperative Perception</h3><p>安装在高架位置的基础设施传感器提供了更广泛的感知范围，并遇到更少的遮挡。通过V2X通信整合基础设施和自车数据，称为车-基础设施合作，在增强感知能力和解决单车自动驾驶中遇到的转角情况方面显示出相当大的优势。</p><p>​    然而,协作感知仍然面临着许多挑战，包括有限的通信带宽和实际通信中断。在本文中，提出了一种新的协同3D目标检测框架CTCE。该框架<strong>以时间上下文增强的方式传输查询，有效地平衡了传输效率和性能</strong>，以适应现实世界的通信条件。此外，我们还提出了一个时间引导的融合模块来进一步提高性能。</p><p>路侧时间增强和车侧时空融合共同构成了多层次的时间上下文融合机制，充分利用时间信息提升性能。</p><p><img data-src="https://s2.loli.net/2025/05/19/eptucRAXdNPwk7D.png" alt="image-20250519202400933"></p><h3 id="Multi-Agent-Collaborative-Perception-via-Motion-Aware-Robust-Communication-Network"><a href="#Multi-Agent-Collaborative-Perception-via-Motion-Aware-Robust-Communication-Network" class="headerlink" title="Multi-Agent Collaborative Perception via Motion-Aware Robust Communication Network"></a>Multi-Agent Collaborative Perception via Motion-Aware Robust Communication Network</h3><p><img data-src="https://s2.loli.net/2025/05/28/JtHQVc1n2v86UXC.png" alt="image-20250528105139615"></p><p><img data-src="https://s2.loli.net/2025/05/28/3UwDiBq8ZRs94Pp.png" alt="image-20250528111736833"></p><p><img data-src="https://s2.loli.net/2025/05/28/UHwDobJxyz32LhW.png" alt="image-20250528111849168"></p><p><img data-src="https://s2.loli.net/2025/05/28/q6HJklWt9fOSIZc.png" alt="image-20250528111903710"></p><p>将feature flow和lstm更新特征的想法结合</p><p>motivation: 多智能体的特征融合是提升协作感知性能的一个关键,过去的一些工作忽略的传输延迟导致时间上的特征不对齐，我们利用历史帧数据,考虑motion状态不断更新. 一个空间上不同位置的注意力和改造后的lstm,结合时序预测. flow generator,in-frame decoding</p><p><strong>STAM</strong> (Spatio-Temporal Aggregation Module)</p><p>transformer+lstm+feature flow+时序预测+帧内位置编码</p><p>每一帧保存一个q,k,v(融合后的)</p><p>相关工作 v2vnet v2x-vit lantancy-aware bevflow </p><h2 id="利用query与晚期检测结果、置信度降低带宽"><a href="#利用query与晚期检测结果、置信度降低带宽" class="headerlink" title="利用query与晚期检测结果、置信度降低带宽"></a>利用query与晚期检测结果、置信度降低带宽</h2><h3 id="CoSDH-Communication-Efficient-Collaborative-Perception-via-Supply-Demand-Awareness-and-Intermediate-Late-Hybridization"><a href="#CoSDH-Communication-Efficient-Collaborative-Perception-via-Supply-Demand-Awareness-and-Intermediate-Late-Hybridization" class="headerlink" title="CoSDH: Communication-Efficient Collaborative Perception via Supply-Demand Awareness and Intermediate-Late Hybridization"></a>CoSDH: Communication-Efficient Collaborative Perception via Supply-Demand Awareness and Intermediate-Late Hybridization</h3><p>​    多智能体协同感知通过利用多个智能体的信息来增强感知能力，被认为是解决自动驾驶中单车感知能力弱问题的根本解决方案。然而，现有的协同感知方法面临着通信效率和感知精度之间的两难问题。</p><p>​    为了解决这个问题，我们提出了一种新颖的基于供需感知和中晚期混合的高效通信协作感知框架，称为CoSDH。该框架通过对Agent之间的供需关系进行建模，细化了协作区域的选择，在保持准确性的同时减少了不必要的通信成本。</p><p>​    此外创新性地引入了中-晚期混合协作模式，其中晚期协作弥补了低通信带宽下协作感知中的性能下降。</p><p><img data-src="https://s2.loli.net/2025/05/28/heA1tbXIiVDYr8o.png" alt="image-20250528141211346"></p><p>首先在PointPillar编码点云时,对于agent i,考虑使用每个支柱中的点云数量来表示点云密度，并将其映射到范围[ 0、1 ]. 然后选择点云密度低于阈值ε a的区域来获得agent i的需求掩码，Di = Ai &lt; εa∈{ 0，1 }^H×W^</p><p>同时使用detection header得到空间置信度图,利用一个供给阈值ε c得到供给掩码S ( l ) i = Ci &gt; εc∈{ 0，1 } ^H×W^.  至此得到supply和demand两个空间mask. 通过调整阈值，我们可以动态地调整用于协作感知的带宽，以适应不断变化的通信条件。</p><p>在协作过程中，agent~j~基于其供应掩码S~j~和agent~i~的需求掩码D~i~生成一个二元供需选择掩码M~j→i~ = D~i~⊙S~j~∈{ 0,1 }^H×W^，并对其进行采样，将其与多尺度BEV特征{ F(l) ~j~ } ~l=1,2,..,L~进行逐元相乘,得到稀疏特征{ Z(l)~j→i~ }~l=1,2,..,L~</p><h3 id="CoopDETR-A-Unified-Cooperative-Perception-Framework-for-3D-Detection-via-Object-Query"><a href="#CoopDETR-A-Unified-Cooperative-Perception-Framework-for-3D-Detection-via-Object-Query" class="headerlink" title="CoopDETR: A Unified Cooperative Perception Framework for 3D Detection via Object Query"></a>CoopDETR: A Unified Cooperative Perception Framework for 3D Detection via Object Query</h3><p><img data-src="https://s2.loli.net/2025/05/28/C3TP5RLomvNcBp2.png" alt="image-20250528151426743"></p><h3 id="How2Com"><a href="#How2Com" class="headerlink" title="How2Com"></a>How2Com</h3><p>​    多智能体协同感知作为一种新兴的驾驶场景应用，最近受到了广泛关注。尽管在先前的努力中取得了进展，但由于感知过程中的各种困境，包括<strong>通信冗余</strong>、<strong>传输延迟</strong>和协作异构性，挑战仍然存在。</p><p>​    为了解决这些问题，提出了How2comm，一种在感知性能和通信带宽之间寻求平衡的协作感知框架。我们的新颖性体现在三个方面。</p><p>首先，设计了一种互信息感知的通信机制，以最大限度地保持合作者共享的信息特征。采用空间通道滤波进行有效的特征稀疏化，以实现高效通信。</p><p>其次，我们提出了一种流导向的延迟补偿策略来预测合作者的未来特征，并消除由于时间不同步导致的特征错位。</p><p>​    最后，引入一个语用协作转换器来整合智能体之间的整体空间语义和时间上下文线索。我们的框架在真实世界和模拟场景中的多个基于LiDAR的协同探测数据集上进行了全面的评估</p><p>​    减少通信开销的主要模式被总结为<strong>特征压缩和空间滤波</strong>。前者假设智能体无差别地共享所有的空间区域，这极大地浪费了带宽。后者过度依赖置信图来突出易受骗的位置，没有考虑空间上的整体信息。此外，这些方法总是会造成传输的有价值信息的损失。</p><p>​    不可避免的传输延迟会导致快速移动物体在绿色圆内的位置错位，从而对后续的协作性能造成潜在的危害。虽然一些延迟感知策略被提出来解决这个问题，但它们要么<strong>受到性能瓶颈的影响</strong>，要么<strong>引入大量的计算开销</strong>，从而导致次优的解决方案。</p><p>​    各Agent之间激光雷达配置差异(例如,不同的LiDAR密度、分布、反射率和噪声干扰)可能导致特征空间内的协作异构. 从这两个感知区域融合有价值的空间语义，有助于全面和务实的感知。然而,先前的大多数方法通过个体/位置信息融合来整合合作者共享的特征以增强自我表征，<strong>其协作过程可能是脆弱的，因为没有从整体上考虑来自异构智能体的不同感知区域的优势。而且，当前的单帧感知范式面临着三维点云稀疏性和定位误差的挑战</strong>，增加了构建鲁棒的多智能体感知系统的难度。</p><p><img data-src="https://s2.loli.net/2025/05/28/L4zjETsIZkaouq3.png" alt="image-20250528161421934"></p><h4 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h4><ol><li>对于减少通信量,</li></ol><p>exclusive map,common map. decouple?</p><p>supply demand object query, confidence map,entropy?</p><ol><li>对于融合</li></ol><p>考虑时延</p><p>解决时延问题,引入feature flow思想,利用多层LSTM. </p><p>feature flow, flow generator,设计损失减少差异</p><p>使用范围编码考虑空间.</p><p>为了更好地关注/聚合历史数据,我们在lstm结构基础上进行了改进,引入注意力机制,关注.多层的query  exclusive common query </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://lilianweng.github.io/posts/2023-06-23-agent/">LLM Powered Autonomous Agents | Lil’Log</a></li><li><a href="https://lilianweng.github.io/posts/2022-06-09-vlm/">Generalized Visual Language Models | Lil’Log</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这半年要论AI哪些方向最火,那关键词必然包括多模态,AI Agent,RAG等等(事实上已经火了一轮开始冷饭热炒了),一些做之前基础大模型的公司基本开始转向做应用甚至其他方向了. 这里整理一些关于AI Agents的知识和相关基础框架,并结合多智能体协同感知看看有哪些能做的结合.&lt;br&gt;</summary>
    
    
    
    
    <category term="collaborative perception" scheme="https://www.sekyoro.top/tags/collaborative-perception/"/>
    
  </entry>
  
  <entry>
    <title>学习桌面开发先进经验,从WPF看起</title>
    <link href="https://www.sekyoro.top/2025/01/10/%E5%AD%A6%E4%B9%A0%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%88%E8%BF%9B%E7%BB%8F%E9%AA%8C%EF%BC%8C%E4%BB%8EWPF%E7%9C%8B%E8%B5%B7/"/>
    <id>https://www.sekyoro.top/2025/01/10/%E5%AD%A6%E4%B9%A0%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%88%E8%BF%9B%E7%BB%8F%E9%AA%8C%EF%BC%8C%E4%BB%8EWPF%E7%9C%8B%E8%B5%B7/</id>
    <published>2025-01-10T11:48:31.000Z</published>
    <updated>2025-02-07T14:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在桌面开发上,我已经尝试过许多框架和组合,比如Qt/PyQt,Electron,Flutter,Winform. 如今跨平台风气正盛,包括MAUI,Flutter以及Kotlin MultiPlatform(KMP)等等都风头正盛. 但我的理解是作为个人开发,很多时候并不需要写跨平台的桌面应用,不如写原生的.</p><p> 目前我的理解是:</p><ol><li>需要仔细思考产品跨平台的必要性,跨平台并不是free launch. </li><li>C++的桌面程序框架也有很多,但许多人因为语言问题放弃了,着实可惜.由于c++的高性能和gl图形库诞生许多简单的GUI,比如<a href="https://github.com/TimoSalomaki/awesome-dear-imgui">awesome-dear-imgui</a>和<a href="https://www.raylib.com/">raylib</a></li><li>Qt框架不只是GUI,拿他跟其他UI库比较不公平.它提供了包括网络库在内的功能,而这本身就是C++相比其他现代语言在标准库和生态的差距. 此外Qt还有结合JS的QML,QWebEngine一堆技术.</li><li>使用Web技术开发桌面应用的开发体验仍然有待提升,目前React Native发展正盛,也是得益于前端的蓬勃生态.</li><li>c++、Rust编写程序有相对更高的性能,可以写成库供其他语言的UI应用调用.  </li><li>微软目前还是在基于XAML的桌面应用开发上发力,MAUI和WinUI3是微软主推的,在win11以及将来都是windows桌面开发重点,Avalonia也很不错</li><li><a href="https://www.lazarus-ide.org/">Lazarus</a>可以用于C++桌面应用的快速开发,此外还有C++ builder社区版<a href="https://blog.ismisv.com/2019/05/try-cpp-builder-ce/">试用C++ Builder社区版 </a></li><li>Flutter,KMP(包括jetpack compose)以及SwiftUI的写法类似(移动端应用写法),不同与xaml也不是同于new对象. 它们都是从移动端技术向跨平台应用发展折射到桌面开发的,一些技术栈和思想和做Qt、Winform的人可能不太相同(Web技术也是).</li></ol><p>这里我从WPF入手学一点基础,由此可以向WinUI3,Uno,MAUI以及Avalonia桌面应用开发发展(后三者是跨平台框架).</p><span id="more"></span><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>对于桌面应用框架,我有几点个人的偏好和思考.</p><ol><li>虽然说对于有经验的程序员并不会因为编程语言问题而不去学习某个框架,毕竟桌面应用是一个domain的知识,这独立于保存语言.但实际这依然会对应用的生态影响,比如Dart语言使用人数相对较少,势必会对第三方库的生态造成影响,使得许多用户不敢深度使用,大企业就更别说了. 相比来说,React Native和Electron就完全可以借用web技术和生态,用户增长趋势稳定</li><li>UI的写法虽然各个框架不同,但完全都能理解并且不会对编写程序有过多影响。目前UI的写法有类似<strong>QtWidgets和Winforms直接new对象</strong>,相对更原始,但控制性还挺高. 还有Flutter,Jetpack Compose,<a href="https://www.jetbrains.com/kotlin-multiplatform/">Kotlin Multiplatform and Compose Multiplatform</a>这种是通过代码但是是<strong>嵌套声明式</strong>的写法,还有微软超爱的<strong>XAML写法和Qt Qml声明式</strong>写法,此外有web开发的大手,通过嵌入浏览器内核的<strong>html,css写法</strong>. 这些写法各有优劣,理性看待便是.</li><li>在渲染性能上,除了electron之外,其他框架大多数时候都没有什么太大的性能问题.而且electron只是使用web技术做桌面应用的一个例子罢了,此外还有<a href="https://tauri.app/">Tauri 2.0 | Tauri</a>,<a href="https://github.com/chromiumembedded/cef">chromiumembedded/cef: Chromium Embedded Framework (CEF). </a>,<a href="https://sciter.com/">sciter – Multiplatform HTML/CSS/JavaScript UI Engine for Desktop and Mobile Application</a>,<a href="https://pywebview.flowrl.com/">pywebview</a>等等此外在跨平台图形绘制上,有像Flutter通过统一的绘制引擎保证一致性的,有在不同操作系统上使用不同绘制库实现的.</li><li>跨平台框架是个伪问题,或者说这个问题不是从解决实际问题出发的。许多时候都要认真思考一下跨平台应用的开发成本</li><li>鉴于许多桌面应用其实基本主流用户都在windows上,而windows原生应用,比如微软的技术就有非常多桌面框架(Winforms,WPF,UWP,WinUI),但许多开发者都担心微软又会立马抛弃,目前MAUI,Blazor,WinUI3这些技术是微软主推的,此外社区也有<a href="https://platform.uno/">Uno</a>和<a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/introduction-to-xaml">Avalonia </a>跨平台技术. 这也导致微软没有构建起良好的社区氛围,大公司的<a href="https://tech.creaders.net/2012/07/04/1166968.html">官僚气息</a>、决策的朝令夕改使得开发者并不好受。希望目前微软能在技术上稳定下来<a href="https://dotnet.microsoft.com/en-us/learn">Learning center | .NET</a>,构建好技术文档和社区资源吸引开发者.</li></ol><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li><a href="https://github.com/sudhakar3697/awesome-electron-alternatives">sudhakar3697/awesome-electron-alternatives: A curated list of awesome Electron alternatives.</a></li><li><a href="https://github.com/robloo/PublicDocs/blob/master/XAMLFrameworkComparison.md">PublicDocs/XAMLFrameworkComparison.md at master · robloo/PublicDocs</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在桌面开发上,我已经尝试过许多框架和组合,比如Qt/PyQt,Electron,Flutter,Winform. 如今跨平台风气正盛,包括MAUI,Flutter以及Kotlin MultiPlatform(KMP)等等都风头正盛. 但我的理解是作为个人开发,很多时候并不需要写跨平台的桌面应用,不如写原生的.&lt;/p&gt;
&lt;p&gt; 目前我的理解是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要仔细思考产品跨平台的必要性,跨平台并不是free launch. &lt;/li&gt;
&lt;li&gt;C++的桌面程序框架也有很多,但许多人因为语言问题放弃了,着实可惜.由于c++的高性能和gl图形库诞生许多简单的GUI,比如&lt;a href=&quot;https://github.com/TimoSalomaki/awesome-dear-imgui&quot;&gt;awesome-dear-imgui&lt;/a&gt;和&lt;a href=&quot;https://www.raylib.com/&quot;&gt;raylib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qt框架不只是GUI,拿他跟其他UI库比较不公平.它提供了包括网络库在内的功能,而这本身就是C++相比其他现代语言在标准库和生态的差距. 此外Qt还有结合JS的QML,QWebEngine一堆技术.&lt;/li&gt;
&lt;li&gt;使用Web技术开发桌面应用的开发体验仍然有待提升,目前React Native发展正盛,也是得益于前端的蓬勃生态.&lt;/li&gt;
&lt;li&gt;c++、Rust编写程序有相对更高的性能,可以写成库供其他语言的UI应用调用.  &lt;/li&gt;
&lt;li&gt;微软目前还是在基于XAML的桌面应用开发上发力,MAUI和WinUI3是微软主推的,在win11以及将来都是windows桌面开发重点,Avalonia也很不错&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt;可以用于C++桌面应用的快速开发,此外还有C++ builder社区版&lt;a href=&quot;https://blog.ismisv.com/2019/05/try-cpp-builder-ce/&quot;&gt;试用C++ Builder社区版 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flutter,KMP(包括jetpack compose)以及SwiftUI的写法类似(移动端应用写法),不同与xaml也不是同于new对象. 它们都是从移动端技术向跨平台应用发展折射到桌面开发的,一些技术栈和思想和做Qt、Winform的人可能不太相同(Web技术也是).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我从WPF入手学一点基础,由此可以向WinUI3,Uno,MAUI以及Avalonia桌面应用开发发展(后三者是跨平台框架).&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>前端运行时、打包与构建简单介绍</title>
    <link href="https://www.sekyoro.top/2025/01/09/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2025/01/09/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-09T07:49:05.000Z</published>
    <updated>2025-01-09T14:57:52.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比前两年,今年前端的工具进展相比可能确实慢了一些. 但还是有许多新的工具以及一些常用工具的新版本. 这里简单介绍一些在开发中关于js一些工具使用.</p><span id="more"></span><h2 id="JS三大运行时"><a href="#JS三大运行时" class="headerlink" title="JS三大运行时"></a>JS三大运行时</h2><p>js可以操作浏览器DOM以及浏览器提供的Web API等,这些都是在强大的浏览器下的功能. 除此之外还有最常用的node和较新的bun,Deno.</p><p>Deno和Bun的优点在于速度和对一些新特性,比如对typescript的支持更快.</p><p>此外Bun还致力于打造整个开发生态而不只是一个运行时。</p><h3 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h3><p>最近deno迎来2.0</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greet(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno main.ts</span><br></pre></td></tr></table></figure><h3 id="Bun"><a href="#Bun" class="headerlink" title="Bun"></a>Bun</h3><p>最近bun迎来1.1. 它提供一整套js和ts的开发工具,使用Bun作为运行时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun run index.tsx </span><br></pre></td></tr></table></figure><h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>npm,yarn以及pnpm都是常用的包管理器,除此之外,还有bun install以及包管理器的管理器corepack. bun install是bun提供的包管理器,而Corepack是node官方做的包括npm,yarn,pnpm的管理器,目前新版的node是自带corepack并且应该是未来的新使用方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corepack <span class="built_in">enable</span></span><br><span class="line">corepack use yarn@latest</span><br></pre></td></tr></table></figure><p>同时会在<code>package.json</code>中写入对应<code>`packageManager</code>字段</p><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><p>打包工具(Bundler)主要目的是<code>compiles small pieces of code into something larger and more complex</code>,包括js,css以及图像等静态文件.</p><blockquote><p>打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web 应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle</p></blockquote><h3 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h3><p><img data-src="https://s2.loli.net/2025/01/09/Rf7M9ecZYbOSyTC.png" alt="image-20250109201151034"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-exact --save-dev esbuild</span><br><span class="line">.\node_modules\.bin\esbuild --version</span><br><span class="line">.\node_modules\.bin\esbuild app.jsx --bundle --outfile=out.js <span class="comment"># 命令行</span></span><br></pre></td></tr></table></figure><p>esbuild优势是速度快,本身支持js,css,ts,jsx</p><p>通过配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;esbuild app.jsx --bundle --outfile=out.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为浏览器js打包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16</span><br></pre></td></tr></table></figure><p>默认情况下，打包器为浏览器输出代码，因此不需要额外的配置即可开始。对于开发构建，使用——sourcemap来启用源映射，而对于生产构建，使用——minify来启用最小化。</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev parcel</span><br></pre></td></tr></table></figure><p>类似esbuild,但功能更多,比如同时支持commonjs和ES模块的输出.</p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p>rollup是将小的代码片段编译成更大、更复杂的代码，例如库或应用程序。它使用 JavaScript 的 ES6 版本中包含的新标准化代码模块格式。</p><p><strong>它适合ES模块编写的js打包</strong></p><p>Vite目前使用的打包工具,但马上将被换为RollDown. rollup突出一个使用简洁方便</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup index.js -o bundle.js -f cjs</span><br></pre></td></tr></table></figure><p>此外也可以配置文件<code>rollup.config.mjs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// rollup.config.mjs</span><br><span class="line">// ---cut-start---</span><br><span class="line">/** @type &#123;import(&#x27;rollup&#x27;).RollupOptions&#125; */</span><br><span class="line">// ---cut-end---</span><br><span class="line">export default &#123;</span><br><span class="line">input: &#x27;src/main.js&#x27;,</span><br><span class="line">output: &#123;</span><br><span class="line">file: &#x27;bundle.js&#x27;,</span><br><span class="line">format: &#x27;cjs&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c</span><br></pre></td></tr></table></figure><h3 id="RollDown"><a href="#RollDown" class="headerlink" title="RollDown"></a>RollDown</h3><p><a href="https://rolldown.rs/guide/">Introduction | Rolldown</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D rolldown</span><br><span class="line">.<span class="regexp">/node_modules/</span>.bin<span class="regexp">/rolldown src/m</span>ain.js --<span class="keyword">file</span> bundle.js</span><br></pre></td></tr></table></figure><p>看起来跟esbuild,rollup没有很大差异.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-rolldown-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rolldown src/main.js --file bundle.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rolldown&quot;</span>: <span class="string">&quot;^1.0.0-beta.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-rolldown-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rolldown -c&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rolldown&quot;</span>: <span class="string">&quot;^1.0.0-beta.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rspack"><a href="#Rspack" class="headerlink" title="Rspack"></a>Rspack</h3><p>更新的工具,包含RsBuild,Rspress等生态.</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>相对来说构建工具的包含概念更大,让更类似于一个项目启动器,可以负责整个项目开发各个阶段的整合,一些具体的处理可能需要使用一些打包、混淆压缩以及热更新.</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>webpack有自带的许多loader<a href="https://www.webpackjs.com/concepts/loaders/">loader</a>以及插件<a href="https://www.webpackjs.com/concepts/plugins/">plugin </a>,功能强大,但配置相对复杂.目前使用Vite更多.</p><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用loader,loader 用于对模块的源代码进行转换。loader 可以使你在 <code>import</code> 或 “load(加载)” 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许直接在 JavaScript 模块中 <code>import</code> CSS 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader ts-loade</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: <span class="string">&#x27;css-loader&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, use: <span class="string">&#x27;ts-loader&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>Vite开箱即用,支持许多预设</p><p>插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm add -D @vitejs/plugin-legacy</span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-legacy&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    legacy(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&#x27;defaults&#x27;</span>, <span class="string">&#x27;not IE 11&#x27;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Rsbuild"><a href="#Rsbuild" class="headerlink" title="Rsbuild"></a>Rsbuild</h3><p><img data-src="https://assets.rspack.dev/rsbuild/assets/rsbuild-1-0-build-tools.png" alt="img"></p><p>可以将 Rsbuild 理解为一个现代化的 Create React App 或 Vue CLI，它与这些工具的主要区别在于：</p><ul><li>底层的打包工具由 Webpack 替换为 Rspack，提供 5 ~ 10 倍的构建性能。</li><li>与前端 UI 框架解耦，并通过 <a href="https://rsbuild.dev/zh/plugins/list/index">插件</a> 来支持所有 UI 框架，包括 React、Vue、Svelte、Solid 等。</li><li>提供更好的扩展性，你可以通过 <a href="https://rsbuild.dev/zh/config/index">配置</a>、 <a href="https://rsbuild.dev/zh/plugins/dev/index">插件 API</a> 和 <a href="https://rsbuild.dev/zh/api/start/index">JavaScript API</a> 来灵活地扩展 Rsbuild。</li></ul><h3 id="Farm"><a href="#Farm" class="headerlink" title="Farm"></a>Farm</h3><p>引用官方的话,Farm类似Webpack和Vite但更快. farm <code>resolve, load, transform</code> 所有 <code>asset(js/jsx/ts/tsx、css/sass/less、html、静态资源、json 等)</code>，并将它们打包成一系列<code>可部署文件</code>。 Farm 是一个速度极快的构建工具，可帮助您构建更快的 <code>web/nodejs</code> 应用程序。</p><h2 id="转码器"><a href="#转码器" class="headerlink" title="转码器"></a>转码器</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>babel用于ES2015+以上的ECMAScripit在较低版本的浏览器上兼容,此外也支持jsx和es模块转换</p><p>babel配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: <span class="string">&quot;3.6.5&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SWC"><a href="#SWC" class="headerlink" title="SWC"></a>SWC</h3><p>Vite中所使用的代码转换器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D @swc/cli @swc/core</span><br><span class="line">npx swc ./file.js</span><br></pre></td></tr></table></figure><p>转译工具和构建工具的使用都不复杂,swc也支持配置支持浏览器,转换模块,压缩. 配置<code>.swcrc</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;https://swc.nodejs.cn/schema.json&quot;,</span><br><span class="line">  &quot;module&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;commonjs&quot;,</span><br><span class="line"> </span><br><span class="line">    // These are defaults.</span><br><span class="line">    &quot;strict&quot;: false,</span><br><span class="line">    &quot;strictMode&quot;: true,</span><br><span class="line">    &quot;lazy&quot;: false,</span><br><span class="line">    &quot;noInterop&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Oxc"><a href="#Oxc" class="headerlink" title="Oxc"></a>Oxc</h3><p>与Rolldown类似,属于Vue,Vite生态圈. 它本身是一个提供了许多工具的总成,包括lint,parser,transformer和resolver</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">oxlint -c</span> </span><br></pre></td></tr></table></figure><p>此外值得一提的是考虑使用<a href="https://biomejs.dev/guides/getting-started/">Biome</a>作为prettier的替代工具,因为前者速度更快.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;对比前两年,今年前端的工具进展相比可能确实慢了一些. 但还是有许多新的工具以及一些常用工具的新版本. 这里简单介绍一些在开发中关于js一些工具使用.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Dive into fine-tuning methods for SD</title>
    <link href="https://www.sekyoro.top/2025/01/02/Dive-into-fine-tuning-methods-for-SD/"/>
    <id>https://www.sekyoro.top/2025/01/02/Dive-into-fine-tuning-methods-for-SD/</id>
    <published>2025-01-02T02:08:06.000Z</published>
    <updated>2025-03-08T12:58:01.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文生图和图生图应用已经出现一段时间了,目前常用的应用就是根据用户需求修改图片,事实上这就是一种自定义. 因为需要模型重新生成整张图或者部分图,要么通过prompt、reference image,也就是改变输入的方式;要么通过修改模型,也就是微调模型的方式. 因此诞生出了许多微调模型的方式,目前常用的微调库是<a href="https://github.com/huggingface/peft">huggingface/peft: 🤗 PEFT</a>. 针对AI绘图应用的微调技术,倒是可以推出一道清晰的发展线. 这里简单整理一下.</p><span id="more"></span><h2 id="Before-LoRA"><a href="#Before-LoRA" class="headerlink" title="Before LoRA"></a>Before LoRA</h2><p>在大名鼎鼎的LoRA之前,绘画相关的微调技术主要有Textual Inversion<a href="https://arxiv.org/pdf/2208.01618">2208.01618</a>和DreamBooth<a href="https://arxiv.org/pdf/2208.12242">2208.12242</a>. 此外还有改变输入以及嵌入向量的Prefix Tuning<a href="https://arxiv.org/abs/2101.00190">Prefix-Tuning: Optimizing Continuous Prompts for Generation</a>和Prompt Tuning<a href="https://arxiv.org/abs/2104.08691">The Power of Scale for Parameter-Efficient Prompt Tuning</a>,由于与AI绘图相关微调联系不大,这里不深入.</p><h3 id="Textual-Inversion"><a href="#Textual-Inversion" class="headerlink" title="Textual Inversion"></a>Textual Inversion</h3><p>​    文本到图像的模型为通过自然语言指导创作提供了前所未有的自由。然而，如何行使这种自由来生成特定独特概念的图像，修改它们的外观，或将它们组成新的角色和新的场景，尚不清楚。</p><p>​    只使用用户提供的一个概念的3 - 5张图像，<strong>比如一个对象或一个样式，在一个冻结的文本到图像模型的嵌入空间中，我们学习通过新的”词”来表示它</strong>。这些”词”可以组合成自然语言句子，以直观的方式指导个性化创作。作者发现单个词嵌入足以捕获独特和多样的概念。</p><p>​    将新概念引入模型的难点: 将新概念引入大规模模型往往是困难的。为每个新概念重新训练一个具有扩展数据集的模型是非常昂贵的，<strong>对少数例子进行微调通常会导致灾难性的遗忘</strong>。<strong>更多的度量方法在面对新概念时冻结模型并训练转换模块以适应其输出。然而，这些方法仍然容易遗忘先验知识，或者与新学习的概念融合时面临困难。</strong></p><p>​    提出<strong>通过在预训练的文本到图像模型的文本嵌入空间中寻找新词来克服这些挑战</strong>。考虑文本编码过程的第一阶段。在这里输入字符串首先被转换为一组token(词元,理解为词典中的不可再分的词)。然后将每个token替换为自己的嵌入向量，这些向量通过下游模型进行反馈。<strong>目标是寻找新的嵌入向量来表示新的、特定的概念</strong>。</p><p>​    用一个新的词(pseudo-word)表示一个新的嵌入向量，我们用S <em>表示。然后这个词像其他任何词一样被处理，并且可以用于为生成模型合成新的文本查询。因此，可以要求”一张沙滩上的S </em>照片”、”一幅挂在墙上的S <em>油画”，甚至可以组成两个概念，如”一幅S </em> 1的S * 2的画”。</p><p>​    重要的是，这个过程没有触及生成模型。在这样做的过程中，我们保留了在新任务上微调视觉和语言模型时通常会丢失的丰富的文本理解和泛化能力。</p><p>​    为了找到这些词，将任务定为求逆运算,<strong>给出了一个固定的预训练文本-图像模型和一个描述概念的小( 3-5 )图像集。目标是找到一个单词嵌入，这样’ A photo of S * ‘形式的句子将导致从我们的小集合中重建图像。这种嵌入是通过一个优化过程找到的，我们称之为”文本倒置”。</strong></p><p><img data-src="https://s2.loli.net/2025/01/02/B3wYEMNog5KPLa7.png" alt="image-20250102112045813"></p><p>具体来说,首先选取若干张相关概念的照片,假设pikachu,对应输入的prompt类似An image of pikachu, A photo of pikachu,然后就照着LDM训练的方式在原本的预训练大模型上继续训练即可.</p><h3 id="DreamBooth"><a href="#DreamBooth" class="headerlink" title="DreamBooth"></a>DreamBooth</h3><p><img data-src="https://s2.loli.net/2025/01/02/CjIZsPOXFoLDYai.png" alt="image-20250102121433867"></p><p>​    DreamBooth的目的和Textual Inversion类似,扩展模型的语言-视觉词典，使其能够将新词与用户想要生成的特定主题绑定在一起。    </p><p>​    给定一个主体的几幅图像，目标是将主体植入模型的输出域，使其能够用唯一的标识符进行合成。为此提出一种技术，用稀有的标记标识符表示给定的主题，并微调一个预训练的、基于扩散的文本到图像框架。</p><p>​    给定一个对象的3 - 5图像，微调一个文本到图像的扩散模型，输入图像与一个包含唯一标识符且对象所属类名为( e.g . , ‘ A [ V ] dog ‘)的文本提示配对，并行地应用一个特定于类的先验保存损失，该损失利用了模型在类上的语义先验，并鼓励它使用文本提示中的类名生成属于该对象类的多样实例。</p><p>​    相比于textual inversion,它对模型而不只是embedding进行了微调,同时增加了新的损失, 对于同类但不同具体实例的图像进行训练.</p><script type="math/tex; mode=display">\begin{array}{l} \mathbb{E}_{\mathbf{x}, \mathbf{c}, \epsilon, \epsilon^{\prime}, t}\left[w_{t}\left\|\hat{\mathbf{x}}_{\theta}\left(\alpha_{t} \mathbf{x}+\sigma_{t} \boldsymbol{\epsilon}, \mathbf{c}\right)-\mathbf{x}\right\|_{2}^{2}+\right. \\\left.\lambda w_{t^{\prime}}\left\|\hat{\mathbf{x}}_{\theta}\left(\alpha_{t^{\prime}} \mathbf{x}_{\mathrm{pr}}+\sigma_{t^{\prime}} \epsilon^{\prime}, \mathbf{c}_{\mathrm{pr}}\right)-\mathbf{x}_{\mathrm{pr}}\right\|_{2}^{2}\right]\end{array}</script><h2 id="LoRA-era"><a href="#LoRA-era" class="headerlink" title="LoRA era"></a>LoRA era</h2><p>如果说上面几种方法都集中通过新的输入修改embedding,那么LoRA就是修改其中涉及重要计算模块的部分,比如Linear或Conv层  .</p><p>LoRA作为AI绘画模型微调技术不得不提的一环,一经提出就带来了一股LoRA潮<a href="https://towardsdatascience.com/an-overview-of-the-lora-family-515d81134725">An Overview of the LoRA Family. LoRA, DoRA, AdaLoRA, Delta-LoRA, and… | by Dorian Drost | Towards Data Science</a>. </p><p>此外LoRA也可以结合上面的修改embedding方法达到更好的效果.</p><h3 id="LoRA"><a href="#LoRA" class="headerlink" title="LoRA"></a>LoRA</h3><p><img data-src="https://s2.loli.net/2025/01/02/FogSW1IwGdLzfVK.png" alt="image-20250102132811471"></p><p>神经网络包含许多执行矩阵乘法的密集层。这些层中的权重矩阵通常具有满秩。在适应特定任务时，Aghajanyan等研究表明，<strong>预训练的语言模型具有较低的”特征维度”(rank)，即使随机投影到较小的子空间，仍然可以高效地学习</strong>。受此启发，<strong>假设权重的更新在适应过程中也具有较低的”内在秩”</strong>。对于一个预训练的权重矩阵W^0^∈R^d×k^，用一个低秩分解W~0~ + $\Delta$W = W~0~ + BA来约束它的更新，其中B∈R^d×r^，A∈R^r×k^，秩为r=min( d , k)。在训练过程中，W^0^被冻结，不接受梯度更新，而A和B包含可训练参数。</p><p>​    注意W~0~和∆W = BA都乘以相同的输入，并且它们各自的输出向量按位求和。</p><p>对于h = W~0~x，修正前向传递得到h = W~0~x +∆W x = W~0~x + BAx</p><p>​    对A使用随机高斯初始化，对B使用零初始化，因此在训练开始时，W = BA为零。然后用α/r对∆W x进行缩放，其中α为r中的常数。</p><p>​    在使用Adam进行优化时，如果对初始化进行适当的缩放，则调整α与调整学习率大致相同。因此，简单地将α设置为r，并不对其进行调整。这种缩放有助于减少当我们改变r时重新调整超参数的需要.</p><p>​    在训练时,加上lora,冻结预训练模型,训练一个包含A和B的MLP,它更新参数时需要减去这个模型的参数</p><p>​    测试时,模型的权重要加上LoRA的参数.</p><p>​    LoRA本身修改了微调时更新权重的方式,将更新的权重放到了一个可拆卸的模块中,同时由于只搭配预训练大模型中的某部分,使得微调过程更短,训练周期更短.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>参考<a href="https://github.com/microsoft/LoRA/blob/main/loralib/layers.py">LoRA/loralib/layers.py at main · microsoft/LoRA</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoRALayer</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self, </span></span></span><br><span class="line"><span class="params"><span class="function">        r: <span class="built_in">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        lora_alpha: <span class="built_in">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        lora_dropout: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        merge_weights: <span class="built_in">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        self.r = r</span><br><span class="line">        self.lora_alpha = lora_alpha</span><br><span class="line">        <span class="comment"># Optional dropout</span></span><br><span class="line">        <span class="keyword">if</span> lora_dropout &gt; <span class="number">0.</span>:</span><br><span class="line">            self.lora_dropout = nn.Dropout(p=lora_dropout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.lora_dropout = <span class="keyword">lambda</span> x: x</span><br><span class="line">        <span class="comment"># Mark the weight as unmerged</span></span><br><span class="line">        self.merged = <span class="literal">False</span></span><br><span class="line">        self.merge_weights = merge_weights</span><br></pre></td></tr></table></figure><p>对于Embedding,Linear以及Conv层有不同的具体实现. 但总体来说,在训练时,通过减去B@A更新参数. 在测试时权重加上LoRA层.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span>(<span class="params">nn.Linear, LoRALayer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 in_features: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 out_features: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 r: <span class="built_in">int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 lora_alpha: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 lora_dropout: <span class="built_in">float</span> = <span class="number">0.</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 fan_in_fan_out: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="comment"># Set this to True if the layer to replace stores weight like (fan_in, fan_out)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                 merge_weights: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 **kwargs</span>):</span></span><br><span class="line">        nn.Linear.__init__(self, in_features, out_features, **kwargs)</span><br><span class="line">        LoRALayer.__init__(self, r=r, lora_alpha=lora_alpha, lora_dropout=<span class="number">0</span>, merge_weights=merge_weights)</span><br><span class="line">        self.fan_in_fan_out = fan_in_fan_out</span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="number">0</span>:</span><br><span class="line">            self.lora_A = nn.Parameter(self.weight.new_zeros((r, in_features)))</span><br><span class="line">            self.lora_B = nn.Parameter(self.weight.new_zeros((out_features, r)))</span><br><span class="line">            self.scaling = self.lora_alpha / self.r</span><br><span class="line">            self.weight.requires_grad = <span class="literal">False</span> <span class="comment"># 禁止梯度更新</span></span><br><span class="line">        self.reset_parameters()</span><br><span class="line">        <span class="keyword">if</span> fan_in_fan_out:</span><br><span class="line">            self.weight.data = self.weight.data.transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LyCORIS"><a href="#LyCORIS" class="headerlink" title="LyCORIS"></a>LyCORIS</h3><p><a href="https://arxiv.org/abs/2309.14859">2309.14859] Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation</a></p><p>提出了一系列用在Stable Diffusion中基于LoRA的微调方式并设计了benchmark测试</p><p><img data-src="https://s2.loli.net/2025/01/02/KEoVxDuY3IiJOar.png" alt="image-20250102152745443"></p><p>主要包括LoHA和LoKr,其实光看图就很容易明白. LoHA另外引入一套BA,并通过点乘得到最终的更新,论文解释这种方法得到的矩阵的秩大于一般的低秩分解. 而LoKr就直接使用矩阵直积了.</p><p>这方面还有很多魔改的各种微调,就不一一介绍了.</p><h2 id="Adapters-for-preserving-Identity"><a href="#Adapters-for-preserving-Identity" class="headerlink" title="Adapters for preserving Identity"></a>Adapters for preserving Identity</h2><p>Adapter的实现和LoRA有类似点,但提出的目的不同与LoRA:LoRA强调用户拿几张个人照片让模型学习新的权重同时不过于遗忘已有知识,而Adapter的场景更偏向适应与融合. </p><h3 id="IP-Adapter"><a href="#IP-Adapter" class="headerlink" title="IP-Adapter"></a>IP-Adapter</h3><p><a href="https://github.com/tencent-ailab/IP-Adapter?tab=readme-ov-file">tencent-ailab/IP-Adapter: The image prompt adapter is designed to enable a pretrained text-to-image diffusion model to generate images with image prompt.</a></p><p><img data-src="https://s2.loli.net/2025/01/02/sItZgfVkolGeN4b.png" alt="image-20250102155440556"></p><p>针对现有的文本到图像扩散模型，提出了一种基于解耦交叉注意力策略的轻量级图像提示自适应方法IP-Adapter。</p><p>在图像编码器之后加入新的权重参数进行编码,并将编码后的特征用于训练一个新的cross attention layer. 论文的关键创新就是引入cross attention将图像特征用来微调模型.</p><p>给定图像特征c~i~，新的交叉注意力Z′′的输出计算如下</p><script type="math/tex; mode=display">\mathbf{Z}^{\prime \prime}=\operatorname{Attention}\left(\mathbf{Q}, \mathbf{K}^{\prime}, \mathbf{V}^{\prime}\right)=\operatorname{Softmax}\left(\frac{\mathbf{Q}\left(\mathbf{K}^{\prime}\right)^{\top}}{\sqrt{d}}\right) \mathbf{V}^{\prime}</script><p>其中Q=ZW~q~,Z是文本编码后的特征,K^’^=cW~k~,c是图像特征,V=cV~v~</p><p><img data-src="https://s2.loli.net/2025/01/02/RAhWYImDw6H2cpM.png" alt="image-20250102161435821"></p><h3 id="InstantID"><a href="#InstantID" class="headerlink" title="InstantID"></a>InstantID</h3><p><a href="https://github.com/instantX-research/InstantID?tab=readme-ov-file">instantX-research/InstantID: InstantID: Zero-shot Identity-Preserving Generation in Seconds 🔥</a></p><p><img data-src="https://s2.loli.net/2025/01/02/pBcPXm7JDOZL6It.png" alt="image-20250102155632207"></p><p>首先，采用人脸编码器代替CLIP提取语义人脸特征，并使用可训练的投影层将其投影到文本特征空间。将投影后的特征作为人脸嵌入。然后，引入解耦交叉注意力的轻量级自适应模块，以支持图像作为提示。最后提出IdentityNet对参考人脸图像中的复杂特征进行编码，并附加弱空间控制。在IdentityNet中，生成过程完全由人脸嵌入引导，无需任何文本信息。只更新新增加的模块，而预训练的文本到图像模型保持冻结，以确保灵活性。经过训练，用户可以自由地生成任意风格的高保真度的ID保持图像。</p><h2 id="Towards-Video-Diffusion-Models"><a href="#Towards-Video-Diffusion-Models" class="headerlink" title="Towards Video Diffusion Models"></a>Towards Video Diffusion Models</h2><p> <a href="https://github.com/ChenHsing/Awesome-Video-Diffusion-Models">CSUR] A Survey on Video Diffusion Models</a></p><p>生成图像已经不够了,可以通过prompt生成连续的多张图片,这样可以组成GIF甚至更长更高质量的视频.</p><p>比如<strong>AnimateDiff</strong></p><p><img data-src="https://s2.loli.net/2025/01/02/WEG5I47BVre3yA1.png" alt="image-20250102140534169"></p><h2 id="训练LoRA"><a href="#训练LoRA" class="headerlink" title="训练LoRA"></a>训练LoRA</h2><p>线性层中的lora</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoraInjectedLinear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self, in_features, out_features, bias=<span class="literal">False</span>, r=<span class="number">4</span>, dropout_p=<span class="number">0.1</span>, scale=<span class="number">1.0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="built_in">min</span>(in_features, out_features):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f&quot;LoRA rank <span class="subst">&#123;r&#125;</span> must be less or equal than <span class="subst">&#123;<span class="built_in">min</span>(in_features,out_features)&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">        self.r = r</span><br><span class="line">        self.linear = nn.Linear(in_features, out_features, bias)</span><br><span class="line">        self.lora_down = nn.Linear(in_features, r, bias=<span class="literal">False</span>)</span><br><span class="line">        self.dropout = nn.Dropout(dropout_p)</span><br><span class="line">        self.lora_up = nn.Linear(r, out_features, bias=<span class="literal">False</span>)</span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.selector = nn.Identity()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  init ΔW = A*B</span></span><br><span class="line">        nn.init.normal_(self.lora_down.weight, std=<span class="number">1</span> / r)</span><br><span class="line">        nn.init.zeros_(self.lora_up.weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            self.linear(<span class="built_in">input</span>)</span><br><span class="line">            + self.dropout(self.lora_up(self.selector(self.lora_down(<span class="built_in">input</span>))))</span><br><span class="line">            * self.scale</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">realize_as_lora</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lora_up.weight.data * self.scale, self.lora_down.weight.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_selector_from_diag</span>(<span class="params">self, diag: torch.Tensor</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> diag.shape == (self.r,)</span><br><span class="line">        self.selector = nn.Linear(self.r, self.r, bias=<span class="literal">False</span>)</span><br><span class="line">        self.selector.weight.data = (</span><br><span class="line">            torch.diag(diag)</span><br><span class="line">            .to(self.lora_up.weight.device)</span><br><span class="line">            .to(self.lora_up.weight.dtype)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>卷积中的lora</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoraInjectedConv2d</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        in_channels: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        out_channels: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        kernel_size: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        stride=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        padding=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dilation=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        groups: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        bias: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        r: <span class="built_in">int</span> = <span class="number">4</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dropout_p: <span class="built_in">float</span> = <span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        scale: <span class="built_in">float</span> = <span class="number">1.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="built_in">min</span>(in_channels, out_channels):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f&quot;LoRA rank <span class="subst">&#123;r&#125;</span> must be less or equal than <span class="subst">&#123;<span class="built_in">min</span>(in_channels, out_channels)&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">        self.r = r</span><br><span class="line">        self.conv = nn.Conv2d(</span><br><span class="line">            in_channels=in_channels,</span><br><span class="line">            out_channels=out_channels,</span><br><span class="line">            kernel_size=kernel_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            dilation=dilation,</span><br><span class="line">            groups=groups,</span><br><span class="line">            bias=bias,</span><br><span class="line">        )</span><br><span class="line">        self.lora_down = nn.Conv2d(</span><br><span class="line">            in_channels=in_channels,</span><br><span class="line">            out_channels=r,</span><br><span class="line">            kernel_size=kernel_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            dilation=dilation,</span><br><span class="line">            groups=groups,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        self.dropout = nn.Dropout(dropout_p)</span><br><span class="line">        self.lora_up = nn.Conv2d(</span><br><span class="line">            in_channels=r,</span><br><span class="line">            out_channels=out_channels,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        self.selector = nn.Identity()</span><br><span class="line">        self.scale = scale</span><br><span class="line"></span><br><span class="line">        nn.init.normal_(self.lora_down.weight, std=<span class="number">1</span> / r)</span><br><span class="line">        nn.init.zeros_(self.lora_up.weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            self.conv(<span class="built_in">input</span>)</span><br><span class="line">            + self.dropout(self.lora_up(self.selector(self.lora_down(<span class="built_in">input</span>))))</span><br><span class="line">            * self.scale</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">realize_as_lora</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lora_up.weight.data * self.scale, self.lora_down.weight.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_selector_from_diag</span>(<span class="params">self, diag: torch.Tensor</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> diag.shape == (self.r,)</span><br><span class="line">        self.selector = nn.Conv2d(</span><br><span class="line">            in_channels=self.r,</span><br><span class="line">            out_channels=self.r,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        self.selector.weight.data = torch.diag(diag)</span><br><span class="line">        self.selector.weight.data = self.selector.weight.data.to(</span><br><span class="line">            self.lora_up.weight.device</span><br><span class="line">        ).to(self.lora_up.weight.dtype)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/675231376">一文辨析清楚LORA、Prompt Tuning、P-Tuning、Adapter 、Prefix等大模型微调方法 - 知乎</a></li><li><a href="https://www.artvy.ai/resource/lora-vs-dreambooth-vs-textual-inversion-vs">LoRA vs Dreambooth vs Textual Inversion vs Hypernetworks: Exploring the World of Stable Diffusion Fine-Tuning Methods</a></li><li><a href="https://openreview.net/forum?id=wfzXa8e783">Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation | OpenReview</a></li><li><a href="https://github.com/KohakuBlueleaf/LyCORIS?tab=readme-ov-file">KohakuBlueleaf/LyCORIS: Lora beYond Conventional methods, Other Rank adaptation Implementations for Stable diffusion.</a></li><li><a href="https://towardsdatascience.com/an-overview-of-the-lora-family-515d81134725">An Overview of the LoRA Family. LoRA, DoRA, AdaLoRA, Delta-LoRA, and… | by Dorian Drost | Towards Data Science</a></li><li><a href="https://arxiv.org/pdf/2106.09685">2106.09685</a></li><li><a href="https://arxiv.org/abs/2309.14859">[2309.14859] Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation</a></li><li><a href="https://arxiv.org/pdf/2307.04725">2307.04725</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;文生图和图生图应用已经出现一段时间了,目前常用的应用就是根据用户需求修改图片,事实上这就是一种自定义. 因为需要模型重新生成整张图或者部分图,要么通过prompt、reference image,也就是改变输入的方式;要么通过修改模型,也就是微调模型的方式. 因此诞生出了许多微调模型的方式,目前常用的微调库是&lt;a href=&quot;https://github.com/huggingface/peft&quot;&gt;huggingface/peft: 🤗 PEFT&lt;/a&gt;. 针对AI绘图应用的微调技术,倒是可以推出一道清晰的发展线. 这里简单整理一下.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>An intro to Websocket and SSE</title>
    <link href="https://www.sekyoro.top/2024/12/31/An-intro-to-Websocket-and-SSE/"/>
    <id>https://www.sekyoro.top/2024/12/31/An-intro-to-Websocket-and-SSE/</id>
    <published>2024-12-31T11:29:32.000Z</published>
    <updated>2024-12-31T15:44:07.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在看LLM的流式输出如何反映到json输出上,现有的解决方案包括 WebSocket 或 Server-Sent Events (SSE) 实时通信技术.<br><span id="more"></span></p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>WebSocket API</strong> 可在用户浏览器和服务器之间开启双向交互式通信会话。利用该 API，可以向服务器发送信息，并接收事件驱动的响应，而无需轮询服务器以获得回复。</p><p><img data-src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png" alt="img"></p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><p><strong>客户端</strong></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>, protocols);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器向所有用户发送文本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造一个 msg 对象，包含了服务器处理所需的数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value,</span><br><span class="line">    <span class="attr">id</span>: clientID,</span><br><span class="line">    <span class="attr">date</span>: <span class="built_in">Date</span>.now(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 msg 对象作为 JSON 格式字符串发送</span></span><br><span class="line">  exampleSocket.send(<span class="built_in">JSON</span>.stringify(msg));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空文本输入元素，为接收下一条消息做好准备。</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><p>可以使用<a href="https://socket.io/">Socket.IO</a>,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Server &#125; = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> Server(&#123; <span class="comment">/* options */</span> &#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFileSync &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; createServer &#125; = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Server &#125; = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpsServer = createServer(&#123;</span><br><span class="line">  <span class="attr">key</span>: readFileSync(<span class="string">&quot;/path/to/my/key.pem&quot;</span>),</span><br><span class="line">  <span class="attr">cert</span>: readFileSync(<span class="string">&quot;/path/to/my/cert.pem&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> Server(httpsServer, &#123; <span class="comment">/* options */</span> &#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">httpsServer.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><p>HTTP 协议本身不允许服务器主动给客户端发送信息，但有一种方法可以让服务器持续向客户端发送数据流。这种方法不是发送一次性数据包，而是保持连接开放，像视频播放那样连续发送数据。这种长时间的下载过程实际上是以数据流的形式进行的。</p><p>服务器发送事件（SSE）就是利用了这个特性，通过HTTP协议让服务器可以向浏览器推送实时更新的信息。传统上，网页需要先请求服务器才能获取新数据，但是使用SSE，服务器可以在任何时候主动向网页推送新的数据和消息，这些消息可以在网页内作为事件来处理。</p><p>服务端推送的数据是单向的，只从服务器到客户端流动。当不需要从客户端向服务器发送信息时，比如更新社交媒体状态、新闻推送或把数据传送到客户端存储（如IndexedDB或Web Storage），SSE就非常适合。</p><p>与SSE不同的是，WebSocket提供了一个更强大的双向通信通道，允许客户端和服务器之间互相发送信息。SSE则是单向的，主要用于服务器向浏览器发送信息。如果浏览器需要向服务器发送信息，它必须发起一个新的HTTP请求。</p><p>这里有几个关于SSE和WebSocket的区别：</p><ul><li>SSE基于HTTP，因此所有现有的服务器软件都能支持它；而WebSocket是一个独立的协议。</li><li>SSE设置起来简单得多，适合轻量级应用；WebSocket则更为复杂。</li><li>SSE自带断线重连功能，而WebSocket需要开发者自己实现这一功能。</li><li>SSE主要用于传输文本数据，若要发送二进制数据则需编码；WebSocket直接支持二进制数据传输。</li><li>SSE允许自定义消息类型，增加了灵活性。</li></ul><h3 id="事件流格式"><a href="#事件流格式" class="headerlink" title="事件流格式"></a>事件流格式</h3><p>事件流是一个简单的文本数据流，文本应该使用UTF-8格式的编码。事件流中的消息由一对换行符分开。以冒号开头的行为注释行，会被忽略。</p><p><strong>备注：</strong> 注释行可以用来防止连接超时，服务器可以定期发送一条消息注释行，以保持连接不断。</p><p>每条消息由一行或多行文字组成，列出该消息的字段。每个字段由字段名表示，后面是冒号，然后是该字段值的文本数据。</p><p>规范中规定了下面这些字段：</p><ul><li><p>event</p><p>一个用于标识事件类型的字符串。如果指定了这个字符串，浏览器会将具有指定事件名称的事件分派给相应的监听器；网站源代码应该使用 <code>addEventListener()</code> 来监听指定的事件。如果一个消息没有指定事件名称，那么 <code>onmessage</code> 处理程序就会被调用。</p></li><li><p>data</p><p>消息的数据字段。当 <code>EventSource</code> 接收到多个以 <code>data:</code> 开头的连续行时，<a href="https://html.spec.whatwg.org/multipage/#dispatchMessage">会将它们连接起来</a>，在它们之间插入一个换行符。末尾的换行符会被删除。</p></li><li><p>id</p><p>事件 ID，会成为当前 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource"><code>EventSource</code></a> 对象的内部属性“最后一个事件 ID”的属性值。</p></li><li><p>retry</p><p>重新连接的时间。如果与服务器的连接丢失，浏览器将等待指定的时间，然后尝试重新连接。这必须是一个整数，以毫秒为单位指定重新连接的时间。如果指定了一个非整数值，该字段将被忽略。</p></li></ul><p>所有其他的字段名都会被忽略</p><h3 id="事件流具体例子"><a href="#事件流具体例子" class="headerlink" title="事件流具体例子"></a>事件流具体例子</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/event-stream</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>每一次发送的信息，由若干个<code>message</code>组成，每个<code>message</code>之间用<code>\n\n</code>分隔。每个<code>message</code>内部由若干行组成，每一行都是如下格式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">field</span>]: <span class="link">value\n</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">: comment</span><br><span class="line">id: 2025\n </span><br><span class="line">event: foo\n</span><br><span class="line">retry: 100\n \\指定浏览器重新发起连接的时间间隔。</span><br><span class="line">data: This is the mesage\n</span><br><span class="line">data: test\n</span><br><span class="line">data: this is the end\n\n</span><br></pre></td></tr></table></figure><p>在浏览器上<code>lastEventId</code>属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的<code>Last-Event-ID</code>头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p><h4 id="命名事件"><a href="#命名事件" class="headerlink" title="命名事件"></a>命名事件</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">event: userconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: userdisconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:23&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;sean&quot;, &quot;time&quot;: &quot;02:34:36&quot;, &quot;text&quot;: &quot;Bye, bobby.&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个事件都有一个由 <code>event</code> 字段指定的事件名称和一个 <code>data</code> 字段，其值是一个适当的 JSON 字符串，包含客户端对该事件采取行动所需的数据。<code>data</code> 字段可以包含任何字符串数据，它不一定是 JSON。</p><h4 id="混合两种事件"><a href="#混合两种事件" class="headerlink" title="混合两种事件"></a>混合两种事件</h4><p>可以在一个事件流中同时使用命名事件和未命名事件。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">event: userconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;&#125;</span><br><span class="line"></span><br><span class="line">data: Here&#x27;s a system message of some kind that will get used</span><br><span class="line">data: to accomplish some task.</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><p>默认情况下，如果客户端和服务器之间的连接关闭，则连接将重新启动。可以使用 <code>.close()</code> 方法终止连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">&quot;xxx&quot;</span>);<span class="comment">//url可以与当前网址同域，也可以跨域。</span></span><br><span class="line">evtSource.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line">evtSource.onerror = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;EventSource failed:&quot;</span>, err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义事件</span></span><br><span class="line">source.addEventListener(<span class="string">&#x27;foo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// handle message</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">date_default_timezone_set(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">header(<span class="string">&quot;Cache-Control: no-store&quot;</span>);</span><br><span class="line">header(<span class="string">&quot;Content-Type: text/event-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$counter</span> = rand(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// Every second, send a &quot;ping&quot; event.</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;event: ping\n&quot;</span>; <span class="comment"># 声明事件</span></span><br><span class="line">  <span class="variable">$curDate</span> = date(DATE_ISO8601);</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;data: &#123;&quot;time&quot;: &quot;&#x27;</span> . <span class="variable">$curDate</span> . <span class="string">&#x27;&quot;&#125;&#x27;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;\n\n&quot;</span>;  <span class="comment"># 一个事件结束</span></span><br><span class="line">  <span class="comment">// Send a simple message at random intervals.</span></span><br><span class="line">  <span class="variable">$counter</span>--;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable">$counter</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;data: This is a message at time &#x27;</span> . <span class="variable">$curDate</span> . <span class="string">&quot;\n\n&quot;</span>; <span class="comment"># 默认onmessage事件处理</span></span><br><span class="line">    <span class="variable">$counter</span> = rand(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ob_end_flush();</span><br><span class="line">  flush();</span><br><span class="line">  <span class="comment">// Break the loop if the client aborted the connection (closed the page)</span></span><br><span class="line">  <span class="keyword">if</span> (connection_aborted()) <span class="keyword">break</span>;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Using server-sent events - Web APIs | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket - Web APIs | MDN</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程 - 阮一峰的网络日志</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">Server-Sent Events 教程 - 阮一峰的网络日志</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在看LLM的流式输出如何反映到json输出上,现有的解决方案包括 WebSocket 或 Server-Sent Events (SSE) 实时通信技术.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Learn OpenGL(二):模型加载与高级OpenGL</title>
    <link href="https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/"/>
    <id>https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/</id>
    <published>2024-12-27T14:19:31.000Z</published>
    <updated>2025-01-07T13:59:29.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从手动设置顶点坐标到加载模型以及OpenGL高级技巧<br><span id="more"></span></p><h2 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h2><p>通过一些建模软件,比如Blender,可以方便地对一些复杂物体进行建模并导出为模型,而这些模型文件包含许多信息,比如顶点坐标,法线以及纹理坐标.</p><p>不同的模型文件格式封装的信息也不同.常见的有<code>.obj</code>，<code>.fbx</code>,<code>s.tl</code>等等</p><p>通常使用<code>Assimp</code>加载模型,Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），<strong>它会将所有的模型数据加载至Assimp的通用数据结构中</strong>。当Assimp加载完模型之后就能够从Assimp的数据结构中提取我们所需的所有数据了。</p><p>由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问需要的数据。</p><p>当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型/场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。</p><p><img data-src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt="img"></p><ul><li>和材质,网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li><li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li><li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li><li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的</li><li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）</li></ul><p>使用Assimp可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。我们从上一节中学到，网格(Mesh)代表的是单个的可绘制实体</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20241228205757945.png" alt="image-20241228205757945"></p><p>一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">  glm::vec3 position;</span><br><span class="line">   glm::vec3 norm;</span><br><span class="line">    glm::vec2 textcoord;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    std::string type;</span><br><span class="line">    aiString dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    std::vector&lt;Texture&gt; textures;</span><br><span class="line">    std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">// 处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::vector&lt;Mesh&gt; meshes;</span><br><span class="line">    std::vector&lt;Textures&gt; loadad_textures;</span><br><span class="line">   <span class="comment">// 处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><blockquote><p><strong>提前深度测试</strong></p><p>提前深度测试允许深度测试<strong>在片段着色器之前运行。只要清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</strong></p><p>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。<strong>当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。</strong>OpenGL不能提前知道深度值。</p></blockquote><p>​    <strong>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息</strong>，并且（通常）和颜色缓冲有着一样的宽度和高度。<strong>深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值</strong>。在大部分的系统中，深度缓冲的精度都是24位的。</p><p>​    当深度测试(Depth Testing)被启用的时候，<strong>OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值</strong>。如果深度测试失败了，片段将会被丢弃。</p><p>​    <strong>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后）在屏幕空间中运行的。</strong>屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以<strong>直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问</strong>。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。</p><p>深度测试默认是禁用的，所以如果要启用深度测试的话用GL_DEPTH_TEST选项来启用它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>当它启用的时候，如果一个片段通过了深度测试的话，OpenGL会在深度缓冲中储存该片段的z值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则会仍在使用上一次渲染迭代中的写入的深度值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但<strong>不</strong>希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。<strong>OpenGL允许禁用深度缓冲的写入，只需要设置它的深度掩码</strong>(Depth Mask)设置为<code>GL_FALSE</code>就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br></pre></td></tr></table></figure><p>注意这只在深度测试被启用的时候才有效果。</p><p>OpenGL允许修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDepthFunc</span>(GL_LESS);</span><br></pre></td></tr></table></figure><p>默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_ALWAYS</td><td style="text-align:left">永远通过深度测试</td></tr><tr><td style="text-align:left">GL_NEVER</td><td style="text-align:left">永远不通过深度测试</td></tr><tr><td style="text-align:left">GL_LESS</td><td style="text-align:left">在片段深度值小于缓冲的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_EQUAL</td><td style="text-align:left">在片段深度值等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_LEQUAL</td><td style="text-align:left">在片段深度值小于等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_GREATER</td><td style="text-align:left">在片段深度值大于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_NOTEQUAL</td><td style="text-align:left">在片段深度值不等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_GEQUAL</td><td style="text-align:left">在片段深度值大于等于缓冲区的深度值时通过测试</td></tr></tbody></table></div><h4 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h4><p>深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的<strong>近平面</strong>(Near)和<strong>远平面</strong>(Far)之间的任何值。</p><p>在透视矩阵中的znear和zfar决定了哪些坐标在视锥体中,我们将处在这个范围的顶点坐标z值转换到[0,1]之间. 一种简单的方式就是使用线性变换</p><script type="math/tex; mode=display">F_{\text {depth }}=\frac{z-n e a r}{f a r-n e a r}</script><p><img data-src="https://learnopengl-cn.github.io/img/04/01/depth_linear_graph.png" alt="img"></p><p>在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度</p><script type="math/tex; mode=display">F_{\text {depth }}=\frac{1 / z-1 / \text { near }}{1 / \text { far }-1 / \text { near }}</script><p>深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。</p><p><img data-src="https://learnopengl-cn.github.io/img/04/01/depth_non_linear_graph.png" alt="img"></p><p>可以将本身的非线性深度值转为线性深度值</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> near = <span class="number">0.1</span>; </span><br><span class="line"><span class="type">float</span> far  = <span class="number">100.0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">float</span> LinearizeDepth(<span class="type">float</span> depth) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near * far) / (far + near - z * (far - near));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">float</span> depth = LinearizeDepth(<span class="built_in">gl_FragCoord</span>.z) / far; <span class="comment">// 为了演示除以 far</span></span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(depth), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h4><p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，<strong>深度缓冲没有足够的精度来决定两个形状哪个在前面</strong>。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p><p>​    箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。</p><p>​    深度冲突是深度缓冲的一个常见问题，<strong>当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突</strong></p><p><strong>防止深度冲突</strong></p><p>第一个也是最重要的技巧是<strong>永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠</strong>。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，<strong>可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生</strong>。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p><p>第二个技巧是<strong>尽可能将近平面设置远一些</strong>。精度在靠近<strong>近</strong>平面时是非常高的，<strong>所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度</strong>。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的<strong>近</strong>平面距离。</p><p>另外一个很好的技巧是牺牲一些性能，<strong>使用更高精度的深度缓冲</strong>。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p><h2 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h2><p>​    当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。<strong>模板测试是根据又一个缓冲来进行的，它叫做模板缓冲(Stencil Buffer)，可以在渲染的时候更新它来获得一些很有意思的效果。</strong></p><p>​    <strong>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值</strong>。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了</p><blockquote><p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p></blockquote><p>模板缓冲操作允许在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们<strong>写入</strong>了模板缓冲。在同一个（或者接下来的）渲染迭代中，可以<strong>读取</strong>这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：</p><ul><li>启用模板缓冲的写入。</li><li>渲染物体，更新模板缓冲的内容。</li><li>禁用模板缓冲的写入。</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); <span class="comment">// 每一位写入模板缓冲时都保持原样</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br></pre></td></tr></table></figure><p>glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为<code>0x00</code>，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的</p><h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p>一共有两个函数能够用来配置模板测试：glStencilFunc和glStencilOp</p><p>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：</p><ul><li><code>func</code>：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的<code>ref</code>值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li><li><code>ref</code>：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li><li><code>mask</code>：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1</li></ul><p>如何更新缓冲就需要glStencilOp函数</p><p>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，能够设定每个选项应该采取的行为：</p><ul><li><code>sfail</code>：模板测试失败时采取的行为。</li><li><code>dpfail</code>：模板测试通过，但深度测试失败时采取的行为。</li><li><code>dppass</code>：模板测试和深度测试都通过时采取的行为。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">行为</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_KEEP</td><td style="text-align:left">保持当前储存的模板值</td></tr><tr><td style="text-align:left">GL_ZERO</td><td style="text-align:left">将模板值设置为0</td></tr><tr><td style="text-align:left">GL_REPLACE</td><td style="text-align:left">将模板值设置为glStencilFunc函数设置的<code>ref</code>值</td></tr><tr><td style="text-align:left">GL_INCR</td><td style="text-align:left">如果模板值小于最大值则将模板值加1</td></tr><tr><td style="text-align:left">GL_INCR_WRAP</td><td style="text-align:left">与GL_INCR一样，但如果模板值超过了最大值则归零</td></tr><tr><td style="text-align:left">GL_DECR</td><td style="text-align:left">如果模板值大于最小值则将模板值减1</td></tr><tr><td style="text-align:left">GL_DECR_WRAP</td><td style="text-align:left">与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td></tr><tr><td style="text-align:left">GL_INVERT</td><td style="text-align:left">按位翻转当前的模板缓冲值</td></tr></tbody></table></div><p>默认情况下glStencilOp是设置为<code>(GL_KEEP, GL_KEEP, GL_KEEP)</code>的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</p><p>通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃</p><h3 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h3><p>模板测试的一个重要应用就是人为选择需要绘制的区域. 如果要绘制一个物体的轮廓,画这个物体时更新模板缓冲为1,然后画一个更大的物体,设置模板缓冲函数,让模板测试是不等于1的位置. 则只会显示轮廓区域.</p><p>重要的几点:</p><ol><li>先进行模板测试后进行深度测试. 在这两个测试都开启时且不使用glDepthMask则在后面的物体是无法通过模板函数显示在前面的</li><li>模板测试的glStencilFunc设置的是模板测试成功条件,也就是怎样才能显示图形以及显示哪一部分图形. 比如设置当模板缓冲的值大于1时则模板测试通过. glStencilOp设置的是如何更新模板缓冲.</li></ol><p>注意:</p><ol><li>模板掩码(Stencil Mask)对 glClear 的影响:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置模板掩码</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>);  <span class="comment">// 允许写入所有位</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class="comment">// 正常清除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>);  <span class="comment">// 禁止写入</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class="comment">// 不会清除模板缓冲</span></span><br></pre></td></tr></table></figure><ol><li>清除模板缓冲区的值设置:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置清除值</span></span><br><span class="line"><span class="built_in">glClearStencil</span>(<span class="number">1</span>);  <span class="comment">// 设置清除值为1</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class="comment">// 用1填充模板缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多缓冲区同时清除</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></td></tr></table></figure><ol><li><p>```c++<br>// 错误示范<br>glStencilMask(0x00);<br>glClear(GL_STENCIL_BUFFER_BIT);  // 无效的清除</p><p>// 正确做法<br>glStencilMask(0xFF);  // 确保清除前设置正确的掩码<br>glClear(GL_STENCIL_BUFFER_BIT);<br>glStencilMask(0x00);  // 之后再改回所需的掩码值</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## 混合</span></span><br><span class="line"></span><br><span class="line">​OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。</span><br><span class="line"></span><br><span class="line">​**一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色**。这也是混合这一名字的出处，混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 Alpha通道表示不透明度,值越大越不透明.</span><br><span class="line"></span><br><span class="line"><span class="meta">### 丢弃片段</span></span><br><span class="line"></span><br><span class="line">如果你有一个纹理，其中某些部分是完全透明的，你可以根据纹理的颜色 alpha 分量来决定是否丢弃片段。例如，对于 alpha 值小于某个阈值的片段，你可以选择将其丢弃，从而实现不规则形状的物体渲染。</span><br><span class="line"></span><br><span class="line">此外,有时你可能想要根据一些条件裁剪掉不需要的部分。比如，在绘制树叶或草地的时候，可能会根据距离相机的距离或者其他条件来决定是否绘制特定的片段。</span><br><span class="line"></span><br><span class="line">加载纹理之后,如果纹理带有alpha通道,可以通过通道值选择是否渲染这个片段. </span><br><span class="line"></span><br><span class="line">```glsl</span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">    <span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    FragColor = texColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>设置距离丢弃条件,太远就丢弃</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 400 core</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span>  TextCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec4</span> textColor = <span class="built_in">texture</span>(texture1,TextCoord);</span><br><span class="line">    <span class="keyword">if</span> (textColor.a &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> dis = <span class="built_in">distance</span>(FragPos,viewPos);</span><br><span class="line">    <span class="keyword">if</span>(dis&gt; <span class="number">15.0</span>)&#123;</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor = textColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，当采样纹理的边缘的时候，OpenGL<strong>会对边缘的值和纹理下一个重复的值进行插值</strong>（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，可以启用GL_BLEND来启用混合</p><p>OpenGL中的混合是通过下面这个方程来实现的：</p><script type="math/tex; mode=display">\bar{C}_{\text {result }}=\bar{C}_{\text {source }} * F_{\text {source }}+\bar{C}_{\text {destination }} * F_{\text {destination }}</script><p><img data-src="https://learnopengl-cn.github.io/img/04/03/blending_equation_mixed.png" alt="img"></p><ul><li>C_source：源颜色向量。这是<strong>源自纹理的颜色向量</strong>。</li><li>C_destination：目标颜色向量。这是<strong>当前储存在颜色缓冲中的颜色向量</strong>。</li><li>F_source：源因子值。指定了alpha值对源颜色的影响。</li><li>F_destination：目标因子值。指定了alpha值对目标颜色的影响</li></ul><p>使用<code>glBlendFunc</code>设置因子值,glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项，我们将在下面列出大部分最常用的选项。注意常数颜色向量C¯constantC¯constant可以通过glBlendColor函数来另外设置。</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left"><code>GL_ZERO</code></td><td style="text-align:left">因子等于00</td></tr><tr><td style="text-align:left"><code>GL_ONE</code></td><td style="text-align:left">因子等于11</td></tr><tr><td style="text-align:left"><code>GL_SRC_COLOR</code></td><td style="text-align:left">因子等于源颜色向量C¯sourceC¯source</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_SRC_COLOR</code></td><td style="text-align:left">因子等于1−C¯source1−C¯source</td></tr><tr><td style="text-align:left"><code>GL_DST_COLOR</code></td><td style="text-align:left">因子等于目标颜色向量C¯destinationC¯destination</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_DST_COLOR</code></td><td style="text-align:left">因子等于1−C¯destination1−C¯destination</td></tr><tr><td style="text-align:left"><code>GL_SRC_ALPHA</code></td><td style="text-align:left">因子等于C¯sourceC¯source的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_SRC_ALPHA</code></td><td style="text-align:left">因子等于1−1− C¯sourceC¯source的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_DST_ALPHA</code></td><td style="text-align:left">因子等于C¯destinationC¯destination的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_DST_ALPHA</code></td><td style="text-align:left">因子等于1−1− C¯destinationC¯destination的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_CONSTANT_COLOR</code></td><td style="text-align:left">因子等于常数颜色向量C¯constantC¯constant</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_CONSTANT_COLOR</code></td><td style="text-align:left">因子等于1−C¯constant1−C¯constant</td></tr><tr><td style="text-align:left"><code>GL_CONSTANT_ALPHA</code></td><td style="text-align:left">因子等于C¯constantC¯constant的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_CONSTANT_ALPHA</code></td><td style="text-align:left">因子等于1−1− C¯constantC¯constant的alphaalpha分量</td></tr></tbody></table></div><p>注意常数颜色向量C_constant可以通过glBlendColor函数来另外设置。</p><p>为了获得之前两个方形的混合结果，我们需要使用源颜色向量的alpha作为源因子，使用1−alpha作为目标因子。这将会产生以下的glBlendFunc：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure><p>也可以使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFuncSeparate</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);</span><br></pre></td></tr></table></figure><p>允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项：</p><ul><li>GL_FUNC_ADD：默认选项，将两个分量相加：</li><li>GL_FUNC_SUBTRACT：将两个分量相减： </li><li>GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：</li></ul><p>通常都可以省略调用glBlendEquation</p><h3 id="渲染半透明纹理"><a href="#渲染半透明纹理" class="headerlink" title="渲染半透明纹理"></a>渲染半透明纹理</h3><p>初始化时我们启用混合，并设定相应的混合函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure><p>由于启用了混合，我们就不需要丢弃片段了，所以我们把片段着色器还原：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可能跟绘图顺序有关.深度测试和混合一起使用的话会产生一些麻烦。当<strong>写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中</strong>。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 也就是说</p><p>要想保证窗户中能够显示它们背后的物体，我们需要首先绘制背后的这部分物体。这也就是说在绘制的时候，必须先手动将窗户按照最远到最近来排序，再按照顺序渲染.</p><blockquote><p>注意，对于草这种全透明的物体，可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）</p></blockquote><h3 id="不要打扰顺序"><a href="#不要打扰顺序" class="headerlink" title="不要打扰顺序"></a>不要打扰顺序</h3><p>​    <strong>要想让混合在多个物体上工作，需要最先绘制最远的物体，最后绘制最近的物体</strong>。</p><p>​    普通<strong>不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序</strong>。但<strong>仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了</strong>。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：</p><ol><li><p>先绘制所有不透明的物体。</p></li><li><p>对所有透明的物体排序。</p></li><li><p>按顺序绘制所有透明的物体</p></li></ol><p>​    排序透明物体的一种方法是，<strong>从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得</strong>。</p><p>​    接下来把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。</p><p>​    在渲染的时候以逆序（从远到近）从map中获取值，之后以正确的顺序绘制对应的窗户.</p><p>​    虽然按照距离排序物体这种方法对这个场景能够正常工作，<strong>但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。</strong></p><p>​    在场景中排序物体是一个很困难的技术，很大程度上由场景的类型所决定，更别说它额外需要消耗的处理能力了。<strong>完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有次序无关透明度</strong>(Order Independent Transparency, OIT)</p><h2 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h2><p>想象任何一个闭合形状，它的每一个面都有两侧，每一侧要么<strong>面向</strong>用户，要么背对用户。如果我们能够只绘制<strong>面向</strong>观察者的面呢？</p><p>这正是面剔除(Face Culling)所做的。OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，<strong>分析顶点数据的环绕顺序(Winding Order)。</strong></p><h4 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h4><p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，会从三角形中间来看，为这3个顶点设定一个环绕顺序。</p><p><strong>每组组成三角形图元的三个顶点就包含了一个环绕顺序</strong>。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。</p><p><strong>默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</strong>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从<strong>观察者视角</strong>所见的了。</p><h4 id="面剔除-1"><a href="#面剔除-1" class="headerlink" title="面剔除"></a>面剔除</h4><p>OpenGL能够丢弃那些渲染为背向三角形的三角形图元。既然已经知道如何设置顶点的环绕顺序了，我们就可以使用OpenGL的面剔除选项了，它默认是禁用状态的。</p><p>在之前教程中使用的立方体顶点数据并不是按照逆时针环绕顺序定义的，所以顶点数据反映了环绕顺序从而反应是正向面和背向面.</p><p>要想启用面剔除，我们只需要启用OpenGL的GL_CULL_FACE选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br></pre></td></tr></table></figure><p>从这一句代码之后，所有背向面都将被丢弃（尝试飞进立方体内部，看看所有的内面是不是都被丢弃了）。目前我们在渲染片段的时候能够节省50%以上的性能，但注意这只对像立方体这样的封闭形状有效。</p><p>OpenGL允许我们改变需要剔除的面的类型。我们可以调用glCullFace来定义这一行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br></pre></td></tr></table></figure><p>glCullFace函数有三个可用的选项：</p><ul><li><code>GL_BACK</code>：只剔除背向面。</li><li><code>GL_FRONT</code>：只剔除正向面。</li><li><code>GL_FRONT_AND_BACK</code>：剔除正向面和背向面。</li></ul><p>glCullFace的初始值是GL_BACK。除了需要剔除的面之外，也可以通过调用glFrontFace，告诉OpenGL我们希望将顺时针的面（而不是逆时针的面）定义为正向面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glFrontFace</span>(GL_CCW);</span><br></pre></td></tr></table></figure><p>默认值是GL_CCW，它代表的是逆时针的环绕顺序，另一个选项是GL_CW，它（显然）代表的是顺时针顺序。</p><p>我们可以来做一个实验，告诉OpenGL现在顺时针顺序代表的是正向面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK);</span><br><span class="line"><span class="built_in">glFrontFace</span>(GL_CW);</span><br></pre></td></tr></table></figure><h2 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h2><p>​    现在已经使用了很多屏幕缓冲了：用于<strong>写入颜色值的颜色缓冲</strong>、用于<strong>写入深度信息的深度缓冲</strong>和允许我们<strong>根据一些条件丢弃特定片段的模板缓冲</strong>。这些缓冲<strong>结合起来叫做帧缓冲(</strong>Framebuffer)</p><p>​    它被<strong>储存在GPU内存</strong>中的某处。<strong>OpenGL允许我们定义我们自己的帧缓冲，也就是说能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲</strong>。</p><p>​    目前所做的<strong>所有操作都是在默认帧缓冲的渲染缓冲上进行的</strong>。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。通过创建自己的帧缓冲，我们可以获得额外的渲染目标(target)。</p><p>渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果</p><h4 id="创建帧缓冲"><a href="#创建帧缓冲" class="headerlink" title="创建帧缓冲"></a>创建帧缓冲</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gluint fbo;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>,&amp;fbo);</span><br><span class="line"><span class="built_in">glBindFrameBuffer</span>(GL_FRAMEBUFFER，fbo);</span><br></pre></td></tr></table></figure><p>在绑定到GL_FRAMEBUFFER目标之后，所有的<strong>读取</strong>和<strong>写入</strong>帧缓冲的操作将会影响当前绑定的帧缓冲。<strong>也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标</strong>。绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上</p><p>一个完整的帧缓冲需要满足以下的条件：</p><ul><li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li><li>至少有一个颜色附件(Attachment)。</li><li>所有的附件都必须是完整的（保留了内存）。</li><li>每个缓冲都应该有相同的样本数(sample)</li></ul><p>​    需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以GL_FRAMEBUFFER为参数调用glCheckFramebufferStatus，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是GL_FRAMEBUFFER_COMPLETE，帧缓冲就是完整的了</p><p>​    <strong>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中</strong>。由于帧缓冲不是默认帧缓冲，<strong>渲染指令将不会对窗口的视觉输出有任何影响</strong>。出于这个原因，<strong>渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到<code>0</code>。</strong></p><p>​    在完整性检查执行之前，<strong>需要给帧缓冲附加一个附件。附件是一个内存位置，它能够作为帧缓冲的一个缓冲</strong>，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer Object)。</p><h4 id="纹理附件"><a href="#纹理附件" class="headerlink" title="纹理附件"></a>纹理附件</h4><p>想象帧缓冲(FBO)是一个画框，纹理附件就是可以放进这个画框的”画布”。这些”画布”可以用来：</p><ul><li>存储颜色(类似照片)</li><li>存储深度(物体的远近信息)</li><li>存储模板值(用于特效)</li></ul><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就像它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，<strong>所有渲染操作的结果将会被储存在一个纹理图像中，之后可以在着色器中很方便地使用它。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>,&amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D,texture);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_RGB,<span class="number">800</span>,<span class="number">600</span>,<span class="number">0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 添加颜色纹理附件</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>对于深度和模板缓冲格式不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_DEPTH_COMPONENT,<span class="number">800</span>,<span class="number">600</span>,<span class="number">0</span>,GL_DEPTH_COMPONENT,GL_UNSIGNED_BYTE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 添加深度纹理附件</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_STENCIL_INDEX,<span class="number">800</span>,<span class="number">600</span>,<span class="number">0</span>,GL_STENCIL_INDEX,GL_UNSIGNED_BYTE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 添加模板纹理附件</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h4><p>​    和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，<strong>它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</strong></p><p>​    <strong>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。</strong>然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>,&amp;rbo);</span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER,rbo);</span><br><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER,GL_DEPTH24_STENCIL8,<span class="number">800</span>,<span class="number">600</span>);</span><br><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER,GL_DEPTH_STENCIL_ATTACHMENT,GL_RENDERBUFFER,rbo);</span><br></pre></td></tr></table></figure><p>由于<strong>渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间都不需要从深度和模板缓冲中读取值</strong>，只关心深度和模板测试。我们<strong>需要</strong>深度和模板值用于测试，但不需要对它们进行<strong>采样</strong>，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p><h4 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h4><p>要想绘制场景到一个纹理上，我需要采取以下的步骤：</p><ol><li>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景</li><li>绑定默认的帧缓冲</li><li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</li></ol><p>将帧缓冲的颜色渲染到默认缓冲的纹理上</p><h4 id="反相"><a href="#反相" class="headerlink" title="反相"></a>反相</h4><p>将纹理颜色反相</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="number">1.0</span> - <span class="built_in">texture</span>(screenTexture, TexCoords)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(screenTexture, TexCoords);</span><br><span class="line">    <span class="type">float</span> average = <span class="number">0.2126</span> * FragColor.r + <span class="number">0.7152</span> * FragColor.g + <span class="number">0.0722</span> * FragColor.b;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(average, average, average, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> <span class="keyword">offset</span> = <span class="number">1.0</span> / <span class="number">300.0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> offsets[<span class="number">9</span>] = <span class="type">vec2</span>[](</span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 左上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="keyword">offset</span>), <span class="comment">// 正上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 右上</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 左</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="number">0.0</span>f),   <span class="comment">// 中</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 右</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>, -<span class="keyword">offset</span>), <span class="comment">// 左下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,   -<span class="keyword">offset</span>), <span class="comment">// 正下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>, -<span class="keyword">offset</span>)  <span class="comment">// 右下</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kernel[<span class="number">9</span>] = <span class="type">float</span>[](</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">9</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> sampleTex[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sampleTex[i] = <span class="type">vec3</span>(<span class="built_in">texture</span>(screenTexture, TexCoords.st + offsets[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> col = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        col += sampleTex[i] * kernel[i];</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有模糊、边缘检测等效果,都是利用卷积核.</p><h2 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h2><p>立方体贴图(Cube Map)是将多个纹理组合起来映射到一张纹理上的一种纹理类型.  </p><p>立方体贴图的坐标至关重要,通过一个方向向量进行索引. 方向向量原点位于立方体中心</p><p><img data-src="https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png" alt="img"></p><p>假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; textures_faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="built_in">stbi_load</span>(textures_faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(</span><br><span class="line">        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">        <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure><p>立方体纹理最常用的就是天空盒,而天空盒的核心就是将贴图用在一个立方体上并通过深度测试将贴图作为背景.  一个简单的方法就是利用<code>glDepthMask</code>,首先渲染天空盒,在绘制其他物体之前再启动Mask,更新深度缓冲.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br><span class="line">skyboxShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="comment">// ... 设置观察和投影矩阵</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(skyboxVAO);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, cubemapTexture);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_TRUE);</span><br><span class="line"><span class="comment">// ... 绘制剩下的场景</span></span><br></pre></td></tr></table></figure><p>注意到天空盒的大部分可能会被其他物体覆盖,通过提前深度测试,将已知的深度较大的物体在之后绘制,这样在片段着色器运行之前就直到被其他物体””盖住”了. 因为天空盒总是在最后,设置其z在透视变换后为1即可,在片段着色器中设置其z为w.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> pos = projection * view * <span class="type">vec4</span>(position, <span class="number">1.0</span>); <span class="comment">// view矩阵取消了移动,projection矩阵只对z进行了缩放,而之后通过透视除法将z设置为了1</span></span><br><span class="line">   <span class="built_in">gl_Position</span> = pos.xyww;</span><br></pre></td></tr></table></figure><h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>我们现在<strong>将整个环境映射到了一个纹理对象</strong>上了，能利用这个信息的不仅仅只有天空盒。通过使用环境的立方体贴图，<strong>可以给物体反射和折射的属性。这样使用环境立方体贴图的技术叫做环境映射</strong>(Environment Mapping)，其中最流行的两个是反射(Reflection)和折射(Refraction)。</p><p><img data-src="https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_theory.png" alt="img"></p><p>反射通过眼睛与物体法线向量得到的反射向量对立方体纹理采样</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="type">vec3</span> CalcEnvReflectLight(<span class="type">vec3</span> viewDir,<span class="type">vec3</span> norm) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="built_in">texture</span>(skybox,<span class="built_in">reflect</span>(-viewDir,norm)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当反射应用到一整个物体上时，这个物体看起来就像是钢或者铬这样的高反射性材质. 在现实中大部分的模型都不具有完全反射性。<strong>可以引入反射贴图(Reflection Map)，来给模型更多的细节。与漫反射和镜面光贴图一样，反射贴图也是可以采样的纹理图像，它决定这片段的反射性</strong>。通过使用反射贴图，可以知道模型的哪些部分该以什么强度显示反射。</p><p><img data-src="https://s2.loli.net/2025/01/05/kCJ4toqla1Vy8FL.png" alt="image-20250105144159047"></p><p>环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。</p><p><img data-src="https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction_theory.png" alt="img"></p><p>折射率是光在真空中的传播速度与光在该介质中的传播速度之比,光从介质1射入介质2发生折射时，入射角与折射角的正弦之比叫做介质2相对介质1的折射率. 折射率越大,光线扭曲程度越大. 有一个观察向量I¯，一个法向量N¯，而这次是折射向量R¯。</p><p>观察向量的方向轻微弯曲了。弯折后的向量R¯R¯将会用来从立方体贴图中采样。折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。</p><p>假设看向水面,折射率就是在空气中的折射率/在水中的折射率.</p><p><img data-src="https://s2.loli.net/2025/01/05/qVRmaAPHS14loCg.png" alt="image-20250105144121316"></p><h4 id="动态环境贴图"><a href="#动态环境贴图" class="headerlink" title="动态环境贴图"></a>动态环境贴图</h4><p>​    现在使用的都是静态图像的组合来作为天空盒，看起来很不错，但它<strong>没有在场景中包括可移动的物体</strong>。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</p><p>​    <strong>通过使用帧缓冲能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic Environment Mapping)，因为动态创建了物体周围的立方体贴图，并将其用作环境贴图。</strong></p><p>​    但它有一个很大的缺点：<strong>需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图</strong>，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p><h2 id="高级数据"><a href="#高级数据" class="headerlink" title="高级数据"></a>高级数据</h2><p>缓冲有不同的类型,比如GL_ARRAY_BUFFER,GL_ELEMENT_BUFFER. 不同缓冲有不同用处. 当<code>glGenBuffers()</code>创建缓冲对象后,需要绑定相应类型才有意义. </p><h3 id="填充缓冲数据"><a href="#填充缓冲数据" class="headerlink" title="填充缓冲数据"></a>填充缓冲数据</h3><p>glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的<code>data</code>参数设置为<code>NULL</code>，那么这个函数将只会分配内存，但不进行填充。这在我们需要<strong>预留</strong>(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER,,<span class="built_in"><span class="keyword">sizeof</span></span>(vertices),<span class="literal">NULL</span>,GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER,<span class="number">24</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(data),&amp;data);</span><br></pre></td></tr></table></figure><p>除了使用一次函数调用填充整个缓冲之外，也可以使用glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从<strong>何处</strong>开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</p><p>此外可以获得指向内存的指针,通过一些内存函数进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="keyword">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in"><span class="keyword">sizeof</span></span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in modern c++ </span></span><br><span class="line">  <span class="keyword">auto</span> ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_READ_WRITE);</span><br><span class="line">  std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(skyboxVertices), std::<span class="built_in">end</span>(skyboxVertices),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line">  <span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure><p>使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。<strong>在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE</strong></p><h3 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h3><p>假设数据如下,表示一个点的三种属性,通过glBufferData加载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">      <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>,</span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>,</span><br><span class="line">      <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">-0.5f</span>, <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STREAM_DRAW);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span> *)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)(<span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer设置了解析这些数据的方式,其中3表示这个属性有几个值,8*sizeof(float)表示下一个点的相同属性的距离,0是偏移量.</p><p>假设读入数据布局不同,比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">      <span class="comment">// positions                 </span></span><br><span class="line">     <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">      <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>,</span><br><span class="line">       <span class="comment">// normals </span></span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, </span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.5f</span>, </span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, </span><br><span class="line">       <span class="comment">// texture coords</span></span><br><span class="line">      <span class="number">-1.0f</span>, <span class="number">1.0f</span>,   </span><br><span class="line">      <span class="number">0.5f</span>,  <span class="number">0.5f</span>,   </span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">0.0f</span>, ,&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)(<span class="number">9</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)(<span class="number">18</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br></pre></td></tr></table></figure><p>此外可以通过<code>glBufferSubData</code>将数据从分别的数据加载到缓冲中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(positions), <span class="built_in"><span class="keyword">sizeof</span></span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(positions) + <span class="built_in"><span class="keyword">sizeof</span></span>(normals), <span class="built_in"><span class="keyword">sizeof</span></span>(tex), &amp;tex);</span><br></pre></td></tr></table></figure><h4 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h4><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。 这可以通过刚才的glMapBuffer实现. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GLuint vbo1, vbo2;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo1);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo2);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="keyword">float</span> data[] =&#123;<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo2);</span><br><span class="line">ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_READ_ONLY);</span><br><span class="line"><span class="keyword">float</span> data1[<span class="number">12</span>];</span><br><span class="line">std::<span class="built_in">copy</span>(data1, data1 + <span class="number">12</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class="line">ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure><p>但通过<code>glCopyBufferSubData</code>更方便.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                         GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>readtarget</code>和<code>writetarget</code>参数需要填入复制源和复制目标的缓冲目标。比如可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p><p>但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。<strong>OpenGL提供另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。</strong>接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vertexData));</span><br></pre></td></tr></table></figure><p>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vertexData));</span><br></pre></td></tr></table></figure><h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>​    <strong>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点</strong>。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，<strong>它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。</strong></p><p>首先定义在c++中绘画命令指定的图元类型,比如<code>GLDrawArrays(GL_POINTS,0,4)</code>绘画点图元,而几何着色器能够作为顶点和片段着色器之间的桥梁,能够增删/修改点的属性. out定义输出的图元以及最多的定点数.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">2</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何着色器需要声明输入和输出的图元类型，以处理从顶点着色器接收的数据并生成新的几何图形。对于输入图元类型，在<code>in</code>关键字前使用布局修饰符（Layout Qualifier），可接收如下图元：</p><ul><li><code>points</code>：用于单个点。图元所包含的最小顶点数 1</li><li><code>lines</code>：用于线段或线带。</li><li><code>lines_adjacency</code>：用于带有相邻信息的线段或线带。</li><li><code>triangles</code>：用于三角形、三角形带或三角形扇。</li><li><code>triangles_adjacency</code>：用于带有相邻信息的三角形或三角形带。</li></ul><p>括号中的数字表示构成该图元所需的最小顶点数。</p><p>对于输出图元类型，在<code>out</code>关键字前同样使用布局修饰符，可设置为：</p><ul><li><code>points</code></li><li><code>line_strip</code></li><li><code>triangle_strip</code></li></ul><p>​    这些输出图元允许几何着色器创建各种形状。例如，为了生成一个三角形，可以将输出定义为<code>triangle_strip</code>并提供3个顶点。</p><p>此外，几何着色器还要求指定其能输出的最大顶点数量，防止超出限制导致OpenGL忽略额外的顶点。此最大值也在<code>out</code>布局修饰符中设定。例如，若要输出一条线段，则应将最大顶点数设为2。</p><p>线条（Line Strip）是由一系列点组成的连续线段，至少需要两个点来形成。每增加一个点，就会与前一个点之间形成一条新的线段。例如，如果有5个顶点，它们会依次相连形成4条线段。</p><p>​    当使用几何着色器时，如果最大输出顶点数设为2，则只能输出一条线段。为了生成更复杂的形状，几何着色器可以通过GLSL提供的内置变量<code>gl_in[]</code>访问来自上一阶段（如顶点着色器）的顶点数据。<code>gl_in[]</code>是一个接口块，它包含了每个输入顶点的位置和其他信息，如<code>gl_Position</code>等。</p><p>​    几何着色器通过调用<code>EmitVertex()</code>函数来发射一个新的顶点，并最终通过<code>EndPrimitive()</code>函数来完成一个图元的定义。代码修改了原始顶点的位置，创建了两个新位置，然后发射了这两个顶点，最后通过调用<code>EndPrimitive()</code>将它们合成为一个线条图元。这样就创建了一条从原始顶点位置向左和向右各平移0.1单位的新线段。</p><p>​    <strong>线条是由连续的点组成，几何着色器可以访问先前阶段的顶点数据并通过发射顶点和结束图元的方法来创建新的几何图形</strong></p><h3 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h3><p>当我们说<strong>爆破</strong>一个物体时，我们并不是指要将宝贵的顶点集给炸掉，我们是要将每个三角形沿着法向量的方向移动一小段时间。效果就是，整个物体看起来像是沿着每个三角形的法线向量<strong>爆炸</strong>一样。</p><p>做法就是在几何着色器中计算一个三角形面的法向量(通过面上的三个点得到两个向量并计算叉乘),在几何着色器中改变顶点位置.</p><h3 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h3><p>​    可以作为一种Debug工具,当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。<strong>光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的</strong>。想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p><p>​    首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>如果我们需要渲染大量物体时，代码看起来会像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amount_of_models_to_draw; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomePreparations</span>(); <span class="comment">// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, amount_of_vertices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为<strong>OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）</strong>。所以，即便渲染顶点非常快，命令GPU去渲染却未必。</p><p>如果<strong>能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)</strong>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从手动设置顶点坐标到加载模型以及OpenGL高级技巧&lt;br&gt;</summary>
    
    
    
    
    <category term="OpenGL" scheme="https://www.sekyoro.top/tags/OpenGL/"/>
    
    <category term="computer graphics" scheme="https://www.sekyoro.top/tags/computer-graphics/"/>
    
  </entry>
  
</feed>

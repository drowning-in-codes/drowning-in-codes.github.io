<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2024-10-09T15:34:28.566Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>也许需要知道的c++概念</title>
    <link href="https://www.sekyoro.top/2024/10/09/%E4%B9%9F%E8%AE%B8%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84c-%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.sekyoro.top/2024/10/09/%E4%B9%9F%E8%AE%B8%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84c-%E6%A6%82%E5%BF%B5/</id>
    <published>2024-10-09T15:34:28.000Z</published>
    <updated>2024-10-09T15:34:28.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>现代c++并发深入</title>
    <link href="https://www.sekyoro.top/2024/10/05/%E7%8E%B0%E4%BB%A3c-%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5/"/>
    <id>https://www.sekyoro.top/2024/10/05/%E7%8E%B0%E4%BB%A3c-%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5/</id>
    <published>2024-10-05T03:09:17.000Z</published>
    <updated>2024-10-09T15:08:45.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>更加深入的探讨并发.<br><span id="more"></span></p><h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>多线程的构造,使用std::thread时我们需要注意哪些?</p><h3 id="可以接受哪些参数"><a href="#可以接受哪些参数" class="headerlink" title="可以接受哪些参数"></a>可以接受哪些参数</h3><p>std::thread接受一个<strong>可调用对象</strong>和其参数.</p><p><strong><em>可调用\</em> *(Callable)*</strong> 类型是可应用INVOKE和INVOKE操作(例如用于 std::function、std::bind和 std::thread::thread)的类型。</p><p>如果满足下列条件，那么类型 <code>T</code> 是<em>可调用</em> <em>(Callable)</em> 的：</p><p>给定</p><ul><li><code>T</code> 类型的对象 <code>f</code></li><li>适合的实参类型列表 <code>ArgTypes</code></li><li>适合的返回类型 <code>R</code></li></ul><p>那么下列表达式必须合法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">要求</th></tr></thead><tbody><tr><td style="text-align:center">INVOKE<R>(f, [std::declval<ArgTypes>()…)</td><td style="text-align:center">该表达式在不求值语境中良构</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task_2</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; std::<span class="built_in">puts</span>(<span class="string">&quot;operator()()const\n&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;; <span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">task_run</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 函数</span></span><br><span class="line">X x;</span><br><span class="line">std::thread t&#123;&amp;X::task_run,&amp;x,<span class="number">3</span>&#125;; <span class="comment">//成员指针必须和对象一起使用，这是唯一标准用法，成员指针不可以转换到函数指针单独使用，即使是非静态成员函数没有使用任何数据成员。</span></span><br><span class="line">std::thread t&#123; std::<span class="built_in">bind</span>(&amp;X::task_run, &amp;x ,<span class="number">3</span>) &#125;;</span><br><span class="line">std::thread t&#123;[]&#123;std::<span class="built_in">puts</span>(<span class="string">&quot;Hi!&quot;</span>)&#125;&#125;; <span class="comment">// lambda函数</span></span><br><span class="line">Task_2 task_2&#123;&#125;;</span><br><span class="line">  std::thread t&#123;task_2&#125;;                     <span class="comment">// 左值 左值引用</span></span><br><span class="line">  std::thread ta&#123;Task_2&#123;&#125;&#125;;                  <span class="comment">// 临时对象</span></span><br><span class="line">  std::thread ta1&#123;[] &#123; std::<span class="built_in">puts</span>(<span class="string">&quot;Hi&quot;</span>); &#125;&#125;;  <span class="comment">// 临时对象</span></span><br><span class="line">  std::thread ta2&#123;h&#125;;  <span class="comment">// 左值</span></span><br></pre></td></tr></table></figure><p>重要的构造函数如下(MSVC实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fn</span>, <span class="title">class</span>... _<span class="title">Args</span>, <span class="title">enable_if_t</span>&lt;</span>!is_same_v&lt;_Remove_cvref_t&lt;_Fn&gt;, thread&gt;, <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    _NODISCARD_CTOR_THREAD <span class="keyword">explicit</span> <span class="built_in">thread</span>(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123;</span><br><span class="line">        _Start(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fn</span>, <span class="title">class</span>... _<span class="title">Args</span>&gt;</span></span><br><span class="line">    <span class="keyword">void</span> _Start(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123;</span><br><span class="line">        <span class="keyword">using</span> _Tuple                 = tuple&lt;<span class="keyword">decay_t</span>&lt;_Fn&gt;, <span class="keyword">decay_t</span>&lt;_Args&gt;...&gt;;</span><br><span class="line">        <span class="keyword">auto</span> _Decay_copied           = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...); </span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> _Invoker_proc = _Get_invoke&lt;_Tuple&gt;(make_index_sequence&lt;<span class="number">1</span> + <span class="keyword">sizeof</span>...(_Args)&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        _Thr._Hnd =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(_CSTD _beginthreadex(<span class="literal">nullptr</span>, <span class="number">0</span>, _Invoker_proc, _Decay_copied.<span class="built_in">get</span>(), <span class="number">0</span>, &amp;_Thr._Id));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Thr._Hnd) &#123; <span class="comment">// ownership transferred to the thread</span></span><br><span class="line">            (<span class="keyword">void</span>) _Decay_copied.<span class="built_in">release</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// failed to start thread</span></span><br><span class="line">            _Thr._Id = <span class="number">0</span>;</span><br><span class="line">            _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先根据传入的可调用对象和参数使用转发引用,并确保传入的可调用对象去掉const/volatile引用后不等于std::thread. 如果传入左值,则为左值引用,调用_Start时传入左引用,否则传入右值. forward内部根据传入的是左值还是右值转为对应的引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD _MSVC_INTRINSIC <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD _MSVC_INTRINSIC <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_Start中使用tuple保存函数和参数类型,使用make_unique得到指向_tuple的指针,使用传入的左值或者右值,比如如果参数如果传递一个左值num(即使是引用),会使用拷贝构造,如果传入一个右值会调用对应移动构造,</p><p>这里需要介绍一些左值和右值,以及模板编程中<code>template&lt;T&gt; void( std::remove_reference_t&lt;T&gt;&amp;)</code>与<code>template&lt;T&gt; void( std::remove_reference_t&lt;T&gt;&amp;&amp;)</code></p><p><a href="https://zh.cppreference.com/w/cpp/language/value_category">值类别 - cppreference.com</a></p><p>变量的类型是右值引用,由它的名字构成的表达式仍是左值表达式</p><p>转换到左值引用类型的转型表达式以及转换到函数的右值引用类型的转型表达式是左值;而转换到对象的右值引用类型的类型转换表达式是亡值,也就是右值,通过static_cast<T&&>这种方式返回了右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tuple</span>, <span class="title">size_t</span>... _<span class="title">Indices</span>&gt;</span></span><br><span class="line">_NODISCARD <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> _Get_invoke(index_sequence&lt;_Indices...&gt;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;_Invoke&lt;_Tuple, _Indices...&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tuple</span>, <span class="title">size_t</span>... _<span class="title">Indices</span>&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __stdcall _Invoke(<span class="keyword">void</span>* _RawVals) <span class="keyword">noexcept</span> <span class="comment">/* terminates */</span> &#123;</span><br><span class="line">    <span class="comment">// adapt invoke of user&#x27;s callable object to _beginthreadex&#x27;s thread procedure</span></span><br><span class="line">    <span class="keyword">const</span> unique_ptr&lt;_Tuple&gt; _FnVals(<span class="keyword">static_cast</span>&lt;_Tuple*&gt;(_RawVals));</span><br><span class="line">    _Tuple&amp; _Tup = *_FnVals.<span class="built_in">get</span>(); <span class="comment">// avoid ADL, handle incomplete types</span></span><br><span class="line">    <span class="function">_STD <span class="title">invoke</span><span class="params">(_STD move(_STD get&lt;_Indices&gt;(_Tup))...)</span></span>;</span><br><span class="line">    _Cnd_do_broadcast_at_thread_exit(); <span class="comment">// TRANSITION, ABI</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_beginthreadex</code>是windows上创建多线程的API,传入一个函数指针(也就是_Invoke)和指向一个tuple(包含函数和参数)的指针,在<code>_Invoke</code>中, _STD invoke(_STD move(_STD get<_Indices>(_Tup))…);`相当于根据可调用对象及其参数进行了调用</p><h3 id="传递的参数"><a href="#传递的参数" class="headerlink" title="传递的参数"></a>传递的参数</h3><p>根据源码实现,传递的参数会在thread对象中创建新值.</p><p><code>auto _Decay_copied = _STD make_unique&lt;_Tuple&gt;(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);</code>创建,而_Tuple中的类型就是左值,<code>using _Tuple = tuple&lt;decay_t&lt;_Fn&gt;, decay_t&lt;_Args&gt;...&gt;;</code>,所以创建时会调用拷贝或移动构造创建新的值,而在实际调用对应可调用对象时,又会使用右值<code>_STD invoke(_STD move(_STD get&lt;_Indices&gt;(_Tup))...);</code>,这意味着,即使函数参数是引用,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> num&#123;<span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">jthread</span>(f,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的num首先会在std::jthread中创建变量,auto _Decay<em>copied    = std::make_unique&lt;_Tuple</em>&gt;(std::forward\<Fn>(__Fn),std::forward\<Args>(args)…);</p><p>使用invoke调用,std::invoke(std::move(std::get&lt;_Indices&gt;(_Tup))…);调用函数时使用了<code>std::move</code>作为右值传递,所以有<code>const int&amp; n = std::move(_num)</code>,如果不加上const会发生运行编译错误,此外这样也支持了只能移动的对象.</p><p>如何使得传递引用呢,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> num&#123;<span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">jthread</span>(f,std::<span class="built_in">ref</span>(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现中将类型先经过 <code>decay</code> 处理，如果要传递引用，则必须用类包装，使用 <code>std::ref</code> 函数会返回一个包装对象</p><p>使用可调用对象的方式是利用<code>_Invoke</code>,其参数是上面的<code>_Decay_copied</code>,将其转为unique_ptr,再通过智能指针转为_Tup&amp;,然后使用 <code>std::invoke</code> 进行调用</p><p>std::ref是一个对象,但是使用时隐式转为引用,所以在构造时直接拷贝赋值std::reference_wrapper\<T>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> num2&#123;<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> n2 = std::<span class="built_in">ref</span>(num2);</span><br><span class="line">  <span class="keyword">auto</span> ttc = n2;</span><br><span class="line">  std::cout &lt;&lt; ttc &lt;&lt; std::endl;</span><br><span class="line">  ttc += <span class="number">12</span>;</span><br><span class="line">std::cout &lt;&lt; n2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="join与detach"><a href="#join与detach" class="headerlink" title="join与detach"></a>join与detach</h3><p>detach() 是线程分离,线程对象放弃了线程资源的所有权，此时thread根本没有关联任何线程。调用 join() 是：“阻塞当前线程直至 *this 所标识的线程结束其执行”，线程对象都没有线程,就不需要阻塞了.</p><h3 id="不能拷贝构造-赋值与转移所有权"><a href="#不能拷贝构造-赋值与转移所有权" class="headerlink" title="不能拷贝构造/赋值与转移所有权"></a>不能拷贝构造/赋值与转移所有权</h3><p>传入可调用对象以及参数，构造 <code>std::thread</code> 对象，启动线程，而线程对象拥有了线程的所有权，线程是一种系统资源，所以可称作“<em>线程资源</em>”。</p><p>std::thread 不可复制。两个 std::thread 对象不可表示一个线程，std::thread 对线程资源是独占所有权。而<strong>移动</strong>操作可以将一个 <code>std::thread</code> 对象的线程资源所有权转移给另一个 <code>std::thread</code> 对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123; [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 线程对象 t 当前关联了活跃线程 打印 1</span></span><br><span class="line">    <span class="built_in">std</span>::thread t2&#123; <span class="built_in">std</span>::move(t) &#125;;    <span class="comment">// 将 t 的线程资源的所有权移交给 t2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 线程对象 t 当前没有关联活跃线程 打印 0</span></span><br><span class="line">    <span class="comment">//t.join(); // Error! t 没有线程资源</span></span><br><span class="line">    t2.join();  <span class="comment">// t2 当前持有线程资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::thread rt = <span class="built_in">f</span>();</span><br><span class="line">    rt.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return t</code> <em>重载决议</em><a href="https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02使用线程.html#footnote1">[1]</a>选择到了<strong>移动构造</strong>，将 <code>t</code> 线程资源的所有权转移给函数调用 <code>f()</code> 返回的临时 <code>std::thread</code> 对象中，然后这个临时对象再用来初始化 <code>rt</code> ，临时对象是右值表达式，这里一样选择到<strong>移动构造</strong>，将临时对象的线程资源所有权移交给 <code>rt</code>。此时 <code>rt</code> 具有线程资源的所有权，由它调用 <code>join()</code> 正常析构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void f(std::thread t)&#123;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    std::thread t&#123; [] &#123;&#125; &#125;;</span><br><span class="line">    f(std::move(t));</span><br><span class="line">    f(std::thread&#123; [] &#123;&#125; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::move</code> 将 t 转换为了一个右值表达式，初始化函数<code>f</code> 形参 <code>t</code>，选择到了移动构造转移线程资源的所有权，在函数中调用 <code>t.join()</code> 后正常析构。<code>std::thread&#123; [] &#123;&#125; &#125;</code> 构造了一个临时对象，本身就是右值表达式，初始化函数<code>f</code> 形参 <code>t</code>，移动构造转移线程资源的所有权到 <code>t</code>，<code>t.join()</code> 后正常析构。</p><h3 id="std-this-thread"><a href="#std-this-thread" class="headerlink" title="std::this_thread"></a>std::this_thread</h3><p><img data-src="https://s2.loli.net/2024/10/09/z68akUwnbqjS9KH.png" alt="image-20241009225729722"></p><ul><li><p>get_id</p></li><li><p>sleep_for</p></li><li><p>yield</p></li><li><p>sleep_until</p></li></ul><h2 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02使用线程.html#启动新线程">使用线程 | 现代C++并发编程教程 (mq-b.github.io)</a></li><li>C++ Concurrency in Action</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;更加深入的探讨并发.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>窗口工具库GLFW使用</title>
    <link href="https://www.sekyoro.top/2024/10/04/%E7%AA%97%E5%8F%A3%E5%B7%A5%E5%85%B7%E5%BA%93GLFW%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2024/10/04/%E7%AA%97%E5%8F%A3%E5%B7%A5%E5%85%B7%E5%BA%93GLFW%E4%BD%BF%E7%94%A8/</id>
    <published>2024-10-04T11:53:18.000Z</published>
    <updated>2024-10-08T14:19:12.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用OpenGL或者Vulkan的图形库时经常使用一些窗口工具库搭配,常见的就是<a href="https://www.glfw.org/docs/latest/index.html">GLFW: Introduction</a>了,类似的有SDL,SFML和win32库,这里也会简单说一下. 这篇文章相当于GLFW的api介绍</p><span id="more"></span><p>SDL与SFML都是跨平台的多媒体库,除了创建窗口之外,还包括音视频库甚至网络库<a href="https://www.sfml-dev.org/tutorials/2.6/network-socket.php">sfml</a>和<a href="https://github.com/libsdl-org/SDL_net">SDL_net</a>,它们在不同平台上使用对应的库.比如SDL在windows上使用win32,使用direct3D作为图形库,在Linux上使用x11作为窗口系统,openGL作为图形库.</p><p><img data-src="https://s2.loli.net/2024/10/06/okrmt3QxWUaOfA2.png" alt="image-20241006121306560"></p><p>SFML可以将其视为面向对象的SDL,在windows上使用了gdi32+opengl32.而GLFW相对来说更纯粹,官网直接说是OpenGL的上下文管理器. </p><p><img data-src="https://s2.loli.net/2024/10/06/WK8hxcI5O9VMLzC.png" alt="image-20241006121554268"></p><p>类似SFML的还有<a href="https://www.fltk.org/">Fast Light Toolkit - Fast Light Toolkit (FLTK)</a></p><p>此外也有更上层imgui和raylib库,相当于同时包含了窗口管理和绘图等功能,raylib在windows和Linux上均使用GLFW和OpenGL<a href="https://github.com/raysan5/raylib/wiki/raylib-platforms-and-graphics">raylib platforms and graphics · raysan5/raylib Wiki (github.com)</a>,而imgui可以相对更自由地选择搭配.</p><p>此外我也看到有人提到<a href="https://skia.org/">Skia</a>,<a href="https://blend2d.com/">Blend2D</a>以及<a href="https://www.cairographics.org/">cairographics.org</a>,<a href="https://libyue.com/">Yue (libyue.com)</a>等等,它们是2D绘图库,相对使用opengl,d3d等更节省资源,本身可以创建上下文,也能与窗口结合</p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>GLFW目前GLFW版本到了3.0,下面是一个GLFW的经典流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h3><p>默认GLFW的头文件包括OpenGL头文件,但是版本可能比较老,一般使用一个loader library获取版本,比如glad. 如果包括了glad可以检测到从而不使用开发环境中的gl头文件.</p><blockquote><p>为了确保没有头冲突，您可以在GLFW头之前定义GLFW_INCLUDE_NONE，以显式禁用开发环境头的包含。这也允许以任何顺序包含两个头</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLFW_INCLUDE_NONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/gl.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化和停止GLFW"><a href="#初始化和停止GLFW" class="headerlink" title="初始化和停止GLFW"></a>初始化和停止GLFW</h3><p>在使用大多数GLFW函数之前，必须初始化库。初始化成功时，返回GLFW_TRUE。如果发生错误，则返回GLFW_FALSE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!glfwInit())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Initialization failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用完GLFW后，通常在应用程序退出之前，需要终止GLFW</p><p>这将终止所有剩余的窗口并释放由GLFW分配的任何其他资源。在此调用之后，在使用任何需要它的GLFW函数之前，必须再次初始化GLFW</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br></pre></td></tr></table></figure><h3 id="设置错误处理"><a href="#设置错误处理" class="headerlink" title="设置错误处理"></a>设置错误处理</h3><p>大多数事件都是通过回调的，无论是按下的键、移动的GLFW窗口还是发生的错误。回调是由GLFW调用的带有描述事件的参数的C函数(或c++静态方法)</p><p>如果GLFW函数失败，则会向GLFW错误回调函数报告一个错误。您可以通过错误回调接收这些报告。此函数必须具有下面的签名，但可以执行其他回调中允许的任何操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_callback</span><span class="params">(<span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span>* description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须设置回调函数，这样GLFW才知道调用它们。设置错误回调的函数是少数几个可以在初始化之前调用的GLFW函数之一，它可以在初始化期间和之后通知错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetErrorCallback(error_callback);</span><br></pre></td></tr></table></figure><h3 id="创建与销毁窗口"><a href="#创建与销毁窗口" class="headerlink" title="创建与销毁窗口"></a>创建与销毁窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;My Title&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window or OpenGL context creation failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将创建一个带有OpenGL上下文的640 * 480窗口模式窗口。如果窗口或OpenGL上下文创建失败，将返回NULL。您应该始终检查返回值。虽然窗口创建很少失败，但上下文创建取决于正确安装的驱动程序，甚至在具有必要硬件的机器上也可能失败。</p><p>默认情况下，GLFW创建的OpenGL上下文可以有任何版本。可以通过在创建之前设置GLFW_CONTEXT_VERSION_MAJOR和GLFW_CONTEXT_VERSION_MINOR提示来要求最小OpenGL版本。如果机器上不支持所需的最低版本，则上下文(和窗口)创建失败</p><p>通过设置GLFW_OPENGL_PROFILE提示,可以选择OpenGL profile.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;My Title&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Window or context creation failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常提到OpenGL上下文, <code>glfwCreateWindow</code>会返回窗口,这个窗口就相当于一个OpenGL上下文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwDestroyWindow(window);</span><br></pre></td></tr></table></figure><p>一旦调用这个函数，就不会再为该窗口传递事件，并且它的句柄无效</p><h3 id="设置当前OpenGL上下文"><a href="#设置当前OpenGL上下文" class="headerlink" title="设置当前OpenGL上下文"></a>设置当前OpenGL上下文</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure><p>该上下文将保持当前状态，直到将另一个上下文设置为当前状态，或者直到拥有当前上下文的窗口被销毁。</p><h3 id="检查窗口是否关闭"><a href="#检查窗口是否关闭" class="headerlink" title="检查窗口是否关闭"></a>检查窗口是否关闭</h3><p>每个窗口都有一个标志，指示该窗口是否应该关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Keep running</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户试图关闭窗口时，通过按标题栏中的关闭小部件或使用像Alt+F4这样的组合键，该标志被设置为1。注意该窗口实际上并没有关闭，因此您应该监视该标志，并销毁该窗口或向用户提供某种反馈</p><p>当用户试图关闭窗口时，你可以通过使用glfwSetWindowCloseCallback设置一个关闭回调来得到通知。在关闭标志被设置后，回调函数将被立即调用。</p><h3 id="接受用户输入"><a href="#接受用户输入" class="headerlink" title="接受用户输入"></a>接受用户输入</h3><p>每个窗口都有大量的回调函数，可以将其设置为接收所有不同类型的事件。要接收按键按下和释放事件，需要创建按键回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, GLFW_TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置键盘回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetKeyCallback(window, key_callback);</span><br></pre></td></tr></table></figure><h3 id="使用OpenGL渲染"><a href="#使用OpenGL渲染" class="headerlink" title="使用OpenGL渲染"></a>使用OpenGL渲染</h3><p>当有一个当前的OpenGL上下文，可以正常使用OpenGL</p><p>使用<code>glfwGetFramebufferSize</code>后去帧缓冲区大小,并为glViewport设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">glfwGetFramebufferSize(window, &amp;width, &amp;height);</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br></pre></td></tr></table></figure><h3 id="获得timer"><a href="#获得timer" class="headerlink" title="获得timer"></a>获得timer</h3><p>为了创建流畅的动画，需要一个时间源。GLFW提供了一个计时器，返回自初始化以来的秒数。所使用的时间源在每个平台上都是最精确的，通常具有微秒或纳秒分辨率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time = glfwGetTime();</span><br></pre></td></tr></table></figure><h3 id="交换缓冲区"><a href="#交换缓冲区" class="headerlink" title="交换缓冲区"></a>交换缓冲区</h3><p>默认情况下，GLFW窗口使用双缓冲。这意味着每个窗口都有两个渲染缓冲区;一个前缓冲，一个后缓冲。<strong>前缓冲区是要显示的缓冲区，后缓冲区是要渲染的缓冲区。</strong></p><p><strong>当整个帧被渲染后，缓冲区需要相互交换，所以后缓冲区变成前缓冲区</strong>，反之亦然</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapBuffers(window);</span><br></pre></td></tr></table></figure><p>交换间隔表示在交换缓冲区之前需要等待多少帧，通常称为vsync。默认情况下，交换间隔为零，这意味着缓冲区交换将立即发生。在快速的机器上，许多这些帧永远不会被看到，因为屏幕通常每秒只更新60-75次，所以这浪费了大量的CPU和GPU周期</p><blockquote><p>屏幕撕裂是视频显示中的视觉伪影，显示设备在单个屏幕绘制中显示来自多个帧的信息</p></blockquote><p>由于这些原因，应用程序通常希望将交换间隔设置为1。它可以设置为更高的值，但通常不建议这样做，因为它会导致输入延迟</p><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>GLFW需要定期与窗口系统通信，以便接收事件并显示应用程序尚未锁定。事件处理必须在有可见窗口时定期执行，通常在缓冲区交换后的每一帧执行。</p><p>处理挂起事件有两种方法:<strong>轮询和等待</strong>。这个例子使用事件轮询，它只处理那些已经接收到的事件，然后立即返回。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwPollEvents()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="使用GLAD"><a href="#使用GLAD" class="headerlink" title="使用GLAD"></a>使用GLAD</h3><p>如果不用glad,opengl版本就与装的动态库与使用的gl头文件相关,如果使用glad,就能根据版本选择对应版本的库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gladLoadGL(glfwGetProcAddress);</span><br></pre></td></tr></table></figure><blockquote><p>一些老代码使用glfwGetProcAddress((GLADloadproc)glfwGetProcAddress)</p></blockquote><p>可以使用<code>gladLoadGL</code>,首先加载dll库,获取gl动态库中的<code>wglGetProcAddress</code>,得到这个函数方便获的gl的地址,调用<code>gladLoadGLLoader</code>传递<code>get_proc</code>,<code>get_proc</code>中调用类似<code>gladGetProcAddressPtr</code>,<code>GetProcAddress</code>操作获取对应的函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gladLoadGL</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(open_gl()) &#123;</span><br><span class="line">        status = gladLoadGLLoader(&amp;get_proc);</span><br><span class="line">        close_gl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_gl</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IS_UWP</span></span><br><span class="line">    libGL = LoadLibraryW(<span class="string">L&quot;opengl32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(libGL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> (* tmp)(<span class="keyword">void</span>);</span><br><span class="line">        tmp = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>)) GetProcAddress(libGL, <span class="string">&quot;wglGetProcAddress&quot;</span>);</span><br><span class="line">        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE) tmp;</span><br><span class="line">        <span class="keyword">return</span> gladGetProcAddressPtr != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_proc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *namez)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(libGL == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__APPLE__) &amp;&amp; !defined(__HAIKU__)</span></span><br><span class="line">    <span class="keyword">if</span>(gladGetProcAddressPtr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        result = gladGetProcAddressPtr(namez);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(__CYGWIN__)</span></span><br><span class="line">        result = (<span class="keyword">void</span>*)GetProcAddress((HMODULE) libGL, namez);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        result = dlsym(libGL, namez);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>gladLoadGLLoader</code>中将利用刚才的<code>get_proc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gladLoadGLLoader</span><span class="params">(GLADloadproc load)</span> </span>&#123;</span><br><span class="line">GLVersion.major = <span class="number">0</span>; GLVersion.minor = <span class="number">0</span>;</span><br><span class="line">glGetString = (PFNGLGETSTRINGPROC)load(<span class="string">&quot;glGetString&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(glGetString == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(glGetString(GL_VERSION) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">find_coreGL();</span><br><span class="line">load_GL_VERSION_1_0(load);</span><br><span class="line">load_GL_VERSION_1_1(load);</span><br><span class="line">load_GL_VERSION_1_2(load);</span><br><span class="line">load_GL_VERSION_1_3(load);</span><br><span class="line">load_GL_VERSION_1_4(load);</span><br><span class="line">load_GL_VERSION_1_5(load);</span><br><span class="line">load_GL_VERSION_2_0(load);</span><br><span class="line">load_GL_VERSION_2_1(load);</span><br><span class="line">load_GL_VERSION_3_0(load);</span><br><span class="line">load_GL_VERSION_3_1(load);</span><br><span class="line">load_GL_VERSION_3_2(load);</span><br><span class="line">load_GL_VERSION_3_3(load);</span><br><span class="line">load_GL_VERSION_4_0(load);</span><br><span class="line">load_GL_VERSION_4_1(load);</span><br><span class="line">load_GL_VERSION_4_2(load);</span><br><span class="line">load_GL_VERSION_4_3(load);</span><br><span class="line">load_GL_VERSION_4_4(load);</span><br><span class="line">load_GL_VERSION_4_5(load);</span><br><span class="line">load_GL_VERSION_4_6(load);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!find_extensionsGL()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> GLVersion.major != <span class="number">0</span> || GLVersion.minor != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFNGLGETSTRINGPROC glad_glGetString = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> glGetString glad_glGetString</span></span><br></pre></td></tr></table></figure><p>首先获取gl获取版本的函数,然后根据版本加载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_coreGL</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thank you @elmindreda</span></span><br><span class="line"><span class="comment">     * https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176</span></span><br><span class="line"><span class="comment">     * https://github.com/glfw/glfw/blob/master/src/context.c#L36</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> i, major, minor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* prefixes[] = &#123;</span><br><span class="line">        <span class="string">&quot;OpenGL ES-CM &quot;</span>,</span><br><span class="line">        <span class="string">&quot;OpenGL ES-CL &quot;</span>,</span><br><span class="line">        <span class="string">&quot;OpenGL ES &quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    version = (<span class="keyword">const</span> <span class="keyword">char</span>*) glGetString(GL_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (!version) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 根据获取到的版本,匹配对应的前缀,再加上</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;  prefixes[i];  i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(prefixes[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(version, prefixes[i], length) == <span class="number">0</span>) &#123;</span><br><span class="line">            version += length;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PR #18 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    sscanf_s(version, <span class="string">&quot;%d.%d&quot;</span>, &amp;major, &amp;minor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">sscanf</span>(version, <span class="string">&quot;%d.%d&quot;</span>, &amp;major, &amp;minor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    GLVersion.major = major; GLVersion.minor = minor;</span><br><span class="line">    max_loaded_major = major; max_loaded_minor = minor;</span><br><span class="line">GLAD_GL_VERSION_1_0 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_1 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_2 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">2</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_3 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">3</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_4 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">4</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_1_5 = (major == <span class="number">1</span> &amp;&amp; minor &gt;= <span class="number">5</span>) || major &gt; <span class="number">1</span>;</span><br><span class="line">GLAD_GL_VERSION_2_0 = (major == <span class="number">2</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">2</span>;</span><br><span class="line">GLAD_GL_VERSION_2_1 = (major == <span class="number">2</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">2</span>;</span><br><span class="line">GLAD_GL_VERSION_3_0 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_3_1 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_3_2 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">2</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_3_3 = (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">3</span>) || major &gt; <span class="number">3</span>;</span><br><span class="line">GLAD_GL_VERSION_4_0 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">0</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_1 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">1</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_2 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">2</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_3 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">3</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_4 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">4</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_5 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">5</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line">GLAD_GL_VERSION_4_6 = (major == <span class="number">4</span> &amp;&amp; minor &gt;= <span class="number">6</span>) || major &gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (GLVersion.major &gt; <span class="number">4</span> || (GLVersion.major &gt;= <span class="number">4</span> &amp;&amp; GLVersion.minor &gt;= <span class="number">6</span>)) &#123;</span><br><span class="line">max_loaded_major = <span class="number">4</span>;</span><br><span class="line">max_loaded_minor = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果版本大于某个大版本,会加载对应的函数,也就是说1.0加载的东西,在1.1的函数中就不会有了,文件中定义了许多函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(APIENTRYP PFNGLGENSAMPLERSPROC)</span><span class="params">(GLsizei count, GLuint *samplers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC)</span><span class="params">(GLsizei n, GLuint *ids)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(APIENTRYP PFNGLGENVERTEXARRAYSPROC)</span><span class="params">(GLsizei n, GLuint *arrays)</span></span>;</span><br><span class="line">PFNGLGENTEXTURESPROC glad_glGenTextures = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = <span class="literal">NULL</span>;</span><br><span class="line">PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>当加载完毕后即可直接使用glad_xx调用glxx库.</p><blockquote><p>glad相当于在知道使用的gl.dll版本之后加载相应版本所有的头文件,加载后即可使用gladxx,而原本的gl头文件实际上就不需要了(除非你还需要在代码中直接使用gl头文件)</p></blockquote><p><img data-src="https://s2.loli.net/2024/10/05/1KpBUDEAqzQlGYn.png" alt="image-20241005230313466"></p><p>在<code>glad.h</code>中如果之前定义了<code>__gl_h_</code>宏,那就会报错,否则自己会定义一个<code>__gl_h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glad.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __glad_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __glad_h_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __gl_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> OpenGL header already included, remove this <span class="meta-keyword">include</span>, glad already provides it</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __gl_h_</span></span><br></pre></td></tr></table></figure><p>而在<code>gl.h</code>中,定义了这个宏,表明使用glad并不需要引入gl头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gl.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __gl_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __GL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __gl_h_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winapifamily.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而在<code>glfw3.h</code>中也说明了如果定义了<code>__gl_h_</code>,就不需要再引入头文件了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !defined(GLFW_INCLUDE_NONE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles1_gl_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl2_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl3_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl31_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gles2_gl32_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl_glcorearb_h_) &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl2_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl3_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl31_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gl32_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__glcorearb_h_) <span class="comment">/*legacy*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__GL_H__) <span class="comment">/*non-standard*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__gltypes_h_) <span class="comment">/*non-standard*/</span> &amp;&amp; \</span></span><br><span class="line"><span class="meta">      !defined(__glee_h_) <span class="comment">/*non-standard*/</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> !defined(GLFW_INCLUDE_GLEXT)</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> GL_GLEXT_LEGACY</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenGL/gl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/*__APPLE__*/</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/gl.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(GLFW_INCLUDE_GLEXT)</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glext.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*__APPLE__*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* OpenGL and OpenGL ES headers */</span></span></span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在调用大多数GLFW函数之前，必须初始化库。这个初始化<strong>检查机器上可用的特性、显示器</strong>、<strong>初始化计时器</strong>并执行任何所需的<strong>特定于平台的初始化</strong>。</p><p>在调用<code>glfwInit</code>之前可以调用一些函数,比如获取版本,平台支持,设置错误处理回调等.</p><ul><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga9f8ffaacf3c269cc48eafbf8b9b71197">glfwGetVersion</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga026abd003c8e6501981ab1662062f1c0">glfwGetVersionString</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga8785d2b6b36632368d803e78079d38ed">glfwPlatformSupported</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga944986b4ec0b928d488141f92982aa18">glfwGetError</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#gaff45816610d53f0b83656092a4034f40">glfwSetErrorCallback</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga110fd1d3f0412822b4f1908c026f724a">glfwInitHint</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga9dde93e9891fa7dd17e4194c9f3ae7c6">glfwInitAllocator</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga76af552d0307bb5f7791f245417d4752">glfwInitVulkanLoader</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a></li><li><a href="https://www.glfw.org/docs/latest/group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a></li></ul><h3 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h3><p>hints用于设置GLFW,包括共享/通用的hints以及platform-specific的hints.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwInitHint(GLFW_JOYSTICK_HAT_BUTTONS, GLFW_FALSE);</span><br><span class="line">glfwInitHint(GLFW_PLATFORM, GLFW_PLATFORM_X11);</span><br></pre></td></tr></table></figure><h3 id="自定义内存分配器"><a href="#自定义内存分配器" class="headerlink" title="自定义内存分配器"></a>自定义内存分配器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLFWallocator allocator;</span><br><span class="line">allocator.allocate = my_malloc;</span><br><span class="line">allocator.reallocate = my_realloc;</span><br><span class="line">allocator.deallocate = my_free;</span><br><span class="line">allocator.user = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">glfwInitAllocator(&amp;allocator);</span><br></pre></td></tr></table></figure><h3 id="设置错误处理-1"><a href="#设置错误处理-1" class="headerlink" title="设置错误处理"></a>设置错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = glfwGetError(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (code != GLFW_NO_ERROR)</span><br><span class="line">    handle_error(code);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glfwSetErrorCallback(error_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_callback</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">const</span> <span class="keyword">char</span>* description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    display_error_message(code, description);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>只要GLFW成功初始化，无论发生多少错误，它都将保持初始化并处于安全状态，直到终止。如果在初始化过程中发生错误导致glfwInit失败，则初始化库的任何部分都将被安全终止</p><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>GLFW有两个主要的坐标系统,虚拟屏幕和窗口内容区域.</p><p><img data-src="https://s2.loli.net/2024/10/08/RwYs2HjEdPLDOiu.png" alt="image-20241008191903556"></p><p>​    虚拟屏幕和内容区域坐标系统的x轴指向右,y轴指向下.</p><p>​    窗口和显示器的位置指定为其内容区域的左上角相对于虚拟屏幕的位置，而光标的位置指定为相对于窗口的内容区域的位置</p><p>​    由于窗口的内容区域坐标系统的原点也是指定窗口位置的点，因此可以通过添加窗口位置将内容区域坐标转换为虚拟屏幕。当窗口frame出现时，它从内容区域向外延伸，但不影响窗口位置</p><p>​    GLFW中几乎所有的位置和大小都是以相对于上述两个原点之一的屏幕坐标来测量的。这包括光标位置、窗口位置和大小、窗口frame大小、显示器位置和视频分辨率.</p><p>​    显示器的物理大小以毫米为单位和帧缓冲区大小(以像素为单位)。</p><p>​    像素和屏幕坐标在一些机器上可能是1:1的映射，但在其他机器上就不一定了，比如在带有Retina显示屏的Mac上dpr是2:1。屏幕坐标和像素之间的比率也可能在运行时改变，这取决于窗口当前被认为在哪个显示器上</p><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>窗口对象封装了顶级窗口和OpenGL或OpenGL ES上下文。它是用glfwCreateWindow创建的，用glfwDestroyWindow或glfwTerminate销毁</p><p>由于窗口和上下文是不可分割地联系在一起的，窗口对象也充当上下文句柄。</p><h3 id="设置窗口的一些属性"><a href="#设置窗口的一些属性" class="headerlink" title="设置窗口的一些属性"></a>设置窗口的一些属性</h3><p>想像一下,一个窗口能有哪些东西? 标题,显示器,位置,大小,是否透明,最小化,最大化,焦点,图标. 这些属性有些可以使用hints设置,有些有单独的函数设置,还可以使用<code>glfwSetWindowAttrib</code>设置.</p><p>需要注意的是Framebuffer size和window size,window size是虚拟屏幕坐标,而framebuffer size是pixel,适合使用glviewport</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">glfwGetFramebufferSize(window, &amp;width, &amp;height);</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br></pre></td></tr></table></figure><h3 id="窗口属性"><a href="#窗口属性" class="headerlink" title="窗口属性"></a>窗口属性</h3><p>Windows有许多属性可以使用glfwGetWindowAttrib返回。一些反映了可能由于用户交互而改变的状态(例如是否有输入焦点)，而另一些反映了窗口的固有属性(例如它有什么样的边界)。一些与窗口相关，另一些与OpenGL或OpenGL ES上下文相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (glfwGetWindowAttrib(window, GLFW_FOCUSED))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// window has input focus</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glfwSetWindowAttrib(window, GLFW_RESIZABLE, GLFW_FALSE);</span><br></pre></td></tr></table></figure><h3 id="buffer交换"><a href="#buffer交换" class="headerlink" title="buffer交换"></a>buffer交换</h3><p>默认情况下，GLFW窗口是双缓冲的。这意味着有两个渲染缓冲区;一个前缓冲，一个后缓冲。前缓冲区是要显示的缓冲区，后缓冲区是要渲染的缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapBuffers(window);</span><br></pre></td></tr></table></figure><p>选择何时进行缓冲区交换是很有用的。使用函数glfwSwapInterval，可以选择驱动程序在交换缓冲区之前从调用glfwSwapBuffers开始应该等待的监视器刷新的最小次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapInterval(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果间隔为零，则在调用glfwSwapBuffers时立即进行交换，而无需等待刷新。否则，每次缓冲区交换之间至少会传递间隔回溯。当不希望测量等待垂直回溯所需的时间时，使用零交换间隔对基准测试很有用。但是，交换间隔为1可以避免撕裂</p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>当使用glfwCreateWindow创建一个窗口和它的OpenGL或OpenGL ES上下文时，可以指定另一个窗口，它的上下文应该与新窗口共享它的对象(纹理，顶点和元素缓冲区等)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* second_window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Second Window&quot;</span>, <span class="literal">NULL</span>, first_window);</span><br></pre></td></tr></table></figure><p>在你进行OpenGL或OpenGL ES调用之前，需要有一个正确类型的当前上下文。一个上下文一次只能对一个线程是当前的，而一个线程一次只能有一个当前的上下文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line">GLFWwindow* window = glfwGetCurrentContext();</span><br></pre></td></tr></table></figure><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器对象表示当前连接的显示器，并表示为指向不透明类型GLFWmonitor的指针。显示器对象不能由应用程序创建或销毁，并保留其地址，直到它们所代表的显示器断开连接或直到库终止</p><p>每个显示器都有一个当前视频模式，一个支持的视频模式列表，一个虚拟位置，一个人类可读的名称，一个估计的物理尺寸和一个gamma ramp。其中一个监控器是主监控器.显示器的虚拟位置以屏幕坐标表示,并与当前视频模式一起描述了连接的显示器提供给跨越它们的虚拟桌面的视口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLFWmonitor* primary = glfwPrimaryMonitor();</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">GLFWmonitor** monitors = glfwGetMonitors(&amp;count);</span><br></pre></td></tr></table></figure><h4 id="显示器配置改变"><a href="#显示器配置改变" class="headerlink" title="显示器配置改变"></a>显示器配置改变</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glfwSetMonitorCallback(monitor_callback);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_callback</span><span class="params">(GLFWmonitor* monitor, <span class="keyword">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == GLFW_CONNECTED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The monitor was connected</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event == GLFW_DISCONNECTED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The monitor was disconnected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示器属性"><a href="#显示器属性" class="headerlink" title="显示器属性"></a>显示器属性</h4><p>当创建一个全屏窗口时,改变它的视频模式或使窗口成为一个全屏,GLFW通常会很好地选择一个合适的视频模式,但有时确切地知道支持哪些视频模式是有用的。</p><p>视频模式表示为GLFWvidmode结构。您可以使用glfwGetVideoModes获得监视器支持的视频模式数组。有关返回数组的生命周期</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">GLFWvidmode* modes = glfwGetVideoModes(monitor, &amp;count);</span><br><span class="line"><span class="keyword">const</span> GLFWvidmode* mode = glfwGetVideoMode(monitor);</span><br></pre></td></tr></table></figure><p>监视器的物理尺寸(以毫米为单位)或其估计值可以使用glfwGetMonitorPhysicalSize来检索。这与当前分辨率无关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width_mm, height_mm;</span><br><span class="line">glfwGetMonitorPhysicalSize(monitor, &amp;width_mm, &amp;height_mm);</span><br></pre></td></tr></table></figure><p>可以使用glfwGetMonitorPos获取监视器在虚拟桌面上的位置(以屏幕坐标表示)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xpos, ypos;</span><br><span class="line">glfwGetMonitorPos(monitor, &amp;xpos, &amp;ypos);</span><br></pre></td></tr></table></figure><p>未被全局任务栏或菜单栏占用的监视器区域是工作区域。这是在屏幕坐标中指定的，可以使用glfwGetMonitorWorkarea进行检索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xpos, ypos, width, height;</span><br><span class="line">glfwGetMonitorWorkarea(monitor, &amp;xpos, &amp;ypos, &amp;width, &amp;height);</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>GLFW提供多种输入。虽然有些只能轮询，如时间，或只能通过回调接收，如滚动，但许多同时提供回调和轮询。回调要比轮询做更多的工作，但CPU密集程度较低，并保证不会错过状态更改</p><p>所有输入回调都接收一个窗口句柄。通过使用窗口用户指针，您可以从回调中访问非全局结构或对象。</p><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>GLFW需要轮询窗口系统的事件，以便向应用程序提供输入，并向窗口系统证明应用程序没有锁定。事件处理通常在缓冲区交换后的每一帧完成。即使没有窗口，也需要进行事件轮询，以便接收监视器和操纵杆连接事件</p><p>有三个函数用于处理挂起事件</p><p>glfwPollEvents，只处理那些已经接收到的事件，然后立即返回。</p><p>如果只需要在接收新输入时更新窗口的内容，那么glfwWaitEvents是更好的选择</p><p>它将线程置于睡眠状态，直到至少接收到一个事件，然后处理所有接收到的事件。这节省了大量的CPU周期，并且对于编辑工具等非常有用。</p><p>如果你想等待事件，但有UI元素或其他需要定期更新的任务,glfwWaitEventsTimeout允许你指定一个超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwWaitEventsTimeout(<span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p>如果主线程在glfwWaitEvents中休眠，可以通过使用glfwPostEmptyEvent向事件队列发送一个空事件来从另一个线程唤醒它</p><p>不要假设回调只会在响应上述函数时被调用。虽然有必要以上述一种或多种方式处理事件，但需要GLFW注册其自身回调的窗口系统可以将事件传递给GLFW以响应许多窗口系统函数调用。GLFW将在返回之前将这些事件传递给应用程序回调</p><h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><p>GLFW将键盘输入分为两类;关键事件和角色事件。键事件与实际的物理键盘键有关，而字符事件与按下其中一些键产生的文本有关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == GLFW_KEY_E &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        activate_airship();</span><br><span class="line">&#125;</span><br><span class="line">glfwSetKeyCallback(window, key_callback);</span><br></pre></td></tr></table></figure><p>GLFW支持由操作系统文本输入系统生成的Unicode码点流形式的文本输入。与按键输入不同，文本输入受键盘布局和修改键的影响</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">character_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">unsigned</span> <span class="keyword">int</span> codepoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">glfwSetCharCallback(window, character_callback);</span><br></pre></td></tr></table></figure><h4 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h4><p>鼠标输入有多种形式，包括鼠标移动、按钮按压和滚动偏移。还可以更改光标的外观，将其更改为自定义图像或来自系统主题的标准光标形状</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> xpos, ypos;</span><br><span class="line">glfwGetCursorPos(window, &amp;xpos, &amp;ypos);</span><br><span class="line">glfwSetCursorPosCallback(window, cursor_position_callback);</span><br></pre></td></tr></table></figure><p>回调函数接收光标位置，以屏幕坐标测量，但相对于窗口内容区域的左上角。。</p><p>如果希望实现基于鼠标运动的相机控制或其他需要无限制鼠标移动的输入方案，请将光标模式设置为<code>GLFW_CURSOR_DISABLED</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure><p>这将隐藏光标并将其锁定到指定的窗口。然后，GLFW将处理光标重新居中和偏移计算的所有细节，并为应用程序提供虚拟光标位置。这个虚拟位置通常通过回调和轮询提供。原始鼠标运动更接近鼠标在表面上的实际运动。它不受应用于桌面光标运动的缩放和加速的影响。这种处理适合于光标，而原始运动更适合于控制，例如3D相机。因此，仅在禁用光标时才提供原始鼠标运动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (glfwRawMouseMotionSupported())</span><br><span class="line">    glfwSetInputMode(window, GLFW_RAW_MOUSE_MOTION, GLFW_TRUE);</span><br></pre></td></tr></table></figure><p>使用glfwCreateCursor创建自定义鼠标，它返回创建的鼠标对象的句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> pixels[<span class="number">16</span> * <span class="number">16</span> * <span class="number">4</span>];</span><br><span class="line"><span class="built_in">memset</span>(pixels, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(pixels));</span><br><span class="line"> </span><br><span class="line">GLFWimage image;</span><br><span class="line">image.width = <span class="number">16</span>;</span><br><span class="line">image.height = <span class="number">16</span>;</span><br><span class="line">image.pixels = pixels;</span><br><span class="line"> </span><br><span class="line">GLFWcursor* cursor = glfwCreateCursor(&amp;image, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以使用glfwCreateStandardCursor创建当前系统游标主题中具有标准形状的游标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLFWcursor* url_cursor = glfwCreateStandardCursor(GLFW_POINTING_HAND_CURSOR);</span><br></pre></td></tr></table></figure><p>如果希望在光标进入或离开窗口的内容区域时得到通知设置光标进入/离开回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursor_enter_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> entered)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entered)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The cursor entered the content area of the window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The cursor left the content area of the window</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">glfwSetCursorEnterCallback(window, cursor_enter_callback);</span><br></pre></td></tr></table></figure><p>可以查询鼠标当前是否在具有glfw_hoved窗口属性的窗口的内容区域内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (glfwGetWindowAttrib(window, GLFW_HOVERED))</span><br><span class="line">&#123;</span><br><span class="line">    highlight_interface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="鼠标按钮输入"><a href="#鼠标按钮输入" class="headerlink" title="鼠标按钮输入"></a>鼠标按钮输入</h4><p>如果希望在鼠标按钮被按下或释放时收到通知设置鼠标按钮回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetMouseButtonCallback(window, mouse_button_callback);</span><br></pre></td></tr></table></figure><p>回调函数接收鼠标按钮、按钮动作和修饰符位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_button_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> button, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (button == GLFW_MOUSE_BUTTON_RIGHT &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        popup_menu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个受支持的鼠标按钮的最后状态也保存在每个窗口状态数组中，可以使用glfwGetMouseButton轮询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT);</span><br><span class="line"><span class="keyword">if</span> (state == GLFW_PRESS)</span><br><span class="line">&#123;</span><br><span class="line">    upgrade_cow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glfw<span class="constructor">SetScrollCallback(<span class="params">window</span>, <span class="params">scroll_callback</span>)</span>;</span><br><span class="line">void scroll<span class="constructor">_callback(GLFWwindow<span class="operator">*</span> <span class="params">window</span>, <span class="params">double</span> <span class="params">xoffset</span>, <span class="params">double</span> <span class="params">yoffset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的鼠标滚轮是垂直的，它提供沿y轴的偏移量</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.如何在windows上去掉启动时出现的控制台(使用vs或cmake)<a href="https://stackoverflow.com/questions/5995433/removing-console-window-for-glut-freeglut-glfw">c++ - Removing console window for Glut/FreeGlut/GLFW? - Stack Overflow</a><a href="https://stackoverflow.com/questions/78704285/how-do-i-remove-the-console-window-in-a-c-application-in-visual-studio">How do I remove the console window in a C++ application in Visual Studio? - Stack Overflow</a> 但是似乎只对cl.exe也就是MSVC管用,无法跨平台了,只能针对不同平台分别编译,gcc/clang(但测试了貌似不管用)可以使用<code>-mwindows</code><a href="https://discourse.glfw.org/t/eliminate-shell-window/354/2">Eliminate shell window? - support - GLFW</a></p><p>在vs上在配置属性,链接器,系统上修改subsystem以及高级中的entry point</p><p>设置应用为窗口应用,由于它默认需要wmain函数而不是main函数,还需要修改入口函数为main<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170">/ENTRY（入口点符号） | Microsoft Learn</a>.</p><p><img data-src="https://s2.loli.net/2024/10/06/l5MFVcaY4thObmx.png" alt="image-20241006151255023"></p><p><img data-src="https://s2.loli.net/2024/10/06/8jMH3BaLvzRJwEl.png" alt="image-20241006151328843"></p><p>在cmake上类似,但需要使用<code>clang-cl.exe</code>(而不是clang.exe),<code>msvc</code>作为generator(不能是其他的).</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_NAME <span class="keyword">STREQUAL</span> <span class="string">&quot;Windows&quot;</span> <span class="keyword">AND</span> CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_options</span>(learn_gl PRIVATE  /SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># 或者使用set_target_properties(exe_name PROPERTIES </span></span><br><span class="line">    LINK_FLAGS <span class="string">&quot;/ENTRY:mainCRTStartup /SUBSYSTEM:WINDOWS&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者在源文件中添加如下<a href="https://stackoverflow.com/questions/11785157/replacing-winmain-with-main-function-in-win32-programs/11785733#11785733">c++ - Replacing WinMain() with main() function in Win32 programs - Stack Overflow</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/subsystem:windows /ENTRY:mainCRTStartup&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一个问题是使用了vs作为generator,目前无法生成clangd的compile_commands.json了<a href="https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html">CMAKE_EXPORT_COMPILE_COMMANDS — CMake 3.30.4 Documentation</a>,那就不使用cland使用微软的c++工具用于代码搜索、跳转.</p><p><a href="https://zhuanlan.zhihu.com/p/635410959">C++轻量级跨平台桌面GUI库FLTK的简单使用 - 知乎 (zhihu.com)</a>介绍了一些现有的跨平台桌面库</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用OpenGL或者Vulkan的图形库时经常使用一些窗口工具库搭配,常见的就是&lt;a href=&quot;https://www.glfw.org/docs/latest/index.html&quot;&gt;GLFW: Introduction&lt;/a&gt;了,类似的有SDL,SFML和win32库,这里也会简单说一下. 这篇文章相当于GLFW的api介绍&lt;/p&gt;</summary>
    
    
    
    
    <category term="window library" scheme="https://www.sekyoro.top/tags/window-library/"/>
    
  </entry>
  
  <entry>
    <title>链接动态库在不同操作系统上的行为</title>
    <link href="https://www.sekyoro.top/2024/10/04/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%A1%8C%E4%B8%BA/"/>
    <id>https://www.sekyoro.top/2024/10/04/%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%A1%8C%E4%B8%BA/</id>
    <published>2024-10-04T03:23:29.000Z</published>
    <updated>2024-10-04T09:22:57.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>想必很多人已经了解了动态库与静态库,在实际开发中也经常使用. 但是,有必要了解在windows和Linux上开发c++程序生成和链接动态库的不同行为,因为经常混淆或者自以为找到了动态库,这里简单学习并澄清一下.其中许多内容来自官方文档<br><span id="more"></span></p><p>在linux上静态库常常以.a结尾,动态库以.so结尾,而windows上分别以.lib与.dll结尾. 于是很多人就把.dll等同于.so使用了,但其实并不一样. </p><h2 id="编译与链接静态库"><a href="#编译与链接静态库" class="headerlink" title="编译与链接静态库"></a>编译与链接静态库</h2><p><strong>生成动态库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfoo.so foo.c</span><br></pre></td></tr></table></figure><p><strong>生成静态库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o libfoo.o foo.c -I include </span><br><span class="line">ar cr libfoo.a libfoo.o</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><strong>-ggdb</strong></td><td>此选项将尽可能的生成 gdb 的可以使用的调试信息.</td></tr><tr><td>-l [lib]</td><td>（这里是小写的L,命令无中括号,下同）指定程序要链接的库,[lib]为库文件名称.如果gcc编译选项中加入了“-static”表示寻找静态库文件</td></tr><tr><td>-L [dir]</td><td>指定-l（小写-L）所使用到的库文件所在路径(链接时而非动态查找),不然编译器将只在标准库的目录找</td></tr><tr><td>-I [dir]</td><td>（这里是大写的I）增加 include 头文件路径</td></tr><tr><td>-static</td><td>链接静态库生成目标文件,禁止使用动态库（在支持动态链接的系统上） 所以编译出来的东西一般都很大,也不需要什么动态连接库就可以运行.</td></tr><tr><td>-shared</td><td>生成共享文件,可以与其它文件链接生成可执行文件</td></tr><tr><td>-fpic</td><td>生成适用于共享库的<strong>与地址无关的代码</strong>（PIC）（如果机器支持的话）</td></tr><tr><td>-fPIC</td><td>生成<strong>与位置无关的的代码</strong>,适用于使用动态库,与“-fpic”的区别在于去除去全局偏移表的任何限制（如果机器支持的话）</td></tr></tbody></table></div><p>链接动态库和链接静态库差别不大,但是需要设置一些路径方便linux查找.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -I/home/alice/foo -lfoo</span><br></pre></td></tr></table></figure><blockquote><p>如果静态库和动态库在同一目录并且前缀相同,e.g. libxx.so和libxx.a,使用<code>g++ -o main main.cpp -L build/lib -l xx -I lib/include</code>会默认链接动态库,添加<code>-static</code>可解决(不过一般也不会同时把动态库和静态库同名放一个目录吧😅)</p></blockquote><p>gcc <code>-L</code> <code>-l</code>含义是什么,不管是动态库还是链接库,如果使用了库,都需要使用<code>-L</code>和<code>-l</code>进行编译时链接,如果是静态库,<code>-l</code>往往就够了,但如果是动态库,<code>-l</code>作用是在编译时让编译器直到用到了库中的某些东西存在,但是运行时还需要另外设置,如果链接动态库不使用<code>-l</code>也会报错</p><p><img data-src="https://s2.loli.net/2024/10/04/w37nS5PECGmVyjc.png" alt="image-20241004132437629"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp   ./build/lib/libdy_lib.so -I lib/include</span><br></pre></td></tr></table></figure><p>或者直接使用<code>.so</code>与<code>.cpp</code>编译链接,注意这在windows上行不通,根本原因是动态库的路径搜索方式不同</p><p>文件一多,项目一大肯定需要使用构建系统的,包括make,Ninja,MSBuilg等等,而cmake就是生成这些构建系统的,当使用cmake时就没有太大必要考虑编译器细节了.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成</span></span><br><span class="line"><span class="keyword">add_library</span>(dy_lib STATIC <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="comment"># add_library(dy_lib SHARED test.cpp)</span></span><br><span class="line"><span class="comment"># 链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(cpp_test PRIVATE dy_lib)</span><br></pre></td></tr></table></figure><h3 id="链接动态库在cmake中的行为"><a href="#链接动态库在cmake中的行为" class="headerlink" title="链接动态库在cmake中的行为"></a>链接动态库在cmake中的行为</h3><p>RPATH在开发过程中很有用,因为可以将构建树中的库链接到可执行文件中.CMake提供了相当多的选项来优化构建树链接和安装链接期间的行为</p><p>我们知道要使用动态库,光是<code>-l</code>是不行的,在windows上需要看链接方式(下面详细介绍),在linux上也要设置动态库搜索路径. 使用cmake时链接动态库,cmake会默认设置buil_rpath,但安装时使用install_rpath<a href="https://cmake.org/cmake/help/latest/prop_tgt/BUILD_RPATH.html">BUILD_RPATH — CMake 3.30.4 Documentation</a></p><p><strong>BUILD_PATH</strong></p><p>一个分号分隔的列表,指定要添加到构建树中链接的二进制文件中的运行时路径(RPATH)条目(对于支持它的平台).默认情况下,CMake在构建树中设置二进制文件的运行时路径,以包含它知道需要查找它们链接的共享库的搜索路径.项目可以设置BUILD_RPATH来指定额外的搜索路径.</p><ul><li>The <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_SKIP_RPATH.html#variable:CMAKE_SKIP_RPATH"><code>CMAKE_SKIP_RPATH</code></a> variable completely disables runtime paths in both the build tree and install tree.</li><li>The <a href="https://cmake.org/cmake/help/latest/prop_tgt/SKIP_BUILD_RPATH.html#prop_tgt:SKIP_BUILD_RPATH"><code>SKIP_BUILD_RPATH</code></a> target property disables setting any runtime path in the build tree.</li><li>The <a href="https://cmake.org/cmake/help/latest/prop_tgt/BUILD_RPATH_USE_ORIGIN.html#prop_tgt:BUILD_RPATH_USE_ORIGIN"><code>BUILD_RPATH_USE_ORIGIN</code></a> target property causes the automatically-generated runtime path to use entries relative to <code>$ORIGIN</code>.</li><li>The <a href="https://cmake.org/cmake/help/latest/prop_tgt/BUILD_WITH_INSTALL_RPATH.html#prop_tgt:BUILD_WITH_INSTALL_RPATH"><code>BUILD_WITH_INSTALL_RPATH</code></a> target property causes binaries in the build tree to be built with the install-tree runtime path.</li></ul><p>下面是默认设置.默认情况下,如果不更改任何 RPATH 相关设置,CMake 将以完整的 RPATH 连接可执行文件和共享库,并将其连接到联编树中所有使用过的库.安装时,它会清除这些目标的 RPATH,因此它们在安装时的 RPATH 为空</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use, i.e. don&#x27;t skip the full RPATH for the build tree</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SKIP_BUILD_RPATH <span class="keyword">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># when building, don&#x27;t use the install RPATH already</span></span><br><span class="line"><span class="comment"># (but later on when installing)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># the RPATH to be used when installing</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># don&#x27;t add the automatically determined parts of the RPATH</span></span><br><span class="line"><span class="comment"># which point to directories outside the build tree to the install RPATH</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH_USE_LINK_PATH <span class="keyword">FALSE</span>)</span><br></pre></td></tr></table></figure><p>也就是说cmake在build时默认添加在build目录下使用的动态库路径,在安装库时rpath默认为空</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>在Linux系统中,动态链接器（如ld-linux.so）负责在应用程序启动时解析其依赖的共享库.动态链接器根据一定的搜索顺序来查找这些共享库,这个顺序通常包括：</p><ol><li><strong>RPATH</strong>：如果可执行文件中指定了RPATH,动态链接器会首先在这个路径下搜索共享库.</li><li><strong>LD_LIBRARY_PATH</strong>：如果未找到所需的库,动态链接器会继续在由环境变量LD_LIBRARY_PATH指定的目录中搜索.</li><li>配置文件/etc/ld.so.conf</li><li><strong>系统默认路径</strong>：如果仍未找到,动态链接器会在系统默认的库路径（如<code>/lib</code>和<code>/usr/lib</code>）中搜索.</li></ol><p>理解这个搜索机制有助于我们更好地掌握如何通过调整RPATH来控制应用程序的动态链接行为</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unless loading object has RUNPATH:</span><br><span class="line">    RPATH <span class="keyword">of</span> <span class="keyword">the</span> loading object,</span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">the</span> RPATH <span class="keyword">of</span> its loader (unless <span class="keyword">it</span> has <span class="keyword">a</span> RUNPATH), ...,</span><br><span class="line">        <span class="keyword">until</span> <span class="keyword">the</span> <span class="function"><span class="keyword">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">chain</span>, <span class="title">which</span> <span class="title">is</span> <span class="title">either</span> <span class="title">the</span> <span class="title">executable</span></span></span><br><span class="line">        <span class="keyword">or</span> <span class="keyword">an</span> object loaded <span class="keyword">by</span> dlopen</span><br><span class="line">    Unless executable has RUNPATH:</span><br><span class="line">        RPATH <span class="keyword">of</span> <span class="keyword">the</span> executable</span><br><span class="line">LD_LIBRARY_PATH</span><br><span class="line">RUNPATH <span class="keyword">of</span> <span class="keyword">the</span> loading object</span><br><span class="line">ld.so.cache</span><br><span class="line">default dirs</span><br></pre></td></tr></table></figure><h3 id="RPATH"><a href="#RPATH" class="headerlink" title="RPATH"></a>RPATH</h3><p>rpath优先级最高,会优先让执行档去寻找相应的动态库(如果设置了RUNPATH就会忽略RPATH<a href="https://stackoverflow.com/questions/7967848/use-rpath-but-not-runpath">c - use RPATH but not RUNPATH? - Stack Overflow</a>,简单来说,如果设置了RUN_PATH,那么RPATH会被忽略,但是RUNPATH优先级又低于<code>LD_LIBRAY_PATH</code></p><p>作者给的建议是<code>当您发布二进制文件时,要么使用RPATH而不是RUNPATH,要么确保在运行它们之前设置了LD_LIBRARY_PATH</code>,当然也有推荐只使用<code>LIBRARY_PATH</code>的.</p><p>注意,runpath和rpath也许操作系统支持有关,新版本的os<strong>应该</strong>默认使用runpath了,也就是使用<code>gcc -rpath</code>时默认设置<code>runpath</code></p><p>设置rpath,告诉新系统使用老行为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ... -Wl --disable-new-dtags -rpath=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>设置runpath,告诉旧系统使用新行为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ... -Wl --enable-new-dtags -rpath=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>查看一个elf文件的PATH,可以看到目前默认是runpath,rpath是depreacated了,这两者最大差异就是优先级</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf --dynamic obj | grep PATH</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/10/04/wKgcNut2XI1T6VD.png" alt="image-20241004140806996"></p><p>使用cmake开发时,默认就是这样使用动态库的</p><h3 id="LIBRAY-PATH"><a href="#LIBRAY-PATH" class="headerlink" title="LIBRAY_PATH"></a>LIBRAY_PATH</h3><p>LIBRAY_PATH不是运行时搜索动态库,其效果类似于<code>gcc -L</code>,设置编译时查找路径</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LIBRARY_PATH=/home/foo</span><br><span class="line">gcc -o main main.c -I/home/foo -lfoo</span><br><span class="line">ls</span><br><span class="line">main  main.c</span><br></pre></td></tr></table></figure><p>推荐使用<code>gcc -L</code>即可</p><blockquote><p>事实上实践中直接使用cmake</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>()</span><br><span class="line"><span class="keyword">target_link_libraries</span>()</span><br></pre></td></tr></table></figure><h3 id="LD-LIBRAY-PATH"><a href="#LD-LIBRAY-PATH" class="headerlink" title="LD_LIBRAY_PATH"></a>LD_LIBRAY_PATH</h3><p>你会发现在链接动态库后执行程序也无法成功,因为linux搜索动态库的路径并没有包括动态库的路径,道理同<code>rpath</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/home/work</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><h3 id="etc-ld-so-conf"><a href="#etc-ld-so-conf" class="headerlink" title="/etc/ld.so.conf"></a>/etc/ld.so.conf</h3><blockquote><p>将非标准路经加入 /etc/ld.so.conf,然后运行 ldconfig 生成 /etc/ld.so.cache. ld.so 加载共享库的时候,会从 ld.so.cache 查找</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ld.so.conf</span><br><span class="line"><span class="comment"># 在文件中添加库路径 e.g. /project/build/libdy_lib.so</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>原理是ldconfig这个程序,程序运行时会通过这个程序查找库.</p><h3 id="默认搜索路径"><a href="#默认搜索路径" class="headerlink" title="默认搜索路径"></a>默认搜索路径</h3><p>可执行程序动态库默认搜索路径包括/usr/lib和/lib</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp libdy_lib.so /lib</span><br><span class="line"><span class="comment"># 以下命令均可</span></span><br><span class="line">cp libdy_lib.so /usr/lib</span><br><span class="line">ln -s libdy_lib.so /usr/lib</span><br></pre></td></tr></table></figure><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>windows并没有类似linux的rpath机制<a href="https://stackoverflow.com/questions/107888/is-there-a-windows-msvc-equivalent-to-the-rpath-linker-flag">dll - Is there a Windows/MSVC equivalent to the -rpath linker flag? - Stack Overflow</a></p><blockquote><p>当你使用visual studio开发使用了动态库时,也许你在vs上执行并没有问题,但直接点击可执行程序执行就报错了(即使你给可执行程序添加了相关引用). 主要原因是vs在编译链接时会去引用生成的目录找相关.dll和.lib(即使是动态库,vs也会生成DLL导入库,这类似一个查找表,方便获取DLL中的函数、变量等)</p><p>而在运行时,动态库的查找机制就不一样了</p><p><img data-src="https://s2.loli.net/2024/10/04/kYxoIivzWmrOuGd.png" alt="链接时加载了.dll库,成功执行"></p></blockquote><h3 id="链接方法"><a href="#链接方法" class="headerlink" title="链接方法"></a>链接方法</h3><p>可执行文件通过以下两种方式之一链接到（或加载）DLL：</p><ul><li>隐式链接,其中操作系统会与使用 DLL 的可执行文件同时加载它. 客户端<strong>可执行文件调用 DLL 的导出函数的方式与函数进行静态链接并包含在可执行文件中时的方式相同</strong>. 隐式链接有时称为静态加载或加载时动态链接.</li><li>显式链接,其中操作系统会在运行时按需加载 DLL. 通过显式链接使用 DLL 的可执行文件必须显式加载和卸载 DLL. 它还必须设置函数指针,用于访问它从 DLL 使用的每个函数. 与静态链接的库或隐式链接 DLL 中的函数调用不同,客户端可执行文件必须通过函数指针调用显式链接 DLL 中的导出函数. 显式链接有时称为动态加载或运行时动态链接.</li></ul><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>当应用程序的代码调用导出 DLL 函数时,会进行隐式链接. 当编译或汇编调用可执行文件的源代码时,DLL 函数调用会在对象代码中生成外部函数引用.</p><p> <strong>若要解析此外部引用,应用程序必须与 DLL 创建者提供的导入库（.lib 文件）链接</strong>.</p><p>导入库包含的代码仅用于加载 DLL 和实现对 DLL 中函数的调用. 在导入库中查找外部函数会告知链接器该函数的代码处于 DLL 中. 若要解析对 DLL 的外部引用,链接器只需将信息添加到可执行文件,告知系统在进程启动时查找 DLL 代码的位置.</p><p>当系统启动包含动态链接引用的程序时,它将使用该程序可执行文件中的信息查找所需 DLL. 如果找不到 DLL,则系统将终止进程,并显示报告错误的对话框. 否则,系统会将 DLL 模块映射到进程地址空间中.</p><p>所以我们需要一个.lib文件方便静态加载,也就是程序在编译时就知道了动态库的位置(通过.lib),这样方便查找,而不是像上面提到的linux再通过rpath等路径去看. 那这样做需要什么呢? 那就是经典的<code>__declspec(dllexport)</code>了<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/dllexport-dllimport?view=msvc-170">dllexport、dllimport | Microsoft Learn</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllImport   __declspec( dllimport )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllExport   __declspec( dllexport )</span></span><br><span class="line"></span><br><span class="line"><span class="function">DllExport <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">DllExport <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">DllImport <span class="keyword">int</span> j;</span><br><span class="line">DllExport <span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure><p>使用 <strong><code>dllexport</code></strong> 意味着定义,而使用 <strong><code>dllimport</code></strong> 则意味着声明. 必须使用带 <strong><code>extern</code></strong> 的 <strong><code>dllexport</code></strong> 关键字来强制进行声明；否则,会进行隐式定义.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __declspec( dllimport ) <span class="keyword">int</span> l; <span class="comment">// Error; not declared extern.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> __declspec( dllimport ) <span class="keyword">int</span> s;  <span class="comment">// Error; not declared</span></span><br><span class="line">                                           <span class="comment">// extern.</span></span><br><span class="line">    __declspec( dllimport ) <span class="keyword">int</span> m;         <span class="comment">// Okay; this is a</span></span><br><span class="line">                                           <span class="comment">// declaration.</span></span><br><span class="line">    __declspec( dllexport ) <span class="keyword">int</span> n;         <span class="comment">// Error; implies external</span></span><br><span class="line">                                           <span class="comment">// definition in local scope.</span></span><br><span class="line">    <span class="keyword">extern</span> __declspec( dllimport ) <span class="keyword">int</span> i;  <span class="comment">// Okay; this is a</span></span><br><span class="line">                                           <span class="comment">// declaration.</span></span><br><span class="line">    <span class="keyword">extern</span> __declspec( dllexport ) <span class="keyword">int</span> k;  <span class="comment">// Okay; extern implies</span></span><br><span class="line">                                           <span class="comment">// declaration.</span></span><br><span class="line">    __declspec( dllexport ) <span class="keyword">int</span> x = <span class="number">5</span>;     <span class="comment">// Error; implies external</span></span><br><span class="line">                                           <span class="comment">// definition in local scope.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当声明 <strong><code>dllexport</code></strong> 类时,它的所有成员函数和静态数据成员都会导出. 必须在同一程序中提供所有此类成员的定义. 否则,将生成链接器错误. 此规则有一个例外情况,即对于纯虚函数,无需为其提供显式定义. 但是,由于基类的析构函数始终在调用继承类的析构函数,因此纯虚析构函数必须始终提供定义</p><p>当声明 <strong><code>dllimport</code></strong> 类时,它的所有成员函数和静态数据成员都会导入. 与非类类型上的 <strong><code>dllimport</code></strong> 和 <strong><code>dllexport</code></strong> 的行为不同,静态数据成员无法在定义 <strong><code>dllimport</code></strong> 类的同一程序中指定定义. 如果整个类都已导入或导出,则禁止将成员函数和数据显式声明为 <strong><code>dllimport</code></strong> 或 <strong><code>dllexport</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllExport   __declspec( dllexport )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DllExport</span> <span class="title">C</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib_link_input_2.cpp</span></span><br><span class="line"><span class="comment">// compile by using: cl /EHsc lib_link_input_1.lib lib_link_input_2.cpp</span></span><br><span class="line">__declspec(dllimport) <span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="built_in">Test</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在windows上,这几乎成了常用的方式,不管你使用的什么编译器,即便是mingw,clang</p><p>如果使用vc++,那会生成xx.dll与libxx.lib,后者用于找动态库,而使用mingw,clang会生成xx.dll和xx.dll.a,效果一样.</p><p>若要通过隐式链接使用 DLL,客户端可执行文件必须从 DLL 的提供程序获取以下文件：</p><ul><li>一个或多个头文件（.h 文件）,其中包含 DLL 中的导出数据、函数和 C++ 类的声明. DLL 导出的类、函数和数据全都必须在头文件中标记为 <code>__declspec(dllimport)</code></li><li>要链接到可执行文件中的导入库. 生成 DLL 时,链接器会创建导入库</li><li>实际 DLL 文件.</li></ul><p>我们在windows上默认都是使用的隐式链接,如果你要使用动态库,还挺麻烦的.</p><h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p>有时需要显式链接. 下面是使用显式链接的一些常见原因：</p><ul><li>应用程序直到运行时才知道它所加载的 DLL 的名称. 例如,应用程序可能会在启动时从配置文件获取 DLL 的名称和导出函数.</li><li>如果在使用隐式链接的进程启动时找不到 DLL,则操作系统会终止进程. 使用显式链接的进程在这种情况下不会终止,可以尝试从错误中恢复. 例如,进程可以向用户通知错误,并让用户指定 DLL 的其他路径.</li><li>如果使用隐式链接的进程所链接到的任何 DLL 的 <code>DllMain</code> 函数失败,则进程也会终止. 使用显式链接的进程在这种情况下不会终止.</li><li>隐式链接到许多 DLL 的应用程序可能会速度较慢,因为 Windows 会在应用程序加载时加载所有 DLL. 若要提高启动性能,应用程序可以只对在加载之后立即需要的 DLL 使用隐式链接. 它可以仅在需要时才使用显式链接加载其他 DLL.</li><li>显式链接无需使用导入库链接应用程序. 如果 DLL 中的更改导致导出序号发生更改,则在使用函数名称而不是序号值调用 <code>GetProcAddress</code> 时,应用程序无需重新链接. 使用隐式链接的应用程序仍必须重新链接到更改的导入库.</li></ul><p>若要通过显式链接使用 DLL,应用程序必须在运行时进行函数调用以显式加载 DLL. 若要显式链接到 DLL,应用程序必须：</p><ul><li>调用LoadLibraryEx或类似函数以加载 DLL 并获取模块句柄.</li><li>调用 GetProcAddress以获取应用程序调用的每个导出函数的函数指针. 由于应用程序通过指针调用 DLL 函数,因此编译器不生成外部引用,从而不需要与导入库链接. 不过必须有 <strong><code>typedef</code></strong> 或 <strong><code>using</code></strong> 语句,此语句定义调用的已导出函数的调用签名.</li><li>处理完 DLL 时,调用 FreeLibrary</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span> <span class="params">(CALLBACK* LPFNDLLFUNC1)</span><span class="params">(DWORD,UINT*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">LoadAndCallSomeFunction</span><span class="params">(DWORD dwParam1, UINT * puParam2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HINSTANCE hDLL;               <span class="comment">// Handle to DLL</span></span><br><span class="line">    LPFNDLLFUNC1 lpfnDllFunc1;    <span class="comment">// Function pointer</span></span><br><span class="line">    HRESULT hrReturnVal;</span><br><span class="line"></span><br><span class="line">    hDLL = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;MyDLL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != hDLL)</span><br><span class="line">    &#123;</span><br><span class="line">        lpfnDllFunc1 = (LPFNDLLFUNC1)<span class="built_in">GetProcAddress</span>(hDLL, <span class="string">&quot;DLLFunc1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != lpfnDllFunc1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// call the function</span></span><br><span class="line">            hrReturnVal = <span class="built_in">lpfnDllFunc1</span>(dwParam1, puParam2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// report the error</span></span><br><span class="line">            hrReturnVal = ERROR_DELAY_LOAD_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(hDLL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hrReturnVal = ERROR_DELAY_LOAD_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hrReturnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态库查找路径"><a href="#动态库查找路径" class="headerlink" title="动态库查找路径"></a>动态库查找路径</h3><blockquote><p>查找路径不仅针对显式链接,隐式链接也能用. 比较方便的就是可执行程序文件、或环境变量PATH</p></blockquote><p>当应用程序调用 LoadLibrary或 LoadLibraryEx函数时,系统会尝试查找 DLL . 如果搜索成功,系统会将 DLL 模块映射到进程的虚拟地址空间,并递增引用计数.</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order">Dynamic-link library search order - Win32 apps | Microsoft Learn</a></p><p>windows搜索dll路径顺序比较麻烦,需要看是否是打包应用(loadPackagedLibrary ),是否开启了安全DLL搜索模式(默认开启)</p><blockquote><p>若要禁用安全 DLL 搜索模式,将<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</code> 创建注册表值并将其设置为 0</p></blockquote><p>如果是未打包并且是安全搜索模式,那么搜索顺序如下,前六个感觉不用看</p><ol><li>DLL 重定向.</li><li>API sets.</li><li>SxS manifest redirection.</li><li>Loaded-module list.</li><li>Known DLLs.</li><li><strong>Windows 11,版本 21H2 (10.0;内部版本 22000) 及更高版本</strong>. The package dependency graph of the process. This is the application’s package plus any dependencies specified as <code>&lt;PackageDependency&gt;</code> in the <code>&lt;Dependencies&gt;</code> section of the application’s package manifest. Dependencies are searched in the order they appear in the manifest.</li><li>从中加载应用程序的文件夹.</li><li>系统文件夹. 使用GetSystemDirectory函数检索此文件夹的路径.</li><li>16 位系统文件夹. 没有获取此文件夹路径的函数,但会对其进行搜索.</li><li>Windows 文件夹. 使用GetWindowsDirectory函数获取此文件夹的路径.</li><li>当前文件夹.</li><li>环境变量中列出的 <code>PATH</code> 目录. 这不包括由应用路径注册表项指定的<strong>App Paths</strong> . 计算 DLL 搜索路径时,不使用 <strong>App Paths</strong> 变量</li></ol><p>如果禁用安全DLL 搜索模式,则搜索顺序基本相同,只是位置11和8交换顺序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下,在linux使用cmake开发c/c++程序链接动态库时使用rpath添加搜索目录,使用windows开发开发动态库实在麻烦,一般默认隐式链接然后使用<code>__declspec( dllexport)</code>导出(因为默认不导出),如果使用现成的xx.dll和libxx.lib就不需要声明<code>__declspec(__dllimport)</code>宏了,因为链接了DLL导入库(也就是libxx.lib) <a href="https://www.youtube.com/watch?v=pLy69V2F_8M&amp;t=481s&amp;ab_channel=TheCherno">Using Dynamic Libraries in C++ (youtube.com)</a></p><p><img data-src="https://learn.microsoft.com/zh-cn/cpp/build/media/mathclient-additional-dependencies-property.png?view=msvc-170" alt="Screenshot of the Property Pages dialog showing the Edit command in the Linker &gt; Input &gt; Additional Dependencies property drop-down."></p><p>至于生成的DLL放哪,连微软自己都说放在可执行文件同一目录中,在vs<code>可将“后期生成事件”添加到项目中,以此添加一条命令,将 DLL 复制到生成输出目录.</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy <span class="regexp">/y /</span>d <span class="string">&quot;..\..\MathLibrary\$(IntDir)MathLibrary.dll&quot;</span> <span class="string">&quot;$(OutDir)&quot;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://learn.microsoft.com/zh-cn/cpp/build/media/mathclient-post-build-command-line.png?view=msvc-170" alt="Screenshot of the Property Pages dialog showing the post build event command line property."></p><p>我的配置如下</p><p><img data-src="https://s2.loli.net/2024/10/04/yH5w6uk8spCKgnW.png" alt="image-20241004164950315"></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy /y /d <span class="string">&quot;<span class="variable">$(OutDir)</span><span class="variable">$(TargetFileName)</span>&quot;</span> <span class="string">&quot;<span class="variable">$(SolutionDir)</span>bin\<span class="variable">$(Platform)</span>\<span class="variable">$(Configuration)</span>\&quot;</span></span><br></pre></td></tr></table></figure><p>在cmake中添加自定义command,道理相同,使用了<code>cmake -E</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> MyTest POST_BUILD        </span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different  </span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/libs/test.dll&quot;</span>      </span><br><span class="line">        $&lt;TARGET_FILE_DIR:MyTest&gt;)                 </span><br></pre></td></tr></table></figure><p>或者类似的使用更好的生成器表达式<code>$&lt;TARGET_RUNTIME_DLLS:MyTest&gt;</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(foo CONFIG REQUIRED) <span class="comment"># package generated by install(EXPORT)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(exe main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(exe PRIVATE foo::foo foo::bar)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> exe POST_BUILD</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy -t $&lt;TARGET_FILE_DIR:exe&gt; $&lt;TARGET_RUNTIME_DLLS:exe&gt;</span><br><span class="line">  COMMAND_EXPAND_LISTS</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>cmake -E copy_if_different</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> <span class="symbol">&lt;file&gt;</span>... destination  - <span class="keyword">copy</span> <span class="keyword">files</span> <span class="keyword">to</span> destination (either <span class="keyword">file</span> <span class="built_in">or</span> directory)</span><br><span class="line">copy_directory <span class="symbol">&lt;dir&gt;</span>... destination   - <span class="keyword">copy</span> content of <span class="symbol">&lt;dir&gt;</span>... directories <span class="keyword">to</span> <span class="string">&#x27;destination&#x27;</span> directory</span><br><span class="line">copy_directory_if_different <span class="symbol">&lt;dir&gt;</span>... destination   - <span class="keyword">copy</span> changed content of <span class="symbol">&lt;dir&gt;</span>... directories <span class="keyword">to</span> <span class="string">&#x27;destination&#x27;</span> directory</span><br><span class="line">copy_if_different <span class="symbol">&lt;file&gt;</span>... destination  - <span class="keyword">copy</span> <span class="keyword">files</span> <span class="keyword">if</span> it <span class="built_in">has</span> changed</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://learn.microsoft.com/zh-cn/cpp/build/linking-an-executable-to-a-dll?view=msvc-170">将可执行文件链接到 DLL | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=msvc-170">演练：创建和使用自己的动态链接库 (C++) | Microsoft Learn</a></li><li><a href="https://blog.csdn.net/feikudai8460/article/details/121823029">gcc/g++ 动态库和静态库,编译与链接（含示例）_g++ 链接静态库-CSDN博客</a></li><li><a href="https://www.baeldung.com/linux/library_path-vs-ld_library_path">LIBRARY_PATH vs LD_LIBRARY_PATH | Baeldung on Linux</a></li><li><a href="https://developer.aliyun.com/article/1469309">【Linux 应用开发 】Linux环境下动态链接库路径（RPATH）的调整策略-阿里云开发者社区 (aliyun.com)</a></li><li><a href="https://www.cnblogs.com/AndyJee/p/3835092.html">Linux动态库(.so)搜索路径 - AndyJee - 博客园 (cnblogs.com)</a></li><li><a href="https://web.archive.org/web/20120418232524/http://labs.qt.nokia.com/2011/10/28/rpath-and-runpath/">RPATH and RUNPATH (archive.org)</a></li><li><a href="https://blog.tremily.us/posts/rpath/">RPATH, RUNPATH, and dynamic linking (tremily.us)</a></li><li><a href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling">RPATH handling · Wiki · CMake / Community · GitLab (kitware.com)</a></li><li><a href="https://stackoverflow.com/questions/10671916/how-to-copy-dll-files-into-the-same-folder-as-the-executable-using-cmake">How to copy DLL files into the same folder as the executable using CMake? - Stack Overflow</a></li><li><a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:TARGET_RUNTIME_DLLS">cmake-generator-expressions(7) — CMake 3.30.4 Documentation</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;想必很多人已经了解了动态库与静态库,在实际开发中也经常使用. 但是,有必要了解在windows和Linux上开发c++程序生成和链接动态库的不同行为,因为经常混淆或者自以为找到了动态库,这里简单学习并澄清一下.其中许多内容来自官方文档&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>窗口系统与图形绘制接口</title>
    <link href="https://www.sekyoro.top/2024/10/02/%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E6%8E%A5%E5%8F%A3/"/>
    <id>https://www.sekyoro.top/2024/10/02/%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E6%8E%A5%E5%8F%A3/</id>
    <published>2024-10-02T03:18:22.000Z</published>
    <updated>2024-10-07T14:03:26.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>当我们想要进行底层图形应用(GUI)开发时,往往需要用到窗口系统和图形库,这里简单介绍一下<br><span id="more"></span></p><h2 id="视窗系统-window-system-与通信协议"><a href="#视窗系统-window-system-与通信协议" class="headerlink" title="视窗系统(window system)与通信协议"></a>视窗系统(window system)与通信协议</h2><p>下面内容主要针对Unix-like操作系统 </p><p><strong>视窗系统</strong>是以使用视窗作为主要特征之一的图形用户接口的构成组件.更为明确地说,它是桌面环境的构成组件.视窗系统支撑著窗口管理器的实现（implementation）；视窗系统为“图像硬件（graphics hardware）、指向设备（pointing devices）提供基本支持.绘制鼠标光标,一般也与视窗系统相关.</p><h3 id="X-Window-System-X11"><a href="#X-Window-System-X11" class="headerlink" title="X Window System(X11)"></a>X Window System(X11)</h3><p>X窗口系统是一种以位图方式显示的软件窗口系统,X窗口系统通过软件工具及架构协议来建立操作系统所用的<a href="https://zh.wikipedia.org/wiki/图形用户界面">图形用户界面</a>,此后则逐渐扩展适用到各形各色的其他操作系统上.</p><blockquote><p>在X11的设计中,应用程序和显示器不必在同一台计算机上,这一点并不明显.在开发X时,X server运行在工作站上,而用户在具有更强处理能力的远程计算机上运行应用程序是很常见的.</p></blockquote><h4 id="X-Window核心协议"><a href="#X-Window核心协议" class="headerlink" title="X Window核心协议"></a>X Window核心协议</h4><p><strong>X Window 核心协议</strong>是X窗口系统的基础协议,它是一个以位图显示的网络化视窗系统,用来在Unix、类Unix和其它操作系统上建立用户图形界面.X Window 系统基于主从式模型：单一服务器控管硬件的输出入,如屏幕、键盘和鼠标；所有的应用程序都被视作客户端,<strong>用户之间透过服务器来交互</strong>.</p><p>交互部分由X Window核心协议来管理.还有其它与X窗口系统有关的协议,有的建立在X Window核心协议之上的,有的是独立的协议.</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/X_client_server_example.svg/220px-X_client_server_example.svg.png" alt="img"></p><p>X server接受来自键盘,鼠标,显示器的输入,并将这些请求发送给client.</p><p><img data-src="https://jichu4n.com/content/images/2018/10/so1jXbe2d2Vvx917pbA5Cjw.png" alt="so1jXbe2d2Vvx917pbA5Cjw"></p><h4 id="X-server"><a href="#X-server" class="headerlink" title="X server"></a>X server</h4><p>与大多数早期的显示协议不同,X是专门设计用于网络连接,而不是用于集成或附加的显示设备.X具有网络透明性,这意味着在网络上某处的计算机(例如Internet)上运行的X程序可以在网络上其他计算机上运行的X服务器上显示其用户界面.</p><p>X服务器通常为X客户机提供图形资源和键盘/鼠标事件,这意味着X服务器通常在人类用户面前的计算机上运行,而X客户机应用程序在网络上的任何地方运行,并与用户的计算机通信,请求图形内容的呈现,并从包括键盘和鼠标在内的输入设备接收事件</p><h4 id="Xlib与其他的客户端程序"><a href="#Xlib与其他的客户端程序" class="headerlink" title="Xlib与其他的客户端程序"></a>Xlib与其他的客户端程序</h4><blockquote><p>大部分的客户端程序借由 Xlib 客户端程序库与服务器交流.特别是客户端大多使用 Xaw、Motif、GTK+、Qt 之类使用到 Xlib 的程序库,方便和服务器交互.</p></blockquote><p>XLib是<strong>X Window System的核心库</strong>,它提供了与窗口系统交互的基本功能,如创建窗口、处理事件和绘制图形</p><blockquote><p><strong>Xlib</strong>是一种X Window System协议的客户端,以C语言撰写.其功能是与X server沟通.这样的功能可以让程序人员撰写程序时,</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* MainDisplay = XOpenDisplay(<span class="number">0</span>);</span><br><span class="line">    Window RootWindow = XDefaultRootWindow(MainDisplay);</span><br><span class="line">    </span><br><span class="line">    Window MainWindow = XCreateSimpleWindow(MainDisplay, RootWindow, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00aade87</span>);</span><br><span class="line">    XMapWindow(MainDisplay, MainWindow);</span><br><span class="line">    XFlush(MainDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123; sleep(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xutil.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    <span class="keyword">int</span> Y;</span><br><span class="line">    <span class="keyword">int</span> Width;</span><br><span class="line">    <span class="keyword">int</span> Height;</span><br><span class="line">&#125; entity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* MainDisplay = XOpenDisplay(<span class="number">0</span>);</span><br><span class="line">    Window RootWindow = XDefaultRootWindow(MainDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DefaultScreen = DefaultScreen(MainDisplay);</span><br><span class="line">    GC Context = XDefaultGC(MainDisplay, DefaultScreen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> WindowX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowWidth = <span class="number">800</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowHeight = <span class="number">600</span>;</span><br><span class="line">    <span class="keyword">int</span> BorderWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WindowDepth = CopyFromParent;</span><br><span class="line">    <span class="keyword">int</span> WindowClass = CopyFromParent;</span><br><span class="line">    Visual* WindowVisual = CopyFromParent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> AttributeValueMask = CWBackPixel | CWEventMask;</span><br><span class="line">    XSetWindowAttributes WindowAttributes = &#123;&#125;;</span><br><span class="line">    WindowAttributes.background_pixel = <span class="number">0xffffccaa</span>;</span><br><span class="line">    WindowAttributes.event_mask = StructureNotifyMask | KeyPressMask | KeyReleaseMask | ExposureMask;</span><br><span class="line"></span><br><span class="line">    Window MainWindow = XCreateWindow(MainDisplay, RootWindow, </span><br><span class="line">            WindowX, WindowY, WindowWidth, WindowHeight,</span><br><span class="line">            BorderWidth, WindowDepth, WindowClass, WindowVisual,</span><br><span class="line">            AttributeValueMask, &amp;WindowAttributes);</span><br><span class="line"></span><br><span class="line">    XMapWindow(MainDisplay, MainWindow);</span><br><span class="line"></span><br><span class="line">    XStoreName(MainDisplay, MainWindow, <span class="string">&quot;Moving rectangle. Use arrow keys to move.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Atom WM_DELETE_WINDOW = XInternAtom(MainDisplay, <span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, False);</span><br><span class="line">    <span class="keyword">if</span>(!XSetWMProtocols(MainDisplay, MainWindow, &amp;WM_DELETE_WINDOW, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t register WM_DELETE_WINDOW property \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    entity Box = &#123;&#125;;</span><br><span class="line">    Box.Width = <span class="number">50</span>;</span><br><span class="line">    Box.Height = <span class="number">80</span>;</span><br><span class="line">    Box.X = WindowWidth/<span class="number">2</span> - Box.Width/<span class="number">2</span>;</span><br><span class="line">    Box.Y = WindowHeight/<span class="number">2</span> - Box.Height/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> StepSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> IsWindowOpen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(IsWindowOpen) &#123;</span><br><span class="line">        XEvent GeneralEvent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        XNextEvent(MainDisplay, &amp;GeneralEvent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(GeneralEvent.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyPress:</span><br><span class="line">            <span class="keyword">case</span> KeyRelease:</span><br><span class="line">            &#123;</span><br><span class="line">                XKeyPressedEvent *Event = (XKeyPressedEvent *)&amp;GeneralEvent;</span><br><span class="line">                <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Escape))</span><br><span class="line">                &#123;</span><br><span class="line">                    IsWindowOpen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Down))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.Y += StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Up))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.Y -= StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Right))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.X += StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event-&gt;keycode == XKeysymToKeycode(MainDisplay, XK_Left))</span><br><span class="line">                &#123;</span><br><span class="line">                    Box.X -= StepSize;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ClientMessage:</span><br><span class="line">            &#123;</span><br><span class="line">                XClientMessageEvent *Event = (XClientMessageEvent *) &amp;GeneralEvent;</span><br><span class="line">                <span class="keyword">if</span>((Atom)Event-&gt;data.l[<span class="number">0</span>] == WM_DELETE_WINDOW) &#123;</span><br><span class="line">                    XDestroyWindow(MainDisplay, MainWindow);</span><br><span class="line">                    IsWindowOpen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        XClearWindow(MainDisplay, MainWindow);</span><br><span class="line">        XFillRectangle(MainDisplay, MainWindow, Context, Box.X, Box.Y, Box.Width, Box.Height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h4><blockquote><p><strong>窗口管理器</strong>（Window manager）是在图形用户界面中,控制窗口位置与外观的软件. 许多窗口管理器是为了桌面环境编写,与桌面环境一同发布的,例如被GNOME使用的Mutter.同时也存在不少独立的窗口管理器,如Openbox、Awesome等.</p></blockquote><p>linux的窗口管理器(dwm,i3wm)以及桌面环境(比如Gnome,KDE等)往往不会直接使用xlib编写界面,而是使用其他库调用xlib,比如GTK,Qt以及<a href="https://www.cairographics.org/">cairographics.org</a>等.</p><p>窗口管理器是一个常规的X客户机.它没有任何超级用户权限;它是X服务器允许调用一组特殊api的普通用户进程</p><p>X通过拒绝客户端对这些api的访问(如果另一个客户端当前具有访问权限),确保在任何给定点上运行的窗口管理器不超过一个.第一个尝试访问这些api的客户端总是成功的.</p><p><img data-src="https://jichu4n.com/content/images/2018/10/so1jXbe2d2Vvx917pbA5Cjw.png" alt="so1jXbe2d2Vvx917pbA5Cjw"></p><p>窗口管理器通过两个X机制与它所管理的窗口进行通信:属性和事件。通信是通过X服务器进行的,而不是直接在窗口管理器和其他应用程序之间进行的。</p><h4 id="substructure-redirection"><a href="#substructure-redirection" class="headerlink" title="substructure redirection"></a>substructure redirection</h4><p>在没有窗口管理器的情况下，当一个应用程序想要对一个窗口做一些事情——移动它、调整它的大小、显示/隐藏它等等——它的请求直接由X服务器处理。但是，窗口管理器需要拦截这些请求。例如，窗口管理器可能需要知道一个新的顶层窗口已经创建并显示，以便在其周围绘制窗口装饰(例如最小化/最大化/关闭按钮)。它可能还需要知道现有的顶层窗口已被调整大小，以便重新绘制窗口装饰以重新填充.允许窗口管理器拦截此类请求的机制称为substructure redirection</p><p>假设我们有一个窗口W。如果程序M在W上注册substructure redirection，<strong>则X服务器不会执行修改W的任何直接子窗口的匹配请求。相反，X服务器将此请求重定向到程序M</strong>,程序M可以对请求执行任何操作,包括直接拒绝请求或通过、修改请求。</p><blockquote><p>窗口管理器能为一个root window(是应用的top-level window的父窗口)注册substructure redirection,使得这个顶层窗口的任何直接子窗口(也就是应用的top-level窗口)发送的请求经过x server不经过修改转发到window manager,windows manager可以进行处理</p></blockquote><p><img data-src="https://jichu4n.com/content/images/2018/10/sTifV_OHk9dsZi6cwbLS7qQ.png" alt="sTifV_OHk9dsZi6cwbLS7qQ"></p><h4 id="reparenting"><a href="#reparenting" class="headerlink" title="reparenting"></a>reparenting</h4><p>如果在没有窗口管理器的情况下运行X应用程序,则应用程序的顶层窗口将是根窗口的直接子窗口.但是,在运行窗口管理器时,应用程序的顶层窗口可能被窗口管理器重新定义;它成为由窗口管理器创建的框架窗口的子窗口,并且它本身是根窗口的直接子窗口。窗口管理器可以将其他UI元素添加到这个框架窗口中,并与应用程序的顶层窗口一起使用</p><p>Reparenting允许不同的窗口管理器绘制不同的窗口装饰，从而实现跨窗口的一致外观。然而，也有一些窗口管理器根本不reparent:这些窗口管理器称为非reparent窗口管理器。窗口管理器不希望重命名有两个原因:</p><ol><li><p>如果窗口管理器不在顶层窗口周围绘制窗口装饰，那么它显然不需要重新表示它们。例如:xmonad、dwm。</p></li><li><p>合成窗口管理器并不总是需要reparent窗口</p></li></ol><blockquote><p>简单来说,reparent赋予了窗口管理器对其他应用程序的top-level也就是顶层窗口绘制的能力</p><p>让window manager管理了应用程序的top-level window</p></blockquote><h4 id="compositing"><a href="#compositing" class="headerlink" title="compositing"></a>compositing</h4><p>从窗口管理器的角度来看,top-level窗口是黑盒;它们各自管理自己的后代窗口(UI元素)，可能通过GTK+或Qt这样的框架，窗口管理器无权干涉那里。</p><p>但现在,随着图形硬件计算能力增强,window manager能做的更多了</p><p><img data-src="https://jichu4n.com/content/images/2018/10/sawR1epQiKxE5bX3Cplms2A.png" alt="sawR1epQiKxE5bX3Cplms2A"></p><p>绘制应用top-level窗口下的子元素往往如果直接由应用程序管理,那么其子元素的绘制和事件处理均通过应用发送请求到X server(中间通过window manager可能做出一些修改)</p><p>让我们花点时间思考一下如何实现像上面的Shift Switcher这样的接口。当用户触发这个接口时，我们需要:</p><ol><li><p>将每个顶层窗口及其所有后代窗口(UI元素)呈现到off-screen的内存缓冲区中，而不是直接呈现给硬件。</p></li><li><p>根据设计变换(旋转，扭曲等)每个缓冲区。</p></li><li><p>将转换后的buffer与背景和我们需要显示的任何其他浮动UI元素一起合成为最终buffer</p></li><li><p>创建一个覆盖窗口，覆盖整个屏幕，并隐藏所有其他窗口</p></li><li><p>渲染最终的buffer到覆盖的窗口</p></li></ol><p>​    Composite扩展提供了一种机制，请求X服务器<strong>不要将特定的窗口及其后代直接呈现给硬件，而是呈现给X服务器维护的一个特殊缓冲区，这样做不需要进行常规的裁剪和重叠计算</strong>。然后，发出请求的客户端(也就是composition window manager)可以读取和使用该缓冲区</p><p>​    由于合成窗口管理器已经知道所有顶层窗口的大小和位置,因此在使用图形操作(例如OpenGL)合成到覆盖窗口时,只需绘制窗口装饰就很容易了,而无需创建实际的X框架窗口和reparent</p><p>另一方面，窗口管理器可能需要同时支持合成和非合成模式，以兼容较旧或不受支持的图形硬件。在这种情况下，它需要为非合成模式实现修复和框架窗口，因此使用图形操作额外实现绘制窗口装饰变得多余。这就是为什么许多其他合成窗口管理器仍然选择重命名的原因</p><h3 id="XCB"><a href="#XCB" class="headerlink" title="XCB"></a>XCB</h3><p><a href="https://zh.wikipedia.org/wiki/XCB">XCB - 维基百科,自由的百科全书 (wikipedia.org)</a></p><p>XCB是目标在于取代Xlib,XCB 主要目标是:</p><ul><li>减轻函数库的大小与复杂度;</li><li>可直接访问 X Window核心协议.</li></ul><h3 id="Wayland"><a href="#Wayland" class="headerlink" title="Wayland"></a>Wayland</h3><blockquote><p>Wayland 是在同一个主机上的 GUI 通信协议：新、简单、快速,不需要 setuid root 二进制</p></blockquote><p><strong>Wayland</strong>是一个通信协议,规定了显示服务器与其客户机之间的通信方式,而使用这个协议的显示服务器称为Wayland Compositor.它由Kristian Høgsberg于2008年发起,目标是用更简单的现代化视窗系统取代X Window System.Wayland协议的参考实现称为Weston,由Wayland项目组使用C语言开发</p><p>Wayland与X Window System的最大不同在于<strong>它规定由客户机自身负责窗口边框和装饰的绘制(应用程序直接修改显存?),并且客户机能够通过EGL以及一些Wayland特定的EGL扩展组件直接在显示内存中算绘自己的缓冲器</strong>.</p><p>窗口管理器简化成显示管理服务,专门负责算绘那些屏幕上的程序.这比X Window System中的窗口管理器要更简单、高效</p><p>以“鼠标点击按钮引发按钮更新动作”为例来说明一下Wayland和X server的区别</p><p><strong>在X中</strong>：</p><ol><li><p>内核捕获鼠标点击事件并发送给X server.</p></li><li><p>X server会计算该把这一事件发送给哪个窗口（事实上,窗口位置是由Compositor控制的,X server并不能够正确的计算Compositor做过特效变化之后的按钮的正确位置）.</p></li><li><p>应用程序对此事件进行处理（将引发按钮更新动作）.但是,在此之前它得向X server发送绘制请求.</p></li><li><p>X server接收到这条绘制请求,然后把它发给视频驱动来渲染.X还计算了更新区域,并且这条“垃圾信息”发送给了Compositor.</p></li><li><p>这时,Compositor知道它必须要重新合成屏幕上的一块区域.当然,这还是要向X server发送绘制请求的.</p></li><li><p>开始绘制.但是X server还会去做一些不必要的本职工作（窗口重叠计算、窗口剪裁计算等）</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/X-architecture.png/220px-X-architecture.png" alt="img"></p></li></ol><p><strong>在Wayland中</strong>：</p><ol><li>内核捕获鼠标点击事件并发送给Wayland Compositor.</li><li>由于是直接发给Wayland Compositor的,所以Wayland Compositor会正确地计算出按钮的位置.同时它会把这一事件发送给按钮所在的应用程序来处理.</li><li>应用程序直接渲染,无需向Wayland Compositor请求.只需在绘制完成之后向Wayland Compositor发送一条信息表明这块区域被更新了.</li><li>Wayland Compositor收到这条信息后,立即重新合成整个桌面</li></ol><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Wayland-architecture.png/220px-Wayland-architecture.png" alt="img"></p><p>实现 Wayland 显示服务器协议的显示服务器也称为 Wayland 合成器,因为它们也执行合成视窗管理器的任务.</p><ul><li><p>Hyprland – 一个用C++ 编写的基于wlroots 的平铺Wayland 合成器,Hyprland 值得注意的功能包括动态平铺、选项卡式视窗、干净且可读的C++ 代码库以及提供视窗动画、圆角和Dual-Kawase模糊的自定义渲染器.</p></li><li><p>Weston – Wayland 合成器的参考实现,实现客户端装饰.</p></li><li><p>Sway – 平铺 Wayland 合成器和 X11 i3 视窗管理器的直接替代品.</p></li></ul><h2 id="在Windows上"><a href="#在Windows上" class="headerlink" title="在Windows上"></a>在Windows上</h2><h3 id="win32-api"><a href="#win32-api" class="headerlink" title="win32 api"></a>win32 api</h3><p><del>我去,这接口名把我看吐了</del></p><p>win32api提供了用户界面,图形,音视频,设备以及网络等等<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/">Win32 API 的编程参考 - Win32 apps | Microsoft Learn</a></p><h3 id="winui"><a href="#winui" class="headerlink" title="winui"></a>winui</h3><p>WinUI 是适用于 Windows 桌面应用和 UWP 应用的本机用户体验 (UX) 框架</p><p>使用界面使用<code>xaml</code>,处逻辑处理使用c++</p><h2 id="图形绘制接口"><a href="#图形绘制接口" class="headerlink" title="图形绘制接口"></a>图形绘制接口</h2><p>图形绘制与窗口管理(窗口上下文)往往是一起的,比如使用OpenGL往往需要搭配类似GLFW的窗口绘制库.</p><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p><img data-src="https://s2.loli.net/2024/10/02/S3p1byofjQceLEu.png" alt="image-20241002130444685"></p><p><a href="https://learnopengl-cn.github.io/">主页 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><h3 id="DirectX"><a href="#DirectX" class="headerlink" title="DirectX"></a>DirectX</h3><p><strong>DirectX</strong>（<strong>Direct</strong> e<strong>X</strong>tension,缩写：<strong>DX</strong>）是一系列专为多媒体以及游戏开发的api.旗下包含Direct3D、Direct2D、DirectCompute等等多个不同用途的子部分,因为这一系列<a href="https://zh.wikipedia.org/wiki/API">API</a>皆以Direct字样开头,所以DirectX（只要把X字母替换为任何一个特定API的名字）就成为这一巨大的API系列的统称.目前最新版本为DirectX 12,随附于Windows 10操作系统之上. 之前还有GDI/GDI++(已经过时)<a href="https://learn.microsoft.com/en-us/windows/win32/graphics-and-multimedia?redirectedfrom=MSDN">Graphics and gaming - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct2d/getting-started-with-direct2d?source=recommendations#step-1-include-direct2d-header">Direct2D 快速入门 - Win32 apps | Microsoft Learn</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ID2D1Factory* pD2DFactory = <span class="literal">NULL</span>;</span><br><span class="line">HRESULT hr = D2D1CreateFactory(</span><br><span class="line">    D2D1_FACTORY_TYPE_SINGLE_THREADED,</span><br><span class="line">    &amp;pD2DFactory</span><br><span class="line">    );</span><br><span class="line">   <span class="comment">// Obtain the size of the drawing area.</span></span><br><span class="line">RECT rc;</span><br><span class="line">GetClientRect(hwnd, &amp;rc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Direct2D render target          </span></span><br><span class="line">ID2D1HwndRenderTarget* pRT = <span class="literal">NULL</span>;          </span><br><span class="line">HRESULT hr = pD2DFactory-&gt;CreateHwndRenderTarget(</span><br><span class="line">    D2D1::RenderTargetProperties(),</span><br><span class="line">    D2D1::HwndRenderTargetProperties(</span><br><span class="line">        hwnd,</span><br><span class="line">        D2D1::SizeU(</span><br><span class="line">            rc.right - rc.left,</span><br><span class="line">            rc.bottom - rc.top)</span><br><span class="line">    ),</span><br><span class="line">    &amp;pRT</span><br><span class="line">); </span><br><span class="line"> ID2D1SolidColorBrush* pBlackBrush = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line">            </span><br><span class="line">    pRT-&gt;CreateSolidColorBrush(</span><br><span class="line">        D2D1::ColorF(D2D1::ColorF::Black),</span><br><span class="line">        &amp;pBlackBrush</span><br><span class="line">        ); </span><br><span class="line">&#125;   </span><br><span class="line">  pRT-&gt;BeginDraw();</span><br><span class="line"></span><br><span class="line">pRT-&gt;DrawRectangle(</span><br><span class="line">    D2D1::RectF(</span><br><span class="line">        rc.left + <span class="number">100.0</span>f,</span><br><span class="line">        rc.top + <span class="number">100.0</span>f,</span><br><span class="line">        rc.right - <span class="number">100.0</span>f,</span><br><span class="line">        rc.bottom - <span class="number">100.0</span>f),</span><br><span class="line">        pBlackBrush);</span><br><span class="line"></span><br><span class="line">HRESULT hr = pRT-&gt;EndDraw();    </span><br><span class="line"> </span><br><span class="line">SafeRelease(pRT);</span><br><span class="line">SafeRelease(pBlackBrush);</span><br></pre></td></tr></table></figure><h3 id="Vulkan"><a href="#Vulkan" class="headerlink" title="Vulkan"></a>Vulkan</h3><p>跨平台图形与计算应用程序接口,号称下一代OpenGL</p><p><a href="https://easyvulkan.github.io/index.html">首页 — EasyVulkan</a></p><p><a href="https://www.vulkan.org/">Home | Vulkan | Cross platform 3D Graphics</a></p><p><a href="https://github.com/PacktPublishing/Learning-Vulkan">PacktPublishing/Learning-Vulkan: Code repository for Learning Vulkan, published by Packt (github.com)</a></p><p><a href="https://vulkan-tutorial.com/">https://vulkan-tutorial.com/</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createInstance();</span><br><span class="line">    setupDebugMessenger();</span><br><span class="line">    createSurface();</span><br><span class="line">    pickPhysicalDevice();</span><br><span class="line">    createLogicalDevice();</span><br><span class="line">    createSwapChain();</span><br><span class="line">    createImageViews();</span><br><span class="line">    createGraphicsPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraphicsPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h3><p>苹果上的类似OpenGL,Direct3D,兼顾图形与计算,面向底层应用程序接口.</p><h2 id="相关应用库"><a href="#相关应用库" class="headerlink" title="相关应用库"></a>相关应用库</h2><ol><li>SFML</li><li>SDL</li><li>FLTK</li><li>Qt</li><li>GLFW(针对OpenGL图形库)</li><li>raylib</li><li>imgui</li><li>nanoGui</li><li>easyx</li><li><a href="https://oxygine.org/">Oxygine - 2D C++ game framework</a></li></ol><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://jichu4n.com/posts/how-x-window-managers-work-and-how-to-write-one-part-i/">How X Window Managers Work, And How To Write One (Part I) (jichu4n.com)</a></li><li><a href="https://hereket.com/posts/linux_creating_x11_windows/">Xlib 01: Creating windows from scratch with Xlib on Linux | Hereket</a></li><li><a href="https://xcb.freedesktop.org/tutorial/">tutorial (xcb.freedesktop.org)</a></li><li><a href="https://www.cairographics.org/">cairographics.org</a></li><li><a href="https://zh.wikipedia.org/wiki/Metal_(API">Metal (API) - 维基百科,自由的百科全书 (wikipedia.org)</a>)</li><li><a href="https://zh.wikipedia.org/wiki/Vulkan">Vulkan - 维基百科,自由的百科全书 (wikipedia.org)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们想要进行底层图形应用(GUI)开发时,往往需要用到窗口系统和图形库,这里简单介绍一下&lt;br&gt;</summary>
    
    
    
    
    <category term="window systems" scheme="https://www.sekyoro.top/tags/window-systems/"/>
    
    <category term="graphics library" scheme="https://www.sekyoro.top/tags/graphics-library/"/>
    
  </entry>
  
  <entry>
    <title>打实基础:cs61c学习</title>
    <link href="https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/10/01/%E6%89%93%E5%AE%9E%E5%9F%BA%E7%A1%80-cs61c%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-01T06:18:42.000Z</published>
    <updated>2024-10-03T06:36:03.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020).</p><span id="more"></span><p>整个课程做起来最大的问题是,过去的课程目前不开放给校外人员了,现有的资料没有保存图片,所以lab没有图片..</p><h2 id="Labs"><a href="#Labs" class="headerlink" title="Labs"></a>Labs</h2><h3 id="00"><a href="#00" class="headerlink" title="00"></a>00</h3><p>学习常用指令,我个人常用(由于我目前使用windows,许多指令都没有)find,grep,ps,kill等指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&quot;xxx&quot;</span></span><br><span class="line">find ./ -<span class="built_in">type</span> f -<span class="built_in">exec</span> grep <span class="string">&quot;xx&quot;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>现在Linux上有许多重写的更好用的工具,比如<code>ripgrep</code>,<code>btop</code>等等</p><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>使用gdb和valgrind</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o hello hello.c</span><br><span class="line">gdb hello</span><br><span class="line">b <span class="comment"># set breakpoint</span></span><br><span class="line">bt <span class="comment"># backtrace </span></span><br><span class="line">p expr <span class="comment"># display value</span></span><br><span class="line">c <span class="comment"># continue running</span></span><br><span class="line">n <span class="comment"># next line,stepping over function calls</span></span><br><span class="line">s <span class="comment"># next line,stepping into function calls</span></span><br></pre></td></tr></table></figure><p>详情查看manual<a href="https://www.learncs.site/assets/files/gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf">gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf (learncs.site)</a></p><p><img data-src="https://s2.loli.net/2024/10/01/vy67mZfx5C9RIok.png" alt="image-20241001160602317"></p><p>运行时内存错误可以使用valgrind. Valgrind是一个程序,模拟你的CPU和跟踪你的内存访问</p><p>此外写一个检查链表是否有循环的c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ll_cycle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ll_has_cycle</span><span class="params">(node *head)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* your code here */</span></span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  node *tortoise = head;</span><br><span class="line">  node *hare = tortoise-&gt;next-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (hare != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    tortoise = tortoise-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (hare == tortoise) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hare-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hare = hare-&gt;next-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>学习使用Makefile(虽然我现在基本使用CMake或者直接用visual studio(当然vs仙子啊也支持了cmake))</p><blockquote><p>makefile是代码目录中的一个文本文件(字面上标记为“makefile”)，其中包含一组规则，每个规则都有为其编译C程序的命令。每个makefile可以包含多个规则，每个规则编译一个或多个目标(例如可执行文件)或执行不同的目标。要编译一个目标，程序员只需要在他们的命令终端输入“make</p></blockquote><p>使用位操作分别获取,设置,翻转一个值的某位.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">get_bit</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// Returning -1 is a placeholder (it makes</span></span><br><span class="line">  <span class="comment">// no sense, because get_bit only returns</span></span><br><span class="line">  <span class="comment">// 0 or 1)</span></span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; n; <span class="comment">// e.g. n  = 5, 000100000</span></span><br><span class="line">  <span class="keyword">return</span> (x &amp; mask) &gt;&gt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the nth bit of the value of x to v.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">unsigned</span> *x, <span class="keyword">unsigned</span> n, <span class="keyword">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">1</span>) &#123;</span><br><span class="line">    *x = *x | mask;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *x = *x &amp; ~mask;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flip the nth bit of the value of x.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip_bit</span><span class="params">(<span class="keyword">unsigned</span> *x, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">  *x = *x ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现线性反馈移位寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfsr_calculate</span><span class="params">(<span class="keyword">uint16_t</span> *reg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">  <span class="keyword">int</span> bit0 = *reg &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bit2 = (*reg &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bit3 = (*reg &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bit5 = (*reg &gt;&gt; <span class="number">5</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> new_bit = bit0 ^ bit2 ^ bit3 ^ bit5;</span><br><span class="line">  *reg = *reg &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mask = new_bit &lt;&lt; <span class="number">15</span>;</span><br><span class="line">  *reg = *reg | mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现一个动态长度array,其实就是利用<code>malloc</code>,<code>free</code>分配内存,这些内存往往在堆上.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  usize capacity;</span><br><span class="line">  uszie size;</span><br><span class="line">  <span class="keyword">int</span>* data;</span><br><span class="line">&#125; DArray;</span><br></pre></td></tr></table></figure><p>初始化和free时主要需要分别malloc整个结构和存储的data数据,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vector_t</span> *<span class="title">vector_new</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Declare what this function will return */</span></span><br><span class="line">  <span class="keyword">vector_t</span> *retval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First, we need to allocate memory on the heap for the struct */</span></span><br><span class="line">  retval = (<span class="keyword">vector_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">vector_t</span>)); <span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check our return value to make sure we got memory */</span></span><br><span class="line">  <span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    allocation_failed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we need to initialize our data.</span></span><br><span class="line"><span class="comment">     Since retval-&gt;data should be able to dynamically grow,</span></span><br><span class="line"><span class="comment">     what do you need to do? */</span></span><br><span class="line">  retval-&gt;size = <span class="number">1</span> <span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line">  retval-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(retval-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) <span class="comment">/* YOUR CODE HERE */</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the data attribute of our vector to make sure we got memory */</span></span><br><span class="line">  <span class="keyword">if</span> (retval-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(retval); <span class="comment">// Why is this line necessary?</span></span><br><span class="line">    allocation_failed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Complete the initialization by setting the single component to zero */</span></span><br><span class="line">  retval-&gt;data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* and return... */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>RISCV汇编,</p><p>.data段落包含初始化的全局和静态变量, .word段用于分配和初始化内存(通常4字节)</p><p>.text段落包括程序的可执行指令,x0寄存器中值始终为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    add t0, x0, x0 # curr_fib = 0</span><br><span class="line">    addi t1, x0, 1 # next_fib = 1</span><br><span class="line">la t3, n # load the address of the label n</span><br><span class="line">lw t3, 0(t3) # get the value that is stored at the adddress denoted by the label n</span><br><span class="line">fib:</span><br><span class="line">    beq t3, x0, finish # exit loop once we have completed n iterations</span><br><span class="line">    add t2, t1, t0 # new_fib = curr_fib + next_fib;</span><br><span class="line">    mv t0, t1 # curr_fib = next_fib;</span><br><span class="line">    mv t1, t2 # next_fib = new_fib;</span><br><span class="line">    addi t3, t3, -1 # decrement counter</span><br><span class="line">    j fib # loop</span><br><span class="line">finish:</span><br><span class="line">    addi a0, x0, 1 # argument to ecall to execute print integer</span><br><span class="line">    addi a1, t0, 0 # argument to ecall, the value to be printed</span><br><span class="line">    ecall # print integer ecall</span><br></pre></td></tr></table></figure><p><code>ecall</code>是系统调用,要传递参数，需要将其放入参数寄存器(a0-a7)。当函数执行时，它将在这些寄存器中查找参数。第一个参数应该放在a0中，第二个参数应该放在a1中，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> source[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dest[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> -x * (x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; source[k] != <span class="number">0</span>; k++) &#123;</span><br><span class="line">        dest[k] = fun(source[k]);</span><br><span class="line">        sum += dest[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面c代码转为汇编,全局变量使用<code>.data</code>和<code>.word</code>分配,只写t和a寄存器(临时寄存器和参数寄存器),s寄存器在调用函数前注意保存</p><p><img data-src="https://s2.loli.net/2024/10/01/iKzPvVZAfa1pCnG.png" alt="image-20241001195355718"></p><ul><li><p><strong><code>li</code> 指令</strong>：将立即数加载到寄存器中。</p></li><li><p><strong><code>la</code> 指令</strong>：加载变量的地址到寄存器中。</p></li><li><p><strong><code>lw</code> 指令</strong>：从内存中加载一个 32 位字到寄存器中。</p></li><li><p><strong><code>sw</code> 指令</strong>：将寄存器中的 32 位字存储到内存中。</p></li><li><p><strong><code>sw</code> 指令</strong>：将寄存器中的 32 位字存储到内存中。</p></li><li><p><strong><code>sh</code> 指令</strong>：将寄存器中的 16 位半字存储到内存中。</p></li><li><p><strong><code>sb</code> 指令</strong>：将寄存器中的 8 位字节存储到内存中</p><p>内存地址主要就是寄存器offset寻址</p></li></ul><h4 id="RISC-V-调用约定"><a href="#RISC-V-调用约定" class="headerlink" title="RISC-V 调用约定"></a>RISC-V 调用约定</h4><p>RISC-V 的调用约定规定了哪些寄存器在函数调用时需要保存，哪些寄存器可以被修改。以下是一些主要的约定：</p><ol><li><strong>临时寄存器（Temporary Registers）</strong>：<ul><li><strong><code>t0</code> 至 <code>t6</code></strong>：这些寄存器可以在函数调用时被修改，调用者不需要保存这些寄存器的值。</li><li><strong><code>a0</code> 至 <code>a7</code></strong>：这些寄存器用于传递函数参数，也可以在函数调用时被修改，调用者不需要保存这些寄存器的值。</li></ul></li><li><strong>保存寄存器（Saved Registers）</strong>：<ul><li><strong><code>s0</code> 至 <code>s11</code></strong>：这些寄存器在函数调用时需要保存，被调用者必须在返回前恢复这些寄存器的值。</li><li><strong><code>ra</code></strong>：返回地址寄存器，被调用者必须在返回前恢复 <code>ra</code> 的值。</li></ul></li></ol><p><strong>保存和恢复寄存器</strong></p><p>为了确保函数调用的正确性，通常需要在函数入口处保存这些寄存器的值，并在函数返回前恢复这些值。这通常通过使用堆栈来实现(利用<code>sp</code>栈寄存器). 通常内存上的值首先加到寄存器上然后再进行计算.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">n: .word 8</span><br><span class="line">lw t0, 0(sp) ; t0 = [sp]</span><br><span class="line">la t1, n</span><br><span class="line">lw t1, 0(t1) ; t1 = [t1]</span><br><span class="line">addi t1,t1,2</span><br><span class="line">sw t0, 0(t1) ; [t1] = t0</span><br></pre></td></tr></table></figure><p>使用RISCV写一段factorial代码,注意要么写为recursion要么写更简单的iteration</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">factorial</span><span class="params">(n)</span></span> = n!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">factorial:</span><br><span class="line">  addi sp,sp,-4</span><br><span class="line">  sw s0,0(sp) # sp[0] = s0</span><br><span class="line">  addi s0,x0,1 # sum = 1</span><br><span class="line">  addi t0,x0,1 # i = 1</span><br><span class="line">loop:</span><br><span class="line">  blt a0,t0,exit # if n &lt; i, goto exit</span><br><span class="line">  mul s0,s0,t0# sum = sum * i</span><br><span class="line">  addi t0,t0,1 # i++</span><br><span class="line">  jal x0,loop</span><br><span class="line">exit:</span><br><span class="line">  add a0,x0,s0 # a0 = sum</span><br><span class="line">  lw s0,0(sp) # s0 = sp[0]</span><br><span class="line">  addi sp,sp,4</span><br><span class="line">  jr ra</span><br></pre></td></tr></table></figure><blockquote><p>所有覆盖按约定保留的寄存器的函数都必须有一个序言(prologue)和一个尾声(epilogue)，序言将这些寄存器值保存到函数开始时的堆栈中;epilogue将为函数的调用者恢复这些值。 由于调用约定违反而导致的bug很难发现,不要直接修改这些寄存器</p><p>也就是对于保存寄存器的处理,包括s开头的寄存器和ra寄存器(受jal影响)</p></blockquote><p>后面有一个专门的测试,在每个函数前后写上将s寄存器值保存到内存的代码,此外如果一个函数栈中调用了另一个函数,如果那个函数修改了t寄存器,那么父函数栈也需要保存相应的寄存器. 对于ra寄存器同理,函数<code>jrl</code>调用另一个函数,修改了ra寄存器值,也需要在调用另一个函数之前保存ra,否则这个函数无法通过<code>jr</code>跳转回去了(当然可以使用j label调转到某个位置).</p><p>此外还使用RISC-V实现了链表分配和map操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">create_default_list:</span><br><span class="line">    addi sp, sp, -12</span><br><span class="line">    sw  ra, 0(sp)</span><br><span class="line">    sw  s0, 4(sp)</span><br><span class="line">    sw  s1, 8(sp)</span><br><span class="line">    li  s0, 0       # pointer to the last node we handled</span><br><span class="line">    li  s1, 0       # number of nodes handled</span><br><span class="line">loop:   #do...</span><br><span class="line">    li  a0, 8</span><br><span class="line">    jal ra, malloc      # get memory for the next node</span><br><span class="line">    sw  s1, 0(a0)   # node-&gt;value = i</span><br><span class="line">    sw  s0, 4(a0)   # node-&gt;next = last</span><br><span class="line">    add s0, a0, x0  # last = node</span><br><span class="line">    addi    s1, s1, 1   # i++</span><br><span class="line">    addi t0, x0, 10</span><br><span class="line">    bne s1, t0, loop    # ... while i!= 10</span><br><span class="line">    lw  ra, 0(sp)</span><br><span class="line">    lw  s0, 4(sp)</span><br><span class="line">    lw  s1, 8(sp)</span><br><span class="line">    addi sp, sp, 12</span><br><span class="line">    jr ra</span><br><span class="line">malloc:</span><br><span class="line">    addi    a1, a0, 0</span><br><span class="line">    addi    a0, x0 9</span><br><span class="line">    ecall</span><br><span class="line">    jr  r</span><br></pre></td></tr></table></figure><p>上面malloc中调用了<code>ecall</code>系统调用.</p><p>实现高阶函数<code>map</code>操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">map:</span><br><span class="line">    # Prologue: Make space on the stack and back-up registers</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    addi sp,sp,-12</span><br><span class="line">    sw ra, 0(sp)</span><br><span class="line">    sw s0, 4(sp)</span><br><span class="line">    sw s1, 8(sp)</span><br><span class="line"></span><br><span class="line">    beq a0, x0, done    # If we were given a null pointer (address 0), we&#x27;re done.</span><br><span class="line"></span><br><span class="line">    add s0, a0, x0  # Save address of this node in s0</span><br><span class="line">    add s1, a1, x0  # Save address of function in s1</span><br><span class="line"></span><br><span class="line">    # Remember that each node is 8 bytes long: 4 for the value followed by 4 for the pointer to next.</span><br><span class="line">    # What does this tell you about how you access the value and how you access the pointer to next?</span><br><span class="line"></span><br><span class="line">    # load the value of the current node into a0</span><br><span class="line">    # THINK: why a0? prepare to call map</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    lw a0,0(s0) # a0 = [s0]</span><br><span class="line"></span><br><span class="line">    # Call the function in question on that value. DO NOT use a label (be prepared to answer why).</span><br><span class="line">    # What function? Recall the parameters of &quot;map&quot;</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    # jal is used to jump to label</span><br><span class="line">    jalr ra, s1 ,0 # call square</span><br><span class="line">    # Where can you assume the returned value is?</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    sw a0, 0(s0) # [s0] = a0</span><br><span class="line"></span><br><span class="line">    # Load the address of the next node into a0</span><br><span class="line">    # The Address of the next node is an attribute of the current node.</span><br><span class="line">    # Think about how structs are organized in memory.</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    lw a0, 4(s0) # a0 = [s0+4]</span><br><span class="line"></span><br><span class="line">    # Put the address of the function back into a1 to prepare for the recursion</span><br><span class="line">    # THINK: why a1? What about a0?</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    mv a1, s1 # not really necessary, cause a1 is not changed in square functino</span><br><span class="line"></span><br><span class="line">    # recurse</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    jal ra, map</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    # Epilogue: Restore register values and free space from the stack</span><br><span class="line">    ### YOUR CODE HERE ###</span><br><span class="line">    lw ra, 0(sp)</span><br><span class="line">    lw s0, 4(sp)</span><br><span class="line">    lw s1, 8(sp)</span><br><span class="line">    addi sp,sp,12</span><br><span class="line">    jr ra # Return to caller</span><br><span class="line"></span><br><span class="line">square:</span><br><span class="line">    mul a0 ,a0, a0</span><br><span class="line">    jr ra</span><br></pre></td></tr></table></figure><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>修改一个汇编代码中的问题,我卡了很久还是看了其他人的解答.</p><p>在main中获取数组第一个值地址和大小,在mainLoop中不断遍历,修改数组值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">map:</span><br><span class="line">    addi sp, sp, -12</span><br><span class="line">    sw ra, 0(sp)</span><br><span class="line">    sw s1, 4(sp)</span><br><span class="line">    sw s0, 8(sp)</span><br><span class="line"></span><br><span class="line">    beq a0, x0, done    # if we were given a null pointer, we&#x27;re done.</span><br><span class="line"></span><br><span class="line">    add s0, a0, x0      # save address of this node in s0</span><br><span class="line">    add s1, a1, x0      # save address of function in s1</span><br><span class="line">    add t0, x0, x0      # t0 is a counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lw t1, 0(s0)   # load the address of the array of current node into t1</span><br><span class="line">    lw t2, 4(s0)        # load the size of the node&#x27;s array into t2</span><br><span class="line">    addi t1, t1, -4</span><br><span class="line">    # remember that each node is 12 bytes long:</span><br><span class="line">    # - 4 for the array pointer</span><br><span class="line">    # - 4 for the size of the array</span><br><span class="line">    # - 4 more for the pointer to the next node</span><br><span class="line"></span><br><span class="line">    # also keep in mind that we should not make ANY assumption on which registers</span><br><span class="line">    # are modified by the callees, even when we know the content inside the functions </span><br><span class="line">    # we call. this is to enforce the abstraction barrier of calling convention.</span><br><span class="line">mapLoop:</span><br><span class="line">    # add t1, s0, x0      # load the address of the array of current node into t1</span><br><span class="line">    addi t1, t1, 4      # offset the array address by the count</span><br><span class="line">    lw a0, 0(t1)        # load the value at that address into a0</span><br><span class="line">    addi sp,sp,-12</span><br><span class="line">    sw t0, 0(sp)</span><br><span class="line">    sw t1, 4(sp)</span><br><span class="line">    sw t2, 8(sp)</span><br><span class="line">    jalr ra,s1,0             # call the function on that value.</span><br><span class="line">    lw t0, 0(sp)</span><br><span class="line">    lw t1, 4(sp)</span><br><span class="line">    lw t2, 8(sp)</span><br><span class="line">    addi sp,sp,12</span><br><span class="line"></span><br><span class="line">    sw a0, 0(t1)        # store the returned value back into the array</span><br><span class="line">    addi t0, t0, 1      # increment the count</span><br><span class="line">    bne t0, t2, mapLoop # repeat if we haven&#x27;t reached the array size yet</span><br><span class="line"></span><br><span class="line">    lw a0, 8(s0)  # load the address of the next node into a0</span><br><span class="line">    mv a1,s1</span><br><span class="line"></span><br><span class="line">    jal  map            # recurse</span><br><span class="line">done:</span><br><span class="line">    lw s0, 8(sp)</span><br><span class="line">    lw s1, 4(sp)</span><br><span class="line">    lw ra, 0(sp)</span><br><span class="line">    addi sp, sp, 12</span><br><span class="line">    jr ra</span><br></pre></td></tr></table></figure><p>然后写一个映射</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(-<span class="number">3</span>)</span></span> = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(-<span class="number">2</span>)</span></span> = <span class="number">61</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(-<span class="number">1</span>)</span></span> = <span class="number">17</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">0</span>)</span></span> = -<span class="number">38</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span> = <span class="number">19</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span> = <span class="number">42</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">3</span>)</span></span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>其中a0寄存器是输入值,a1是输出列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">    addi a0,a0,3</span><br><span class="line">    # li t0, 4</span><br><span class="line">    # mul a0,a0,t0</span><br><span class="line">    # add s0,a1,a0 # s0 is the address</span><br><span class="line">    slli a0,a0,2</span><br><span class="line">    add a0,a1,a0</span><br><span class="line">    lw a0, 0(a0)</span><br><span class="line">    </span><br><span class="line">    jr ra   </span><br></pre></td></tr></table></figure><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>使用logisim工具构建模拟电路,使用AND,OR,NOT基本件构建NAND,NOR,XOR以及Mux. 此外还有个寄存器</p><p><img data-src="https://s2.loli.net/2024/10/02/2QKgjTAZU48rXcP.png" alt="image-20241002193745279"></p><p>FSM代表有限状态机。FSM跟踪给定的输入，根据这些输入在状态之间移动，并在每次输入时输出一些东西。</p><p>我们使用寄存器来存储当前所在FSM的状态，并使用组合逻辑将FSM的输入和当前寄存器状态映射到FSM的输出和下一个寄存器状态。说实话,这个FSM的作用我没太看懂,貌似是连续两次一样的输入,输出就固定了. 需要连现在状态到下一次状态的电路线,我按照truth  table直接推的.</p><p>此外还需要画出rotr电路,我一开始画成下面这样,使用Mux-16针对每个0-15值选择对应偏移…</p><p><img data-src="https://s2.loli.net/2024/10/02/VFjKlRYLwc826qb.png" alt="image-20241002224915855"></p><p>其实可以根据每一位使用mux-2,简单得多</p><p><img data-src="https://s2.loli.net/2024/10/02/MG3ecRyFif1njkb.png" alt="image-20241002231322258"></p><h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><p>关于电路流水线时间的问题,通过编排优化流水线</p><p><img data-src="https://s2.loli.net/2024/10/02/q8GXlWucIeimaCz.png" alt="image-20241002231814951"></p><p>这个电路所做的就是接收两个输入，将它们相乘，然后将结果与当前状态值相加。对于这个电路，设<strong>加法器块的传播延迟为45ns，乘法块的传播延迟为60ns。寄存器的CLK-to-Q延迟为10ns，设置时间为10ns，保持时间为5ns</strong>。计算该电路可以工作的最大时钟速率。假设两个输入都来自从外部源接收数据的时钟寄存器。</p><p>为了确保电路能够正确工作，时钟周期必须满足以下条件：</p><ol><li><strong>数据路径延迟</strong> + <strong>CLK-to-Q 延迟</strong> + <strong>建立时间</strong> ≤ 时钟周期</li><li><strong>保持时间</strong> &lt; 时钟周期</li></ol><p>首先，计算第一个条件： 时钟周期≥数据路径延迟+CLK-to-Q 延迟+建立时间时钟周期≥数据路径延迟+CLK-to-Q 延迟+建立时间 时钟周期≥105 ns+10 ns+10 ns时钟周期≥105ns+10ns+10ns 时钟周期≥125 ns时钟周期≥125ns</p><p>接下来，检查保持时间的要求： 时钟周期&gt;5 ns时钟周期&gt;5ns</p><p>显然，125ns 已经大于 5ns，所以保持时间的要求自然满足。</p><p><img data-src="https://s2.loli.net/2024/10/02/HAY1F6ZsJbhjix7.png" alt="image-20241002232639288"></p><p>如果一个计算依赖于前一个计算的输出，那么很难对它们进行管道处理，我们通常需要插入一个(或几个)管道“bubbles”，以确保第一个计算的输出准备好成为第二个计算的输入。提醒一下，bubbles是在管道中故意延迟指令的过程。理解为什么这种“bubbles”对于这种特殊的电路是不必要的是很重要的。</p><p>下面这种pipeline方案在乘法和加法之间增加了一个register保存中间值,输出会增加一个前导0</p><p><img data-src="https://s2.loli.net/2024/10/02/DZFX7x5wgIiQHCK.png" alt="image-20241002234052193"></p><p>在non_pipeline版本中,一个tick会同时更新输出值和寄存器的值</p><p>假设我们在乘法器和加法器之间插入一个寄存器，将电路分成两个阶段：</p><ol><li><strong>第一阶段</strong>：乘法器</li><li><strong>第二阶段</strong>：加法器</li></ol><p>每个阶段的延迟如下：</p><ul><li>第一阶段（乘法器）延迟：60ns</li><li>第二阶段（加法器）延迟：45ns</li></ul><p>寄存器的时序要求</p><ul><li><strong>CLK-to-Q 延迟</strong>：10ns</li><li><strong>建立时间</strong>：10ns</li><li><strong>保持时间</strong>：5ns</li></ul><p><strong>计算每个阶段的最大时钟周期</strong></p><p>为了确保每个阶段的时序要求都得到满足，我们需要计算每个阶段的最大时钟周期。</p><p><strong>第一阶段</strong></p><ul><li><strong>数据路径延迟</strong>：60ns</li><li><strong>CLK-to-Q 延迟</strong>：10ns</li><li><strong>建立时间</strong>：10ns</li></ul><p>第一阶段的时钟周期要求： 时钟周期≥60 ns+10 ns+10 ns时钟周期≥60ns+10ns+10ns 时钟周期≥80 ns时钟周期≥80ns</p><p><strong>第二阶段</strong></p><ul><li><strong>数据路径延迟</strong>：45ns</li><li><strong>CLK-to-Q 延迟</strong>：10ns</li><li><strong>建立时间</strong>：10ns</li></ul><p>第二阶段的时钟周期要求： 时钟周期≥45 ns+10 ns+10 ns时钟周期≥45ns+10ns+10ns 时钟周期≥65 ns时钟周期≥65ns</p><p>为了确保整个流水线电路能够正确工作，时钟周期必须满足所有阶段中最严格的要求。因此，最终的时钟周期应取这两个阶段的最大值：</p><p>时钟周期=max⁡(80 ns,65 ns)=80 ns时钟周期=max(80ns,65ns)=80ns</p><p>由于乘法延时比加法长,这两个阶段相对独立.</p><p>在流水线设计中，“气泡”（bubbles）通常指的是空闲的时钟周期，用于处理流水线中的依赖关系或避免冲突。在某些情况下，插入气泡是为了确保数据的正确性和避免数据冒险（data hazards）。然而，在这个电路中，插入一个寄存器将乘法和加法操作分成两个独立的阶段，这样可以避免大多数常见的数据冒险，因此不需要插入气泡。</p><p>为什么这个电路不需要气泡？</p><ol><li><strong>独立的流水线阶段</strong>：<ul><li>通过在乘法器和加法器之间插入一个寄存器，将整个操作分成了两个独立的阶段。</li><li>每个阶段都有自己的时钟周期，数据在每个阶段的末尾被寄存器捕获并传递到下一个阶段。</li></ul></li><li><strong>数据流的清晰分离</strong>：<ul><li>在第一阶段，乘法器完成乘法操作，并将结果存储在寄存器中。</li><li>在第二阶段，加法器从寄存器中读取乘法结果，并将其与当前状态值相加。</li><li>这种分离确保了每个阶段的数据都是在前一个阶段完成后的稳定状态下进行处理的，避免了数据冒险。</li></ul></li><li><strong>时序要求的满足</strong>：<ul><li>每个阶段的时钟周期都足够长，以满足寄存器的时序要求（CLK-to-Q 延迟、建立时间和保持时间）。</li><li>例如，第一阶段的时钟周期为 80ns，第二阶段的时钟周期为 65ns，这两个值都足以确保数据在每个阶段的末尾被正确捕获和传递</li></ul></li></ol><h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><p>主要介绍cache,</p><p>write-back意味着在写入命中时，数据只被写入缓存，当这个写入发生时，被写入块的脏位变为1。写入缓存的速度很快，因此回写缓存中的写入延迟通常非常小。但是，当从回写缓存中取出块时，如果脏位为1，则必须使用该块的内容更新内存，因为它包含尚未反映在内存中的更改。这使得回写缓存更难以在硬件中实现。</p><p>write-through意味着在写命中时，数据同时写入缓存和主存。写入缓存很快，但写入主存很慢;这使得透写缓存中的写延迟比回写缓存中的写延迟慢。然而，透写缓存意味着更简单的硬件，因为我们可以假设在透写缓存中，内存总是拥有最新的数据。</p><p>Write-around意味着在任何情况下，数据只被写入主存;如果缓存中有要写入的块，则块的有效位变为无效位。从本质上讲，在写绕过缓存中没有写命中这样的事情;写“命中”和写“未命中”的作用是一样的</p><p><strong>miss policies</strong></p><p>write -allocate的意思是，在写失败时，将丢失的块拉到缓存中。对于回写，写分配缓存，这意味着内存永远不会直接写入;相反，总是对缓存进行写操作，并且在删除时更新内存。</p><p><strong>过程</strong>：</p><ol><li><strong>写操作</strong>：处理器尝试写入某个内存地址。</li><li><strong>缓存查找</strong>：缓存控制器检查该地址是否在缓存中。</li><li><strong>未命中</strong>：如果该地址不在缓存中，发生未命中。</li><li><strong>加载缓存行</strong>：从主存中读取该地址所在的整个缓存行，并将其加载到缓存中。</li><li><strong>写入缓存</strong>：将写操作的数据写入缓存中的相应位置。</li><li><strong>写入主存</strong>：根据缓存的写策略（写回或写穿透），决定是否立即将数据写入主存</li></ol><p>no write-allocate意味着在写失败时，不会将错过的块拉到缓存中。只更新内存</p><p><strong>过程</strong>：</p><ol><li><strong>写操作</strong>：处理器尝试写入某个内存地址。</li><li><strong>缓存查找</strong>：缓存控制器检查该地址是否在缓存中。</li><li><strong>未命中</strong>：如果该地址不在缓存中，发生未命中。</li><li><strong>加载缓存行</strong>：从主存中读取该地址所在的整个缓存行，并将其加载到缓存中。</li><li><strong>写入缓存</strong>：将写操作的数据写入缓存中的相应位置。</li><li><strong>写入主存</strong>：根据缓存的写策略（写回或写穿透），决定是否立即将数据写入主存</li></ol><p><strong>更新策略</strong></p><p>LRU—最近最少使用当我们决定移除缓存块以腾出空间时，我们选择在所有块中使用时间最远的块</p><p>随机-当我们决定移除一个缓存块来腾出空间时，我们随机选择缓存中的一个块来移除。</p><p>MRU—最近使用的—当我们决定移除缓存块以腾出空间时，我们选择所有块中最近使用的块</p><p>针对下面代码,假设缓存是write through,write-allocate,也就是命中时同时写入缓存和内存,没有命中写入缓存与内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[];  <span class="comment">//Assume sizeof(int) == 4</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; repcount; k++) &#123;<span class="comment">// repeat repcount times</span></span><br><span class="line">  <span class="comment">/* Step through the selected array segment with the given step size. */</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; arraysize; index += stepsize) &#123;</span><br><span class="line">    <span class="keyword">if</span>(option==<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">array</span>[index] = <span class="number">0</span>;<span class="comment">// Option 0: One cache access - write</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">array</span>[index] = <span class="built_in">array</span>[index] + <span class="number">1</span>;<span class="comment">// Option 1: Two cache accesses - read AND write</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存行的组织</strong></p><p>缓存行的组织方式通常有以下几种：</p><ol><li><strong>直接映射（Direct-Mapped）</strong>：<ul><li>每个主存块只能映射到缓存中的一个特定位置。</li><li>简单但容易发生冲突未命中。</li></ul></li><li><strong>组相联（Set-Associative）</strong>：<ul><li>主存块可以映射到缓存中的多个位置（一组）。</li><li>平衡了直接映射和全相联的优缺点。</li></ul></li><li><strong>全相联（Fully Associative）</strong>：<ul><li>主存块可以映射到缓存中的任意位置。</li><li>复杂但灵活性高</li></ul></li></ol><h4 id="Scene-1"><a href="#Scene-1" class="headerlink" title="Scene 1"></a>Scene 1</h4><ul><li><strong>Array Size (<code>a0</code>)</strong>: 128 (bytes)</li><li><strong>Step Size (<code>a1</code>)</strong>: 8</li><li><strong>Rep Count (<code>a2</code>)</strong>: 4</li><li><strong>Option (<code>a3</code>)</strong>: 0</li></ul><p><strong>Cache Parameters</strong>: (set these in the Cache tab)</p><ul><li><strong>Cache Levels</strong>: 1</li><li><strong>Block Size</strong>: 8</li><li><strong>Number of Blocks</strong>: 4</li><li><strong>Enable?</strong>: Should be green</li><li><strong>Placement Policy</strong>: Direct Mapped</li><li><strong>Associativity</strong>: 1 (Venus won’t let you change this, why?)</li><li><strong>Block Replacement Policy</strong>: LRU</li></ul><p>128/8/4=4,所以一次遍历会写入4次,遍历4次就会写入16次. 发现每次都没有命中,这是为什么呢？ 我们想想,每次没命中就会把对应4字节内容放入缓存和内存(write through,write-allocate),遍历一遍之后block中</p><p><img data-src="https://s2.loli.net/2024/10/03/nkSE5IHOro7KWYV.png" alt="image-20241003134801342"></p><p>cache命中的应用就是矩阵(线性代数)运算</p><p>要正确计算矩阵乘法，循环顺序并不重要。但是<strong>选择访问矩阵元素的顺序会对性能产生很大的影响。当内存访问利用空间和时间局部性，利用已经包含在缓存中的块时，缓存性能更好</strong>(缓存命中更多，缓存丢失更少)。优化程序的内存访问模式对于从内存层次结构中获得良好的性能至关重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multMat1</span><span class="params">( <span class="keyword">int</span> n, <span class="keyword">float</span> *A, <span class="keyword">float</span> *B, <span class="keyword">float</span> *C )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="comment">/* This is ijk loop order. */</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">            <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; n; k++ )</span><br><span class="line">                C[i+j*n] += A[i+k*n]*B[k+j*n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cache-Blocksize"><a href="#Cache-Blocksize" class="headerlink" title="Cache Blocksize"></a>Cache Blocksize</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_blocking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> blocksize, <span class="keyword">int</span> *dst, <span class="keyword">int</span> *src)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += blocksize) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += blocksize) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; blocksize; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; blocksize; y++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i + x &lt; n &amp;&amp; j + y &lt; n) &#123;</span><br><span class="line">            dst[j + y + (i + x) * n] = src[i + x + (j + y) * n];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置blocksize,一次填写一个方形块，其中每个方形块的尺寸为blocksize × blocksize。</p><p>后面几个lab就是关于页内存,SIMD,OpenMP并行编程以及Spark等等.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.learncs.site/docs/intro">前言 | CS自学社区 (learncs.site)</a></li><li><a href="https://www.learncs.site/assets/files/gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf">gdb5-refcard-89fdebb2475f348ded03071dd13271df.pdf (learncs.site)</a></li><li><a href="https://www.learncs.site/assets/files/riscvcard-75f9fb3a791fab6eee17d3cf216f77f0.pdf">HTU2.indd (learncs.site)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;很早之间就想学学传说中的cs61a/b/c了,这里花两三天时间过一遍cs61c(2020).&lt;/p&gt;</summary>
    
    
    
    
    <category term="c" scheme="https://www.sekyoro.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Just For Fun: 学习c++之后可以尝试的框架/工具</title>
    <link href="https://www.sekyoro.top/2024/09/30/Just-For-Fun-%E5%AD%A6%E4%B9%A0c-%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6-%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.sekyoro.top/2024/09/30/Just-For-Fun-%E5%AD%A6%E4%B9%A0c-%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E7%9A%84%E6%A1%86%E6%9E%B6-%E5%B7%A5%E5%85%B7/</id>
    <published>2024-09-30T09:13:50.000Z</published>
    <updated>2024-10-02T15:05:51.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习c++与其他语言一个不同之处就是, 你可能不能很快地构建一些有趣的项目. </p><p>这时你可能会转向Rust作为代餐,享受安全系统编程语言带来的性能,同时也有一些高级语言所有的强大标准库.或者你也有可能转向Java,C#等更加具有高级应用生态的语言,利用自带的标准库以及强大的三方生态,快速构建性能并不算差的应用. 这里,我简单介绍一下可以使用c++的框架/库以便play for fun.<br><span id="more"></span></p><p>c++常见的开发系统/底层应用主要方向就是1)图形学 2)网络 3) 存储 4)高性能计算</p><p>这里面作为应用开发比较有趣的可能就是利用网络通信再加上图形绘制的游戏开发了. 事实上c++中游戏开发的大佬还是很多的. 作为学习者来说也有许多这方面的库/框架</p><h2 id="较为底层的图形学接口"><a href="#较为底层的图形学接口" class="headerlink" title="较为底层的图形学接口"></a>较为底层的图形学接口</h2><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p><a href="https://www.opengl.org/">OpenGL - The Industry Standard for High Performance Graphics</a></p><p><a href="https://learnopengl-cn.github.io/">主页 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><p>OpenGL是一个图形API,它是跨平台的,使用c++. 我觉得这里并不需要过多介绍</p><p>Vulkan,Dir等也类似.</p><h2 id="封装后的UI"><a href="#封装后的UI" class="headerlink" title="封装后的UI"></a>封装后的UI</h2><h3 id="Dear-ImGUI"><a href="#Dear-ImGUI" class="headerlink" title="Dear ImGUI"></a>Dear ImGUI</h3><p><a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p><p>Dear ImGui是一个c++图形用户界面库.它输出优化的顶点缓冲区,可以在启用3d管道的应用程序中随时渲染。它快速、可移植、与渲染器无关，并且是自包含的(没有外部依赖)</p><p>这个库需要你格外安装图形学API与窗口管理工具,比如OpenGL+GLFW.之前我写过简单的搭建教程<a href="https://www.sekyoro.top/2024/09/11/Dear-ImGUI-不太一样的GUI/#more">Dear-ImGUI:不太一样的GUI | Sekyoro的博客小屋</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imgui_impl_glfw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;imgui_impl_opengl3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span> <span class="comment">// Will drag system OpenGL headers</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">glfw_error_callback</span><span class="params">(<span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span> *description)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;GLFW Error %d: %s\n&quot;</span>, error, description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">  <span class="built_in">glfwSetErrorCallback</span>(glfw_error_callback);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *glsl_version = <span class="string">&quot;#version 130&quot;</span>;</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">0</span>);</span><br><span class="line">  GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(</span><br><span class="line">      <span class="number">1280</span>, <span class="number">720</span>, <span class="string">&quot;Dear ImGui GLFW+OpenGL3 example&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (window == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">  <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>); <span class="comment">// Enable vsync</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMGUI_CHECKVERSION</span>();</span><br><span class="line">  <span class="comment">// initialize</span></span><br><span class="line">  ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">  ImGuiIO &amp;io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">  io.ConfigFlags |=</span><br><span class="line">      ImGuiConfigFlags_NavEnableKeyboard; <span class="comment">// Enable Keyboard Controls</span></span><br><span class="line">  io.ConfigFlags |=</span><br><span class="line">      ImGuiConfigFlags_NavEnableGamepad; <span class="comment">// Enable Gamepad Controls</span></span><br><span class="line">  <span class="comment">// io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // IF using Docking</span></span><br><span class="line">  <span class="comment">// Branch</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup Platform/Renderer backends</span></span><br><span class="line">  <span class="built_in">ImGui_ImplGlfw_InitForOpenGL</span>(</span><br><span class="line">      window, <span class="literal">true</span>); <span class="comment">// Second param install_callback=true will install</span></span><br><span class="line">                     <span class="comment">// GLFW callbacks and chain to existing ones.</span></span><br><span class="line">  <span class="built_in">ImGui_ImplOpenGL3_Init</span>();</span><br><span class="line">  <span class="keyword">bool</span> show_demo_window&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">  <span class="keyword">bool</span> show_another_window&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line">  <span class="comment">// (Your code calls glfwPollEvents())</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Start the Dear ImGui frame</span></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="comment">// Poll and handle events (inputs, window resize, etc.)</span></span><br><span class="line">    <span class="comment">// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to</span></span><br><span class="line">    <span class="comment">// tell if dear imgui wants to use your inputs.</span></span><br><span class="line">    <span class="comment">// - When io.WantCaptureMouse is true, do not dispatch mouse input data to</span></span><br><span class="line">    <span class="comment">// your main application, or clear/overwrite your copy of the mouse data.</span></span><br><span class="line">    <span class="comment">// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input</span></span><br><span class="line">    <span class="comment">// data to your main application, or clear/overwrite your copy of the</span></span><br><span class="line">    <span class="comment">// keyboard data. Generally you may always pass all inputs to dear imgui,</span></span><br><span class="line">    <span class="comment">// and hide them from your application based on those two flags.</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetWindowAttrib</span>(window, GLFW_ICONIFIED) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ImGui_ImplGlfw_Sleep</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// at the begining of the frame</span></span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfw_NewFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line">    <span class="comment">// ImGui::ShowDemoWindow(); // Show demo window! :)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> f = <span class="number">.0</span>f;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;This is some useful text.&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);</span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line">    ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">.0</span>f, <span class="number">1.f</span>);</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="keyword">float</span> *)&amp;clear_color);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>)) &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f PFS)&quot;</span>,</span><br><span class="line">                <span class="number">1000.0f</span> / io.Framerate, io.Framerate);</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">    <span class="keyword">if</span> (show_another_window) &#123;</span><br><span class="line">      ImGui::<span class="built_in">Begin</span>(</span><br><span class="line">          <span class="string">&quot;Another Window&quot;</span>,</span><br><span class="line">          &amp;show_another_window); <span class="comment">// Pass a pointer to our bool variable (the</span></span><br><span class="line">                                 <span class="comment">// window will have a closing button that will</span></span><br><span class="line">                                 <span class="comment">// clear the bool when clicked)</span></span><br><span class="line">      ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello from another window!&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Close Me&quot;</span>))</span><br><span class="line">        show_another_window = <span class="literal">false</span>;</span><br><span class="line">      ImGui::<span class="built_in">End</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Rendering</span></span><br><span class="line">    <span class="comment">// (Your code clears your framebuffer, renders your other stuff etc.)</span></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="keyword">int</span> display_w, display_h;</span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;display_w, &amp;display_h);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h);</span><br><span class="line">    <span class="built_in">glClearColor</span>(clear_color.x, clear_color.y, clear_color.z, clear_color.w);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cleanup</span></span><br><span class="line">  <span class="built_in">ImGui_ImplOpenGL3_Shutdown</span>();</span><br><span class="line">  <span class="built_in">ImGui_ImplGlfw_Shutdown</span>();</span><br><span class="line">  ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust也有类似作用的egui<a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native (github.com)</a></p><p><img data-src="https://s2.loli.net/2024/09/30/gymonshOAW9r1BP.png" alt="image-20240930172646741"></p><h3 id="raylib"><a href="#raylib" class="headerlink" title="raylib"></a>raylib</h3><p><a href="https://www.raylib.com/index.html">raylib | A simple and easy-to-use library to enjoy videogames programming</a></p><p>看到有人推荐没过几天我就看到很多使用它开发的小东西. 官网说主要用于vediogames的开发(跟使用imgui的目的类似). </p><p>个人使用体验比imgui更舒服,因为实际上使用imgui需要调用opengl/vulkan的接口,这些接口命名太<del>傻逼</del>了而且使用更繁琐.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;raylib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> screenWidth = <span class="number">800</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> screenHeight = <span class="number">450</span>;</span><br><span class="line">  <span class="built_in">InitWindow</span>(screenWidth, screenHeight, <span class="string">&quot;raylib [core] example - basic window&quot;</span>);</span><br><span class="line">  <span class="built_in">SetTargetFPS</span>(<span class="number">60</span>);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">WindowShouldClose</span>()) &#123;</span><br><span class="line">    <span class="built_in">BeginDrawing</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClearBackground</span>(RAYWHITE);</span><br><span class="line">    <span class="built_in">DrawText</span>(<span class="string">&quot;Congrats! You created your first window!&quot;</span>, <span class="number">190</span>, <span class="number">200</span>, <span class="number">20</span>,</span><br><span class="line">             LIGHTGRAY);</span><br><span class="line">    <span class="built_in">EndDrawing</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CloseWindow</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="更加高级的跨平台应用开发"><a href="#更加高级的跨平台应用开发" class="headerlink" title="更加高级的跨平台应用开发"></a>更加高级的跨平台应用开发</h2><h3 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h3><p><a href="https://www.libsdl.org/">Simple DirectMedia Layer - Homepage (libsdl.org)</a></p><p><a href="https://wiki.libsdl.org/SDL2/Tutorials">SDL2/Tutorials - SDL Wiki (libsdl.org)</a></p><p>SDL本身是跨平台的多媒体库,使用c++与音视频设备交互. 目前最新是SDL3.0版本了,本身使用c编写,也经常用来写小游戏.</p><p>SDL有对应的网络库<a href="https://github.com/libsdl-org/SDL_net">libsdl-org/SDL_net: A simple, cross-platform wrapper over TCP/IP sockets. (github.com)</a></p><h3 id="SFML"><a href="#SFML" class="headerlink" title="SFML"></a>SFML</h3><p><a href="https://www.sfml-dev.org/">SFML (sfml-dev.org)</a></p><p>与SDL类似,但个人觉得API更简洁更易于使用</p><p>关于两者的讨论<a href="https://www.reddit.com/r/gamedev/comments/n8d6an/sfml_vs_sdl2_which_one_should_i_choose/">sfml vs sdl2 .. which one should i choose? : r/gamedev (reddit.com)</a></p><p>这两者都不止是简单的图形接口了,提供音频和网络模块方便使用</p><p><img data-src="https://s2.loli.net/2024/09/30/HlfgAV9Z2exv8Gb.png" alt="image-20240930174112035"></p><h2 id="功能强大的框架"><a href="#功能强大的框架" class="headerlink" title="功能强大的框架"></a>功能强大的框架</h2><h3 id="WinUI3-期待"><a href="#WinUI3-期待" class="headerlink" title="WinUI3 期待"></a>WinUI3 期待</h3><p>借助微软的力量<a href="https://learn.microsoft.com/zh-cn/windows/apps/winui/winui3/">WinUI 3 - Windows apps | Microsoft Learn</a></p><p>使用WinUI开发windows应用,缺点是不能跨平台,并且微软已经有了很多桌面开发框架了,WPF,MAUI,UWP?等等,不知道这个框架能够一直积极维持多久. </p><h3 id="Qt-不只是UI"><a href="#Qt-不只是UI" class="headerlink" title="Qt 不只是UI"></a>Qt 不只是UI</h3><p>Qt是跨平台桌面?(目前Qt也支持了安卓开发)开发工具.目前已经到了6.0+,除了使用widget之外,针对移动端的Qt quick也发展得不错. 除了UI之外,它还有网络库,图形渲染等常用的库. 甚至可以说Qt的一些库都能拿来代替c++贫瘠的标准库了</p><p>Qt不仅可以进行桌面应用开发,也可以拿来开发游戏.</p><h2 id="至尊C-游戏开发"><a href="#至尊C-游戏开发" class="headerlink" title="至尊C++游戏开发"></a>至尊C++游戏开发</h2><p><a href="https://www.unrealengine.com/zh-CN">最强大的实时3D创作工具 - Unreal Engine</a></p><h2 id="实战raylib"><a href="#实战raylib" class="headerlink" title="实战raylib"></a>实战raylib</h2><p>个人使用上感觉raylib-&gt;Qt-&gt;UE从简易到复杂,功能也越来越多. 而imgui还是功能更少. 下面就介绍一下raylib写点小东西学习学习.</p><ul><li><a href="https://www.raylib.com/cheatsheet/cheatsheet_zh.html">raylib - cheatsheet</a></li><li><a href="https://www.raylib.com/examples.html">raylib - examples</a></li></ul><p><img data-src="https://s2.loli.net/2024/09/30/9zaylEkxOSm1eG2.png" alt="image-20240930203756619"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;raylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Types and Structures Definition</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">GameScreen</span> &#123;</span> LOGO = <span class="number">0</span>, TITLE, GAMEPLAY, ENDING &#125; GameScreen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Program main entry point</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialization</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> screenWidth = <span class="number">800</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> screenHeight = <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitWindow</span>(screenWidth, screenHeight, <span class="string">&quot;raylib [core] example - basic screen manager&quot;</span>);</span><br><span class="line"></span><br><span class="line">    GameScreen currentScreen = LOGO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Initialize all required variables and load all required data here!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> framesCounter = <span class="number">0</span>;          <span class="comment">// Useful to count frames</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetTargetFPS</span>(<span class="number">60</span>);               <span class="comment">// Set desired framerate (frames-per-second)</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main game loop</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">WindowShouldClose</span>())    <span class="comment">// Detect window close button or ESC key</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(currentScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> LOGO:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update LOGO screen variables here!</span></span><br><span class="line"></span><br><span class="line">                framesCounter++;    <span class="comment">// Count frames</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Wait for 2 seconds (120 frames) before jumping to TITLE screen</span></span><br><span class="line">                <span class="keyword">if</span> (framesCounter &gt; <span class="number">120</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = TITLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TITLE:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update TITLE screen variables here!</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Press enter to change to GAMEPLAY screen</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsKeyPressed</span>(KEY_ENTER) || <span class="built_in">IsGestureDetected</span>(GESTURE_TAP))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = GAMEPLAY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GAMEPLAY:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update GAMEPLAY screen variables here!</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Press enter to change to ENDING screen</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsKeyPressed</span>(KEY_ENTER) || <span class="built_in">IsGestureDetected</span>(GESTURE_TAP))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = ENDING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENDING:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Update ENDING screen variables here!</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Press enter to return to TITLE screen</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsKeyPressed</span>(KEY_ENTER) || <span class="built_in">IsGestureDetected</span>(GESTURE_TAP))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentScreen = TITLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw</span></span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">BeginDrawing</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ClearBackground</span>(RAYWHITE);</span><br><span class="line"></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(currentScreen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> LOGO:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw LOGO screen here!</span></span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;LOGO SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, LIGHTGRAY);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;WAIT for 2 SECONDS...&quot;</span>, <span class="number">290</span>, <span class="number">220</span>, <span class="number">20</span>, GRAY);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TITLE:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw TITLE screen here!</span></span><br><span class="line">                    <span class="built_in">DrawRectangle</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight, GREEN);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;TITLE SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, DARKGREEN);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;PRESS ENTER or TAP to JUMP to GAMEPLAY SCREEN&quot;</span>, <span class="number">120</span>, <span class="number">220</span>, <span class="number">20</span>, DARKGREEN);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GAMEPLAY:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw GAMEPLAY screen here!</span></span><br><span class="line">                    <span class="built_in">DrawRectangle</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight, PURPLE);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;GAMEPLAY SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, MAROON);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;PRESS ENTER or TAP to JUMP to ENDING SCREEN&quot;</span>, <span class="number">130</span>, <span class="number">220</span>, <span class="number">20</span>, MAROON);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ENDING:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Draw ENDING screen here!</span></span><br><span class="line">                    <span class="built_in">DrawRectangle</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight, BLUE);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;ENDING SCREEN&quot;</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, DARKBLUE);</span><br><span class="line">                    <span class="built_in">DrawText</span>(<span class="string">&quot;PRESS ENTER or TAP to RETURN to TITLE SCREEN&quot;</span>, <span class="number">120</span>, <span class="number">220</span>, <span class="number">20</span>, DARKBLUE);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EndDrawing</span>();</span><br><span class="line">        <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// De-Initialization</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Unload all loaded data (textures, fonts, audio) here!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseWindow</span>();        <span class="comment">// Close window and OpenGL context</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">raylib example source code</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习c++与其他语言一个不同之处就是, 你可能不能很快地构建一些有趣的项目. &lt;/p&gt;
&lt;p&gt;这时你可能会转向Rust作为代餐,享受安全系统编程语言带来的性能,同时也有一些高级语言所有的强大标准库.或者你也有可能转向Java,C#等更加具有高级应用生态的语言,利用自带的标准库以及强大的三方生态,快速构建性能并不算差的应用. 这里,我简单介绍一下可以使用c++的框架/库以便play for fun.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="fun" scheme="https://www.sekyoro.top/tags/fun/"/>
    
  </entry>
  
  <entry>
    <title>脑子没有坏掉系列:使用Rust写Web</title>
    <link href="https://www.sekyoro.top/2024/09/29/%E8%84%91%E5%AD%90%E6%B2%A1%E6%9C%89%E5%9D%8F%E6%8E%89%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Rust%E5%86%99Web/"/>
    <id>https://www.sekyoro.top/2024/09/29/%E8%84%91%E5%AD%90%E6%B2%A1%E6%9C%89%E5%9D%8F%E6%8E%89%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Rust%E5%86%99Web/</id>
    <published>2024-09-29T12:46:44.000Z</published>
    <updated>2024-09-30T09:26:04.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用rust写web框架的目的: </p><p>1)学习rust语法等知识. 找个感兴趣的项目写写</p><p>2)写写web程序练练手感.<br><span id="more"></span><br>我这里使用的是<a href="https://rocket.rs/">Rocket - Simple, Fast, Type-Safe Web Framework for Rust</a></p><p><img data-src="https://s2.loli.net/2024/09/29/YBv5JnyopKIZDzC.png" alt="image-20240929205536867"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>路由</li></ol><p>Rocket 会将传入的 HTTP 请求解析为本地结构，供你的代码间接操作。Rocket 通过与应用程序中声明的路由属性进行匹配，确定要调用的请求处理程序</p><ol><li>验证</li></ol><p>Rocket根据匹配路由中存在的类型和守卫验证传入请求。如果验证失败，Rocket将请求转发到下一个匹配路由或调用错误处理程序。</p><ol><li>处理</li></ol><p>使用经过验证的参数调用与路由关联的请求处理程序。这是应用程序的主要业务逻辑。处理通过返回一个响应完成。</p><ol><li>相应</li></ol><p>处理返回的响应。Rocket生成适当的HTTP响应并将其发送到客户机。这就完成了生命周期。Rocket继续侦听请求，重新启动每个传入请求的生命周期。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/flosse/rust-web-framework-comparison?tab=readme-ov-file">flosse/rust-web-framework-comparison: A comparison of some web frameworks and libs written in Rust (github.com)</a></li><li><a href="https://course.rs/practice/third-party-libs.html">日常开发三方库精选 - Rust语言圣经(Rust Course)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用rust写web框架的目的: &lt;/p&gt;
&lt;p&gt;1)学习rust语法等知识. 找个感兴趣的项目写写&lt;/p&gt;
&lt;p&gt;2)写写web程序练练手感.&lt;br&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
    <category term="rust" scheme="https://www.sekyoro.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>现代cpp多线程与并发初探</title>
    <link href="https://www.sekyoro.top/2024/09/26/%E7%8E%B0%E4%BB%A3cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2024/09/26/%E7%8E%B0%E4%BB%A3cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2/</id>
    <published>2024-09-26T15:28:12.000Z</published>
    <updated>2024-09-28T11:32:01.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在现代c++(c++20)中,有了jthread和协程的概念,使得我们编写并发程序更加方便. 这里作简单学习.<br><span id="more"></span></p><h2 id="前言知识"><a href="#前言知识" class="headerlink" title="前言知识"></a>前言知识</h2><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p><code>std::thread</code> 用于创建一个执行的线程实例,所以它是一切并发编程的基础,使用时需要包含 <code>&lt;thread&gt;</code> 头文件, 它提供了很多基本的线程操作,例如 <code>get_id()</code> 来获取所创建线程的线程 ID,使用 <code>join()</code> 来等待这个线程结束（与该线程汇合）等等</p><p><code>std::mutex</code> 是 C++11 中最基本的互斥量类,可以通过构造 <code>std::mutex</code> 对象创建互斥量, 而通过其成员函数 <code>lock()</code> 可以进行上锁,<code>unlock()</code> 可以进行解锁. 但是在实际编写代码的过程中,最好不去直接调用成员函数, 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code></p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的,<code>std::unique_lock</code> 更加灵活, <strong><code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权）</strong> 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作.所以在并发编程中,推荐使用 <code>std::unique_lock</code>.</p><p>如果用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数.</p><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生,当互斥操作不够用而引入的. 比如,线程可能需要等待某个条件为真才能继续执行, 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时,就会发生死锁. 所以,<code>condition_variable</code> 对象被创建出现主要就是用于唤醒等待线程从而避免死锁. <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程</p><p><code>std::future</code>,它提供了一个访问异步操作结果的途径</p><p>试想,如果主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务,并返回一个结果. 而这时候,线程 A 可能正在忙其他的事情,无暇顾及 B 的结果, 所以我们会很自然的<strong>希望能够在某个特定的时间获得线程 B 的结果</strong>.</p><p>在 C++11 的 <code>std::future</code> 被引入之前,通常的做法是： 创建一个线程 A,在线程 A 里启动任务 B,当准备完毕后发送一个事件,并将结果保存在全局变量中. 而主函数线程 A 里正在做其他的事情,当需要结果的时候,调用一个线程等待函数来获得执行的结果</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程,可以用来获取异步任务的结果. 自然地,我们很容易能够想象到把它作为一种简单的线程同步手段,即屏障（barrier）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个返回值为7的 lambda 表达式封装到 task 中</span></span><br><span class="line">    <span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 获得 task 的期物</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">    result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障,阻塞到期物的完成</span></span><br><span class="line">    <span class="comment">// 输出执行结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span></span><br><span class="line">              &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-packaged-task-async-解决异步"><a href="#promise-packaged-task-async-解决异步" class="headerlink" title="promise packaged_task async 解决异步"></a>promise packaged_task async 解决异步</h3><p>也许你在Python,Js中已经享受到了异步的好处,在c++中也可以,不过可能会稍微麻烦一些.</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><code>std::async</code>函数可以接受几个不同的启动策略,这些策略在<code>std::launch</code>枚举中定义</p><p>使用 <code>std::launch::async</code> 时,<code>std::async</code> 会立即在一个新线程中启动任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步任务,比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 异步调用 fetchDataFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB =      std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h4><p><code>std::packaged_task</code>是一个可调用目标,它包装了一个任务,该任务可以在另一个线程上运行.它可以捕获任务的返回值或异常,并将其存储在<code>std::future</code>对象中,以便以后使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象  </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象  </span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离,以便主线程可以等待任务完成  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果  </span></span><br><span class="line">    <span class="keyword">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p><code>std::promise</code>用于在某一线程中设置某个值或异常,而<code>std::future</code>则用于在另一线程中获取这个值或异常</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt; prom)</span> </span>&#123; prom.<span class="built_in">set_value</span>(<span class="number">10</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> std::promise&lt;<span class="keyword">int</span>&gt; prom;</span><br><span class="line">  std::future&lt;<span class="keyword">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::move(prom))</span></span>;</span><br><span class="line">  <span class="keyword">int</span> value2 = fut.<span class="built_in">get</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="面向c-20"><a href="#面向c-20" class="headerlink" title="面向c++20"></a>面向c++20</h2><p>C++11 引入了 std::thread 类型,其与操作系统提供的线程对应,但该类型有一个严重的设计缺陷: 不是 RAII 类型. std::thread 要求在其生命周期结束时,若表示正在运行的线程,则调用 join()(等待线程结束) 或 detach()(让线程在后台运行)</p><p>若两者都没有调用,析构函数会立即导致异常的程序终止 (在某些系统上导致段错误).</p><p>不能“杀死”已 经启动的线程.线程不是进程,线程只能通过结束自身或结束整个程序来结束. 因此,在调用 join() 之前,应该确保等待的线程将取消其执行.不过,对于 std::thread,没有这 样的机制,必须自己实现取消请求和对它的响应</p><h3 id="std-jthread"><a href="#std-jthread" class="headerlink" title="std::jthread"></a>std::jthread</h3><p>std::jthread 解决了这些问题,它是 RAII 类型.若线程是可汇入的 (“j”代表“汇入”),析构函数会自动调用 join()</p><ol><li><strong>自动加入</strong>：<code>std::jthread</code> 在析构时会自动调用 <code>join</code>,确保线程在销毁前完成执行.这避免了 <code>std::thread</code> 在析构时未调用 <code>join</code> 或 <code>detach</code> 导致的未定义行为.</li><li><strong>停止标记</strong>：<code>std::jthread</code> 支持停止标记（stop token）,允许线程协作地停止执行.这使得线程可以优雅地处理停止请求.</li><li><strong>异常安全</strong>：<code>std::jthread</code> 在异常处理方面更加安全,确保在异常抛出时线程能够正确地清理资源.</li></ol><p>使用 std::jthread 就不再存在导致异常程序终止的危险,也不需要异常处理.为了支持尽可能容易地切换到 std::jthread 类,该类提供了与 std::thread 相同的 API,包括: </p><ul><li><strong><code>jthread()</code></strong>：默认构造函数,创建一个未关联任何线程的 <code>jthread</code>.</li><li><strong><code>jthread(Function&amp;&amp; f, Args&amp;&amp;... args)</code></strong>：构造函数,启动一个新的线程来执行给定的函数.</li><li><strong><code>join()</code></strong>：等待线程完成执行.</li><li><strong><code>detach()</code></strong>：分离线程,使其独立运行.</li><li><strong><code>get_id()</code></strong>：获取线程的标识符.</li><li><strong><code>joinable()</code></strong>：检查线程是否可以加入.</li><li><strong><code>swap(jthread&amp; other)</code></strong>：交换两个 <code>jthread</code> 对象.</li><li><strong><code>request_stop()</code></strong>：请求线程停止执行.</li><li><strong><code>stop_requested()</code></strong>：检查是否请求了停止.</li><li><strong><code>get_stop_token()</code></strong>：获取线程的停止标记</li><li><strong>get_stop_source</strong>:获取线程停止源</li></ul><h4 id="引入停止请求与停止回调"><a href="#引入停止请求与停止回调" class="headerlink" title="引入停止请求与停止回调"></a>引入停止请求与停止回调</h4><p>std::jthread 提供了一种协作机制来表示线程不应该再运行.它是“协作的”,因为该机制 不会杀死正在运行的线程 (因为 C++ 线程根本不支持杀死线程,杀死线程的操作可能很容易使程序处于损坏状态).</p><p>为了响应停止请求,已启动的线程必须声明<code>std::stop_token</code>作为附加的第一个参数, 并使用它不时的检查是否应该继续运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(std::stop_token st, std::string s, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!st.<span class="built_in">stop_requested</span>())&#123; # 检查是否停止了请求</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// t.request_sop() 显式请求task()停止执行</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is stopping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">jt</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求工作线程停止</span></span><br><span class="line">    jt.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    jt.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另一种对停止请求作出反应的方法: 可以为<code>std::stop_token</code>注册回调,该回调将在请求停止时自动调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::stop_callback cb&#123;st,[]()&#123;&#125;&#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stop_token&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::stop_callback <span class="title">sc</span><span class="params">(st, []&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Stop request received, cleaning up...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is stopping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">jt</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求工作线程停止</span></span><br><span class="line">    jt.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    jt.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::jthread 的主要优点是会自动建立停止信号的机制.<strong>启动线程的构造函数将创建一个停止源</strong>,将其存储为线程对象的成员,并将相应的停止令牌传递给被调用的函数,以避免该函数将额外的 stop_token 作为第一个参数</p><h4 id="停止来源"><a href="#停止来源" class="headerlink" title="停止来源"></a>停止来源</h4><p><code>std::stop_source</code> 是 C++20 引入的一个类,用于管理停止请求.它与 <code>std::stop_token</code> 和 <code>std::jthread</code> 一起使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::stop_source ssrc;</span><br><span class="line">  std::stop_token stok&#123;ssrc.<span class="built_in">get_token</span>()&#125;;</span><br><span class="line">  std::stop_callback cb&#123;stok, []() &#123; <span class="built_in">syncOut</span>() &lt;&lt; <span class="string">&quot;stop requested\n&quot;</span>; &#125;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(std::launch::async, [stok] &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">stop_callback_task</span>(stok, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ssrc.<span class="built_in">request_stop</span>();</span><br></pre></td></tr></table></figure><p>停止来源可以request_stop,jthread对象也可以request_stop. jthread对象可以可以获得停止源和stop_token</p><p>若启动多个 jthread,每个线程都有自己的停止令牌,这可能会导致停止所有线程的时间可能比预期的要长</p><p>可能还需要使用相同的停止令牌为多个线程请求停止,只需自己创建停止令牌,或者从已经启 动的第一个线程中获取停止令牌,并将此停止令牌作为第一个参数启动线程</p><h3 id="std-latch锁存器与std-barrier"><a href="#std-latch锁存器与std-barrier" class="headerlink" title="std::latch锁存器与std::barrier"></a>std::latch锁存器与std::barrier</h3><p><code>std::latch</code> 是一个一次性的同步点,类似于倒计时事件.它允许多个线程等待某个计数器达到零,然后所有等待的线程同时继续执行.一旦计数器达到零,<code>std::latch</code> 就不能再被重置.</p><p><strong>主要特点</strong></p><ul><li><strong>一次性</strong>：一旦计数器达到零,<code>std::latch</code> 就不能再被重置.</li><li><strong>倒计时</strong>：多个线程可以通过调用 <code>count_down</code> 方法减少计数器的值.</li><li><strong>等待</strong>：线程可以调用 <code>wait</code> 方法等待计数器达到零.</li></ul><p><strong>成员方法</strong></p><ul><li><strong><code>latch(count_t count)</code></strong>：构造函数,初始化计数器.</li><li><strong><code>count_down(count_t n = 1)</code></strong>：减少计数器的值.</li><li><strong><code>count_down_and_wait(count_t n = 1)</code></strong>：减少计数器的值并等待计数器达到零.</li><li><strong><code>wait()</code></strong>：等待计数器达到零.</li><li><strong><code>try_wait()</code></strong>：尝试等待计数器达到零,如果计数器尚未达到零则立即返回 <code>false</code>.</li><li><strong><code>arrive_and_wait(count_t n = 1)</code></strong>：等同于 <code>count_down_and_wait(n)</code></li></ul><p>锁存器是用于并发执行的一种新的同步机制,支持单次使用异步倒计时.从初始整数值开始, 各种线程可以自动将该值计数到零.当计数器达到零时,等待此倒计时的所有线程继续运行</p><p><img data-src="https://s2.loli.net/2024/09/28/eyjWsP9bpHdwacD.png" alt="image-20240928144118863"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::latch &amp;l)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  l.<span class="built_in">count_down</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Worker thread finished and counted down\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_threads&#123;<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="function">std::latch <span class="title">l</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">  std::vector&lt;std::jthread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(l));</span><br><span class="line">  &#125;</span><br><span class="line">  l.<span class="built_in">wait</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::latch allReady&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  std::vector&lt;std::jthread&gt; threads2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    std::jthread t&#123;[i, &amp;allReady] &#123;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">      allReady.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">5</span>; ++j) &#123;</span><br><span class="line">        std::cout.<span class="built_in">put</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;A&#x27;</span> + j));</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    threads2.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>barrier</code>是用于并发执行的新的同步机制,允许多次同步多个异步任务.设置初始计数后,多个线程可以对其进行计数,并等待计数器达到零.与锁存器相比,当达到零时,将调用一个 (可选的) 回调,计数器将重新初始化为初始计数</p><p><img data-src="https://s2.loli.net/2024/09/28/SKiqeEcvdDM9N2C.png" alt="image-20240928145528067"></p><p>arrive() 函数会返回一个类型为 std::barrier::arrival_token 的到达令牌,以确保 barrier 知道要等待哪个线程.</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>C++20 引入了处理信号量的新类型.信号量是轻量级同步原语,允许同步或限制对一个或一组资源的访问</p><p>C++ 标准库提供了两种信号量类型:</p><ul><li>std::counting_semaphore&lt;&gt; 将多个资源的使用限制在最大值</li><li>std::binary_semaphore&lt;&gt; 限制对单一资源的使用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::queue&lt;<span class="keyword">char</span>&gt; values;</span><br><span class="line">  std::mutex valuesMx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    values.<span class="built_in">push</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;a&#x27;</span> + (i % (<span class="string">&#x27;z&#x27;</span> - <span class="string">&#x27;a&#x27;</span>))));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> numThreads = <span class="number">10</span>;</span><br><span class="line">  std::counting_semaphore&lt;numThreads&gt; enabled&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  std::vector&lt;std::jthread&gt; pool;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; numThreads; ++idx) &#123;</span><br><span class="line">    std::jthread t&#123;[idx, &amp;enabled, &amp;values, &amp;valuesMx](std::stop_token st) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        enabled.<span class="built_in">acquire</span>();</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        &#123;</span><br><span class="line">          std::lock_guard lg&#123;valuesMx&#125;;</span><br><span class="line">          val = values.<span class="built_in">front</span>();</span><br><span class="line">          values.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          std::cout.<span class="built_in">put</span>(val);</span><br><span class="line">          <span class="keyword">auto</span> dur = <span class="number">130</span>ms * ((idx % <span class="number">3</span>) + <span class="number">1</span>);</span><br><span class="line">          std::this_thread::<span class="built_in">sleep_for</span>(dur);</span><br><span class="line">        &#125;</span><br><span class="line">        enabled.<span class="built_in">release</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    pool.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  enabled.<span class="built_in">release</span>(<span class="number">3</span>);</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t:pool)&#123;</span><br><span class="line">    t.<span class="built_in">request_stop</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动了 10 个线程,但限制了允许其中多少线程主动运行和处理数据,因此将信号量 初始化为最大数量 (10) 和初始资源数量 (0)</p><p>因为信号量初始化为零,所以最初的情况是阻塞,因此没有可用的资源.使用release控制最大资源,acquire获得资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line">std::binary_semaphore dataReady&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::binary_semaphore dataDone&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::jthread process&#123;[&amp;](std::stop_token st) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dataReady.<span class="built_in">try_acquire_for</span>(<span class="number">1</span>s)) &#123;</span><br><span class="line">      <span class="keyword">int</span> data = sharedData;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[process] read &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(data * <span class="number">.5</span>s);</span><br><span class="line"></span><br><span class="line">      dataDone.<span class="built_in">release</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[process] no data to process\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[main] write &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">  sharedData = i;</span><br><span class="line">  dataReady.<span class="built_in">release</span>();</span><br><span class="line">  dataDone.<span class="built_in">acquire</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[main] data processed\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><ul><li><strong><code>std::atomic_ref</code></strong>：用于在现有对象上提供原子操作,适用于非侵入性地将非原子类型包装成原子类型.</li><li><strong><code>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</code></strong>：用于在多线程环境中安全地管理共享指针,确保指针的引用计数和其他操作是线程安全的.</li></ul><p>流的并发输出会导致未定义行为 (这是数据竞争,指具有未定义行为的竞争条件).</p><p>同步并发输出流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syncstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">syncOut</span><span class="params">(std::ostream&amp; strm=std::cout)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::osyncstream&#123;strm&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-中的协程"><a href="#c-中的协程" class="headerlink" title="c++中的协程"></a>c++中的协程</h2><p>C++20 引入了对协程的支持,<strong>协程 是可以挂起的函数</strong>(类似于python中yield的生成器?)</p><p>调用普通函数 (或过程) 时,然后运行到它们的结束 (或直到到达返回语句或抛出异常),而协程 是可以分多个步骤运行的函数 </p><p>某些时刻,可以挂起一个协程,所以该函数暂停其计算,直到恢复.挂起可能是因为函数必须 等待某些东西,有其他 (更重要的) 事情要做,或者有一个中间结果要给调用者. 因此,启动协程意味着启动另一个函数,直到它的一部分完成.调用函数和协程都在它们的两 条执行路径之间来回切换.</p><p>注意,这两个函数不是并行运行的,我们用控制流来打乒乓球:</p><ul><li>函数可以通过开始或继续协程的语句来决定启动或恢复其当前控制流. </li><li>当协程运行时,协程可以决定挂起或结束其执行,启动或恢复协程的函数将继续执行其控制流.</li></ul><p><img data-src="https://s2.loli.net/2024/09/28/6q3sc8P4LS7wt5x.png" alt="image-20240928155220941"></p><p>协程的最简单形式中,主控制流和协程的控制流都在同一个线程中运行.不需要使用多线程, 也不需要处理并发访问,但可以在不同的线程中运行协程.甚至可以在不同的线程上将协程恢复到 先前挂起的位置.协程有一种正交特性,但其可以与多个线程一起使用.甚至可以在不同的线程上 将协程恢复到先前挂起的位置</p><p>使用协程就像在后台有一个函数,可以不时地启动和继续.然而,由于协程的生命周期超出了嵌套作用域,因此协程也是一个将其状态存储在某些内存中并提供处理状态的 API.</p><ul><li>协程通常返回一个对象,作为调用者的协程接口.根据协程的目的和用途,该对象可以表示 一个不时挂起或切换上下文的正在运行的任务,不时产生值的生成器,或者一个按需惰性地 返回一个或多个值的工厂</li><li>协程无堆栈.不挂起外部协程的情况下,无法挂起在外部协程中调用的内部协程,只能将外 部协程作为一个整体挂起. 当协程挂起时,协程的状态作为一个整体被存储在与堆栈分开的对象中,以便它可以在完全 不同的上下文中 (在不同的调用堆栈中,在另一个线程中等) 恢复.</li></ul><p>只需在函数中使用以下关键字即可隐式定义协程: </p><ul><li>co_await </li><li>co_yield</li><li>co_return </li></ul><p>若这些关键字在协程中都不没有,则必须显式地使用 co_return; 语句.</p><p>协程具有以下属性和限制: </p><ul><li>协程不允许有返回语句. </li><li>协程不能是 constexpr 或 consteval</li><li>协程不能有返回类型 auto 或其他占位符类型. </li><li>main() 不能是协程. </li><li>构造函数或析构函数不可为协程</li><li>协程可以是静态</li><li>协程若不是构造函数或析构函数,可以是成员函数</li><li>协程甚至可以是 Lambda,但在这种情况下,必须谨慎使用</li></ul><h3 id="实现协程接口与句柄"><a href="#实现协程接口与句柄" class="headerlink" title="实现协程接口与句柄"></a>实现协程接口与句柄</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroTask</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span>;</span></span><br><span class="line">  <span class="keyword">using</span> CoroHdl = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CoroHdl hdl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">auto</span> h) : hdl&#123;h&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CoroTask</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hdl)</span><br><span class="line">      hdl.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoroTask &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hdl || hdl.<span class="built_in">done</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    hdl.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !hdl.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoroTask</span>:</span>:promise_type &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CoroTask&#123;CoroHdl::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>处理 C++ 中的协程,需要做两件事: </p><ul><li>promise 类型 此类型用于定义处理协同例程的某些自定义点,特定的成员函数定义了在特定情况下调用的 回调函数. </li><li>std::coroutine_handle&lt;&gt; 类型的内部协程句柄 此对象在调用协程时创建 (使用上述 promise 类型的标准回调之一),可以通过提供一个底层接 口来恢复协程以及处理协程的结束,从而用于管理协程的状态</li></ul><p>引入 promise_type(每个协程类型都必须拥有),并声明本地协程句柄 hdl,它管理协程的状态. 原生协程句柄 std::coroutine_handle&lt;&gt; 的类型是用 promise 类型参数化的,存储在 promise 中的任何 数据都是句柄的一部分,promise 中的函数可以通过句柄访问</p><p>resume方法在协程挂起时恢复协程,其或多或少地将恢复请求传播到原生协程句 柄,其<strong>返回表示是否有必要再次恢复协程</strong>. </p><p>函数检查是否有句柄,或者协程是否已经结束. 尽管在这个实现中协程接口总是有一个句柄,但这是一个必要的检查,例如,若接口支持移动 语义. 只有当协程挂起且尚未结束时才允许调用 resume(),所以检查是否 done() 是必要的.调用本身恢复挂起的协程并阻塞,直到下一个挂起点或结束</p><p><strong>针对co_await等待</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoroTask.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Coro <span class="title">coro</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; start\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= max; ++val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> coroTask = <span class="built_in">coro</span>(<span class="number">3</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;coro() started\n&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (coroTask.<span class="built_in">resume</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;coro() suspended&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;coro() done\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 定义promise 类型目的是: </p><ul><li>定义如何创建或获取协程的返回值 (通常包括创建协程句柄)</li><li>决定协同程序是应该在开始还是结束时挂起</li><li>处理协程调用者与协程之间交换的值</li><li>处理未处理的异常</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoroTask</span>:</span>:promise_type &#123;</span><br><span class="line">  <span class="comment">// init and return coroutine interface</span></span><br><span class="line">  <span class="comment">// 创建协程接口 创建对象</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CoroTask&#123;CoroHdl::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">  <span class="comment">// 主动启动还是需要resume</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">  <span class="comment">// 到达结束时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 异常处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 最终是否挂起</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>针对co_yield返回值</strong></p><p>在promise_type中定义值,并定义<code>yield_value</code>用于保存值,在协程返回对象中定义<code>getValue</code>方便访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroTask</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coroValue = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">      coroValue = val;</span><br><span class="line">      <span class="keyword">return</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> CoroHdl = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CoroHdl hdl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">auto</span> h) : hdl&#123;h&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CoroTask</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hdl)</span><br><span class="line">      hdl.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoroTask &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hdl || hdl.<span class="built_in">done</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    hdl.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !hdl.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hdl.<span class="built_in">promise</span>().coroValue; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>针对co_return结束并返回值</strong></p><p>通过使用 co_return,协程可以在其结束时向调用者返回结果. 实现方式是在promise_type中增加return_value,然后依旧在协程接口对象中声明一个方法访问coroutine_handle.</p><p>若协程以有时可能返回值,有时可能不返回值的方式实现,则这是未定义行为.则这个协程无效. 也就是return_value和return_void也不能同时声明</p><h3 id="实现Awaitable对象"><a href="#实现Awaitable对象" class="headerlink" title="实现Awaitable对象"></a>实现Awaitable对象</h3><p>协程必须)提供Awaitables(实现方式是使用 Awaiter)</p><p> Awaitables 是 co_await 需要作为其操作数的术语,所以 awaitables 是 co_await 可以处理的所有对象. </p><p>Awaiter 是实现 Awaitables 的一种特定 (和典型) 方式的术语.</p><p>其必须提供三个特定的成员函数来处理协程的暂停和恢复</p><p><img data-src="https://s2.loli.net/2024/09/28/giQEJnrPypb7Ko8.png" alt="image-20240928181236087"></p><p><strong>await_ready()</strong> 在协程被挂起之前调用,提供挂起.若它返回 true,则协程根本不会挂起. 这个函数通常只返回 false</p><p><strong>auto await_suspend(awaitHdl)</strong> </p><p>在<strong>协程挂起后立即为协程调用此函数</strong>.参数 awaitHdl 是被挂起的协程的句柄,其类型是 std::coroutine_handle. 这个函数中,可以指定下一步要做什么,包括立即恢复挂起的或等待的协程.</p><p> <strong>auto await_resume()</strong> 当<strong>成功挂起后恢复协程时,将为协程调用此函数</strong>.可以返回一个值,这个值就是 co_await 表达式产生的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; await_ready\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="keyword">auto</span> hdl)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; await_suspend\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot; await_resume\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>Awaiter</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CoroTask <span class="title">coro</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; start\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= max; ++val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    <span class="keyword">co_await</span> Awaiter&#123;&#125;;</span><br><span class="line">    <span class="comment">// co_yield val;</span></span><br><span class="line">    <span class="comment">// co_return 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个标准<code>Awaiters</code>,<code>`std::suspend_always</code>和<code>std::suspend_never</code>. 差别就是<code>await_ready</code>的返回值</p><p>若在 await_ready() 中返回 false(而在 await_suspend() 中没有返回任何值),则 suspend_always 接受每个挂起,并将协程返回给其调用者. </p><p>若在 await_ready() 中返回 true,则 suspend_never 永远不会接受任何挂起,则协程继续 (永远不会调用 await_suspend()).</p><p><code>std::suspend_always</code>通常用作 co_await 的基本 awaiter.</p><p><strong>挂起后将值传递回协程</strong></p><p>协程接口的 promise 类型是协程与调用者共享和交换数据的最佳位置,在promse_type的<code>yield_value</code>中返回一个<code>awaiter</code>,这个<code>awaiter</code>能够修改协程接口中的promise并在挂起恢复时设置值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val)</span> </span>&#123; hdl.<span class="built_in">promise</span>().backValue = val; &#125; <span class="comment">// 在协程接口中写一个方法能够修改返回值</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  coroValue = val;</span><br><span class="line">  backValue.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// return std::suspend_always&#123;&#125;;</span></span><br><span class="line">  <span class="keyword">return</span> BackAwaiter&lt;CoroHdl&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Hdl&gt; <span class="class"><span class="keyword">class</span> <span class="title">BackAwaiter</span> &#123;</span></span><br><span class="line">  Hdl hdl = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BackAwaiter</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BackAwaiter await_ready\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(Hdl h)</span> <span class="keyword">noexcept</span> </span>&#123; hdl = h; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hdl.<span class="built_in">promise</span>().backValue; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/">第 7 章 并行与并发 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp07.html">C++ 并发三剑客future, promise和async · 恋恋风辰的编程笔记 (llfc.club)</a></li><li>C++ Concurrency In Action</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在现代c++(c++20)中,有了jthread和协程的概念,使得我们编写并发程序更加方便. 这里作简单学习.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="thread" scheme="https://www.sekyoro.top/tags/thread/"/>
    
    <category term="concurrency" scheme="https://www.sekyoro.top/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>回看深度学习:经典网络学习</title>
    <link href="https://www.sekyoro.top/2024/09/24/%E5%9B%9E%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/09/24/%E5%9B%9E%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-24T07:38:15.000Z</published>
    <updated>2024-10-08T08:12:45.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>传统深度学习,或者说在llm之前的深度学习,现在看来,还是有很多trick以及各种模块”缝合”的内容,这部分有很多提出来的方法其实都有一些共通点的,这里简单回顾总结一下.<br><span id="more"></span></p><h2 id="Vision-Transformer-and-its-variants"><a href="#Vision-Transformer-and-its-variants" class="headerlink" title="Vision Transformer and its variants"></a>Vision Transformer and its variants</h2><h3 id="AN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE"><a href="#AN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE" class="headerlink" title="AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE"></a>AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE</h3><p><img data-src="https://s2.loli.net/2024/09/26/GI83VzYUF4PaKg6.png" alt="image-20240926173222690"></p><h3 id="Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows"><a href="#Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows" class="headerlink" title="Swin Transformer: Hierarchical Vision Transformer using Shifted Windows"></a>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows</h3><p><img data-src="https://s2.loli.net/2024/09/26/BEDZibGuALMsfUx.png" alt="image-20240926173305765"></p><h2 id="Modernify-Conv"><a href="#Modernify-Conv" class="headerlink" title="Modernify Conv"></a>Modernify Conv</h2><h3 id="A-ConvNet-for-the-2020s"><a href="#A-ConvNet-for-the-2020s" class="headerlink" title="A ConvNet for the 2020s"></a>A ConvNet for the 2020s</h3><p>出发点是一个ResNet-50模型.首先使用类似的训练技术来训练vision transformer,并获得了比原始ResNet-50更好的结果</p><p>然后我们研究了一系列的设计决策,总结为</p><p>1 )marco design,2 ) ResNeXt,3 )inverted- bottleneck,4 )大核尺寸,5 )各种layer-wise的mirco design.</p><p><img data-src="https://s2.loli.net/2024/09/26/LoV7htDUYzE3TuI.png" alt="image-20240926153040226"></p><h4 id="训练技术"><a href="#训练技术" class="headerlink" title="训练技术"></a>训练技术</h4><p>最近的研究表明,一套现代的训练技术可以显著提高一个简单的ResNet-50模型的性能.在本研究中,使用了与Dei-T和Swin Transformer相近的训练方法.</p><p>对于深度残差网络,训练从原来的90次扩展到300次.</p><p>使用Adam W优化器,数据增强技术如Mixup、Cutmix、Rand Augment、Random Erasing,以及正则化方案包括Stochastic Depth和Label Smoothing</p><h4 id="Marco-Design"><a href="#Marco-Design" class="headerlink" title="Marco Design"></a>Marco Design</h4><h5 id="修改阶段计算比例"><a href="#修改阶段计算比例" class="headerlink" title="修改阶段计算比例"></a>修改阶段计算比例</h5><p>Swin-T阶段计算比例略有不同,为1：1：3：1.对于较大的Swin Transformer,比例为1：1：9：1.</p><p>根据设计将每个阶段的块数从ResNet-50中的( 3、4、6、3)调整为( 3、3、9、3),这也将FLOPs与Swin-T对齐</p><h4 id="修改stem为patchify"><a href="#修改stem为patchify" class="headerlink" title="修改stem为patchify"></a>修改stem为patchify</h4><p>标准ResNet中的stem包含一个7 × 7的步幅为2的卷积层,然后是一个max pooling,这导致对输入图像进行4 ×的下采样.</p><p>在Vision Transformers中,使用了patchify策略作为stem,对应于较大的核尺寸(如kernel大小= 14或16)和非重叠卷积.</p><p>Swin Transformer使用了类似的” Patchify “层,但是具有更小的Patch size 4以适应架构的多级设计</p><p>将ResNet风格的stem替换为使用4 × 4,stride为4的卷积层实现的patchify层.准确率从79.4 %变为79.5 %.这表明ResNet中的stem可能被更简单的” patchify “层ViT替代,这将导致类似的性能</p><h4 id="ResNext-ify"><a href="#ResNext-ify" class="headerlink" title="ResNext-ify"></a>ResNext-ify</h4><p>核心部件是group normalization,其中卷积滤波器被分成不同的组.在更高的层面上,ResNeXt的指导原则是”利用更多群体,拓展宽度”.更确切地说,ResNeXt对瓶颈块中的3 × 3 conv层使用分组卷积.由于这显著降低了FLOPs,因此扩大了网络宽度以补偿容量损失,</p><p>depth-wise卷积类似于自注意力中的加权和操作,它在每个通道的基础上操作,即只在空间维度上混合信息</p><p>深度卷积和1 × 1卷积的结合导致了空间和通道混合的分离,这是视觉转换器共有的特性,其中每个操作要么混合了空间或通道维度的信息,但不是两者都混合.</p><p>depth-wise卷积的使用有效地降低了网络的FLOPs,但会降低精度</p><p>根据ResNeXt提出的策略,将网络宽度增加到与Swin-T的( 64 ~ 96)相同的通道数.随着FLOPs ( 5.3G )的增加,网络性能达到80.5 %.</p><h4 id="Inverted-Bottleneck"><a href="#Inverted-Bottleneck" class="headerlink" title="Inverted Bottleneck"></a>Inverted Bottleneck</h4><p>在每个Transformer模块中,一个重要的设计是它创建了一个反向瓶颈,即<strong>MLP模块的隐藏维度比输入维度宽4倍</strong></p><p><img data-src="https://s2.loli.net/2024/09/26/qsz5JcBe1dC9Dak.png" alt="image-20240926163046594"></p><p>尽管depth-wise卷积层的FLOP值有所增加,但由于下采样残差块的捷径1 × 1 conv层的FLOP值显著降低,该变化使得整个网络的FLOP值降低到4.6 G</p><h4 id="更大的尺寸大小"><a href="#更大的尺寸大小" class="headerlink" title="更大的尺寸大小"></a>更大的尺寸大小</h4><p>Vision Transformer最具有特色的一个方面是其非局部自注意力,这使得每一层都具有全局的感受野.过去,卷积神经网络使用大的内核尺寸,而(由VGGNet 推广)的金标准是堆叠小的内核尺寸( 3 × 3 )的conv层,它们在现代GPU上具有高效的硬件实现</p><p>虽然Swin Transformers将局部窗口重新引入到自注意力块中,但窗口大小至少为7 × 7,明显大于ResNe ( X ) t核大小3 × 3.在这里重新考虑了卷积神经网络中大核卷积的使用.</p><p>为了探索大核,<strong>一个先决条件是将depth-wise卷积放在前面</strong>.这在Transformers中也是显而易见的设计决策:MSA块( 大内核conv)放置在复杂/低效的模块的MLP层之前会有更少的通道,而高效、密集的1 × 1层会做繁重的提升.这一中间步骤将FLOPs降低到4.1 G,导致性能暂时下降到79.9 %.</p><p><img data-src="https://s2.loli.net/2024/09/26/j1EB3GYx5Kz9wJa.png" alt="image-20240926164338145"></p><p>在所有这些准备工作中,采用更大的核卷积的好处是显著的.实验了几种不同的核尺寸,包括3、5、7、9和11.网络的性能从79.9 % ( 3 × 3 )提高到80.6 % ( 7 × 7 ),而网络的FLOPs基本保持不变.此外观察到<strong>较大的核尺寸带来的收益在7 × 7处达到饱和点</strong>.在大容量模型中也验证了这一行为:将内核大小增加到7 × 7以上时,ResNet - 200机制模型没有表现出进一步的增益</p><h4 id="Micro-Design"><a href="#Micro-Design" class="headerlink" title="Micro Design"></a>Micro Design</h4><p><strong>使用GELU替换RELU</strong></p><p>NLP和视觉架构的一个不同之处在于使用的激活函数的具体形式.随着时间的推移,许多激活函数已经被开发出来,但ReLU 由于其简单和高效,仍然被广泛用于卷积神经网络中.</p><p>在ConvNet中,ReLU也可以用GELU代替,尽管精度保持不变</p><p><strong>更少的激活函数</strong></p><p>transfomer的激活函数较少.考虑一个具有key / query / value线性嵌入层的Transformer块,一个MLP块中的投影层和两个线性层.MLP块中只有一个激活函数.相比较而言,通常的做法是在每个卷积层中添加一个激活函数,包括1 × 1卷积层.</p><p>除了两个1 × 1层之间的GELU层外,从残差块中消除了所有GELU层,复制了Transformer块的风格.该过程使结果提高了0.7 % ~ 81.3 %,与Swin - T的性能基本匹配</p><p><strong>更少的normalization层</strong></p><p>transformer块通常也具有较少的归一化层数.这里去掉两个Batch Norm ( BN )层,在conv 1 × 1层之前只留下一个BN层.</p><p>每个块的归一化层数甚至比Transformers还要少,因为从经验上发现在块的开头增加一个BN层并不能提高性能</p><p><strong>替换BN为LN</strong></p><p>BatchNorm是卷积神经网络中的一个重要组成部分,它提高了收敛性并减少了过拟合</p><p>更简单的层归一化 在Transformer中得到了应用,在不同的应用场景中表现出良好的性能</p><p>直接将原始ResNet中的LN替换为BN会导致次优的性能.随着网络结构和训练技术的改变,这里重新使用LN代替BN的影响,观察到ConvNet模型在使用LN进行训练时没有任何困难；事实上,性能略好,获得了81.5 %的准确率</p><p><strong>单独的下采样层</strong></p><p>在ResNet中,空间下采样是通过每个阶段开始时的残差块来实现的,采用3×3的conv,stride为2 (short connection时使用stride为2的1 × 1 conv).</p><p>在Swin Transformers中,不同尺度之间增加了单独的下采样层.这里使用2×2的conv层和stride为2进行空间下采样.</p><p>进一步的研究表明,<strong>在空间分辨率变化的地方增加归一化层有助于稳定训练</strong>.其中包括Swin Transformers中也使用的几个LN层：每个下采样层之前的一个,stem之后的一个,最后全局平均池化之后的一个.可以将准确率提高到82.0%,明显超过Swin-T的81.3%</p><h3 id="Early-Convolutions-Help-Transformers-See-Better"><a href="#Early-Convolutions-Help-Transformers-See-Better" class="headerlink" title="Early Convolutions Help Transformers See Better"></a>Early Convolutions Help Transformers See Better</h3><p><img data-src="https://s2.loli.net/2024/09/26/Q5ajrv8dZT6MoKS.png" alt="image-20240926160213575"></p><p>Vision Transformer(ViT)模型表现出不达标的可优化性。特别地，它们对优化器( Adam W vs . SGD)、优化器超参数和训练调度长度的选择非常敏感。相比较而言，现代卷积神经网络更容易优化。为什么会出现这种情况?在这项工作中猜想问题在于ViT模型的patchify stem,它是通过应用于输入图像的stride-p p × p卷积(默认p = 16)来实现的</p><blockquote><p>也就是下采样p倍</p></blockquote><p>这种大核加大步长的卷积与神经网络中卷积层的典型设计选择背道而驰。为了检验这种非典型的设计选择是否会导致问题，分析了ViT模型的优化行为，其原始的Patchify词干与一个简单部分对应,将ViT patchify stem替换为少量堆叠的stride-2 3 × 3卷积。</p><p>虽然两种ViT设计的绝大多数计算量是相同的,但发现这种<strong>早期视觉处理的微小变化导致训练行为在对优化设置的敏感性以及最终的模型精度方面有明显的不同</strong>。在ViT中使用卷积树干显著地增加了优化的稳定性，并提高了峰值性能(在ImageNet - 1k上的top - 1准确率提高了1 - 2 %)，同时保持了触发器和运行时间</p><p>这种改进可以在模型复杂度(从1G到36G触发器)和数据集规模(从ImageNet - 1k到ImageNet - 21k)的宽光谱范围内观察到。这些发现促使我们推荐在该机制下为ViT模型使用一个标准的、轻量级的卷积主干，作为比原始ViT模型设计更稳健的架构选择。</p><h2 id="Vector-quantization-and-Codebook"><a href="#Vector-quantization-and-Codebook" class="headerlink" title="Vector quantization and Codebook"></a>Vector quantization and Codebook</h2><h3 id="Neural-Discrete-Representation-Learning"><a href="#Neural-Discrete-Representation-Learning" class="headerlink" title="Neural Discrete Representation Learning"></a>Neural Discrete Representation Learning</h3><p><a href="https://arxiv.org/abs/1711.00937">1711.00937] Neural Discrete Representation Learning (arxiv.org)</a></p><p><strong>在没有监督的情况下学习有用的表示</strong>(个人认为算是自监督-&gt;生成式学习)仍然是机器学习中的一个关键挑战.</p><p>VQ-VAE 两个关键方面与VAEs不同：</p><ul><li>encoder输出离散的编码,也就是中间嵌入是离散的</li><li>先验知识是学到的.</li></ul><p>为了学习一个离散的潜在表示,结合了向量量化( VQ )的思想.使用VQ方法可以使模型避免”后验崩溃”问题- -当潜在变量(中间嵌入)与decoder配对时被忽略</p><h4 id="离散潜变量-中间嵌入"><a href="#离散潜变量-中间嵌入" class="headerlink" title="离散潜变量(中间嵌入)"></a>离散潜变量(中间嵌入)</h4><p>定义一个潜在嵌入空间e∈R^K×D^,其中K为离散潜在空间(即K - way范畴)的大小,D为每个潜在嵌入向量e^i^的维数.注意到存在K个嵌入向量e~i~∈R^D^,i∈1,2,..,K.该模型取一个输入x,通过编码器产生输出z~e~(x)</p><p>然后利用共享嵌入空间e通过最近邻查找计算离散潜变量z</p><p><img data-src="https://s2.loli.net/2024/09/24/B5C7huNZsTWfdGP.png" alt="image-20240924160115359"></p><p>Z~e~(x)是编码器网络的输出,根据这个输出通过找到最近邻映射到给定的潜在空间中,得到z~q~(x)作为decoder的输入.</p><script type="math/tex; mode=display">z_q(x)=e_k,\quad\text{where}\quad k=\text{argmin}_j\|z_e(x)-e_j\|_2</script><p>对于梯度,直接将z~q~(x)的梯度copy到z~e~(x)</p><p>由于encoder的输出表示和decoder的输入共享相同的D维空间<strong>,梯度包含了encoder如何改变其输出以降低重构损失的有用信息</strong></p><p>总损失如下,有三个组成部分,分别用于训练VQ-VAE的不同部分.</p><p>第一项是重构损失(或数据项),它优化了解码器和编码器</p><p>由于z~e~ (x)到z~q~( x)映射的直通梯度估计(梯度直接copy),嵌入e~i~没有从重构损失log~p~ ( z | z~q~ ( x ) )中获得梯度.因此,为了学习嵌入空间,使用最简单的字典学习算法之一,向量量化( VQ ).VQ目标使用l2误差将嵌入向量e~i~移动到编码器输出z~e~ (x).</p><p>最后,由于嵌入空间的体积是无量纲的,如果嵌入e~i~的训练速度没有编码器参数那么快,嵌入空间的体积可以任意增长.</p><script type="math/tex; mode=display">L=\log p(x|z_q(x))+\|\mathrm{sg}[z_e(x)]-e\|_2^2+\beta\|z_e(x)-\mathrm{sg}[e]\|_2^2</script><p>Sg表示在前向计算时定义为恒等式且具有零偏导数的停止梯度算子,从而有效地约束其操作数为非更新常数</p><script type="math/tex; mode=display">sg(x)=\left\{\begin{array}{l}x (in forward propagation)\\0 (in backward propagation)\end{array}\right.</script><p>decoder只优化第一个损失项,encoder优化第一个和最后一个损失项,嵌入由中间损失项优化.</p><p><img data-src="https://raw.githubusercontent.com/zalandoresearch/pytorch-vq-vae/b98fde9a8f8f65486dbfaf12958049e8d33184a1//images/vq-vae.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorQuantizer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_embeddings, embedding_dim, commitment_cost</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VectorQuantizer, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self._embedding_dim = embedding_dim</span><br><span class="line">        self._num_embeddings = num_embeddings</span><br><span class="line">        </span><br><span class="line">        self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim)</span><br><span class="line">        self._embedding.weight.data.uniform_(-<span class="number">1</span>/self._num_embeddings, <span class="number">1</span>/self._num_embeddings)</span><br><span class="line">        self._commitment_cost = commitment_cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">        <span class="comment"># convert inputs from BCHW -&gt; BHWC</span></span><br><span class="line">        inputs = inputs.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).contiguous()</span><br><span class="line">        input_shape = inputs.shape</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Flatten input</span></span><br><span class="line">        flat_input = inputs.view(-<span class="number">1</span>, self._embedding_dim)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate distances</span></span><br><span class="line">        distances = (torch.<span class="built_in">sum</span>(flat_input**<span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) </span><br><span class="line">                    + torch.<span class="built_in">sum</span>(self._embedding.weight**<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">                    - <span class="number">2</span> * torch.matmul(flat_input, self._embedding.weight.t()))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Encoding</span></span><br><span class="line">        encoding_indices = torch.argmin(distances, dim=<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        encodings = torch.zeros(encoding_indices.shape[<span class="number">0</span>], self._num_embeddings, device=inputs.device)</span><br><span class="line">        encodings.scatter_(<span class="number">1</span>, encoding_indices, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Quantize and unflatten</span></span><br><span class="line">        quantized = torch.matmul(encodings, self._embedding.weight).view(input_shape)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Loss</span></span><br><span class="line">        e_latent_loss = F.mse_loss(quantized.detach(), inputs)</span><br><span class="line">        q_latent_loss = F.mse_loss(quantized, inputs.detach())</span><br><span class="line">        loss = q_latent_loss + self._commitment_cost * e_latent_loss</span><br><span class="line">        </span><br><span class="line">        quantized = inputs + (quantized - inputs).detach()</span><br><span class="line">        avg_probs = torch.mean(encodings, dim=<span class="number">0</span>)</span><br><span class="line">        perplexity = torch.exp(-torch.<span class="built_in">sum</span>(avg_probs * torch.log(avg_probs + <span class="number">1e-10</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># convert quantized from BHWC -&gt; BCHW</span></span><br><span class="line">        <span class="keyword">return</span> loss, quantized.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>).contiguous(), perplexity, encodings</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/640000410">VQVAE PyTorch 实现教程 - 知乎 (zhihu.com)</a></li><li><a href="https://github.com/Jackson-Kang/Pytorch-VAE-tutorial/blob/master/02_Vector_Quantized_Variational_AutoEncoder.ipynb">Pytorch-VAE-tutorial/02_Vector_Quantized_Variational_AutoEncoder.ipynb at master · Jackson-Kang/Pytorch-VAE-tutorial (github.com)</a></li><li><a href="https://github.com/zalandoresearch/pytorch-vq-vae/blob/master/vq-vae.ipynb">pytorch-vq-vae/vq-vae.ipynb at master · zalandoresearch/pytorch-vq-vae (github.com)</a></li></ul><h3 id="Generating-Diverse-High-Fidelity-Images-with-VQ-VAE-2"><a href="#Generating-Diverse-High-Fidelity-Images-with-VQ-VAE-2" class="headerlink" title="Generating Diverse High-Fidelity Images with VQ-VAE-2"></a>Generating Diverse High-Fidelity Images with VQ-VAE-2</h3><p><img data-src="https://s2.loli.net/2024/10/08/mZbQlPEJiKeTztn.png" alt="image-20241008113944530"></p><h3 id="Taming-Transformers-for-High-Resolution-Image-Synthesis"><a href="#Taming-Transformers-for-High-Resolution-Image-Synthesis" class="headerlink" title="Taming Transformers for High-Resolution Image Synthesis"></a>Taming Transformers for High-Resolution Image Synthesis</h3><p><a href="https://arxiv.org/pdf/2012.09841">2012.09841 (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/24/eyoQUhlq24Ynxru.png" alt="image-20240924210104616"></p><p>为了学习序列数据上的长程交互,Transformer在各种各样的任务上不断地展示出最先进的结果.与卷积神经网络不同的是,它们不包含优先考虑局部交互的归纳偏差.这使得它们具有表达能力,<strong>但对于长序列,如高分辨率图像,在计算上也是不可行的.本文展示了如何将CNN的感应偏置的有效性与transformer的表达能力相结合,使其能够建模,从而合成高分辨率图像</strong></p><p>复杂度不是建立在单个像素上,而是需要一种方法,使用学习表示的离散码本,使得任何图像x∈R^H×W×3^都可以由码本项的空间集合z~q~∈R^h×w×nz^表示,其中nz是中间变量的维数</p><h4 id="学习高效codebook"><a href="#学习高效codebook" class="headerlink" title="学习高效codebook"></a>学习高效codebook</h4><p>首先学习一个由编码器E和解码器G组成的卷积模型,使得它们一起从一个学习的离散codebook $\mathcal{Z}={z<em>k}</em>{k=1}^K\subset\mathbb{R}^{n_z}$中学习用码表示图像,获得</p><script type="math/tex; mode=display">z_{\mathbf{q}}=\mathbf{q}(\hat{z}):=\left(\underset{z_k\in\mathcal{Z}}{\operatorname*{\arg\min}}\|\hat{z}_{ij}-z_k\|\right)\in\mathbb{R}^{h\times w\times n_z}</script><script type="math/tex; mode=display">\hat{x}=G(z_\mathbf{q})=G\left(\mathbf{q}(E(x))\right)</script><p>利用编码( z = E(x)∈R^h×w×nz^ )和每个空间码( z~ij~^^^∈R^nz^ )在其最近的codebook项z~k~上的后续逐元素量化q ( · )得到zq</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}_{\mathrm{VQ}}(E,G,\mathcal{Z})&=\|x-\hat{x}\|^{2}+\|\mathrm{sg}[E(x)]-z_{\mathbf{q}}\|_{2}^{2}\\&+\|\mathrm{sg}[z_{\mathbf{q}}]-E(x)\|_{2}^{2}.\end{aligned}</script><p>使用Transformer将图像表示为潜在图像成分上的分布</p><h4 id="生成视觉丰富的codebook"><a href="#生成视觉丰富的codebook" class="headerlink" title="生成视觉丰富的codebook"></a>生成视觉丰富的codebook</h4><script type="math/tex; mode=display">\mathcal{L}_\mathrm{GAN}(\{E,G,\mathcal{Z}\},D)=[\log D(x)+\log(1-D(\hat{x}))]</script><script type="math/tex; mode=display">\begin{aligned}\mathcal{Q}^{*}=\arg\min_{E,G,\mathcal{Z}}\max_{D}\mathbb{E}_{x\sim p(x)}\Big[\mathcal{L}_{\mathrm{VQ}}(E,G,\mathcal{Z})\\+\lambda\mathcal{L}_{\mathrm{GAN}}(\{E,G,\mathcal{Z}\},D)\Big]\end{aligned}</script><p>$\lambda$设置取</p><script type="math/tex; mode=display">\lambda=\frac{\nabla_{G_L}[\mathcal{L}_{\mathrm{rec}}]}{\nabla_{G_L}[\mathcal{L}_{\mathrm{GAN}}]+\delta}</script><p>∂~GL~ [ · ]表示其梯度也就是在decoder最后一层L的梯度</p><h4 id="使用transformers学习图像生成"><a href="#使用transformers学习图像生成" class="headerlink" title="使用transformers学习图像生成"></a>使用transformers学习图像生成</h4><p>在E和G可用的情况下可以根据它们编码的codebook索引来表示图像.图像x的量化编码是由z~q~ = q ( E ( x ) )∈R^h×w×nz^给出的,并且等价于一个序列从码本中得到的索引$s\in{0,\ldots,|\mathcal{Z}|-1}^{n\times w}$,它是由码本Z中的索引替换每个码得到的</p><p>通过将序列s的索引映射回其对应的码本项,z~q~ = ( z~sij~ )很容易恢复并解码成图像(x = G(z~q~ ) ).</p><p>在s中选择一些指标的排序后图像生成可以表示为自回归下一指标预测：给定指标s &lt; i,转换器学习预测可能的下一指标的分布,即p(s~i~ | s &lt; i)</p><script type="math/tex; mode=display">\mathcal{L}_{\text{Transformer}}=\mathbb{E}_{x\sim p(x)}\left[-\log p(s)\right]</script><h4 id="约束的图像生成"><a href="#约束的图像生成" class="headerlink" title="约束的图像生成"></a>约束的图像生成</h4><p>在许多图像合成任务中,用户需要通过提供额外的信息来控制生成过程,从而合成一个示例.这种信息,我们称之为c,可以是描述整体图像类别的单个标签,也可以是另一幅图像本身.然后任务是学习给定这个信息c的序列的似然</p><script type="math/tex; mode=display">p(s|c)=\prod_ip(s_i|s_{<i},c)</script><h4 id="生成高分辨率图片"><a href="#生成高分辨率图片" class="headerlink" title="生成高分辨率图片"></a>生成高分辨率图片</h4><p>为了生成百万像素级别的图像,我们必须在训练过程中对图像块和裁剪图像进行处理,将s的长度限制在最大可行尺寸.</p><p>为了对图像进行采样使用滑动窗口方式的transformers</p><p><img data-src="https://s2.loli.net/2024/09/24/fPyLMHekCdGRWrT.png" alt="image-20240924225113569"></p><p><a href="https://github.com/Shubhamai/pytorch-vqgan">Shubhamai/pytorch-vqgan: This repo contains the implementation of VQGAN, Taming Transformers for High-Resolution Image Synthesis in PyTorch from scratch. I have added support for custom datasets, testings, experiment tracking etc. (github.com)</a></p><h2 id="UDA"><a href="#UDA" class="headerlink" title="UDA"></a>UDA</h2><h3 id="Unsupervised-Domain-Adaptation-by-Backpropagation"><a href="#Unsupervised-Domain-Adaptation-by-Backpropagation" class="headerlink" title="Unsupervised Domain Adaptation by Backpropagation"></a>Unsupervised Domain Adaptation by Backpropagation</h3><p><a href="https://arxiv.org/abs/1409.7495">1409.7495] Unsupervised Domain Adaptation by Backpropagation (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/24/l5AuBIpzqbGL2WO.png" alt="image-20240924230029897"></p><h3 id="CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation"></a>CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation</h3><p><a href="https://arxiv.org/abs/2109.06165">2109.06165] CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/25/dPITi2QMRE8u4Z3.png" alt="image-20240925162052101"></p><p>它由3个权重共享的transformer组成,通过使用two-way center-aware labeling method方法选择成对输入.</p><p>源分支( HS )和目标分支( HT )采用交叉熵,源-目标分支( HS + T )和HT之间采用蒸馏损失</p><h3 id="TVT-Transferable-Vision-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#TVT-Transferable-Vision-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation"></a>TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation</h3><p><a href="https://openaccess.thecvf.com/content/WACV2023/papers/Yang_TVT_Transferable_Vision_Transformer_for_Unsupervised_Domain_Adaptation_WACV_2023_paper.pdf">TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation (thecvf.com)</a></p><p>随着近年来Vision Transformer在视觉任务中的应用呈指数增长,然而,ViT在适应跨领域知识方面的能力在文献中仍未被探索.为了填补这一空白,本文首先全面考察了ViT在多种域适应任务上的表现.令人惊讶的是,ViT表现出优越的泛化能力,而通过结合对抗自适应可以进一步提高性能</p><p>尽管如此,直接使用基于CNNs的适应策略并没有利用ViT在知识转移中发挥重要作用的内在优势(例如,注意力机制和序列图像表示).为了弥补这一缺陷,我们提出了一个统一的框架,即可迁移视觉转换器( Transferable Vision Transformer,TVT ),以充分利用视觉里程计的可迁移性进行领域自适应.</p><p><img data-src="https://s2.loli.net/2024/09/25/bVSItlqa89kWpmj.png" alt="image-20240925162302199"></p><p>与ViT一样,源图像和目标图像都被分割成固定大小的图像块,然后线性映射并嵌入位置信息.生成的补丁送入变压器编码器,最后一层由可转让性适配模块( TAM )替换.特征学习、对抗域适应和分类由ViT-akin骨干、两个域判别器(在path-level和global-level上)、判别聚类模块( Discriminative Clustering Module,DCM )和基于MLP的分类器完成</p><h2 id="Variant-Transformer"><a href="#Variant-Transformer" class="headerlink" title="Variant Transformer"></a>Variant Transformer</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;传统深度学习,或者说在llm之前的深度学习,现在看来,还是有很多trick以及各种模块”缝合”的内容,这部分有很多提出来的方法其实都有一些共通点的,这里简单回顾总结一下.&lt;br&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>完整的C++项目构建注意事项</title>
    <link href="https://www.sekyoro.top/2024/09/16/%E5%AE%8C%E6%95%B4%E7%9A%84C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://www.sekyoro.top/2024/09/16/%E5%AE%8C%E6%95%B4%E7%9A%84C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2024-09-16T09:27:04.000Z</published>
    <updated>2024-09-18T15:31:47.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近常常使用cmake构建c++项目有感,从创建项目到打包发布总结一下需要注意的事情.<br><span id="more"></span></p><h2 id="项目组织方式"><a href="#项目组织方式" class="headerlink" title="项目组织方式"></a>项目组织方式</h2><p>具体的项目组织方式因人而异,这里推荐一种,在src目录中创建模块目录,再在include目录中常见对应的同名目录包含头文件,可执行程序的源代码或者最终生成库的源代码可以放在app目录中.</p><p>比如我看的一个项目组织如图</p><ol><li>在src目录中包括demo,view,assignment三个项目,对应include目录相同,或者在生成程序的目录中包含头文件而不另外放include中.</li></ol><p><img data-src="https://s2.loli.net/2024/09/16/ctGKixOyJs19qo6.png" alt="image-20240916205927734"></p><ol><li>此外也有src目录中放所有的源代码文件,include目录分别放每个模块对应的头文件,相对来说更方便.</li></ol><p>针对第一种组织方式,cmake会在src目录添加模块</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(view)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(demo)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(assignments)</span><br></pre></td></tr></table></figure><p>每个模块再单独写cmake,甚至可以单独写project,这样方便模块化,可以看到下面利用不同的<code>$&#123;PROJECT_NAME&#125;</code>设置库生成位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(demo_hello_world)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/demo_hello_world.cpp&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES </span><br><span class="line">  DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;BINARY_DIR&#125;&quot;</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC view) </span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/demo.cpp&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/window_demo.cpp&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/window_demo.h&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES </span><br><span class="line">  DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;BINARY_DIR&#125;&quot;</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC view) </span><br></pre></td></tr></table></figure><p>比较来看,如果给src目录中放所有的cpp源文件,那不好给模块分离,因为一个项目中一般包括一个生成可执行程序或最终库的源代码,一起一堆供这个目标依赖的模块,这些模块如果能单独提出来更好,也就是说这些模板的cpp代码如果放在分别的模块目录下虽然更麻烦但更好. 此外将main程序放在app目录中也更加清晰.</p><h2 id="依赖图与文档生成"><a href="#依赖图与文档生成" class="headerlink" title="依赖图与文档生成"></a>依赖图与文档生成</h2><h3 id="查看目标的依赖"><a href="#查看目标的依赖" class="headerlink" title="查看目标的依赖"></a>查看目标的依赖</h3><p>下载graphviz</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake .. --graphviz=graph.dot &amp;&amp; dot -Tpng graph.dot -o graphImage.png</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/17/z7DmyW4sqKfaMFg.png" alt="graphImage"></p><h3 id="使用Doxygen生成文档"><a href="#使用Doxygen生成文档" class="headerlink" title="使用Doxygen生成文档"></a>使用Doxygen生成文档</h3><p>需要按照规定格式撰写注释,根据注释生成文档<a href="https://www.doxygen.nl/manual/docblocks.html">Doxygen: Documenting the code</a>. </p><p>doxygen支持许多格式注释,下面列举三种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Brief description which ends at this dot. Details follow</span></span><br><span class="line"><span class="comment"> *  here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*! \brief Brief description.</span></span><br><span class="line"><span class="comment"> *         Brief description continued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Detailed description starts here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> ... text ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>注释</th><th>介绍</th></tr></thead><tbody><tr><td>@file</td><td>文件说明</td></tr><tr><td>@author</td><td>作者的信息</td></tr><tr><td>@brief</td><td>用于class 或function的批注中，后面为class 或function的简易说明</td></tr><tr><td>@param</td><td>参数介绍</td></tr><tr><td>@return</td><td>函数传回值的说明</td></tr></tbody></table></div><blockquote><p>Doxygen 还需要一个 Doxyfile，其包含文档生成的所有参数，比如输出格式、排除的文件模式、 项目名称等。因为配置参数太多，开始配置 Doxygen 可能会让人望而生畏，但 CMake 可以自动生 成 Doxyfile。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doxygen -g <span class="comment"># 生成doxyfile</span></span><br></pre></td></tr></table></figure><p>配置doxygenfile然后运行<code>doxygen</code>生成.</p><p>当然更好的方式是结合cmake,首先找到doxygen程序,然后设置需要的选项<a href="https://www.doxygen.nl/manual/config.html#cfg_recursive">Doxygen: Configuration</a>,最后生成文旦. 可以使用<code>add_custom_target</code>或者<code>doxygen_add_docs(推荐)</code><a href="https://cmake.org/cmake/help/latest/module/FindDoxygen.html">FindDoxygen — CMake 3.30.3 Documentation</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Doxygen)</span></span></span><br><span class="line"><span class="keyword">if</span> (DOXYGEN_FOUND)</span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_OUTPUT_DIRECTORY<span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/docs&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_GENERATE_HTML YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_GENERATE_MAN YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_MARKDOWN_SUPPORT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_AUTOLINK_SUPPORT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_HAVE_DOT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_COLLABORATION_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_CLASS_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_UML_LOOK YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_DOT_UML_DETAILS YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_DOT_WRAP_THRESHOLD <span class="number">100</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_CALL_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_QUIET YES)</span></span></span><br><span class="line"><span class="number">#add</span>_custom_target(docs  $&#123;DOXYGEN_EXECUTABLE&#125; WORKING_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/docs))</span><br><span class="line">doxygen_add_docs(</span><br><span class="line">docs</span><br><span class="line"><span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;</span></span><br><span class="line">ALL</span><br><span class="line">COMMENT <span class="string">&quot;Generating documentation for myproject&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doxygen_add_docs(targetName</span><br><span class="line"><span class="string">    [filesOrDirs...]</span></span><br><span class="line"><span class="string">    [ALL]</span></span><br><span class="line"><span class="string">    [USE_STAMP_FILE]</span></span><br><span class="line"><span class="string">    [WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="string">    [COMMENT comment]</span></span><br><span class="line"><span class="string">    [CONFIG_FILE filename]</span>)</span><br></pre></td></tr></table></figure><p>第一个参数 targetName 是文档目标的名称,该函数将生成一个名为 targetName 的自定义目 标。这个目标将触发 Doxygen,并在构建时使用代码创建文档。</p><p>filesOrDirs包含想要从文档生成的代码的文件或目录的列表。</p><p>ALL 参数用于使 CMake 的 ALL 元目标依赖于 doxygen_add_docs(…) 创建的文档目标，因此在构建 ALL 元目标时自动生成文档。</p><p>WORKING_DIRECTORY默认是 <code>CMAKE_CURRENT_SOURCE_DIR</code></p><h2 id="代码检查和格式化工具"><a href="#代码检查和格式化工具" class="headerlink" title="代码检查和格式化工具"></a>代码检查和格式化工具</h2><p>这部分工作其实完全可以交由IDE提供,不需要在cmake build时使用的,但为了保持兼容,这里简略写一点</p><p>可以考虑使用<code>clang-tidy</code>和<code>clang-format</code>工具,在cmake文件中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE ALL_SOURCE_FILES</span><br><span class="line">    *.c *.h *.cpp *.hpp *.cxx *.hxx *.cc *.hh *.cppm *.ipp *.ixx)</span><br><span class="line"><span class="keyword">add_custom_target</span>(format</span><br><span class="line">    <span class="keyword">COMMAND</span> clang-format</span><br><span class="line">    -i</span><br><span class="line">    <span class="variable">$&#123;ALL_SOURCE_FILES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于<code>clang-tidy</code>完全可以在<code>.clang-tidy</code>文件中设置并通过clangd进行检查<a href="https://discourse.llvm.org/t/enabling-clang-tidy-checks-in-clangd/4906/2">Enabling clang-tidy checks in clangd - Clang Frontend / clangd - LLVM Discussion Forums</a></p><p><a href="https://clangd.llvm.org/config.html#clangtidy">Configuration (llvm.org)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .clangd</span><br><span class="line">Diagnostics:</span><br><span class="line">  ClangTidy:</span><br><span class="line">    CheckOptions:</span><br><span class="line">      readability-identifier-naming.VariableCase: CamelCase</span><br></pre></td></tr></table></figure><p>此外还可以设置编译器编译链接选项检查内存和初始化等错误</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (add_sanitier <span class="keyword">target</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Adding sanitizer to target $&#123;target&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;CLANG&quot;</span> <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(<span class="string">&quot;-fno-omit-frame-pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">add_link_options</span>(<span class="string">&quot;-fno-omit-frame-pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=address)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=address)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=undefined)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=undefined)</span><br><span class="line">  <span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE /fsanitize=address)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;Sanitier is not supported for $&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>除此之外,可以使用<code>valgrind</code>等工具动态debug查找内存问题.</p><h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><h3 id="CTest"><a href="#CTest" class="headerlink" title="CTest"></a>CTest</h3><p><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Testing With CMake and CTest.html">Testing With CMake and CTest — Mastering CMake</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">add_executable</span>(TestInstantiator TestInstantiator.cxx)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestInstantiator vtkCommon)</span><br><span class="line"><span class="keyword">add_test</span>(NAME TestInstantiator</span><br><span class="line">         <span class="keyword">COMMAND</span> TestInstantiator)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>CTest 模块通常应该只包含在项目的顶层 CMakeLists.txt 中。自从 CMake 版本 3.21 以 来，PROJECT_IS_TOP_LEVEL 可以用来测试当前的 CMakeLists.txt 是否为顶层文件。</p><p>对于项目的顶层目录和使用 ExternalProject 添加的项目顶层目录，此变量为 True。对于使用 add_subdirectory 或 FetchContent 添加的目录，该值为 False</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(CMakeBestPractice)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_test(NAME &lt;name&gt; COMMAND &lt;command&gt; <span class="meta">[&lt;arg&gt;...]</span></span><br><span class="line"><span class="meta">[CONFIGURATIONS &lt;config&gt;...]</span></span><br><span class="line"><span class="meta">[WORKING_DIRECTORY &lt;dir&gt;]</span></span><br><span class="line">[COMMAND_EXPAND_LISTS])</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctest --test-dir &lt;build_dir&gt;</span><br><span class="line">cmake --build &lt;build_dir&gt; --target <span class="built_in">test</span> <span class="comment"># 注意这里目标就是test,而不是add_test中添加的NAME</span></span><br><span class="line">ctest --build-and-test &lt;source_dir&gt; &lt;build_dir&gt;</span><br></pre></td></tr></table></figure><p>可以设置ctest多个lable,然后通过过滤查看对应结果</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_1 <span class="keyword">COMMAND</span> someTest)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test PROPERTIES LABELS <span class="string">&quot;example&quot;</span>)</span><br><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_2 <span class="keyword">COMMAND</span> anotherTest)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test_2 PROPERTIES LABELS <span class="string">&quot;will_fail&quot;</span> )</span><br><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_3 <span class="keyword">COMMAND</span> YetAnotherText)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test_3 PROPERTIES LABELS <span class="string">&quot;example;will_fail&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest -L <span class="string">&quot;example|will_fail&quot;</span></span><br></pre></td></tr></table></figure><p><code>-L</code>进行过滤</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest -I [Start,End,Stride,<span class="built_in">test</span><span class="comment">#,test#,...|Test file] </span></span><br></pre></td></tr></table></figure><p>通过 Start、End 和 Stride，可以指定要执行的测试的范围。这三个数字是与显式测试数字 test# 相结合的范围，或传递包含参数的文件</p><h4 id="处理大量测试"><a href="#处理大量测试" class="headerlink" title="处理大量测试"></a>处理大量测试</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create_test_sourcelist</span> (SourceListName</span><br><span class="line">                        DriverName</span><br><span class="line">                        test1 test2 test3</span><br><span class="line">                        EXTRA_INCLUDE <span class="keyword">include</span>.h</span><br><span class="line">                        <span class="keyword">FUNCTION</span> <span class="keyword">function</span></span><br><span class="line">                        )</span><br></pre></td></tr></table></figure><blockquote><p>注意ctest并不提供方便测试的方法,可以使用第三方库提供的REQUIRE等方法</p></blockquote><p>使用<code>include(Ctest)</code>和<code>add_test</code>可使得可以方便使用<code>ctest</code>命令进行测试</p><p>比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; ctest</span><br></pre></td></tr></table></figure><h3 id="使用Catch2"><a href="#使用Catch2" class="headerlink" title="使用Catch2"></a>使用Catch2</h3><p><a href="https://github.com/catchorg/Catch2">catchorg/Catch2: A modern, C++-native, test framework for unit-tests, TDD and BDD - using C++14, C++17 and later (C++11 support is in v2.x branch, and C++03 on the Catch1.x branch) (github.com)</a></p><p>创建tests目录,编写cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">ENABLE_TESTING</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(TEST_MAIN <span class="string">&quot;unit_tests&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(TEST_SOURCES main.cpp)</span><br><span class="line">    <span class="keyword">set</span>(TEST_INCLUDES <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> PUBLIC <span class="variable">$&#123;TEST_INCLUDES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> PUBLIC <span class="variable">$&#123;LIBRARY_NAME&#125;</span> Catch2::Catch2WithMain)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>自动发现测试</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(baz LANGUAGES CXX VERSION <span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Catch2 REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(tests <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(tests PRIVATE Catch2::Catch2)</span><br><span class="line"><span class="comment"># list(APPEND CMAKE_MODULE_PATH $&#123;catch2_SOURCE_DIR&#125;/extras) # use FetchContent</span></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">include</span>(Catch)</span><br><span class="line">catch_discover_tests(tests)</span><br></pre></td></tr></table></figure><h3 id="使用GoogleTest"><a href="#使用GoogleTest" class="headerlink" title="使用GoogleTest"></a>使用GoogleTest</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GoogleTest requires at least C++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_test hello_test.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_test GTest::gtest_main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(hello_test) <span class="comment"># 自动发现测试</span></span><br></pre></td></tr></table></figure><h3 id="代码覆盖检查"><a href="#代码覆盖检查" class="headerlink" title="代码覆盖检查"></a>代码覆盖检查</h3><p>检查测试了哪些代码并生成覆盖率报告,使用Gcov生成覆盖率信息,使用覆盖分析程序,如 Gcovr 或 LCOVn分析覆盖文件并生成报告</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CTest+Catch2即可</p><h2 id="第三方库管理"><a href="#第三方库管理" class="headerlink" title="第三方库管理"></a>第三方库管理</h2><h3 id="使用FetchContent下载库"><a href="#使用FetchContent下载库" class="headerlink" title="使用FetchContent下载库"></a>使用FetchContent下载库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(nlohmann_json </span><br><span class="line">GIT_REPOSITORY https://github.com/nlohmann/json</span><br><span class="line">GIT_TAG v3.<span class="number">11.2</span></span><br><span class="line">GIT_SHALLOW <span class="keyword">TRUE</span>)</span><br><span class="line">FetchContent_Makeavailable(nlohmann_json)</span><br></pre></td></tr></table></figure><p>需要项目是cmake项目</p><h3 id="使用vcpkg等包管理工具下载库"><a href="#使用vcpkg等包管理工具下载库" class="headerlink" title="使用vcpkg等包管理工具下载库"></a>使用vcpkg等包管理工具下载库</h3><p><a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">包管理器与xmake介绍</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-preset&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;toolchainFile&quot;</span>: <span class="string">&quot;$env&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">find_package</span>(ftxui REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE ftxui::dom ftxui::screen ftxui::component)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br><span class="line">cmake --preset my-preset</span><br><span class="line">cmake --build build</span><br><span class="line">./build/my-app</span><br></pre></td></tr></table></figure><h3 id="使用Conan"><a href="#使用Conan" class="headerlink" title="使用Conan"></a>使用Conan</h3><p>简单介绍一下使用流程</p><p>首先定义conanfile.txt和conan profile</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[requires]</span></span><br><span class="line">zlib/<span class="number">1.2</span><span class="number">.11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[generators]</span></span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p>然后执行<code>conan insatll</code>会生成<code>conan_toolchain.cmake</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>再在cmake中使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br></pre></td></tr></table></figure><h3 id="借助git-submodule下载库"><a href="#借助git-submodule下载库" class="headerlink" title="借助git submodule下载库"></a>借助git submodule下载库</h3><p><a href="https://git.github.io/git-scm.com/docs/git-submodule/zh_HANS-CN">Git - git-submodule Documentation</a></p><p><a href="https://www.atlassian.com/git/tutorials/git-submodule">Git submodule | Atlassian</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://bitbucket.org/jaredw/awesomelibrary <span class="comment"># 添加子模块(当前新版本git也会下载对应模块)</span></span><br><span class="line">git submodule init //初始化子模块 (根据.gitmodules更新信息)</span><br><span class="line">git submodule update //更新子模块</span><br><span class="line">git submodule update --init --recursive <span class="comment"># 更新映射关系并递归下载模块</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/17/yJh84dN6IPrOjAz.png" alt="image-20240917150517478"></p><p>使用<code>git submodule add</code>之后会创建<strong>.gitmodules</strong>文件并写入相关信息,包括子模块path和url,其中path是安装路径,因此我们可以借助修改path,使得<code>git update --init</code>安装子模块时安装到3rd_party或vendor目录便于管理,比如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">&quot;glfw&quot;</span>]</span><br><span class="line">path = third_party/glfw</span><br><span class="line">url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/glfw/g</span>lfw.git</span><br></pre></td></tr></table></figure><p>修改.gitmodules 文件中对应模块的名字或者path,然后使用<code>git submodule sync</code>进行更新.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule sync --recursive</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>此外还会在<code>.git/config</code>和<code>.git/modules</code>中添加子模块信息</p><p><code>update</code>的作用是根据项目的配置信息,拉取更新子模块中的代码,也可以使用<code>git clone --recurse-submodules</code>直接下载子模块</p><p><strong>卸载子模块</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule deinit project-sub <span class="comment"># 在.gitmodules中对应的模块名 </span></span><br><span class="line">git rm project-sub <span class="comment"># 删除模块目录与.git/config,.git/modules信息</span></span><br></pre></td></tr></table></figure><p>总结来说,可以使用第三方管理工具,下载链接非常方便. 对于自己写的一些库或者没有cmake的项目可以使用vendor/3rd_party方式,放在一个单独目录,如果是源代码,添加源文件和头文件,生成库,cmake如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glad</span></span><br><span class="line"><span class="keyword">set</span>(glad_SOURCE_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/glad&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;glad_SOURCE_DIR&#125;/src/*.c&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_library</span>(glad <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(glad</span><br><span class="line">  PUBLIC <span class="string">&quot;$&#123;glad_SOURCE_DIR&#125;/include&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES FOLDER <span class="string">&quot;third_party&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果是已经编译好的库,使用<code>add_library(xxx SHARED IMPORTED)</code>并设置库文件位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(glad SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES IMPORTED_LOCATION <span class="string">&quot;/path/to/glad/library&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES IMPORTED_IMPLIB <span class="string">&quot;/path/to/glad/library&quot;</span>) <span class="comment"># 针对windows</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES FOLDER <span class="string">&quot;third_party&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>IMPORTED_IMPLIB:用于指定导入库的导入库文件（import library file）。在 Windows 上，通常用于 .lib 文件。这个属性通常用于静态链接的导入库</p></blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>vcpkg,conan的逻辑是使用一个文件声明项目信息和依赖,然后在cmake中添加toolchainfile用于下载对应的包,而CPM和FetchContent直接在cmake中声明需要添加的包.</p><p>优先使用第三方包管理工具,因为相比<code>FetchContent</code>提供更多功能,如果第三方库不是cmake项目,使用<code>git submodule</code>方式,下载到某个文件夹编译源代码、链接库</p><h2 id="项目打包、安装与分发"><a href="#项目打包、安装与分发" class="headerlink" title="项目打包、安装与分发"></a>项目打包、安装与分发</h2><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><h4 id="安装target"><a href="#安装target" class="headerlink" title="安装target"></a>安装target</h4><p>具体来说install(TARGETS …)会安装生成的的东西,不会安装头文件或者项目中的json、txt等读取文件.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS &lt;target&gt;... [...])</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/mkgtxHpDOQMJfuh.png" alt="image-20240918153002484"></p><p>这里最需要注意的就是动态库不包括windows上的dll.</p><p>默认安装路径如下,安装目录在Unix上usr/local,Windows是C:/program files,前缀通过<code>cmake  --prefix</code>或<code>CMAKE_INSTALL_PREFIX</code>指定</p><p><img data-src="https://s2.loli.net/2024/09/18/15lWXcPTQeqg37F.png" alt="image-20240918160115134"></p><p>install(TARGETS…) 如果 包 含 EXPORT 参 数, 用 于 从 给 定 的 install(…) 目 标 创 建 一 个 导 出 名 称,可以使用此导出名称导出这些目标</p><h4 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h4><blockquote><p>安装的东西并不总是目标输出构件的一部分。它们可能是目标的运行时依赖项，例如图片、源文件、脚本和配置文件</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span> (</span><br><span class="line">DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>install(FILES…) 指令接受一个或多个文件作为参数，TYPE 和DESTINATION 用于确定指定文件的目标目录。TYPE 用于指示哪些文件将使用该文件类型的默认 路径作为安装目录</p><p><img data-src="https://s2.loli.net/2024/09/18/WBoifXtdSRDcejq.png" alt="image-20240918155717561"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/greeter_content&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">install</span>(PROGRAMS <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/greeter.py&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span> RENAME chapter4_greeter)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dir1 dir2 dir3 TYPE LOCALSTATE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY dir2 DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_</span></span><br><span class="line"><span class="variable">LOCALSTATEDIR&#125;</span> FILES_MATCHING PATTERN <span class="string">&quot;*.hpp&quot;</span></span><br><span class="line">EXCLUDE PATTERN <span class="string">&quot;*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以指定匹配文件和排除文件模式.</p><h4 id="config-file"><a href="#config-file" class="headerlink" title="config-file"></a>config-file</h4><p>当别人安装了你的库,也要方便使用.为了让其他用户使用<code>find_package</code>找到我们的包,需要config-file.</p><p>包配置文件<code>Config.cmake</code>设置如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs) <span class="comment"># 便于获取安装路径变量</span></span><br><span class="line"><span class="keyword">set</span>(FOO_INCLUDE_DIRS <span class="variable">$&#123;PREFIX&#125;</span>/<span class="keyword">include</span>/foo-<span class="number">1.2</span>)</span><br><span class="line"><span class="keyword">set</span>(FOO_LIBRARIES <span class="variable">$&#123;PREFIX&#125;</span>/lib/foo-<span class="number">1.2</span>/libfoo.a)</span><br></pre></td></tr></table></figure><p>搜索包时,find_package(…) 会查找 /cmake 目录,所以包配置文件放在/cmake中.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top level cmake</span></span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(project_INSTALL_CMAKEDIR cmake CACHE PATH</span><br><span class="line"><span class="string">&quot;Installation directory for config-file package cmake files&quot;</span>) <span class="comment"># 于设置 config-file 打包配置文件的安装目录</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(ch4_ex05_lib PUBLIC</span><br><span class="line">$&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_features</span>(ch4_ex05_lib PUBLIC cxx_std_11)</span><br></pre></td></tr></table></figure><p>使用$<BUILD_INTERFACE>设置头文件目录,因为在安装时</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS ex05_lib</span><br><span class="line"><span class="keyword">EXPORT</span> cex05_lib_export</span><br><span class="line">INCLUDES DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span> (</span><br><span class="line">DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/</span><br><span class="line">DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用<code>install(EXPORT)</code>得到xxConfig.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> ex05_lib_export</span><br><span class="line"><span class="keyword">FILE</span> ex05_lib-config.cmake</span><br><span class="line">NAMESPACE ex05_lib::</span><br><span class="line">DESTINATION <span class="variable">$&#123;project_INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要实现对 find_package(…) 的完全支持，还需要获取xxxConfig-version.cmake 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include(CMakePackageConfigHelpers)</span><br><span class="line">write_basic_package_version_file(</span><br><span class="line"><span class="string">&quot;ex05_lib-config-version.cmake&quot;</span></span><br><span class="line"><span class="comment"># Package compatibility strategy. SameMajorVersion is</span></span><br><span class="line">essentially <span class="string">&#x27;semantic versioning&#x27;</span>.</span><br><span class="line">COMPATIBILITY SameMajorVersion <span class="comment"># 与主版本号相同即可</span></span><br><span class="line">)</span><br><span class="line">install(FILES</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/ex05_lib-config-version.</span></span><br><span class="line"><span class="string">cmake&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;<span class="variable">$&#123;project_INSTALL_CMAKEDIR&#125;</span>&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake –S . -B ./build</span><br><span class="line">cmake --build ./build</span><br><span class="line">cmake --install ./build --prefix /3rdparty</span><br></pre></td></tr></table></figure><p>安装包并使用<code>find_package</code>使用包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The chapter-4, ex05_consumer project is</span></span><br><span class="line"><span class="string">intended to be a standalone, top-level project. Do not</span></span><br><span class="line"><span class="string">include this directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">find_package</span>(ex05_lib <span class="number">1</span> CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(ex05_consumer src/main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(ex05_consumer PRIVATE cxx_std_11)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ex05_consumer ex05_lib::ch4_ex05_</span><br><span class="line">lib)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/Fg985AeDWyStn47.png" alt="image-20240918175420391"></p><h3 id="CPack"><a href="#CPack" class="headerlink" title="CPack"></a>CPack</h3><p><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging With CPack.html">Packaging With CPack — Mastering CMake</a></p><p>cpack包含多种生成器生成包</p><p><img data-src="https://s2.loli.net/2024/09/18/xgPj8oBc7YtLTXC.png" alt="image-20240918161939375"></p><p>常用cpack变量,用于设置项目打包时的信息</p><p><img data-src="https://s2.loli.net/2024/09/18/vTwgth6iM8qGKWV.png" alt="image-20240918162023449"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(</span><br><span class="line">ch4_ex06_pack</span><br><span class="line">VERSION <span class="number">1.0</span></span><br><span class="line">DESCRIPTION <span class="string">&quot;Chapter 4 Example 06, Packaging with CPack&quot;</span></span><br><span class="line">LANGUAGES CXX)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The chapter-4, ex06_pack project is</span></span><br><span class="line"><span class="string">intended to be a standalone, top-level project.</span></span><br><span class="line"><span class="string">Do not include this directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(executable)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(library)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="string">&quot;CTT Authors&quot;</span>) <span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_GENERATOR <span class="string">&quot;DEB;RPM;TBZ2&quot;</span>) <span class="comment"># 包管理器</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_THREADS <span class="number">0</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class="string">&quot;CTT Authors&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure><p>CPACK<em>PACKAGE_NAME 和 CPACK_PACKAGE_VERSION</em>* 默认从顶层项目名称和版本中获取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake –S . -B build/</span><br></pre></td></tr></table></figure><p>项目配置后,生成CpackConfig.cmake 和 CpackConfigSource.cmake文件到build/CPack*中,使用<code>cpack</code>得到最终包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build/</span><br><span class="line">cpack --config build/CPackConfig.cmake -B build/</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/5VcBEb1fQwq7eDA.png" alt="image-20240918164647416"></p><blockquote><p>注意设置generator时,其中每个都需要符合条件. 比如nsis需要安装对应的软件,否则设置generator包括它时会直接报错</p></blockquote><h2 id="经常遗忘的指令"><a href="#经常遗忘的指令" class="headerlink" title="经常遗忘的指令"></a>经常遗忘的指令</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name <span class="comment">[ALL]</span> <span class="comment">[command1 <span class="comment">[args1...]</span>]</span></span><br><span class="line"><span class="comment">[COMMAND command2 <span class="comment">[args2...]</span> ...]</span></span><br><span class="line"><span class="comment">[DEPENDS depend depend depend ... ]</span></span><br><span class="line"><span class="comment">[BYPRODUCTS <span class="comment">[files...]</span>]</span></span><br><span class="line"><span class="comment">[WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="comment">[COMMENT comment]</span></span><br><span class="line"><span class="comment">[JOB_POOL job_pool]</span></span><br><span class="line"><span class="comment">[VERBATIM]</span> <span class="comment">[USES_TERMINAL]</span></span><br><span class="line"><span class="comment">[COMMAND_EXPAND_LISTS]</span></span><br><span class="line"><span class="comment">[SOURCES src1 <span class="comment">[src2...]</span>]</span>)</span><br></pre></td></tr></table></figure><p>add_custom_target 的核心是通过 COMMAND 选项传递的命令列表。虽然第一个命令可 以不带这个选项,但最好在 add_custom_target 中添加 COMMAND 选项。</p><p><strong>默认情况下,定制目标只在显式请求时执行,除非指定了 ALL 选项</strong>。</p><p>自定义目标总认为是过时的，因此总是运行指 定的命令，而不管是否会反复产生相同的结果。</p><p>使用 DEPENDS 关键字，可以使定制目标依赖于使用 add_custom_command 或其他目标定义的定制命令的文件和输出。</p><p>要使自定义目标依赖于另 一个目标，可以使用 add_dependencies。若使用自定义目标创建文件，可以在 BYPRODUCTS 选项下列出这些文件。</p><p>列出的文件都将使用 GENERATED 属性标记，CMake 使用该属性来确定构建是否过期，并找出需要清理的文件，但使用 add_custom_command 创建文件的任务可能更适 合。</p><p> 通常，命令在当前二进制目录中执行，该目录在 CMAKE_CURRENT_BINARY_DIRECTORY 缓存变量中。若需要修改，这可以<strong>通过 WORKING_DIRECTORY 选项来更改</strong>。该选项可以是绝对 路径，也可以是相对路径 (当前二进制目录的相对路径)。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET &lt;target&gt;</span><br><span class="line">PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">COMMAND command1 <span class="comment">[ARGS]</span> <span class="comment">[args1...]</span></span><br><span class="line"><span class="comment">[COMMAND command2 <span class="comment">[ARGS]</span> <span class="comment">[args2...]</span> ...]</span></span><br><span class="line"><span class="comment">[BYPRODUCTS <span class="comment">[files...]</span>]</span></span><br><span class="line"><span class="comment">[WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="comment">[COMMENT comment]</span></span><br><span class="line"><span class="comment">[VERBATIM]</span> <span class="comment">[USES_TERMINAL]</span></span><br><span class="line"><span class="comment">[COMMAND_EXPAND_LISTS]</span>)</span><br></pre></td></tr></table></figure><p>可以在以下时段将命令连接到构建中: </p><p>• PRE_BUILD: 在 Visual Studio 中，此命令在执行其他构建步骤之前执行。当使用其他生成器 时，会在 PRE_LINK 命令之前运行。</p><p> • PRE_LINK: 此命令将在编译源代码之后运行，在可执行文件或存档工具链接到静态库之前运行。</p><p> • <strong>POS_BUILD: 这将在执行所有其他构建规则后运行该命令</strong>。 执行自定义步骤最常见的方法是使用 POST_BUILD; 其他两个选项很少使用，要么是因为支持 有限，要么是因为它们既不能影响链接，也不能影响构建。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_parse_arguments</span>(&lt;prefix&gt; &lt;options&gt; &lt;one_value_keywords&gt;</span><br><span class="line">                      &lt;multi_value_keywords&gt; &lt;args&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_parse_arguments</span>(PARSE_ARGV &lt;N&gt; &lt;prefix&gt; &lt;options&gt;</span><br><span class="line">                      &lt;one_value_keywords&gt; &lt;multi_value_keywords&gt;)</span><br></pre></td></tr></table></figure><p><a href="https://cmake.org/cmake/help/latest/command/cmake_parse_arguments.html">cmake_parse_arguments — CMake 3.30.3 Documentation</a></p><h3 id="Great-resoureces-for-learning"><a href="#Great-resoureces-for-learning" class="headerlink" title="Great resoureces for learning"></a>Great resoureces for learning</h3><ol><li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake (github.com)</a></li><li><a href="https://github.com/franneck94/CppProjectTemplate">franneck94/CppProjectTemplate: C++ project template with unit-tests, documentation, ci-testing and workflows. (github.com)</a></li></ol><p>书籍推荐<a href="https://book.douban.com/subject/35793146/">CMake Best Practices (豆瓣) (douban.com)</a>和<a href="https://book.douban.com/subject/34936765/">Professional CMake (豆瓣) (douban.com)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近常常使用cmake构建c++项目有感,从创建项目到打包发布总结一下需要注意的事情.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="cmake" scheme="https://www.sekyoro.top/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>build a mini project starter in Rust</title>
    <link href="https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/"/>
    <id>https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/</id>
    <published>2024-09-15T01:45:08.000Z</published>
    <updated>2024-09-15T15:52:27.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator<br><span id="more"></span></p><p>项目源码:<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/mini-project-starter">build-my-own-x/mini-project-starter at main · drowning-in-codes/build-my-own-x (github.com)</a></p><p>crates.io:<a href="https://crates.io/crates/mini-project-starter">mini-project-starter - crates.io: Rust Package Registry</a></p><p><img data-src="https://s2.loli.net/2024/09/15/39hKmTFezL5vJM1.png" alt="image-20240915235220102"></p><h2 id="常见的c-项目组织方式"><a href="#常见的c-项目组织方式" class="headerlink" title="常见的c++项目组织方式"></a>常见的c++项目组织方式</h2><p>项目组织方式因人而异,但一些基本点还是相同的,比如参考Rust一些模块组织方式,由于c++代码需要有头文件(不知道c++26之后的未来会不会尽可能地使用模块替代头文件这种组织方式)</p><p>由于在其他语言中,一个模块基本上就是单独一个文件,而c++中是cpp源文件和对应的头文件,这个模块最好(或者说必须)放在对应名字的目录下,比如我的项目下写了一个logger模块,它一种组织方式如下,src目录下放置需要的库,app目录下放可执行程序或者最后生成的库.相当于在src目录下放置多个模块目录,每个目录中放源文件和头文件</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\  (optional)</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>          -<span class="ruby"> main.hpp (optional)</span></span><br></pre></td></tr></table></figure><p>或者稍微改改,将模块的头文件放在include中,也就是头文件和源文件不放在同一个目录</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br></pre></td></tr></table></figure><p>此外还有一种,将所有cpp文件都放在src中,头文件放在include中,差异就是它的源文件是放在一起的,没有放在一个所谓模块目录下.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br></pre></td></tr></table></figure><p>上面几种方式其实都行,我们看看rust是怎么组织的,由于没有头文件,在src目录下有main.rs,而garden.rs是模块,garden目录下的vegetables.rs是模块的子模块.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo<span class="selector-class">.lock</span></span><br><span class="line">├── Cargo<span class="selector-class">.toml</span></span><br><span class="line">└── <span class="attribute">src</span></span><br><span class="line">    ├── garden</span><br><span class="line">    │   └── vegetables<span class="selector-class">.rs</span></span><br><span class="line">    ├── garden<span class="selector-class">.rs</span></span><br><span class="line">    └── <span class="selector-tag">main</span>.rs</span><br></pre></td></tr></table></figure><p>上面组织方式的核心差别,是针对头文件,要么在include目录下按照模块名分几个目录,而不是将头文件放在一起,要么在src目录下分多个需要的库目录,每个目录包括源文件和头文件.</p><h2 id="mini-project-starter"><a href="#mini-project-starter" class="headerlink" title="mini-project-starter"></a>mini-project-starter</h2><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><p>使用<code>Clap</code>库解析参数，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mini-project-starter new -p &lt;DIR&gt; <span class="comment"># 在一个目录下创建项目</span></span><br><span class="line">mini-project-starter init <span class="comment"># 在当前目录下初始化项目</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils;</span><br><span class="line"><span class="keyword">use</span> clap::&#123;command, Arg, Command&#125;;</span><br><span class="line"><span class="keyword">use</span> utils::&#123;init_project, new_project&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> starter_config = command!()</span><br><span class="line">        .propagate_version(<span class="literal">true</span>)</span><br><span class="line">        .subcommand_required(<span class="literal">true</span>)</span><br><span class="line">        .arg_required_else_help(<span class="literal">true</span>)</span><br><span class="line">        .subcommand(</span><br><span class="line">            Command::new(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">                .about(<span class="string">&quot;Create a new project in the specified directory&quot;</span>)</span><br><span class="line">                .arg(</span><br><span class="line">                    Arg::new(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .short(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">                        .long(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .value_name(<span class="string">&quot;DIR&quot;</span>)</span><br><span class="line">                        .value_parser(clap::builder::NonEmptyStringValueParser::new())</span><br><span class="line">                        .help(<span class="string">&quot;The root dir of the project&quot;</span>)</span><br><span class="line">                        .required(<span class="literal">true</span>),</span><br><span class="line">                ),</span><br><span class="line">        )</span><br><span class="line">        .subcommand(Command::new(<span class="string">&quot;init&quot;</span>).about(<span class="string">&quot;Init the project in the current directory&quot;</span>))</span><br><span class="line">        .get_matches();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> starter_config.subcommand() &#123;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;new&quot;</span>, sub_matches)) =&gt; &#123;</span><br><span class="line">            new_project(sub_matches.get_one::&lt;<span class="built_in">String</span>&gt;(<span class="string">&quot;project_root_dir&quot;</span>).unwrap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;init&quot;</span>, _)) =&gt; init_project(),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Please specify a subcommand&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让用户输入项目的一些信息,这些信息可以替换后面<code>CMakeLists.txt</code>中的项目信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root_dir_name = default_root_dir_name</span><br><span class="line">                .file_name()</span><br><span class="line">                .unwrap()</span><br><span class="line">                .to_str()</span><br><span class="line">                .unwrap();</span><br><span class="line">    <span class="keyword">let</span> project_name = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">r&quot;Enter your project name.(project root folder name if leave blank)&quot;</span>)</span><br><span class="line">        .with_initial_text(root_dir_name.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(root_dir_name.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目版本</span></span><br><span class="line">    <span class="keyword">let</span> project_version = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project version.(default: 0.1.0)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;0.1.0&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;0.1.0&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目描述</span></span><br><span class="line">    <span class="keyword">let</span> project_desc = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project description.(default: A new project)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;A new project&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;A new project&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择项目类型</span></span><br><span class="line">    <span class="keyword">let</span> project_types = <span class="built_in">vec!</span>[ ProjectType::Cpp];</span><br><span class="line">    <span class="keyword">let</span> project_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the peoject type&quot;</span>)</span><br><span class="line">        .items(&amp;project_types)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择生成目标类型</span></span><br><span class="line">    <span class="keyword">let</span> target_type = <span class="built_in">vec!</span>[</span><br><span class="line">        TargetType::Executable,</span><br><span class="line">        TargetType::StaticLibrary,</span><br><span class="line">        TargetType::DynamicLibrary,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> target_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the target type&quot;</span>)</span><br><span class="line">        .items(&amp;target_type)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择包管理器</span></span><br><span class="line">    <span class="keyword">let</span> package_manager_list = <span class="built_in">vec!</span>[PackageManager::VCPKG, PackageManager::CPM,PackageManager::<span class="literal">None</span>];</span><br><span class="line">    <span class="keyword">let</span> package_manager_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the package manager &quot;</span>)</span><br><span class="line">        .items(&amp;package_manager_list)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line">    <span class="keyword">let</span> package_manager = package_manager_list[package_manager_selection].clone();</span><br></pre></td></tr></table></figure><p>创建一个项目需要拷贝一些目录和文件,如果是目录注意不要重复创建,而文件可以直接truncate</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建src目录与main.cpp</span></span><br><span class="line"> <span class="keyword">match</span> fs::create_dir_all(root_dir.join(project_name).join(<span class="string">&quot;src&quot;</span>)) &#123;</span><br><span class="line">         <span class="literal">Ok</span>(_)=&gt;&#123;&#125;,</span><br><span class="line">         <span class="literal">Err</span>(e)=&gt;&#123;</span><br><span class="line">             eprintln!(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,e.kind(),e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">let</span> src_file = File::create(root_dir.join(project_name).join(<span class="string">&quot;src/main.cpp&quot;</span>)).unwrap();</span><br><span class="line">         <span class="keyword">match</span> fs::read_to_string(env::current_dir().unwrap().join(<span class="string">&quot;templates/main.cpp&quot;</span>)) &#123;</span><br><span class="line">             <span class="literal">Ok</span>(contents) =&gt; <span class="built_in">write!</span>(&amp;src_file, <span class="string">&quot;&#123;&#125;&quot;</span>, contents).unwrap(),</span><br><span class="line">             <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;Error reading file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>中,添加如下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.29</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang++.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment"># include($&#123;CMAKE_SOURCE_DIR&#125;/cmake/sanitier.cmake)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(sanitizer)</span><br><span class="line"><span class="keyword">include</span>(copy_target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(@PROJECT_NAME@ LANGUAGES C CXX VERSION @PROJECT_VERSION@ PROJECT_DESCRIPTION <span class="string">&quot;@PROJECT_DESCRIPTION@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE LIB_SOURCE  src/*.cpp src/*.c)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE HEADER  <span class="keyword">include</span>/*.h <span class="keyword">include</span>/*.hpp)</span><br><span class="line"><span class="keyword">source_group</span>(headers FILES <span class="variable">$&#123;HEADER&#125;</span>) </span><br><span class="line"><span class="keyword">add_library</span>(@PROJECT_NAME@ STATIC <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(@PROJECT_NAME@ PRIVATE <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_SANITIZER <span class="string">&quot;Enable sanitizer&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_SANITIZER)</span><br><span class="line">  add_sanitier(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_COPY_TARGET <span class="string">&quot;Enable copy target&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_COPY_TARGET)</span><br><span class="line">  copy_target(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>针对包管理器,我设置了可以使用vcpkg或者cpm,如果是cpm可以在网上下载对应cmake脚本,如果是vcpkg,在<code>CMakePresets.json</code>中添加对应toolchainfile.</p><p>最后还有测试目录,cmake脚本,scripts辅助脚本,docs文档等等,如下</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> .gitignore</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> FindSomeLib.cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> something_else.cmake</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> README.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> LICENCE.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> tests</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> testlib.cpp</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> docs</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> extern</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> googletest</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> scripts</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> helper.py</span></span><br></pre></td></tr></table></figure><h3 id="还不错的视频参考"><a href="#还不错的视频参考" class="headerlink" title="还不错的视频参考"></a>还不错的视频参考</h3><ol><li><a href="https://www.bilibili.com/video/BV1Z44y1c7UX">CMake, Tests and Tooling for C/C++ Projects</a></li><li><a href="https://www.bilibili.com/video/BV1Tr4y1Z762">Update to Modern C++</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator&lt;br&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://www.sekyoro.top/tags/Rust/"/>
    
    <category term="Cpp" scheme="https://www.sekyoro.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>xmake:另一个C++现代构建系统</title>
    <link href="https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-09-11T09:22:10.000Z</published>
    <updated>2024-09-14T10:42:43.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,</p><p>所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了<a href="https://xmake.io/#/getting_started">xmake</a>之外,还有<a href="https://mesonbuild.com/">The Meson Build system</a>，<a href="https://spack.io/about/">About Spack - Spack</a>，<a href="https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn">Bazel 简介 (google.cn)</a>等等.我选择xmake主要原因是其自带的包管理和方便的写法<br><span id="more"></span></p><p>在进一步介绍xmake之前,有必要区分构建工具和包管理工具.c++目前常用的包管理工具有vcpkg,cpm以及conan,它们都有自己的registries,类似于node的npm,cargo的crates,python的pip registries,java的maven仓库. 都是社区或官方维护的库下载点,一般来允许用户注册后上传自己的包(不过考虑到c++生态是一堆轮子哥,用第三方库的人可能没有python,js一半多).</p><h2 id="纯纯FetchContent"><a href="#纯纯FetchContent" class="headerlink" title="纯纯FetchContent"></a>纯纯FetchContent</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## from https://cmakebyexample.dev/use-library-fetchcontent/</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  cpr</span><br><span class="line">  GIT_REPOSITORY https://github.com/libcpr/cpr.git</span><br><span class="line">  <span class="comment"># https://github.com/libcpr/cpr/releases</span></span><br><span class="line">  GIT_TAG <span class="number">1.10</span>.<span class="number">4</span>)</span><br><span class="line">FetchContent_MakeAvailable(cpr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PUBLIC cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE cpr::cpr)</span><br></pre></td></tr></table></figure><p>利用cmake内置功能,下载相应库.它需要从源代码构建curl.</p><blockquote><p>FetchContent 可让您直接在 CMake 项目中包含外部项目，从而更轻松地处理依赖关系，而无需用户单独下载和构建，或依赖系统级软件包管理器。它通过自动处理下载、构建和配置这些依赖项等任务，简化了将外部代码引入项目的过程。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    my_dependency</span><br><span class="line">    GIT_REPOSITORY https://github.com/example/my_dependency.git</span><br><span class="line">    GIT_TAG v1.<span class="number">0.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_MakeAvailable(my_dependency)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use the components of &#x27;my_dependency&#x27; in your project</span></span><br></pre></td></tr></table></figure><h2 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h2><p>包仓库<a href="https://vcpkg.io/en/packages">Browse public vcpkg packages</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myModule &amp;&amp; <span class="built_in">cd</span> myModule</span><br><span class="line">vcpkg --new application <span class="comment"># 创建应用</span></span><br></pre></td></tr></table></figure><p>在目录下生成了两个文件,<code>vcpkg.json</code>和<code>vcpkg-confuguration.json</code>分别用于存依赖信息和仓库信息.初始前者为空,后者</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;default-registry&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;baseline&quot;</span>: <span class="string">&quot;9760ce6194ef51aa4faf77b6321e1280daa4545c&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;repository&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;registries&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;artifact&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;microsoft&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认的 <code>vcpkg-configuration.json</code> 文件引入了基线约束，指定了项目应使用的依赖项的最小版本,将 <code>vcpkg-configuration.json</code> 添加到代码控制中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg add port fmt</span><br></pre></td></tr></table></figure><p>添加依赖信息,这里并没有下载包,所以直接引入头文件会报错的</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911180835085.png" alt="image-20240911180835085"></p><p>使用下面指令下载<code>vcpkg.json</code>中的包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br></pre></td></tr></table></figure><p>还会贴心提示在cmake中如何使用</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181040866.png" alt="image-20240911181040866"></p><p>vcpkg官方推荐使用<code>CMakePresets.json</code>配置进行构建</p><blockquote><p>使用预设，项目的顶层目录必须包含名为 CMakePresets.json 或 CMakeUserPresets.json 的文 件。若两个文件都存在，将先解析 CMakePresets.json，再解析 CMakeUserPresets.json。这两个文件 有相同的格式，但使用方式略有不同</p></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181547753.png" alt="image-20240911181547753"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181640286.png" alt="image-20240911181640286"></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cmake</span> <span class="built_in">--listpresets</span> <span class="comment"># 列出写的预设</span></span><br><span class="line"><span class="string">cmake</span> <span class="built_in">--preset=name</span> <span class="comment">#选择某个预设</span></span><br></pre></td></tr></table></figure><p>其要求写入缓存变量<code>CMAKE_TOOLCHAIN_FILE</code>就是本机安装的<code>vcpkg.cmake</code>,</p><p>如果你设置了<code>VCPKG_ROOT</code>环境变量,可以使用”$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake”</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;displayname&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generator&quot;</span>: <span class="string">&quot;Ninja&quot;</span>, # 构建工具</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>, # 构建输出目录</span><br><span class="line">      <span class="attr">&quot;cacheVariables&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;CMAKE_TOOLCHAIN_FILE&quot;</span>: <span class="string">&quot;&lt;VCPKG_ROOT&gt;/scripts/buildsystems/vcpkg.cmake&quot;</span> #设置vcpkg工具链</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>version 字段指定要使用的 JSON 模式。版本 1 是 CMake 3.19 的第一个版本，只支持 configurePresets。版本 2 增加了 buildPresets 和 testPresets，CMake 3.20 开始支持; 版本 3 增加了 更多选项，CMake 3.21 开始支持。 可选的 cmakeMinimumRequired 字段可以用来定义构建此项目所需的 CMake 的最小版本。由于 最低要求通常也在 CMakeLists.txt 文件中说明，这通常会省略。 这三个列表:configurePresets、buildPresets 和 testPresets，每个列表都包含了用于配置、构建和 测试项目的配置。构建和测试的预置要求至少有一个配置预置，将在本节后面看到。 vendor 字段包含特定于供应商或 IDE 信息的可选映射。CMake 不解释该字段的内容</p><p>然后写上cmake文件,因为先使用preset会执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED) <span class="comment">#重点 find_package找包</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld PRIVATE fmt::fmt) <span class="comment">#进行链接</span></span><br></pre></td></tr></table></figure><p>执行<code>cmake --preset=name</code>会进行构建,如果没有安装相应库,也会安装.所以上面的<code>vcpkg install</code>就没必要执行了.</p><p>我在使用时遇到了找不到实现的问题,这貌似需要设置vcpkg triplet,网上有一些triplets模板,简单来说需要设置一系列vcpkg变量</p><ul><li><a href="https://stackoverflow.com/questions/74422058/how-to-use-vcpkg-with-clang-on-linux">How to use vcpkg with clang on linux? - Stack Overflow</a> 创建的自己的triplets<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/vcpkg/concepts/triplets">三元组 | Microsoft Learn</a>在windows默认的就是msvc的,难怪编译不过,我使用的时mingw…</li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a> 在windows上编译后将动态库拷贝一份到可执行程序同一个目录.<code>exe文件运行必须依赖同一目录(或者环境变量)下的dll</code></li></ul><p>一个简单的方法时设置<code>VCPKG_TARGET_TRIPLET</code>变量为”x64-mingw-dynamic”,表示使用mingw的动态库.或者使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install fmt:x64-mingw-dynamic</span><br></pre></td></tr></table></figure><p>可以设置 <code>VCPKG_TARGET_TRIPLET</code>(需要下载和使用的库的架构)和<code>VCPKG_HOST_TRIPLET</code>(生成自己的库需要的构建架构)来设置target和host的架构,使用<code>VCPKG_OVERLAY_TRIPLETS</code>使用社区的.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg <span class="built_in">help</span> triplets </span><br></pre></td></tr></table></figure><p>查看官方和社区提供的triplets.</p><h3 id="Triplets"><a href="#Triplets" class="headerlink" title="Triplets"></a>Triplets</h3><p>triplets指定平台架构,并按照对应的架构去设置toolchain,默认是在vcpkg/triplets下找一个符合平台的,比如<code>vcpkg install xxx:abcd</code>,其中abcd就是一个triplets,设置好triplet后清单模式下就去下载相应的包</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912123855699.png" alt="image-20240912123855699" style="zoom:50%;" /></p><blockquote><p>更新:如果你只是想用clang++编译器,在<code>CMakeLists.txt</code>project指令之前指定即可</p></blockquote><p>用于交叉编译的,也就是在宿主机上编译不同平台架构的程序/库.</p><p>默认triplets</p><ul><li>Windows: <code>x64-windows</code></li><li>Linux: <code>x64-linux</code></li><li>OSX: <code>x64-osx</code></li></ul><p>可以分别指定target-triplet和host-triplet设置对应需要的工具链名称,会根据对应的名字去vcpkg/triplets找,或者使用overlay-triplets覆盖目录</p><p>以上的问题可以总结为</p><ol><li><p>使用clang需要配置triplets,可以使用社区的</p><p><a href="https://github.com/microsoft/vcpkg/issues/38042">How to compile vcpkg libraries using Clang? · Issue #38042 · microsoft/vcpkg (github.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><a href="https://github.com/Neumann-A/my-vcpkg-triplets/tree/master">Neumann-A/my-vcpkg-triplets: my collection of vcpkg triplets (github.com)</a></p></li></ol><p>我注意到社区中的triplets中很多使用了<code>VCPKG_CHAINLOAD_TOOLCHAIN_FILE</code>指定要使用的备用 CMake 工具链文件,如果设置将替代所有其他编译器检测逻辑.默认情况下工具链文件是从 <code>scripts/toolchains/</code> 适合平台选择的,使用<code>--overlay-triplets</code>选择一个目录进行覆盖<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232109031.png" alt="image-20240911232109031"></p><blockquote><p>CMake 使用工具链实用程序来编译、link libraries和创建archives，并执行其他任务来进行构建。</p><p>可用的工具链由启用的语言决定。在正常编译中，<strong>CMake 会根据系统自省和默认值自动为主机编译确定工具链</strong>。在交叉编译情况下，可指定一个包含编译器和工具路径信息的工具链文件</p></blockquote><p>下面信息很重要,cmake在project()指令处查找可用的工具链,在<code>CMAKE_TOOLCHAIN_FILE</code>中处理vcpkg逻辑,其中将默认调用合适的vckpg/scripts/toolchains/中的toolchain</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232412863.png" alt="image-20240911232412863"></p><ol><li>在windows上使用vcpkg安装得到的动态库如果想要自己放在一个统一的3rdparty目录,include目录和bin目录中再自己设置link</li></ol><p>需要放在可执行程序目录下,可以通过设置路径解决</p><p><a href="https://blog.csdn.net/Tracker647/article/details/142070768">CMake+MinGW+vcpkg项目引入三方库的两种方式（手动路径，vcpkg）-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a>注意需要设置链接的.lib和.dll库,通过<code>IMPORTED_IMPLIB</code>设置输出的.lib库</p><blockquote><ul><li><strong>IMPORTED_LOCATION</strong>：用于存储导入库的实际文件路径，通常是共享库或可执行文件的位置。</li><li><strong>IMPORTED_IMPLIB</strong>：用于存储导入库（导入库 .lib 文件）的路径，通常在 Windows 平台上使用。</li></ul></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911230257291.png" alt="image-20240911230257291"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll)</span><br><span class="line"><span class="comment"># 改变导入库的.dll的位置</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(fmt INTERFACE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld fmt)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> HelloWorld POST_BUILD     <span class="comment">#-for copy libs in windows</span></span><br><span class="line">            <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/build)</span><br><span class="line">            <span class="comment"># 将输出动态库放在build目录下</span></span><br></pre></td></tr></table></figure><p>需要添加设置<code>IMORTED_IMPLIB</code>路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY</span><br><span class="line">  IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll</span><br><span class="line">  IMORTED_IMPLIB <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/lib/libfmt.lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意,使用vcpkg自动引入需要设置build_type,这样第三方库的动态库.dll就放在对应位置不用改了.</p></blockquote><p>使用vcpkg时注意,</p><ol><li>设置<code>CMAKE_TOOLCHAIN_FILE</code>要在project指令之前</li></ol><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911224541731.png" alt="image-20240911224541731"></p><ol><li>使用find_package(xxx <strong>CONFIG</strong> REQUIRED)</li><li>推荐使用preset</li><li>设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>为ON让clangd检测头文件目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -S /my/project --preset debug</span><br></pre></td></tr></table></figure><p>除了下载包之外,也有打包、发布等常用功能,已经满足常用需求了,cmake本身有cpack,但没有vcpkg提供的一些发布功能</p><p>要创建vcpkg包,首先创建manifest清单文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;libogg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version-string&quot;</span>: <span class="string">&quot;1.3.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目<code>vcpkg.json</code>中写上包内容,然后创建<code>portfile.cmake</code>,修改下面的配置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO xiph/ogg</span><br><span class="line">    <span class="keyword">REF</span> v1.<span class="number">3.3</span></span><br><span class="line">    SHA512 <span class="number">0</span>bd6095d647530d4cb1f509eb5e99965a25cc3dd9b8125b93abd6b248255c890cf20710154bdec40568478eb5c4cde724abfb2eff1f3a04e63acef0fbbc9799b</span><br><span class="line">    HEAD_REF <span class="keyword">master</span></span><br><span class="line"><span class="title">)</span></span><br></pre></td></tr></table></figure><p>用于GitHub存储库路径的REPO,用于使用稳定标签/提交的REF，以及带有下载文件校验和的SHA512,别人使用时也使用vcpkg下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_cmake_configure(SOURCE_PATH <span class="variable">$&#123;SOURCE_PATH&#125;</span>)</span><br><span class="line">vcpkg_cmake_install()</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">INSTALL</span> <span class="string">&quot;$&#123;SOURCE_PATH&#125;/COPYING&quot;</span> DESTINATION <span class="string">&quot;$&#123;CURRENT_PACKAGES_DIR&#125;/share/libogg&quot;</span> RENAME copyright)</span><br></pre></td></tr></table></figure><p>缺点就是微软文档实在烂,不是翻译的问题,英文原文的用词像是东拼西凑,感觉像是不停换人写出来的.</p><h2 id="CPM-cmake"><a href="#CPM-cmake" class="headerlink" title="CPM.cmake"></a>CPM.cmake</h2><p>轻量的包管理工具<a href="https://github.com/cpm-cmake/CPM.cmake">cpm-cmake/CPM.cmake: 📦 CMake’s missing package manager. A small CMake script for setup-free, cross-platform, reproducible dependency management. (github.com)</a>,基于cmake的FetchContent.</p><p>你只需要<code>include</code>提供的<code>cpm.cmake</code>文件即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p cmake</span><br><span class="line">wget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake</span><br></pre></td></tr></table></figure><p>此外也可以在cmake文件中下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># download CPM.cmake</span></span><br><span class="line"><span class="keyword">file</span>(</span><br><span class="line">  DOWNLOAD</span><br><span class="line">  https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.<span class="number">38.3</span>/CPM.cmake</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake</span><br><span class="line">  EXPECTED_HASH SHA256=cc155ce02e7945e7b8967ddfaff0b050e958a723ef7aad3766d368940cb15494</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add dependencies here</span></span><br><span class="line">CPMAddPackage(...)</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>然后就能直接使用了,</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPMAddPackage(</span><br><span class="line">  NAME          <span class="comment"># The unique name of the dependency (should be the exported target&#x27;s name)</span></span><br><span class="line">  VERSION       <span class="comment"># The minimum version of the dependency (optional, defaults to 0)</span></span><br><span class="line">  PATCHES       <span class="comment"># Patch files to be applied sequentially using patch and PATCH_OPTIONS (optional)</span></span><br><span class="line">  OPTIONS       <span class="comment"># Configuration options passed to the dependency (optional)</span></span><br><span class="line">  DOWNLOAD_ONLY <span class="comment"># If set, the project is downloaded, but not configured (optional)</span></span><br><span class="line">  [...]         <span class="comment"># Origin parameters forwarded to FetchContent_Declare, see below</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>来源可以由 GIT_REPOSITORY 指定，但也支持其他来源，如一般的URL。如果没有明确指定 GIT_TAG，则默认为 v(VERSION)，这是 git 项目的通用约定。另一方面，如果没有明确指定 VERSION，在某些常见情况下，CPM 可以根据 git 标签自动识别版本。GIT_TAG 也可以设置为特定的提交或分支名称（如 master），但不建议这样做，因为这样的软件包只有在缓存被清除时才会被更新</p><p>如果将附加的可选参数 EXCLUDE_FROM_ALL 设为真,则默认情况下不会编译依赖关系中定义的任何目标.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A git package from a given uri with a version</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version&quot;</span>)</span><br><span class="line"><span class="comment"># A git package from a given uri with a git tag or commit hash</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri#tag&quot;</span>)</span><br><span class="line"><span class="comment"># A git package with both version and tag provided</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version#tag&quot;</span>)</span><br></pre></td></tr></table></figure><p>与findpackage差别,在 CMake 项目中添加库的通常方法是调用 find_package(\<PackageName>)，并与 \<PackageName>_LIBRARIES 变量中定义的库进行链接。这种方法虽然简单，<strong>但可能会导致无法预测的编译，因为它需要在系统中安装库，而且不清楚添加的是哪个版本的库</strong>。此外，<strong>交叉编译项目（如mobile项目）也很困难</strong>，因为需要针对每个目标架构手动重建依赖关系。</p><p>CPM.cmake 允许明确定义依赖关系，并从源代码构建依赖关系。请注意，该行为不同于 find_package，因为使用 CPM.cmake 添加软件包后，导出到父作用域的变量（如 \<PackageName>_LIBRARIES ）将不可见。如果需要，可以手动实现该行为<a href="https://github.com/cpm-cmake/CPM.cmake/issues/132">find_package and CPMFindPackage have different behaviors · Issue #132 · cpm-cmake/CPM.cmake (github.com)</a>。</p><p>与fech_content差别,CPM.cmake 会检查任何添加的依赖项的版本号，如果另一个依赖项需要更新版,则会发出警告。<br>离线编译： CPM.cmake 将覆盖 CMake 的下载和更新命令，如果本地有所有依赖项，则可在离线状态下配置新的构建。<br>自动浅层克隆：如果提供了版本标签（如 v2.2.0）并使用了 CPM_SOURCE_CACHE，CPM.cmake 将执行依赖关系的浅层克隆，这应比完全克隆更快，同时使用的存储空间更少。可重写：通过设置 CMake 标志，所有 CPMAddPackage 都可配置为使用 find_package，从而轻松集成到可能需要通过系统的软件包管理器进行本地版本控制的项目中。软件包锁定文件可实现更简便的跨依赖关系管理。<br>每次编译时，可使用 CMake CLI 参数覆盖依赖关系。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">include</span>(cmake/CPM.cmake)</span><br><span class="line">CPMAddPackage(<span class="string">&quot;gh:fmtlib/fmt#10.2.0&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app fmt::fmt)</span><br></pre></td></tr></table></figure><p>上面的就使用<code>CPMAddPackage</code>添加了github上的fmtlib作者的fmt库,版本10.2.0</p><p>更多例子<a href="https://github.com/cpm-cmake/CPM.cmake/tree/master/examples">CPM.cmake/examples at master · cpm-cmake/CPM.cmake (github.com)</a></p><h2 id="CONAN"><a href="#CONAN" class="headerlink" title="CONAN"></a>CONAN</h2><p>这里做简单介绍,conan有仓库中心<a href="https://conan.io/center">Conan 2.0: C and C++ Open Source Package Manager</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conan</span><br></pre></td></tr></table></figure><p>在项目中创建<code>conanfile.txt</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[requires]</span><br><span class="line">zlib/1.2.11</span><br><span class="line"></span><br><span class="line">[generators]</span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><p>generators表示将使用CMakeDeps来生成关于Zlib库文件安装位置的信息，CMakeToolchain通过CMake工具链文件传递构建信息给CMake</p><p>此外还要创建conan profile,里面提供本机系统信息,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912092357159.png" alt="image-20240912092357159"></p><p>生成的信息可以修改,比如改编译器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>安装库,在build目录下会生成preset和conan_toolchain.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(compressor C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(ZLIB REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ZLIB::ZLIB)</span><br></pre></td></tr></table></figure><p>再写个cmake文件,链接库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># assuming Visual Studio 15 2017 is your VS version and that it matches your default profile</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>利用toolchain文件导入包. </p><p>上面讲的都是包管理工具(实际上脱离不了相应的构建工具),最大的问题就是两者分开了,但事实上完全可以放在一起,就像rust的cargo,<code>cargo build</code>,<code>cargo add</code></p><h2 id="xmake"><a href="#xmake" class="headerlink" title="xmake"></a>xmake</h2><p>xmake包括了自带的构建工具和包管理,也有项目创建工具的功能.xmake使用lua配置. xmake create创建项目,可以选择语言和模板(竟然还包括zig)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912100635482.png" alt="image-20240912100635482"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create -P hello</span><br></pre></td></tr></table></figure><p>创建好后目录下有<code>xmake.lua</code>,使用xmake即可直接构建.<code>xmake run hello</code>运行程序,</p><p>在<code>xmake.lua</code>中常见配置就是创建可执行程序,库,添加头文件,设置语言标准等.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;library&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) # 设置生成的类型</span><br><span class="line">    add_files(<span class="string">&quot;src/library/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;library&quot;</span>) # 添加依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外<code>add_headerfiles</code>添加头文件,<code>set_languages</code>设置语言版本.</p><p><code>xmake f -p</code>表示配置架构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake config -m debug xmake`</span><br><span class="line">xmake run -d hello</span><br></pre></td></tr></table></figure><p>可以进行debug</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p [macosx|linux|iphoneos ..] -a [x86_64|i386|arm64 ..] -m [debug|release]</span><br></pre></td></tr></table></figure><p>使用xmake配置项目,注意编译器设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++</span><br></pre></td></tr></table></figure><p>我在windows上使用clang++工具,配置llvm工具链即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p cross --toolchain=llvm --sdk=<span class="string">&quot;C:\Program Files\LLVM&quot;</span> </span><br><span class="line">xmake</span><br><span class="line">xmake run hello</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake -v <span class="comment"># 验证工具链配置</span></span><br></pre></td></tr></table></figure><p>或者使用mingw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p mingw</span><br></pre></td></tr></table></figure><p>xmake官方有<code>`xmake-repo</code>仓库用于下载包,</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;tbox 1.6.*&quot;</span>, <span class="string">&quot;libpng ~1.16&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;tbox&quot;</span>, <span class="string">&quot;libpng&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面配置从官方仓库中添加了依赖,执行<code>xmake</code>进行构建,会拉取相关的源包，然后自动编译安装，最后编译项目，并链接依赖包,此外还可以设置第三方依赖,从vcpkg,conan等地方</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib&quot;</span>, <span class="string">&quot;vcpkg::pcre2&quot;</span>)</span><br></pre></td></tr></table></figure><p>此外还有独立的xrepo可用于下载包,可以指定平台,版本等,支持从vcpkg,conan中搜索下载.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xrepo install zlib tbox </span><br><span class="line">xrepo install <span class="string">&quot;zlib &gt;=1.2.0&quot;</span> </span><br><span class="line">xrepo install -p iphoneos -a arm64 zlib</span><br><span class="line">xrepo install vcpkg::zlib </span><br><span class="line">xrepo install conan::zlib/1.2.11 </span><br></pre></td></tr></table></figure><p>我写了下面<code>xmake.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">add_packages(<span class="string">&quot;fmt::fmt&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果说vcpkg重点是选好triplet、toolchainfile,那么xmake也是配好toolchain</p><p>我直接配置<code>xmake f -p windows</code>使用msvc能成功build,如果要使用clang,配置好平台和工具链即可,相比vcpkg要好一些,vcpkg官方对clang/llvm貌似没有那么上心,官方triplet都没有,只能用社区的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p windows  --toolchain=clang-cl </span><br><span class="line">xmake f -p windows  --toolchain=clang <span class="comment">#或者</span></span><br></pre></td></tr></table></figure><p><code>xmake show -l toolchains</code>查看所有的toolchains</p><p>或者在<code>xmake.lua</code>中使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_plat(<span class="built_in">os</span>.host())</span><br><span class="line">set_arch(<span class="built_in">os</span>.arch())</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>)</span><br><span class="line"># 或者直接统一设置</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>,&#123;palt=<span class="built_in">os</span>.host(),arch=<span class="built_in">os</span>.arch()&#125;)</span><br></pre></td></tr></table></figure><p>目前还存在头文件无法识别的问题</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912121858364.png" alt="image-20240912121858364" style="zoom:50%;" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>参考作者给出的解决<a href="https://github.com/xmake-io/xmake-vscode/issues/40">支持为vscode-cpptools提供intellisense配置信息 · Issue #40 · xmake-io/xmake-vscode (github.com)</a>生成<code>compile_commands.json</code>包含编译器,工作目录和头文件目录等信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k vsxmake -m <span class="string">&quot;debug,release&quot;</span> <span class="comment"># New vsproj generator (Recommended)</span></span><br><span class="line">xmake project -k vs -m <span class="string">&quot;debug,release&quot;</span></span><br><span class="line">xmake project -k cmake</span><br><span class="line">xmake project -k ninja</span><br><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>因为目前就langd和vscode的intellisense能检测文件中头文件目录信息等,需要这个文件</p><p>使用下来的体验就是写起来比cmake用的轻松,文档写的案例也比较全面.但是因为没有深度使用,一些细节不知道怎样.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为我已经在很多项目中使用了cmake,经验相对更多,xmake学习起来并不困难,搭配官方文档很容易搭建一个项目.</p><p>但目前还是推荐使用cmake+vcpkg/cpm.cmake方案,因为更成熟,解决方案更多.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,&lt;/p&gt;
&lt;p&gt;所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了&lt;a href=&quot;https://xmake.io/#/getting_started&quot;&gt;xmake&lt;/a&gt;之外,还有&lt;a href=&quot;https://mesonbuild.com/&quot;&gt;The Meson Build system&lt;/a&gt;，&lt;a href=&quot;https://spack.io/about/&quot;&gt;About Spack - Spack&lt;/a&gt;，&lt;a href=&quot;https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn&quot;&gt;Bazel 简介 (google.cn)&lt;/a&gt;等等.我选择xmake主要原因是其自带的包管理和方便的写法&lt;br&gt;</summary>
    
    
    
    
    <category term="c++ build" scheme="https://www.sekyoro.top/tags/c-build/"/>
    
  </entry>
  
  <entry>
    <title>Dear-ImGUI:不太一样的GUI</title>
    <link href="https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/"/>
    <id>https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/</id>
    <published>2024-09-11T07:00:54.000Z</published>
    <updated>2024-10-05T11:57:47.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.<br><span id="more"></span></p><p>这种立即模式可能受到一些游戏开发的喜爱,ImGui<a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a>直到最近还不停有commit,Unity也采用了类似模式构建控件<a href="https://docs.unity.cn/cn/2019.4/Manual/gui-Basics.html">IMGUI 基础知识 - Unity 手册</a>. 在Rust也有<a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native (github.com)</a>,Go也有<a href="https://gioui.org/">Gio UI</a>.</p><p>下面写个简单的ImGUI程序学习学习.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们把GUI分成了retained mode和immediate mode</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics06.png" alt="a diagram that shows retained-mode graphics."></p><p>保留模式(retained mode) API 是声明式的。应用程序通过图形基元（如形状和线条）构建场景。图形库将场景模型存储在内存中。要绘制帧，图形库会将场景转换为一组绘图命令。在帧与帧之间，图形库会将场景保存在内存中。要更改渲染的内容，应用程序会发出更新场景的命令，例如添加或删除一个形状。然后图形库负责重新绘制场景。</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics07.png" alt="a diagram that shows immediate-mode graphics."></p><p>即时模式 API (immediate mode)是程序性的。每次绘制新帧时，应用程序都会直接发出绘制命令。图形库不会在帧与帧之间存储场景模型。相反，应用程序会跟踪场景</p><p>保留模式 API 使用起来可能更简单，因为 API 会为您完成更多工作，如初始化、状态维护和清理。另一方面，它们通常灵活性较差，因为 API 强加了自己的场景模型。此外，保留模式 API 对内存的要求可能更高，因为它需要提供通用场景模型。使用即时模式 API，您可以实现有针对性的优化。</p><p>此外注意到还有DirectUI的说法,区分win32窗体<a href="https://www.zhihu.com/question/20580684"> DirectUI与GUI框架有什么区别，如MFC，QT，wxWidgets的区别是什么？ - 知乎 (zhihu.com)</a></p><blockquote><p>系统窗口的消息路由是操作系统负责的，比如按钮上的消息就会被自动分发给按钮的窗口过程。而DirectUI这类框架创建的窗口的消息是由应用程序负责的路由的，无论你点击了窗口中哪个按钮，消息统统分发给单一的窗口过程，它再根据鼠标的坐标判决应该由哪个对象进一步处理消息</p></blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>imgui背后需要调用图形backend和窗体调用. 它提供了几种不同的头文件,包括win32(窗体)+direcx11/12(图形api),glfw+opengl,sdl+opengl,glfw+vulkan等等.</p><p>这里我使用glfw+opengl.</p><p>你可以在在对应的官方仓库下载源码或者预编译包链接使用,但是为了更方便地使用,可以直接使用包管理器vcpkg等下载然后再cmake中加上两句即可. vcpkg具体使用可以参考<a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">xmake:另一个C++现代构建系统 | Sekyoro的博客小屋</a>.</p><p>简单来说就是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir project &amp;&amp; <span class="built_in">cd</span> project</span><br><span class="line">vcpkg new --application</span><br><span class="line">vcpkg add port opengl</span><br><span class="line">cmake install <span class="comment"># 如果在cmakepresets中设置好了直接cmake --preset=&lt;preset_name&gt;即可</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>然后在<code>main.cpp</code>添加相应代码,执行程序</p><p><img data-src="https://s2.loli.net/2024/09/14/IdSPbTwpMn5U1XC.png" alt="image-20240914172255349"></p><blockquote><p>很多时候一些c++程序员喜欢把源码下载到本地然后进行编译,得到的库统一放在vendor/3rd_party目录,但是利用现代工具(vcpkg,conan等)可以方便地进行交叉编译(在宿主机上通过不同工具链得到其他架构的库/可执行程序),何乐而不为呢?</p></blockquote><p>其与Qt等<code>高等</code>框架相比,直接使用图形api和系统或在系统之上封装的窗口管理生成窗口、进行绘图.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">At</span> initialization:</span><br><span class="line">  <span class="keyword">call</span> ImGui::CreateContext()</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_Init() for <span class="number">each</span> backend.</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> the beginning of your frame:</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_NewFrame() for <span class="number">each</span> backend.</span><br><span class="line">  <span class="keyword">call</span> ImGui::NewFrame()</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> the end of your frame:</span><br><span class="line">  <span class="keyword">call</span> ImGui::Render()</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_RenderDrawData() for your Renderer backend.</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> shutdown:</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_Shutdown() for <span class="number">each</span> backend.</span><br><span class="line">  <span class="keyword">call</span> ImGui::DestroyContext()</span><br></pre></td></tr></table></figure><p>基本逻辑如上,我们需要在<code>while</code>循环中针对每帧做动作,比如下面代码表示如果窗口最小化等待10ms再进行,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="comment">// Poll and handle events (inputs, window resize, etc.)</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetWindowAttrib</span>(window, GLFW_ICONIFIED) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ImGui_ImplGlfw_Sleep</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些简单代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> clicked = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 按钮</span></span><br><span class="line">       <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))</span><br><span class="line">           clicked++;</span><br><span class="line">       <span class="keyword">if</span> (clicked &amp; <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">           ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Thanks for clicking me!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 选择框</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">bool</span> check = <span class="literal">true</span>;</span><br><span class="line">       ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;checkbox&quot;</span>, &amp;check);</span><br><span class="line"><span class="comment">// 选择按钮</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio a&quot;</span>, &amp;e, <span class="number">0</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio b&quot;</span>, &amp;e, <span class="number">1</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio c&quot;</span>, &amp;e, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">               ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">           ImGui::<span class="built_in">PushID</span>(i);</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.6f</span>, <span class="number">0.6f</span>));</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>));</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>));</span><br><span class="line">           ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">           ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);</span><br><span class="line">           ImGui::<span class="built_in">PopID</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Use AlignTextToFramePadding() to align text baseline to the baseline of framed widgets elements</span></span><br><span class="line">       <span class="comment">// (otherwise a Text+SameLine+Button sequence will have the text a little too high by default!)</span></span><br><span class="line">       <span class="comment">// See &#x27;Demo-&gt;Layout-&gt;Text Baseline Alignment&#x27; for details.</span></span><br><span class="line">       ImGui::<span class="built_in">AlignTextToFramePadding</span>();</span><br><span class="line">       ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hold to repeat:&quot;</span>);</span><br><span class="line">       ImGui::<span class="built_in">SameLine</span>();</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p></li><li><p><a href="https://blog.codingnow.com/2020/07/game_ui.html">云风的 BLOG: 游戏 UI 模块的选择 (codingnow.com)</a></p><p>如果你不想使用Qt庞然大物,也不想使用提供内置功能太少的界面库,可以试试SFML<a href="https://www.sfml-dev.org/">SFML (sfml-dev.org)</a>.</p></li><li><p><a href="https://tulach.cc/writing-gui-apps-for-windows-is-painful/">Writing GUI apps for Windows is painful - Samuel Tulach</a>一篇介绍windows上桌面程序开发框架选择的文章,提到了winui3,qt以及使用其他技术栈链接.dll库,比如wpf等.事实上我已经多次谈论界面开发/桌面开发/移动端开发,注意一个事实,一些库不只是用于界面绘制的,除去界面绘制,一些基本工具库的提供往往也非常有必要.所以在windows下使用微软带来的生态是很好的(wpf,maui,winui3等),在移动端下使用compose也很舒服.还有Flutter也吃Dart的生态. 此外也有很多使用web的技术,比如electron,tauri,<a href="https://pywebview.flowrl.com/">pywebview (flowrl.com)</a></p><p>很多时候没有必要考虑跨平台的需求(那就做web).</p><p>(delphi和lazarus有谁用过?)<a href="https://www.zhihu.com/question/54905309">用 Lazarus 做 GUI 程序合适吗？ - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html">ImGui Manual (pthom.github.io)</a>第三方文档</p></li><li><p>其他教程<a href="https://www.cnblogs.com/timefiles/p/17632348.html#打包程序">使用C++界面框架ImGUI开发一个简单程序 - 二次元攻城狮 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/639795542">【漫谈】关于图形引擎的一些看法 - 知乎 (zhihu.com)</a> 一位知乎er对现有绘图引擎评价</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.&lt;br&gt;</summary>
    
    
    
    
    <category term="GUI" scheme="https://www.sekyoro.top/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>cs144:intro to computer network</title>
    <link href="https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/"/>
    <id>https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/</id>
    <published>2024-09-01T11:50:34.000Z</published>
    <updated>2024-09-12T12:47:21.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.<br><span id="more"></span></p><p>代码lian’jie<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/cs144">build-my-own-x/cs144 at main · drowning-in-codes/build-my-own-x (github.com)</a></p><h2 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h2><p>第一个项目minnow,看看<code>CMakeLists.txt</code>,写得是真的好.</p><p>首先确保generator必须是Unix Makefiles,然后保证out of build(也就是src和build目录不同,使用cmake -B build)</p><p>然后添加其他辅助cmake脚本,这里通过<code>include</code>指令添加,应该是为了访问父作用域的变量. 然后添加头文件目录,最后使用<code>add_subdirectory</code>添加需要编译的子项目.每个目录下都是一个<code>CMakeLists.txt</code>,设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>得到编译指令(也是为了搭配一些编辑器使用).光是CmakeLists.txt就学到很多c++项目组织的知识.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.24</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(minnow CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_GENERATOR&#125;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Unix Makefiles&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_MAKE_PROGRAM <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/scripts/make-parallel.sh&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Minnow must be built outside its source directory, e.g. `cmake -B build`.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(etc/build_type.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/cflags.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/scanners.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/tests.cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/apps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>在添加的cmake脚本中,包括设置构建类型的(Debug或Release),一些编译器设置,clang-tidy和format用于语法提示和格式化,以及一些测试.</p><p>在代码中,许多c++17和20新东西都用上了,比如string_view,span等,</p><p>第一次作业要求写一个bytestream的reader和writer,分别读取和写入字节流. 我看了一些网上的实现,太吓人了,还使用<code>`std::deque</code>等容器,根本没必要,还可能在提交测试时出现heap overflow. 直接使用string即可,熟悉一下一些STL常用操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="keyword">uint64_t</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::push</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  std::<span class="keyword">size_t</span> data_len = data.<span class="built_in">length</span>();</span><br><span class="line">  std::<span class="keyword">size_t</span> avai_cap = <span class="keyword">this</span>-&gt;<span class="built_in">available_capacity</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_len &gt;= avai_cap) &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + avai_cap);</span><br><span class="line">    push_counts += avai_cap;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    push_counts += data_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  _is_closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> capacity_ - _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> push_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed &amp;&amp; _buffer.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> pop_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  string_view sv&#123;&amp;*_buffer.<span class="built_in">begin</span>(), _buffer.<span class="built_in">size</span>()&#125;;</span><br><span class="line">  <span class="keyword">return</span> sv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader::pop</span><span class="params">(<span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">size</span>() &lt;= len) &#123;</span><br><span class="line">    pop_counts += _buffer.<span class="built_in">size</span>();</span><br><span class="line">    _buffer.<span class="built_in">clear</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">assign</span>(_buffer.<span class="built_in">begin</span>() + len, _buffer.<span class="built_in">end</span>());</span><br><span class="line">    pop_counts += len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/03/7M1R6WH3g8iKQdc.png" alt="image-20240903120538215"></p><blockquote><p>后面我看到有人使用queue\<string>,效果还不错.所以我又改了😅</p><p>逻辑是每次push数据,都是推一个新的string,如果没有超过容量直接推,如果超了就截断后再推.</p><p>pop数据时,如果queue中string数据长度大于len,就不需要将该数据pop掉,而是设置为removed_prefix,方便peek时返回. 如果小于等于,就将其推掉再看下一个string的长度.</p></blockquote><h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p>第一个实验就折磨了我很久,写一个对乱序(是指的发送的数据段的序列是乱的,数据段substring内部是顺序的)的字节流进行重排的reassembler.</p><p><img data-src="https://s2.loli.net/2024/09/06/gJCwbV4RtfLrW9j.png" alt="image-20240906172137248"></p><p>重点就是上面的图,绿色加红色的段落是固定长度并且只会往右移动到发送过来的数据最大长度.</p><p>如果来的数据段first_index为first_unasembled_index,那就说明来对了.但是在push到bytestream之前,需要注意可能有重叠部分,</p><p><img data-src="https://s2.loli.net/2024/09/06/cgsVmdDfLGSXWBj.png" alt="image-20240906172716413"></p><p>比如上面有重叠部分,需要截断数据,比较好的方法是将incoming data前面没有重叠的部分取出来作为新的数据,后面准备直接push到bytestream</p><p><img data-src="https://s2.loli.net/2024/09/06/RvQ3uFjrKMeIVwX.png" alt="image-20240906173236584"></p><p>有人就要问了,为啥不直接将这段数据直接都推进去,就像下图中红框这样,如果像上面那样截断,不就要后面多推一次吗？</p><p><img data-src="https://s2.loli.net/2024/09/06/84oJBaVHhO1PkDj.png" alt="image-20240906173340799"></p><p>理论上来说也是可行的,包括也可以像下面这样截断,但隐含的问题是,这两种方法后面的数据都有可能overlap.</p><p><img data-src="https://s2.loli.net/2024/09/06/wGFBxXy8jOcgWkr.png" alt="image-20240906173540255"></p><p>而像第一种截断方法中绿色那一段数据就不会有overlap.  而且后面的数据重复段可能不止一个,需要连续处理知道处理完后面的所有数据或者部分重叠.</p><p>如果是完全重叠,就可以直接删掉这段,比如下面的红色段数据.</p><p><img data-src="https://s2.loli.net/2024/09/06/UjCw2PEJ9mtbeAp.png" alt="image-20240906174432079"></p><p>除了对后面的数据做截断,针对排在前面的数据也是类似. 注意,在这里并没有对超过first_unaccepted_index的数据段进行截取.</p><p><img data-src="https://s2.loli.net/2024/09/06/letiLN4d5mMpsHS.png" alt="image-20240906173933135"></p><p>总的来说,首先需要对数据的first_index和大小进行调整,比如截断啥的. 使得它没有与其他数据段重叠.</p><p>然后就是判断更新后的first_index与first_unassemble_index,如果相等,push数据(由于在上一节push的实现中,如果数据长度大于capacity,就只会将数据填满,超过的数据忽略),否则放在一个map<uint64_t,string>中,称为substrings,注意这里有多种选择,你可以将其超过first_unassemble_index的段截断,也可以先直接推进去,后面再处理,但为了节省内存,可以直接先截断.</p><p>可能到这里有人以为已经结束了,但当推送了某个数据之后,可能后面的substrings就能使用上了,就需要进行处理.如果是next_assembled_idx(其实就是first_unassemble_idx==bytes_pushed),就继续推,因为前面存substrings中的数据时已经考虑到了截断超过first_unassemble_index的数据,数据长度加起来肯定小于容量,这里直接推进去就行了.</p><p><img data-src="https://s2.loli.net/2024/09/06/Czik8Pc4KM2rBHE.png" alt="image-20240906173613597" style="zoom:50%;" /></p><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><blockquote><p>TCP是一种协议，它在不可靠的数据报上可靠地传输一对流控制的字节流(每个方向一个)。双方或“peers”参与TCP连接，每个peers都充当(其自身输出字节流的)“发送者”和“接收者”</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/06/nzAsKGwy4xWNqH3.png" alt="image-20240906180021011"></p><p>首先需要实现一个32-bit的相对索引wrapper与64位绝对索引相互转换.</p><p><img data-src="https://s2.loli.net/2024/09/06/dD4tQgeqRLTm8vj.png" alt="image-20240906234140049"></p><p>而注意在接受的数据段(stream index),是直接从0开始,不包括SYN的.</p><p>从接收到的absolute seqno-&gt;seqno,也就是从64位转为32位,比较简单,可以采取取余或者直接<code>static_cat&lt;uint32_t&gt;</code>即可,相当于把多出的截断.从seqno-&gt;absolute seqno,有非常多可能,比如假设seqno-zero_point的值是144,那么就有可能是144+GAP*k,其中GAP是<code>1UL&lt;&lt;32</code>. 所以需要一个值帮助确定,checkpoint就是这个值,离它最近的就是这个absolute seqno. 需要做的就是求k. k是(checkpoint-absolute seqno)/(1UL&lt;&lt;32)的四舍五入值.  但是要注意,如果checpoint&lt;absolute seqno,上面的公式就会出问题.</p><p>当checpoint&lt;absolute seqno时,直接返回<code>seqno-zero_point</code>即可.</p><p>在此基础上需要实现TCP receiver.</p><p>它将(1)从peer的发送方接收消息并使用Reassembler重新组装字节流</p><p>(2)将包含确认号(ackno)和窗口大小的消息发送回peer的发送方.</p><p>注意SYN和FIN并不包含在数据payload中,但是在计算ackno时需要加上相应的值以确定需要的数据index. </p><p>接收到数据时,如果带有SYN则对应的seqno就是zero_point(并不是数据的开始,zero_point+1才是数据),我们本身需要的是发过来的数据在absolute seqno中的索引,但这个值我们无法确定,checkpoint可以设置为bytes_pushed也就是first_unassembled_index,因为这是我们需要的值.在获得absolute seqno后还需要-1除去SYN,然后再insert数据. 如果writer关闭则设置FIN关闭,方便后面send及时关闭.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPSenderMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Wrap32 seqno &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> SYN &#123;&#125;;</span><br><span class="line">std::string payload &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> FIN &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line"><span class="comment">// How many sequence numbers does this segment use?</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sequence_length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SYN + payload.<span class="built_in">size</span>() + FIN; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPReceiverMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">std::optional&lt;Wrap32&gt; ackno &#123;&#125;;</span><br><span class="line"><span class="keyword">uint16_t</span> window_size &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Construct with given Reassembler</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCPReceiver</span><span class="params">( Reassembler&amp;&amp; reassembler )</span> : reassembler_( std::move( reassembler ) ) &#123;</span>&#125;</span><br><span class="line"><span class="comment">// The TCPReceiver receives TCPSenderMessages from the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message )</span></span>;</span><br><span class="line"><span class="comment">// The TCPReceiver sends TCPReceiverMessages to the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// Access the output (only Reader is accessible non-const)</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Reassembler&amp; <span class="title">reassembler</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_; &#125;</span><br><span class="line"><span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">writer</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Reassembler reassembler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在send中,需要返回ackno和window_size,后者就是writer().available_capacity(),但注意如果初始化时超过了就设置MAX.</p><p>前者就是目前接收到的数据加上标志位.</p><p>发送数据时首先初始化SYN作为开始位置,开始位置之后的一个位置是数据位置.发送数据时携带这个标志和数据payload,同时每次只允许最多发送uint_32_t数据,所以发送数据时需要将原本64位的索引转成32位</p><blockquote><p>在TCP报头中，空间是宝贵的，流中的每个字节的索引不是用64位索引表示，而是用32位的“序列号”或“seqno”表示。这增加了复杂性</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/07/gE7IOc6ZdzyKbel.png" alt="image-20240907145920140"></p><p>当接收者拿到32位的相对索引时如何知道在绝对位置上的索引呢<img data-src="https://s2.loli.net/2024/09/07/HRkMqCVI5ApihuJ.png" alt="image-20240907151332005"></p><p>关键是确定checkpoint,因为absolute seqno可能是k*GAP+offset,offset是小于GAP的.</p><p>假设如下图,如果此时发送一个之前的重复段,实际的absolute seqno比较小,如果使用bytes_pushed,那么可能会导致得到的first_index比较大. 出现这种情况的前提是,bytes_pushed&gt;uint32_t,因为此时会有多个可能的绝对位置,如果再发送之前的数据,那么absolute seqno的first_index就会选择错误.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907152015454.png" alt="image-20240907152015454"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907155828700.png" alt="image-20240907155828700"></p><p>当我尝试这么测试时,要么报错oom要么timeout.</p><h2 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h2><p>实现TcpSender.在文档中需要要点都说了.但是有些细节还是容易忘.</p><p>首先在push方法中,什么时候发送数据?</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231650614.png" alt="image-20240908231650614"></p><p>只要有可读数据并且空余的window_size就能使用transmit读取数据.什么叫做空余的window_size,只要window_size大于0就能发送数据吗,事实上并不是,比如如果我连续发送了很多数据,但是window_size一直为0,我还需要不断发送直到读完所有数据吗,貌似也是可行的. 更好的方式是window_size如果小于outstanding_bytes的数量,那就先等着,直到接收到peer发来的ackno更新window_size.  每次发送的数据就是window_size-outstanding_bytes,但是有个MAX_PAYLOAD_SIZE的限制,另外注意发送的数据大小是包含SYN的,也就是说如果是开始的数据,window_size =100,那么只能发送99个数据.payload大小是99.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907171424559.png" alt="image-20240907171424559"></p><p>如何确定sender需要发送FIN？</p><p>首先reader需要结束,也就是reader().is_finished() (注意不是bytes_bufferd==0,还需要reader关闭,因为还没有关闭时也有可能存在buffer为空的情况).此外剩余的数据已经小于window_size-outstanding_bytes(相当于peer还剩的空间).</p><p>然后发送数据,开启计时同时增加发送的index和outstanding_bytes,保存发送的信息. 当接收到ackno和window_size时进行更新窗口大小,并根据ackno删除数据,如果确实超过了保留数据的ackno+seq_len,那就更新ack_abs_seqno,此外重新设置timer,如果清空了outstanding_byte_stream,那就关闭定时器,否则还是打开但需要重置时间.tick方法计时器超时并且还有重传数据时,发送最早的重传数据,重置timer,如果window_size不为0,double重传时间,重传次数+1,背后的逻辑可能是,如果window_size为0,表示peer没有什么要接受的,没有那么急</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908234129034.png" alt="image-20240908234129034"></p><p>注意,当window_size为0时,说明peer没有需要的数据了,但如果依然能发送(&gt;outstanding_bytes),就需要多发送1byte数据来查看peer还能否扩展空间.如果没有数据了就不发了. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235508628.png" alt="image-20240908235508628"></p><p>想象一下,如果peer依然发送window_size=0,在tick中我们就会不断重试,直到超过次数然后退出.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235847377.png" alt="image-20240908235847377" style="zoom:50%;" /></p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><p>使用之前的工具进行数据分析.无代码</p><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><p>在有了TCP实现之后,还需要怎么封装才能传输信息?</p><ul><li>TCP-in-UDP-in-IP:TCP段可以在用户数据报的有效载荷中携带。在正常(用户空间)设置中工作时，这是最容易实现的:Linux提供了一个接口(“数据报套接字”，UDPSocket)，它允许应用程序只提供用户数据报的有效载荷和目标地址，内核负责构造UDP报头、IP报头和以太网报头，然后将数据包发送到适当的下一跳</li><li>内核确保每个套接字具有本地和远程地址和端口号的独占组合，并且由于内核负责将这些写入UDP和IP头，因此它可以保证不同应用程序之间的隔离</li><li>TCP-in-IP:在通常的用法中，TCP段几乎总是直接放在互联网数据报中，在IP和TCP头之间没有UDP头。这就是人们所说的“TCP/IP”.“这有点难以实施。Linux提供了一个称为TUN设备的接口，它允许应用程序提供一个完整的Internet数据报，内核负责其余的工作(写入以太网头，并实际通过物理以太网卡发送，等等)。但是应用程序必须自己构造完整的IP报头，而不仅仅是有效负载</li><li>TCP-in-IP-in-Ethernet: 在上述方法中仍然依赖Linux内核来实现部分网络堆栈。每次代码向TUN设备写入IP数据报时，Linux都必须用IP数据报作为有效负载构建一个适当的链路层(以太网)帧。这意味着Linux必须找出下一跳以太网目的地址，给定下一跳的IP地址。如果不知道,Linux广播一个查询:“谁声明了以下内容?IP地址?以太网地址是什么?，然后等待回复。这些功能由网络接口执行:一个将出站IP数据报转换为链路层(例如，以太网)帧的组件，反之亦然。(在实际系统中，网络接口通常有eth0、eth1、wlan0等名称)</li></ul><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231059785.png" alt="image-20240908231059785" style="zoom: 50%;" /></p><p>这一节说白了就是实现简单的ARP,保存IP地址与MAC(以太网)地址映射.</p><p>关键是两个方法,接受数据和发送数据.对于发送数据,如果在映射表中,那就直接发送,如果不在,那就需要发送arp消息,但前提是之前没有发送过或者发送后超过了一定时间,发送arp消息后timer置0.注意发送的arp请求消息中,目标以太网地址为0,广播地址在以太网地址字段中而不是arp中.arp消息是payload,以太网头是header.然后将要发送的消息和next_hop保存,等接受到相应的地址后再发送.对于接受消息,如果数据是ip数据报并且目标ip是自己,就接受消息并且更新映射表,如果是新的映射设置timer,否则不管.然后看新的映射是否跟保存的消息的目标ip相同,相同则发送.如果是arp消息,也更新映射与timer,如果是请求就发送自己的ip.否则根据更新的映射发送消息. 在tick中更新timer,并且如果超时就删除对应映射. 需要注意的是,什么时候需要开启timer,什么时候删除.</p><p>发送了arp消息时需要设置为0,接收到arp回应时删除对应arp请求的ip记录. 接收到新的映射时开启timer,超过30s后删除映射表和timer. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910202737584.png" alt="image-20240910202737584" style="zoom:67%;" /></p><h2 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h2><p>一个router有几个网络接口，可以在其中任何一个接口上接收Internet数据报.</p><p>router的工作是根据路由表转发它收到的数据报:路由表是一个规则列表，它告诉router，对于任何给定的数据报，</p><p>•发送哪个接口</p><p>•下一跳IP地址</p><p>实现一个路由器，它可以为给定的数据报得到这两个东西。</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910204547680.png" alt="image-20240910204547680"></p><p>这里本身逻辑并不复杂,写一个路由表记录ip掩码和掩码后的地址,对应下一跳地址和interface. 首先遍历interface,拿到消息队列,对于每个消息ttl的ttl如果小于等于1,直接丢掉,否则拿去匹配路由表中,找到最长匹配的ip地址.</p><p>我一开始使用的路由表结构是map,但是发现一直过不了,改成multimap就过了,说明有重复的key,我的结构体如下,如果有重复key,表明掩码长度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;; #掩码后的地址</span><br><span class="line"><span class="keyword">uint8_t</span> prefix_length&#123;&#125;; # 前缀长度</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prefix_length &lt; ip_.prefix_length;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由两种解决方法,要么使用multimap允许重复key,要么将&lt;比较操作为修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(prefix_length != ip_.prefix_length) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix_length&lt;ip_.prefix_length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> masked_ipaddr&lt;ip_.masked_ipaddr;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>c++20增加了<code>&lt;=&gt;</code>操作符和 std::strong_ordering,std::weak_ordering<br>,std::partial_ordering. 定义一个默认的<code>&lt;=&gt;</code>操作符基本就能允许所有比较,实在是太酷啦! 比较顺序与类中声明成员的顺序一致.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  std::string name&#123;&#125;;</span><br><span class="line">  <span class="keyword">double</span> value&#123;&#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Person &amp;) <span class="keyword">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p1&#123;.name = <span class="string">&quot;张三&quot;</span>, .value = <span class="number">12.</span>&#125;, p2&#123;.name = <span class="string">&quot;李四&quot;</span>, .value = <span class="number">13.</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;我们都一样&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h2><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912173600895.png" alt="image-20240912173600895"></p><p>lab7也是测试</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200347129.png" alt="image-20240912200347129"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200356663.png" alt="image-20240912200356663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次计算机网络实验,从一开始的bytestream,到reassember,再到tcpsender,reader,最后写路由分配ip数据报. </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Kiprey/sponge/tree/master">Kiprey/sponge: CS144 Lab Assignments (github.com)</a></li><li><a href="https://github.com/Kenshin2438/CS144">Kenshin2438/CS144: CS 144: Introduction to Computer Networking, Winter 2024 (github.com)</a></li><li><a href="https://cs144.github.io/">CS 144: Introduction to Computer Networking</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>dive deeper into functional programming</title>
    <link href="https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/"/>
    <id>https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/</id>
    <published>2024-08-17T06:49:47.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用<a href="https://ocaml.org/">ocaml.org</a>学习函数式编程.</p><span id="more"></span><p>相对来说,ocaml,elixir,scala以及clojure等在工业界用得比其他语言要多一点,主要原因个人认为还是对于大数据、多线程的处理以及语法上的可读性.  学习这些语言能帮助扩展思维以及在其他现代的编程语言中,你很可能会看见类似的设计和思想.</p><p>函数式语言的设计往往非常优雅严谨,以此达到编写正确优美的代码.下面以ocaml作介绍.</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>OCaml语法的主要部分是表达式。就像命令式语言中的程序主要由命令构建一样，函数式语言中的程序主要由表达式构建。表达式的例子包括2+2和increment 21</p><p>在函数式语言中，计算的主要任务是将表达式求值为一个值。值是一个表达式，它不需要执行任何计算。所以，<strong>所有的值都是表达式，但不是所有的表达式都是值</strong>。值的例子包括2、true和”yay!”</p><h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>表达式assert e求e的值。如果结果为真，则不再发生任何事情，整个表达式的求值为一个名为unit的特殊值。unit写作()，类型为unit。但如果结果为false，则会引发异常。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input1 = output1)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input2 = output2)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input3 = output3)</span><br></pre></td></tr></table></figure><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span> + <span class="number">5</span> &gt; <span class="number">2</span> <span class="keyword">then</span> <span class="string">&quot;yay!&quot;</span> <span class="keyword">else</span> <span class="string">&quot;boo!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span> <span class="keyword">in</span> x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意<code>let x = 42;;</code>是定义而不是表达式</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [fact n] is [n!].</span></span><br><span class="line"><span class="comment">    Requires: [n &gt;= 0]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> fact n = <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * fact (n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> inc x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> inc = <span class="keyword">fun</span> x -&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square (inc <span class="number">5</span>);;</span><br><span class="line"><span class="number">5</span> |&gt; inc |&gt; square;;</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>这是在其他编程语言中非常常见的,包括map,filter,fold等等操作</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> add1 = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; (h + <span class="number">1</span>) :: add1 t</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst1 = add1 [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> map f = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; f h :: map f t</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> add1 = map (<span class="keyword">fun</span> x -&gt; x + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [concat_bang lst] concatenates &quot;!&quot; to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> concat_bang = map (<span class="keyword">fun</span> x -&gt; x ^ <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p x = print_int x; print_newline<span class="literal">()</span>; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst = map p [<span class="number">1</span>; <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> filter p = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; <span class="keyword">if</span> p h <span class="keyword">then</span> h :: filter p t <span class="keyword">else</span> filter p t</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> combine op init = <span class="keyword">function</span></span><br><span class="line">            | <span class="literal">[]</span> -&gt; init</span><br><span class="line">            | h::t -&gt; op h (combine op init t)</span><br><span class="line"><span class="keyword">let</span> sum = combine ( + ) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> concat = combine (^) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="primitive-types和values"><a href="#primitive-types和values" class="headerlink" title="primitive types和values"></a>primitive types和values</h2><p>基本类型是内置的和最基本的类型:整数、浮点数、字符、字符串和布尔值。它们将被识别为类似于其他编程语言中的基本类型.</p><p>除了上面之外,Ocaml还有许多东西,但我也就止于此了.目前我主要关注的还高阶函数</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://cs3110.github.io/textbook/chapters/intro/past.html">1.1. The Past of OCaml — OCaml Programming: Correct + Efficient + Beautiful (cs3110.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用&lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org&lt;/a&gt;学习函数式编程.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CUDA101</title>
    <link href="https://www.sekyoro.top/2024/08/16/CUDA101/"/>
    <id>https://www.sekyoro.top/2024/08/16/CUDA101/</id>
    <published>2024-08-16T10:23:41.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>作为既对AI又对sys、hpc感兴趣的人来说,cuda编程应该是不可不看的,我也早有耳闻.这里简单学习一下.<br><span id="more"></span></p><p>目前AI大模型的推理以及AI+HPC、深度学习系统构建等都需要了解cuda以及使用cuda编程,通过使用cuda、c++以及pybind写一些深度学习算子等提升运行速度都是一些常见应用途径.</p><h2 id="介绍CUDA"><a href="#介绍CUDA" class="headerlink" title="介绍CUDA"></a>介绍CUDA</h2><blockquote><p><a href="https://www.geeksforgeeks.org/how-to-run-cuda-c-c-on-jupyter-notebook-in-google-colaboratory/">CUDA</a> stands for Compute Unified Device Architecture. It is an extension of C/C++ programming. CUDA is a programming language that uses the Graphical Processing Unit (GPU). It is a parallel computing platform and an API (Application Programming Interface) model, Compute Unified Device Architecture was developed by Nvidia. This allows computations to be performed in parallel while providing well-formed speed. Using CUDA, one can harness the power of the Nvidia GPU to perform common computing tasks, such as processing matrices and other linear algebra operations, rather than simply performing graphical calculations.</p></blockquote><p><img data-src="https://media.geeksforgeeks.org/wp-content/uploads/20211007112954/UntitledDiagram1.jpg" alt="img" style="zoom:67%;" /></p><ul><li>上图展示了16个并行(流)多(streaming multiprocessor)处理块(digrams)</li><li>每个并行多处理块有8个并行处理器(streanming processors),所以一共128个并行处理器</li><li>每个并行处理器有一个乘加单元 (Multiplication and Addition Unit)和一个加单元(multiplication unit).</li><li>一张GT200显卡有30个并行多处理器,每个处理器有8个并行处理器,所以一共240个并行处理器,有多余1的TFLOP处理能力</li><li>每个流处理器都是线程，每个应用程序可以运行数千个线程</li><li>G80卡有16个流多处理器(SMs)，每个SM有8个流处理器(SPs)，即总共128个SPs，每个流多处理器支持768个线程(注意:不是每个SP)。</li><li>最终，每个流式多处理器有 8 个 SP 后，每个 SP 最多支持 <strong>768/8 = 96 个线程</strong>。可在 128 个 SP 上运行的线程总数 - 128* 96 = 12 228 次(=16*768)</li><li>因此，这些处理器被称为大规模并行处理器(massively parallel)。</li><li>G80 芯片的内存带宽为 86.4GB/s。</li><li>G80 芯片的内存带宽为 86.4GB/s，与 CPU 之间的通信通道为 8GB/s（4GB/s 上传到 CPU RAM，4GB/s 从 CPU RAM 下载）。</li></ul><h4 id="CUDA工作"><a href="#CUDA工作" class="headerlink" title="CUDA工作"></a>CUDA工作</h4><ul><li>GPU 一次运行一个内核（一组任务）。</li><li>每个内核由独立的 ALU 组块组成。</li><li>每个区块包含线程，线程是计算的层次。</li><li>每个块中的线程通常共同计算一个值。</li><li>同一区块中的线程可以共享内存。</li><li>在 CUDA 中，从 CPU 向 GPU 发送信息通常是计算中最典型的部分。</li><li>对每个线程而言，本地内存速度最快，共享内存次之，全局、静态和纹理内存速度最慢。</li></ul><h4 id="CUDA以及工作流程"><a href="#CUDA以及工作流程" class="headerlink" title="CUDA以及工作流程"></a>CUDA以及工作流程</h4><ul><li>将数据加载到 CPU 内存</li><li>将数据从 CPU 复制到 GPU 内存 - 例如，cudaMemcpy(…, cudaMemcpyHostToDevice)</li><li>使用设备变量调用 GPU 内核 - 例如，kernel&lt;&lt;&lt;&gt;&gt; (gpuVar)</li><li>将结果从 GPU 复制到 CPU 内存 - 例如，cudaMemcpy(…, cudaMemcpyDeviceToHost)</li><li>在 CPU 上使用结果</li></ul><h2 id="编写CUDA代码"><a href="#编写CUDA代码" class="headerlink" title="编写CUDA代码"></a>编写CUDA代码</h2><p>需要在Nvidia显卡下安装cudatoolkit,以使用nvcc编译器和一些库.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__global__ void cuda_hello()&#123;</span><br><span class="line">    printf(&quot;Hello World from GPU!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cuda_hello&lt;&lt;&lt;1,1&gt;&gt;&gt;(); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_<em>global_</em>说明符表示在设备(GPU)上运行的函数.这样的函数可以通过宿主代码调用,例如示例中的main()函数,也被称为“<em>kernel</em>”</p><p>当调用内核时，它的执行配置通过&lt;&lt;&lt;…&gt;&gt;&gt;语法，例如cuda_hello&lt;&lt;<1,1>&gt;&gt;()。在CUDA术语中，这被称为“<em>kernel launch</em>”</p><p>CPU和GPU是独立的实体。它们都有自己的内存空间。CPU不能直接访问GPU内存，反之亦然。在CUDA术语中，CPU内存称为主机内存，GPU内存称为设备内存。指向CPU和GPU内存的指针分别称为主机指针和设备指针.</p><p>对于GPU可以访问的数据，它必须呈现在设备内存中。CUDA提供了用于分配设备内存和主机与设备内存之间数据传输的api。</p><ol><li>分为宿主内存给宿主数据</li><li>分配设备内存</li><li>将输入数据从宿主内存转到设备内存</li><li>执行kernels(_<em>global\</em>_标识 )</li><li>将输出从设备转移到宿主</li></ol><p>CUDA提供了几个用于分配设备内存的函数。最常见的是<code>cudaMalloc()</code>和<code>cudaFree()</code></p><p>分配了GPU内存后需要将cpu内存上的数据copy到设备上,利用<code>cudaMemcpy</code></p><p>然后调用kernel(内核执行配置&lt;<1,1>&gt;&gt;表示内核启动时只有1个线程),在设备上执行,最后进行free<code>cudaFree(void *devPtr);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaMalloc(void **devPtr, size_t count);</span><br><span class="line">cudaFree(void *devPtr);</span><br><span class="line">cudaMemcpy(void *dst, void *src, size_t count, cudaMemcpyKind kind)</span><br></pre></td></tr></table></figure><h4 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h4><p>NVIDIA提供了一个名为nvprof的命令行分析器工具，它可以更深入地了解CUDA程序的性能。</p><p>CUDA使用内核执行配置&lt;&lt;&lt;…&gt;&gt;&gt;告诉CUDA<strong>运行时在GPU上启动多少线程</strong></p><p>CUDA将线程组织成一个称为“thread block”的组。内核可以启动多个线程块，组织成一个“grid”结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; <span class="string">M , T &gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>表示启动M个线程块,每个线程块包括T个线程.</p><h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>CUDA为访问线程信息提供了内置变量。其中的<code>threadIdx.x</code>和<code>blockDim.x</code>分别表示,一个块内线程的索引以及一个块中线程数量.</p><p>假设在一个块内的多个线程执行并行程序.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__global__ void vector_add(float *out, float *a, float *b, int n) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int stride = 1</span><br><span class="line">    for(int i = index; i &lt; n; i += stride)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial02/01_parallel_thread.png" alt="parallel thread"></p><p>假设N个数据,一共256个线程,那么对于第k个线程,它会执行N/256次iteration,每次执行kernel中的代码</p><h4 id="thread-blocks"><a href="#thread-blocks" class="headerlink" title="thread blocks"></a>thread blocks</h4><p>CUDA gpu有几个并行处理器，称为流多处理器或SMs。每个SM由多个并行处理器组成，可以运行多个并发线程块。为了利用CUDA gpu，内核应该启动多个线程块。</p><p>对于block,有<code>blockIdx.x</code>以及<code>gridDim.x</code>分别表示块索引和块的数量.</p><p><img data-src="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial02/02_parallel_block.png" alt="parallel block"></p><p>要将线程分配给特定元素，我们需要知道每个线程的唯一索引。该指数可计算如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int tid <span class="operator">=</span> blockIdx.<span class="keyword">x</span> * blockDim.<span class="keyword">x</span> + threadaddx.<span class="keyword">x</span></span><br></pre></td></tr></table></figure><p>为了利用并行多线程的优势(否则就是多个线程计算相同的代码),需要将对应的数据索引修改为线程的索引.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 100000</span><br><span class="line">__global__ void addOfblocks(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">  int stride = blockDim.x * gridDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i += stride) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line">__global__ void addOfThreads(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = threadIdx.x;</span><br><span class="line">  int stride = blockDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i += blockDim) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  float *a, *out;</span><br><span class="line"></span><br><span class="line">  cudaMallocManaged(&amp;a, N * sizeof(float));</span><br><span class="line">  cudaMallocManaged(&amp;out, N * sizeof(float));</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = 2;</span><br><span class="line">    b[i] = 4;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add&lt;&lt;&lt;2, 4&gt;&gt;&gt;(N, a, b);</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">  cudaFree(a);</span><br><span class="line">  cudaFree(b);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 10000000</span><br><span class="line">__global__ void vector_add(float* out, float* a, float* b, int n) &#123;</span><br><span class="line">  int stride = 1;</span><br><span class="line">  for (int i = 0; i &lt; n; i += stride) &#123;</span><br><span class="line">    out[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__ void cuda_hello() &#123;</span><br><span class="line">  printf(&quot;Hello from block %d, thread %d\n&quot;, blockDim.x, threadIdx.x);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  cuda_hello&lt;&lt;&lt;1, 4&gt;&gt;&gt;();</span><br><span class="line">  float *a, *b, *out;</span><br><span class="line">  float *d_a, *d_b, *d_out;</span><br><span class="line">  a = (float*)malloc(N * sizeof(float));</span><br><span class="line">  b = (float*)malloc(N * sizeof(float));</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    b[i] = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  out = (float*)malloc(N * sizeof(float));</span><br><span class="line">  cudaMalloc((void**)&amp;d_b, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_b, b, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  cudaMalloc((void**)&amp;d_out, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_out, out, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  cudaMalloc((void**)&amp;d_a, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_a, a, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line">  vector_add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">  cudaMemcpy(out, d_out, sizeof(float) * N, cudaMemcpyDeviceToHost);</span><br><span class="line">  printf(&quot;out[0] = %f\n&quot;, out[0]);</span><br><span class="line">  cudaFree(d_a);</span><br><span class="line">  free(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// Kernel function to add the elements of two arrays</span><br><span class="line">__global__ void add(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = threadIdx.x;</span><br><span class="line">  int stride = blockDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i+=stride) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  int N = 1 &lt;&lt; 20;</span><br><span class="line">  float *x, *y;</span><br><span class="line"></span><br><span class="line">  // Allocate Unified Memory – accessible from CPU or GPU</span><br><span class="line">  cudaMallocManaged(&amp;x, N * sizeof(float));</span><br><span class="line">  cudaMallocManaged(&amp;y, N * sizeof(float));</span><br><span class="line"></span><br><span class="line">  // initialize x and y arrays on the host</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    x[i] = 1.0f;</span><br><span class="line">    y[i] = 2.0f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Run kernel on 1M elements on the GPU</span><br><span class="line">  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(N, x, y);</span><br><span class="line"></span><br><span class="line">  // Wait for GPU to finish before accessing on host</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">  // Check for errors (all values should be 3.0f)</span><br><span class="line">  float maxError = 0.0f;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) maxError = fmax(maxError, fabs(y[i] - 3.0f));</span><br><span class="line">  std::cout &lt;&lt; &quot;Max error: &quot; &lt;&lt; maxError &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // Free memory</span><br><span class="line">  cudaFree(x);</span><br><span class="line">  cudaFree(y);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ol><li><a href="https://github.com/cuda-mode/lectures?tab=readme-ov-file">cuda-mode/lectures: Material for cuda-mode lectures (github.com)</a></li><li><a href="https://github.com/CodedK/CUDA-by-Example-source-code-for-the-book-s-examples-/tree/master">CodedK/CUDA-by-Example-source-code-for-the-book-s-examples-: CUDA by Example, written by two senior members of the CUDA software platform team, shows programmers how to employ this new technology. The authors introduce each area of CUDA development through working examples. (github.com)</a></li><li><a href="https://gist.github.com/diorahman/648478c2c5c24d819f0f">CUDA Books: Self taught (github.com)</a> maybe this is what all we need.</li><li><a href="https://developer.nvidia.com/blog/even-easier-introduction-cuda/">An Even Easier Introduction to CUDA | NVIDIA Technical Blog</a></li><li><a href="https://github.com/whutbd/cuda-learn-note?tab=readme-ov-file">whutbd/cuda-learn-note: 🎉CUDA 笔记 / 高频面试题汇总 / C++笔记，个人笔记，更新随缘: sgemm、sgemv、warp reduce、block reduce、dot product、elementwise、softmax、layernorm、rmsnorm、hist etc. (github.com)</a></li><li><a href="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/">Tutorial 01: Say Hello to CUDA - CUDA Tutorial (cuda-tutorial.readthedocs.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为既对AI又对sys、hpc感兴趣的人来说,cuda编程应该是不可不看的,我也早有耳闻.这里简单学习一下.&lt;br&gt;</summary>
    
    
    
    
    <category term="cuda" scheme="https://www.sekyoro.top/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>typst学习与工具使用</title>
    <link href="https://www.sekyoro.top/2024/08/11/typst%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2024/08/11/typst%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-11T08:51:38.000Z</published>
    <updated>2024-08-29T12:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>目前使用Latex的的一些问题,也是很多新手常常遇到的</p><ul><li>一些命令不知道名字或者不知道是否有类似的命令,<strong>官方没有友好的reference</strong>.</li><li><strong>报错信息</strong>有些让人疑惑,一些标记语法写法让程序员很难受.</li><li><strong>Latex编译速度并不快</strong></li><li>本地编写Latex光装环境就难倒一批人.</li><li>一些库之间冲突太多,有些时候排版也不自然.</li></ul><p>于是我想尝试一些typst作为写一些小文章、简历甚至slides.</p><span id="more"></span><p>官方<a href="https://typst.app/">Typst: Compose papers faster</a>提供了在线的工具<a href="https://typst.app/">Typst: Compose papers faster</a>,目前社区也挺活跃的,当然写学术论文可能还是Latex占据绝大多数生态,不过在写个人文章或者简历方面Typst还是有优势的</p><p>下面以官方介绍和使用Latex的人的视角学学Typst.首先可以使用vscode安装相关插件或者官方在线工具方便协作(希望后期能超越Overleaf).</p><h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a>Scripting</h2><blockquote><p>像写代码一样写typst</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>在Typst中，标记和代码融合为一体。<strong>除了最常见的元素(加粗、斜体等表示)外，所有元素都是用函数创建的</strong>。为了尽可能方便，Typst提供了紧凑的语法来将代码表达式嵌入到标记中:用#符号引入表达式，在表达式完成后继续正常的标记解析。如果一个字符将继续表达式，但应被解释为文本，则表达式可以强制以分号(;)结束。</p><h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>有两种块,code blocks和content block,可以随意地嵌套</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#&#123;</span><br><span class="line">  let a = [from]</span><br><span class="line">  let b = [*world*]</span><br><span class="line">  [hello ]</span><br><span class="line">  a + [ the ] + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定和解构"><a href="#绑定和解构" class="headerlink" title="绑定和解构"></a>绑定和解构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#let name = &quot;Typst&quot;</span><br><span class="line">This is #name&#x27;s documentation.</span><br><span class="line">It explains #name.</span><br><span class="line"></span><br><span class="line">#let add(x, y) = x + y</span><br><span class="line">Sum is #add(2, 3).</span><br></pre></td></tr></table></figure><p>Let绑定也可以用来解构数组和字典。在这种情况下，赋值的左侧应该镜像一个数组或字典。. .操作符可以在模式中使用一次，以收集数组或字典项的剩余部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#let (x, y) = (1, 2)</span><br><span class="line">The coordinates are #x, #y.</span><br><span class="line"></span><br><span class="line">#let (a, .., b) = (1, 2, 3, 4)</span><br><span class="line">The first element is #a.</span><br><span class="line">The last element is #b.</span><br><span class="line"></span><br><span class="line">#let books = (</span><br><span class="line">  Shakespeare: &quot;Hamlet&quot;,</span><br><span class="line">  Homer: &quot;The Odyssey&quot;,</span><br><span class="line">  Austen: &quot;Persuasion&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#let (Austen,) = books</span><br><span class="line">Austen wrote #Austen.</span><br><span class="line"></span><br><span class="line">#let (Homer: h) = books</span><br><span class="line">Homer wrote #h.</span><br><span class="line"></span><br><span class="line">#let (Homer, ..other) = books</span><br><span class="line">#for (author, title) in other [</span><br><span class="line">  #author wrote #title.</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>if和loops</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if 1 &lt; 2 [</span><br><span class="line">  This is shown</span><br><span class="line">] else [</span><br><span class="line">  This is not.</span><br><span class="line">]</span><br><span class="line">#for c in &quot;ABC&quot; [</span><br><span class="line">  #c is a letter.</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#let n = 2</span><br><span class="line">#while n &lt; 10 &#123;</span><br><span class="line">  n = (n * 2) - 1</span><br><span class="line">  (n,)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>众所周知,我们常用的一些操作包括针对字体,包括斜体、加粗、各种数学格式，针对图(Figure)、表(Table,常用三线表)、公式(包括内联的以及占据整行的)￥%……&amp;*（|</p><p><img data-src="https://s2.loli.net/2024/08/11/ygxDBYOMmH2pCv5.png" alt="image-20240811172259678"></p><p>此外针对论文,有引用,论文参考,作者介绍(在Latex中常用<code>\thanks</code>)等等.上面列举了一些常用 素.</p><p>Typst目前的command有markup模式(默认)和code模式,markup模式就像是输入正常的内容,在进阶一点就是通过一些简单的标记markup改变内容表现,code模式及看起来更强大,能调用许多命令.</p><p>通过#使用code模式,[]在code模式中将使用content.</p><div class="table-container"><table><thead><tr><th>New mode</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Code</td><td>Prefix the code with <code>#</code></td><td><code>Number: #(1 + 2)</code></td></tr><tr><td>Math</td><td>Surround equation with <script type="math/tex">..</script></td><td><script type="math/tex">-x$ is the opposite of $x</script></td></tr><tr><td>Markup</td><td>Surround markup with <code>[..]</code></td><td><code>let name = [*Typst!*]</code></td></tr></tbody></table></div><h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p>code模式就像函数一样,有参数,也需要content(相当于输入).</p><blockquote><p>一个函数可以有多个参数。有些参数是位置参数。</p><p>许多函数使用命名参数而不是位置参数来提高可读性。</p></blockquote><p><img data-src="https://s2.loli.net/2024/08/11/iRjep4UnkyCWsOb.png" alt="image-20240811183015272" style="zoom: 80%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typst is an #underline[alternative]</span><br><span class="line">to LaTeX.</span><br><span class="line"></span><br><span class="line">#rect(fill: aqua)[Get started here!]</span><br></pre></td></tr></table></figure><h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Data type</th><th style="text-align:left">Example</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/content/">Content</a></td><td style="text-align:left"><code>[*fast* typesetting]</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/str/">String</a></td><td style="text-align:left"><code>&quot;Pietro S. Author&quot;</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/int/">Integer</a></td><td style="text-align:left"><code>23</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/float/">Floating point number</a></td><td style="text-align:left"><code>1.459</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/layout/length/">Absolute length</a></td><td style="text-align:left"><code>12pt</code>, <code>5in</code>, <code>0.3cm</code>, …</td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/layout/ratio/">Relative length</a></td><td style="text-align:left"><code>65%</code></td></tr></tbody></table></div><blockquote><p>内容和字符串之间的区别在于，内容可以包含标记，包括函数调用，而字符串实际上只是一个普通的字符序列</p></blockquote><p>Typst提供控制流结构和操作符，例如用于添加内容的+或用于检查两个变量之间是否相等的==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if 1 &lt; 2 [</span><br><span class="line">  This is shown</span><br><span class="line">] else [</span><br><span class="line">  This is not.</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="show-rule"><a href="#show-rule" class="headerlink" title="show rule"></a>show rule</h2><p>使用show规则，您可以重新定义Typst如何显示某些元素。指定Typst应该以不同的方式显示哪些元素以及它们的外观。Show规则可以应用于文本实例、许多函数，甚至整个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#show &quot;ArtosFlow&quot;: name =&gt; box[</span><br><span class="line">  #box(image(</span><br><span class="line">    &quot;logo.svg&quot;,</span><br><span class="line">    height: 0.7em,</span><br><span class="line">  ))</span><br><span class="line">  #name</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/08/11/VjBAwbrCaTmlitu.png" alt="image-20240811220712931" style="zoom:50%;" /></p><p>上面第一个也可以省略内容参数,直接写函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#show</span>: <span class="selector-tag">project</span><span class="selector-class">.with</span>(</span><br><span class="line">  <span class="attribute">theme</span>: rgb(<span class="string">&quot;#0F83C0&quot;</span>),</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">&quot;proanimer&quot;</span>,</span><br><span class="line">  <span class="attribute">title</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="attribute">contact</span>:(</span><br><span class="line">    contact(</span><br><span class="line">      <span class="attribute">text</span>: <span class="string">&quot;personal blog&quot;</span>,</span><br><span class="line">      <span class="attribute">link</span>: <span class="string">&quot;https://sekyoro.top&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    contact(</span><br><span class="line">      <span class="attribute">text</span>: <span class="string">&quot;gmail&quot;</span>,</span><br><span class="line">      <span class="attribute">link</span>:<span class="string">&quot;mailto:bukalala174@gmail.com&quot;</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="set-rule"><a href="#set-rule" class="headerlink" title="set rule"></a>set rule</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#set heading(numbering: &quot;I.&quot;)</span><br><span class="line">#set text(</span><br><span class="line">  font: &quot;New Computer Modern&quot;</span><br><span class="line">)</span><br><span class="line">#set text(</span><br><span class="line">  font: &quot;New Computer Modern&quot;,</span><br><span class="line">  size: 10pt</span><br><span class="line">)</span><br><span class="line">#set page(</span><br><span class="line">  paper: &quot;a6&quot;,</span><br><span class="line">  margin: (x: 1.8cm, y: 1.5cm),</span><br><span class="line">)</span><br><span class="line">#set par(</span><br><span class="line">  justify: true,</span><br><span class="line">  leading: 0.52em,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>show和set是两种全局设置样式的表达式,差别是show 更细致,针对选择的元素</p><ul><li><a href="https://typst.app/docs/reference/text/text/"><code>text</code></a> to set font family, size, color, and other properties of text</li><li><a href="https://typst.app/docs/reference/layout/page/"><code>page</code></a> to set the page size, margins, headers, enable columns, and footers</li><li><a href="https://typst.app/docs/reference/model/par/"><code>par</code></a> to justify paragraphs, set line spacing, and more</li><li><a href="https://typst.app/docs/reference/model/heading/"><code>heading</code></a> to set the appearance of headings and enable numbering</li><li><a href="https://typst.app/docs/reference/model/document/"><code>document</code></a> to set the metadata contained in the PDF output, such as title and autho</li></ul><h3 id="Field获取"><a href="#Field获取" class="headerlink" title="Field获取"></a>Field获取</h3><p>可以使用点表示法访问值上的字段。值可以是:</p><ul><li>a <a href="https://typst.app/docs/reference/foundations/dictionary/">dictionary</a> that has the specified key,</li><li>a <a href="https://typst.app/docs/reference/symbols/symbol/">symbol</a> that has the specified modifier,</li><li>a <a href="https://typst.app/docs/reference/foundations/module/">module</a> containing the specified definition,</li><li><a href="https://typst.app/docs/reference/foundations/content/">content</a> consisting of an element that has the specified field. The available fields match the arguments of the <a href="https://typst.app/docs/reference/foundations/function/#element-functions">element function</a> that were given when the element was constructed.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#let dict = (greet: &quot;Hello&quot;)</span><br><span class="line">#dict.greet \</span><br><span class="line">#emoji.face</span><br><span class="line"></span><br><span class="line">#let it = [= Heading]</span><br><span class="line">#it.body \</span><br><span class="line">#it.depth</span><br></pre></td></tr></table></figure><h2 id="实战写一个简历"><a href="#实战写一个简历" class="headerlink" title="实战写一个简历"></a>实战写一个简历</h2><p>你并不需要看每一个方法的介绍,看多了也没用,先来看看其他人怎么写的.</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先需要一个基本模板,模板中包括<strong>设置一些基本值</strong>,以及<strong>一些辅助函数</strong>.</p><p>基本值包括字体、页面等配置.一般使用<code>#set</code>和<code>#show</code>设置. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#set par(justify: true)</span><br><span class="line">#set text(</span><br><span class="line">font: &quot;Linux Libertine&quot;,</span><br><span class="line">size: 11pt,</span><br><span class="line">) </span><br><span class="line">#set page(</span><br><span class="line">paper: &quot;us-letter&quot;,</span><br><span class="line">header: align(</span><br><span class="line">  right + horizon,</span><br><span class="line">  title</span><br><span class="line">),</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line">//设置页面,段落与字体</span><br></pre></td></tr></table></figure><p>考虑通过一个show rule和函数包装起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#let conf(title,doc) = &#123;</span><br><span class="line">  set par(justify: true,)</span><br><span class="line">  set text(font:&quot;0xProto Nerd Font Propo&quot;,size:11pt)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  &quot;Paper title&quot;,</span><br><span class="line">  doc</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用命名参数,这样需要在写函数时设置默认值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#let conf(</span><br><span class="line">  title: none,</span><br><span class="line">  authors: (),</span><br><span class="line">  abstract: [],</span><br><span class="line">  doc,</span><br><span class="line">) = &#123;</span><br><span class="line">  // Set and show rules from before.</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  set align(center)</span><br><span class="line">  text(17pt, title)</span><br><span class="line"></span><br><span class="line">  let count = authors.len()</span><br><span class="line">  let ncols = calc.min(count, 3)</span><br><span class="line">  grid(</span><br><span class="line">    columns: (1fr,) * ncols,</span><br><span class="line">    row-gutter: 24pt,</span><br><span class="line">    ..authors.map(author =&gt; [</span><br><span class="line">      #author.name \</span><br><span class="line">      #author.affiliation \</span><br><span class="line">      #link(&quot;mailto:&quot; + author.email)</span><br><span class="line">    ]),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  par(justify: false)[</span><br><span class="line">    *Abstract* \</span><br><span class="line">    #abstract</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  set align(left)</span><br><span class="line">  columns(2, doc)</span><br><span class="line">&#125;</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  title: [Towards Improved Modelling],</span><br><span class="line">  authors: (</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Theresa Tungsten&quot;,</span><br><span class="line">      affiliation: &quot;Artos Institute&quot;,</span><br><span class="line">      email: &quot;tung@artos.edu&quot;,</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Eugene Deklan&quot;,</span><br><span class="line">      affiliation: &quot;Honduras State&quot;,</span><br><span class="line">      email: &quot;e.deklan@hstate.hn&quot;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  abstract: lorem(80),</span><br><span class="line">  doc,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在单独的文件中写模板,使用<code>import</code>导入并使用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;conf.typ&quot;: conf</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  title: [</span><br><span class="line">    Towards Improved Modelling</span><br><span class="line">  ],</span><br><span class="line">  authors: (</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Theresa Tungsten&quot;,</span><br><span class="line">      affiliation: &quot;Artos Institute&quot;,</span><br><span class="line">      email: &quot;tung@artos.edu&quot;,</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Eugene Deklan&quot;,</span><br><span class="line">      affiliation: &quot;Honduras State&quot;,</span><br><span class="line">      email: &quot;e.deklan@hstate.hn&quot;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  abstract: lorem(80),</span><br><span class="line">  doc,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">= Introduction</span><br><span class="line">#lorem(90)</span><br><span class="line"></span><br><span class="line">== Motivation</span><br><span class="line">#lorem(140)</span><br><span class="line"></span><br><span class="line">== Problem Statement</span><br><span class="line">#lorem(50)</span><br><span class="line"></span><br><span class="line">= Related Work</span><br><span class="line">#lorem(200)</span><br></pre></td></tr></table></figure><p>也可以使用<code>#import &quot;temp.typ&quot;: *</code>导入去掉命名空间. </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Call a function.</span><br><span class="line">#list([A], [B])</span><br><span class="line"></span><br><span class="line">// Named arguments and trailing</span><br><span class="line">// content blocks.</span><br><span class="line">#enum(start: 2)[A][B]</span><br><span class="line"></span><br><span class="line">// Version without parentheses.</span><br><span class="line">#list[A][B]</span><br></pre></td></tr></table></figure><p>函数是Typst的基本构建块。Typst提供了各种排版任务的函数。此外，您编写的标记是由函数支持的，所有的样式都是通过函数实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#let alert(body, fill: red) = &#123;</span><br><span class="line">  set text(white)</span><br><span class="line">  set align(center)</span><br><span class="line">  rect(</span><br><span class="line">    fill: fill,</span><br><span class="line">    inset: 8pt,</span><br><span class="line">    radius: 4pt,</span><br><span class="line">    [*Warning:\ #body*],</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#alert[</span><br><span class="line">  Danger is imminent!</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#alert(fill: blue)[</span><br><span class="line">  KEEP OFF TRACKS</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>函数有<code>with</code>和<code>where</code>,<code>with</code>返回一个预先应用了给定参数的新函数</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个选择器，该选择器筛选属于此函数的元素，其字段具有给定参数的值</span></span><br><span class="line">#show heading.where(level: 2): set text(blue)</span><br><span class="line"><span class="section">= Section</span></span><br><span class="line"><span class="section">== Subsection</span></span><br><span class="line"><span class="section">=== Sub-subection</span></span><br></pre></td></tr></table></figure><h3 id="看看别人的"><a href="#看看别人的" class="headerlink" title="看看别人的"></a>看看别人的</h3><p>我在Github上搜刮了一堆别人的模板,写的很不错. 主要使用的方法就是上面提到的函数、set rule,show rule以及map,join等方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#let contact(text:&quot;&quot;,link:none) = &#123;</span><br><span class="line">  (text:text,link:link)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let subSection(title:&quot;&quot;,titleEnd:none,subTitle:none,subTitleEnd:none,content:[]) = &#123;</span><br><span class="line">  (title:title,titleEnd:titleEnd,subTitle:subTitle,subTitleEnd:subTitleEnd,content:content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let section(title:&quot;&quot;,content:subSection()) = &#123;</span><br><span class="line">  (title:title,content:content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let project(</span><br><span class="line">  theme:rgb(&quot;#4273B0&quot;),</span><br><span class="line">  name:&quot;&quot;,</span><br><span class="line">  email:none,</span><br><span class="line">  title:none,</span><br><span class="line">  contact:((text:[],link:&quot;&quot;)),</span><br><span class="line">  skills:(</span><br><span class="line">    languages:()</span><br><span class="line">  ),</span><br><span class="line">  main:(</span><br><span class="line">   ( title:&quot;&quot;,content:[])</span><br><span class="line">  ),</span><br><span class="line">  sidebar:(),</span><br><span class="line">  body</span><br><span class="line">) = &#123;</span><br><span class="line">  let backgroundTitle(content) = &#123;</span><br><span class="line">    align(center,box(fill:theme,text(white,size:1.25em,weight:&quot;bold&quot;,upper(content)),width:1fr,inset:0.3em))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let secondaryTitle(content) = &#123;</span><br><span class="line">    text(weight:&quot;bold&quot;,size:1.125em,upper(content))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let italicColorTitle(content) = &#123;</span><br><span class="line">    text(weight:&quot;bold&quot;,style:&quot;italic&quot;,size:1.125em,theme,content)</span><br><span class="line">  &#125;</span><br><span class="line">  let contactColumn = align(center)[#contact.map(c =&gt; &#123;</span><br><span class="line">    if c.link == none [</span><br><span class="line">      #c.text\</span><br><span class="line">    ] else [</span><br><span class="line">      #underline(link(c.link,text(theme,c.text)))\</span><br><span class="line">    ]</span><br><span class="line">  &#125;).join()]</span><br><span class="line"></span><br><span class="line">  grid(</span><br><span class="line">    columns:(1fr,2fr),</span><br><span class="line">    column-gutter:2em,</span><br><span class="line">    contactColumn,</span><br><span class="line">    titleColumn</span><br><span class="line">  )</span><br><span class="line">  set par(justify: true)</span><br><span class="line">  let formattedLanguageSkills = [</span><br><span class="line">    #text(skills.languages.join(&quot; • &quot;))</span><br><span class="line">  ]</span><br><span class="line">  let createLeftRight(left:[],right:none)=&#123;</span><br><span class="line">    if(right == none) &#123;</span><br><span class="line">      align(start,text(left))</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      grid(</span><br><span class="line">        columns:(1fr,1fr),</span><br><span class="line">        align(start,text(left)),</span><br><span class="line">        align(end,right) </span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let parseSubSections(subSections) = &#123;</span><br><span class="line">    subSections.map(s=&gt;&#123;</span><br><span class="line">      [</span><br><span class="line">        #createLeftRight(</span><br><span class="line">          left:secondaryTitle(s.title),</span><br><span class="line">          right:if s.titleEnd != none [</span><br><span class="line">            #italicColorTitle(s.titleEnd)</span><br><span class="line">          ]</span><br><span class="line">        )</span><br><span class="line">        #if s.subTitle != none or s.subTitleEnd != none [</span><br><span class="line">          #text(top-edge: 0.2em,</span><br><span class="line">          createLeftRight(left: italicColorTitle(s.subTile),right:s.subTitleEnd)</span><br><span class="line">          )</span><br><span class="line">        ]</span><br><span class="line">        #s.content</span><br><span class="line">      ]</span><br><span class="line">    &#125;).join()</span><br><span class="line">  &#125;</span><br><span class="line">  let parseSection(seciton) = &#123;</span><br><span class="line">    section.map(m=&gt;&#123;</span><br><span class="line">      [</span><br><span class="line">        #backgroundTitle(m.title),</span><br><span class="line">        #parseSubSections(m.content)</span><br><span class="line">      ]</span><br><span class="line">    &#125;).join()</span><br><span class="line">  &#125;</span><br><span class="line">  let mainSection = parseSection(main)</span><br><span class="line">  let sidebarSection = parseSection(sidebar)</span><br><span class="line">  grid(</span><br><span class="line">    columns: (1fr,2fr),</span><br><span class="line">  column-gutter: 1em,</span><br><span class="line">  sidebarSection,</span><br><span class="line">  mainSection</span><br><span class="line">  )</span><br><span class="line">// Main body.</span><br><span class="line">  set par(justify:true)</span><br><span class="line">  show: columns.with(3,gutter:1.3em)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;template.typ&quot;: *</span><br><span class="line"></span><br><span class="line">#set page(</span><br><span class="line">  margin:(</span><br><span class="line">    left: 10mm,</span><br><span class="line">    right: 10mm,</span><br><span class="line">    top: 15mm,</span><br><span class="line">    bottom: 15mm</span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">#set text(font: &quot;Mulish&quot;)</span><br><span class="line"></span><br><span class="line">#show: project.with(</span><br><span class="line">  theme: rgb(&quot;#0F83C0&quot;),</span><br><span class="line">  name: &quot;proanimer&quot;,</span><br><span class="line">  title: &quot;Software Engineer&quot;,</span><br><span class="line">  contact:(</span><br><span class="line">    contact(</span><br><span class="line">      text: &quot;personal blog&quot;,</span><br><span class="line">      link: &quot;https://sekyoro.top&quot;</span><br><span class="line">    ),</span><br><span class="line">    contact(</span><br><span class="line">      text: &quot;gmail&quot;,</span><br><span class="line">      link:&quot;mailto:bukalala174@gmail.com&quot;</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  main:(</span><br><span class="line">    section(</span><br><span class="line">      title:&quot;Work Experience&quot;,</span><br><span class="line">      content:(</span><br><span class="line">        subSection(</span><br><span class="line">          title: &quot;Freelancer&quot;,</span><br><span class="line">          subTitle: &quot;Software Engineer&quot;,</span><br><span class="line">          content:list(</span><br><span class="line">            [&quot;Developed a personal blog using Gatsby and React, with a focus on performance and accessibility.&quot;],</span><br><span class="line">            [&quot;Implemented a custom CMS using React and Firebase, allowing for easy content management.&quot;],</span><br><span class="line">            [&quot;Optimized the blog for SEO, resulting in a 50% increase in organic traffic.&quot;],</span><br><span class="line">            [&quot;Designed and implemented a custom theme, resulting in a 30% increase in user engagement.&quot;]</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  sidebar:(</span><br><span class="line">    section(</span><br><span class="line">      title: &quot;Skills&quot;,</span><br><span class="line">      content:(</span><br><span class="line">        subSection(</span><br><span class="line">          title: &quot;Languages&quot;,</span><br><span class="line">          content: list(</span><br><span class="line">            [&quot;JavaScript&quot;, &quot;TypeScript&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      section(</span><br><span class="line">        title:&quot;Education&quot;,</span><br><span class="line">        content:(</span><br><span class="line">          subSection(</span><br><span class="line">            title: &quot;University of British Columbia&quot;,</span><br><span class="line">            titleEnd: &quot;Vancouver, BC&quot;,</span><br><span class="line">            subTitle: &quot;Bachelor of Computer Science&quot;,</span><br><span class="line">            subTitleEnd: &quot;(2018 - 2022)&quot;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>肯定没有必要使用typst写简历的,主要还是想替代Latex写点小论文或者文章,可以拿简历练练手.</p><p>如果真需要简历可以在网上填写信息直接生成.</p><h2 id="如何写一个幻灯片"><a href="#如何写一个幻灯片" class="headerlink" title="如何写一个幻灯片"></a>如何写一个幻灯片</h2><blockquote><p>用手拖来拖去制作幻灯片实在太麻烦了,我们喜欢简洁、可控与重用.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 为了跨项目重用构建块,可以创建和导入Typst包.包导入被指定为名称空间、名称和版本的三元组</span><br><span class="line">#import &quot;@preview/example:0.1.0&quot;: add</span><br><span class="line">#add(2, 7)</span><br></pre></td></tr></table></figure><p>使用编程的方式写ppt主要目的是为了方便写公式,图片摆放以及更加简洁.这里使用touying包制作,目前typst都是生成pdf格式的,也完全可以使用相关软件播放.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;@preview/touying:0.4.2&quot;: *</span><br><span class="line"></span><br><span class="line">#let s = themes.simple.register()</span><br><span class="line">#let (init, slides) = utils.methods(s)</span><br><span class="line">#show: init</span><br><span class="line"></span><br><span class="line">#let (slide, empty-slide) = utils.slides(s)</span><br><span class="line">#show: slides</span><br><span class="line"></span><br><span class="line">= Title</span><br><span class="line"></span><br><span class="line">This is written in Typst.</span><br><span class="line"></span><br><span class="line">== First Slide</span><br><span class="line"></span><br><span class="line">Hello, Touying!</span><br><span class="line">This is written in Typst.</span><br><span class="line">Attention = $frac(Q*K^(T),sqrt(d))*V$</span><br><span class="line"></span><br><span class="line">#pause</span><br><span class="line"></span><br><span class="line">Hello, Typst!</span><br></pre></td></tr></table></figure><p>最后说一下,利用<a href="https://github.com/jgm/pandoc">jgm/pandoc: Universal markup converter (github.com)</a>完全可以实现latex与typst互换.</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>目前使用感觉还是很不错,优点包括两个</p><ul><li>使用命令语法对程序员友好,官方文档全面</li><li>编译速度快,本地写也很方便</li></ul><p>如果要说缺点就是 生态相对Latex没那么好,如果想要实现一些效果网上可能没有现成方法,有些东西目前也没有支持<a href="https://typst.app/docs/roadmap/">Roadmap – Typst Documentation</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://typst.app/docs">Typst Documentation</a></li><li><a href="https://typst.app/universe/package/touying/">touying – Typst Universe</a> typst写幻灯片, 此外Latex也有beamer<a href="https://latex-beamer.com/quick-start/">LaTeX Beamer introduction / Quick-start guide - LaTeX Beamer (latex-beamer.com)</a>库类似的功能</li><li><a href="https://github.com/jgm/pandoc">jgm/pandoc: Universal markup converter (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前使用Latex的的一些问题,也是很多新手常常遇到的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些命令不知道名字或者不知道是否有类似的命令,&lt;strong&gt;官方没有友好的reference&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报错信息&lt;/strong&gt;有些让人疑惑,一些标记语法写法让程序员很难受.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Latex编译速度并不快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本地编写Latex光装环境就难倒一批人.&lt;/li&gt;
&lt;li&gt;一些库之间冲突太多,有些时候排版也不自然.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是我想尝试一些typst作为写一些小文章、简历甚至slides.&lt;/p&gt;</summary>
    
    
    
    
    <category term="写作" scheme="https://www.sekyoro.top/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>profile a deep learning model</title>
    <link href="https://www.sekyoro.top/2024/07/30/profile-a-deep-learning-model/"/>
    <id>https://www.sekyoro.top/2024/07/30/profile-a-deep-learning-model/</id>
    <published>2024-07-30T07:34:36.000Z</published>
    <updated>2024-07-31T03:54:33.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是大型软件、算法开发中容易被忽视同时也并不简单的一环,如何分析一个程序.这涉及到分析内存、使用一系列现有工具并进行可能冗长的测试. 但不管怎样,这是走向成熟应用关键的一步,</p><span id="more"></span><h3 id="如何进行性能分析"><a href="#如何进行性能分析" class="headerlink" title="如何进行性能分析"></a>如何进行性能分析</h3><blockquote><p>过早的性能分析是万恶之源</p></blockquote><p>你可以先完成程序的基本功能再进行优化,分析的方式和工具很多.最基础的包括计时.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure><p>考虑到一个程序执行时间包含太多部分,比如如果你的电脑同时跑着太多程序并且内存不太够,造成的中断等也会影响时间.</p><p>对于工具来说,需要区分真实时间、用户时间和系统时间.通常来说,用户时间+系统时间代表了进程所消耗的实际 CPU .</p><ul><li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）；</li><li><em>User</em> - CPU 执行用户代码所花费的时间；</li><li><em>Sys</em> - CPU 执行系统内核代码所花费的时间</li></ul><p>对于cpu,内存,事件分析以及可视化等,都有一系列工具处理,具体可看<a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h3 id="深度学习模型的性能分析"><a href="#深度学习模型的性能分析" class="headerlink" title="深度学习模型的性能分析"></a>深度学习模型的性能分析</h3><p>如何评估一个模型在实际部署或者推理时的效果,计算量和参数都是重要因素,一个限制GPU/CPU,一个限制内存.<br>此外对于图像或视频,fps也是重要因素,对于大模型而言就是输出token的速度,说白了就是输出时间,影响了实时性和用户使用体验,个人认为这个因素也跟计算量和参数相关.<br>那么如何计算模型计算量和参数量呢?<br>根据字面意思,参数量好理解,无非几种网络结构,每种网络结构都或多或少有参数,每个参数当作f32或者其他类型计算即可. 当然实际推理或者部署完全可以使用量化的方法得到整数,甚至是i8类型.这样就把参数量降低了,此外浮点数变成了整数,事实上计算也降低了复杂度,因为浮点数计算在CPU/GPU上往往更复杂.</p><p>这样一想,计算参数量就比较简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_param</span>(<span class="params">model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Calculate the number of parameters in the model.</span></span><br><span class="line"><span class="string">    :param model: model</span></span><br><span class="line"><span class="string">    :return: number of parameters</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    param_num =  <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">    <span class="built_in">print</span>(param_num*<span class="number">4</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">&#x27;MB&#x27;</span>) <span class="comment"># assume dtype float32</span></span><br></pre></td></tr></table></figure><p>那如何计算计算量呢,由于浮点数和整数运算上在CPU计算的不同,我们只考虑更为复杂的浮点数计算,就有了FLOPs. FLOPS计算如下,卷积层和全连接计算不同</p><p><img data-src="https://s2.loli.net/2024/07/30/QchEs9vxK1unXjH.png" alt="image-20240730111224462"></p><p>还有些地方使用的是MACs和MAdds,</p><p>MAC：Multiply Accumulate，乘加运算。乘积累加运算（英语：Multiply Accumulate, MAC）是在数字信号处理器或一些微处理器中的特殊运算。实现此运算操作的硬件电路单元，被称为“乘数累加器”。这种运算的操作，是将乘法的乘积结果和累加器的值相加，再存入累加器：</p><script type="math/tex; mode=display">a ← a + b × c</script><p>使用MAC可以将原本需要的两个指令操作减少到一个指令操作，从而提高运算效率。</p><blockquote><p>MAdds 本质上与 MACs 相同，都是指一次乘法和一次加法的组合。术语 MAdds 更常见于一些文献中，尤其是早期的文献。实际上，在大多数情况下，MACs 和 MAdds 可以互换使用.</p><p>1个 MACs 包含一个乘法操作与一个加法操作，大约包含2个 FLOPs。因此，通常 MACs 与 FLOPs 存在一个2倍的关系。(但是很多时候又会把它们会混淆合在一起)</p></blockquote><p>抽象地高度来说</p><blockquote><ul><li>计算量是指网络模型需要计算的<strong>运算次数</strong>，参数量是指网络模型自带的<strong>参数数量</strong>多少</li><li>计算量对应<strong>时间复杂度</strong>，参数量对应于<strong>空间复杂度</strong></li><li>计算量决定了<strong>网络执行时间的长短</strong>，参数量决定了占用显存的量</li></ul></blockquote><p><a href="https://blog.csdn.net/qq_33952811/article/details/124276599">5种方法获取Torch网络模型参数量计算量等信息_查看模型参数量-CSDN博客</a></p><h3 id="fvcore"><a href="#fvcore" class="headerlink" title="fvcore"></a>fvcore</h3><p>Meta的开源工具,包含pytorch layers,计算flop,计算参数,</p><p><strong>FlopCountAnalysis</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from fvcore<span class="selector-class">.nn</span> import FlopCountAnalysis</span><br><span class="line">flops = FlopCountAnalysis(model, input)</span><br><span class="line">flops<span class="selector-class">.total</span>()</span><br><span class="line">flops<span class="selector-class">.by_operator</span>()</span><br><span class="line"><span class="function"><span class="title">Counter</span><span class="params">(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">194616</span>, <span class="string">&#x27;addmm&#x27;</span>: <span class="number">80040</span>&#125;)</span></span></span><br><span class="line">flops<span class="selector-class">.by_module</span>()</span><br><span class="line">Counter(&#123;<span class="string">&#x27;&#x27;</span>: <span class="number">274656</span>, <span class="string">&#x27;conv1&#x27;</span>: <span class="number">48600</span>,</span><br><span class="line">         <span class="string">&#x27;conv2&#x27;</span>: <span class="number">146016</span>, <span class="string">&#x27;fc1&#x27;</span>: <span class="number">69120</span>,</span><br><span class="line">         <span class="string">&#x27;fc2&#x27;</span>: <span class="number">10080</span>, <span class="string">&#x27;fc3&#x27;</span>: <span class="number">840</span>&#125;)</span><br><span class="line">flops<span class="selector-class">.by_module_and_operator</span>()</span><br><span class="line">&#123;<span class="string">&#x27;&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">194616</span>, <span class="string">&#x27;addmm&#x27;</span>: <span class="number">80040</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;conv1&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">48600</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;conv2&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">146016</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc1&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">69120</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc2&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">10080</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc3&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">840</span>&#125;)&#125;</span><br></pre></td></tr></table></figure><p><strong>flop_count_table</strong></p><p>Format the per-module parameters and flops of a model in a table</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(flop_count_table(FlopCountAnalysis(model, inputs)))</span><br></pre></td></tr></table></figure><p>可以单独看某个模块的参数量和计算量.</p><h3 id="torch-profiler"><a href="#torch-profiler" class="headerlink" title="torch profiler"></a>torch profiler</h3><p>pytorch官方工具</p><blockquote><p>PyTorch Profiler是一个允许在训练和推理期间收集性能指标的工具。Profiler的上下文管理器API可以用来更好地理解哪些模型操作符是最昂贵的，检查它们的输入形状和堆栈跟踪，研究设备内核活动并可视化执行跟踪</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">with</span> profile(activities=[ProfilerActivity.CUDA], record_shapes=<span class="literal">True</span>, use_cuda=<span class="literal">True</span>) <span class="keyword">as</span> prof:</span><br><span class="line">        <span class="keyword">with</span> record_function(<span class="string">&quot;model_inference&quot;</span>):</span><br><span class="line">            model(input_data[<span class="string">&#x27;ego&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;GPU time sorted operators:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prof.key_averages().table(sort_by=<span class="string">&quot;cuda_time_total&quot;</span>, row_limit=<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPU time sorted operators:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prof.key_averages().table(sort_by=<span class="string">&quot;cpu_time_total&quot;</span>, row_limit=<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面计算了GPU和CPU的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.profiler.profile(</span><br><span class="line">    activities=[</span><br><span class="line">        torch.profiler.ProfilerActivity.CPU,</span><br><span class="line">        torch.profiler.ProfilerActivity.CUDA,</span><br><span class="line">    ]</span><br><span class="line">) <span class="keyword">as</span> p:</span><br><span class="line">    code_to_profile()</span><br><span class="line"><span class="built_in">print</span>(p.key_averages().table(</span><br><span class="line">    sort_by=<span class="string">&quot;self_cuda_time_total&quot;</span>, row_limit=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/31/3yWSVITxsYGHbR8.png" alt="image-20240731115415621"></p><h3 id="deepspeed"><a href="#deepspeed" class="headerlink" title="deepspeed"></a>deepspeed</h3><p>大模型训练的加速框架,微软开源的.一般的模型上面两个足以.这里不过多介绍.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> deepspeed.profiling.flops_profiler <span class="keyword">import</span> FlopsProfiler</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line">prof = FlopsProfiler(model)</span><br><span class="line"></span><br><span class="line">profile_step = <span class="number">5</span></span><br><span class="line">print_profile= <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">  <span class="comment"># start profiling at training step &quot;profile_step&quot;</span></span><br><span class="line">  <span class="keyword">if</span> step == profile_step:</span><br><span class="line">    prof.start_profile()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># forward() method</span></span><br><span class="line">  loss = model(batch)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># end profiling and print output</span></span><br><span class="line">  <span class="keyword">if</span> step == profile_step: <span class="comment"># if using multi nodes, check global_rank == 0 as well</span></span><br><span class="line">    prof.stop_profile()</span><br><span class="line">    flops = prof.get_total_flops()</span><br><span class="line">    macs = prof.get_total_macs()</span><br><span class="line">    params = prof.get_total_params()</span><br><span class="line">    <span class="keyword">if</span> print_profile:</span><br><span class="line">        prof.print_model_profile(profile_step=profile_step)</span><br><span class="line">    prof.end_profile()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># runs backpropagation</span></span><br><span class="line">  loss.backward()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># weight update</span></span><br><span class="line">  optimizer.step()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>除了上面几个之外,还有thop,stat以及ptflops等,其中一个问题时,很多库要求给出输出的tensor shape,但实际情况是输入的是一个list或者dict然后在模型中进行处理,为了避免模型改动,我推荐可以使用thop.</p></blockquote><h3 id="运行模型时间"><a href="#运行模型时间" class="headerlink" title="运行模型时间"></a>运行模型时间</h3><p>前面讲到如果要测试程序时间,并没有想的那么简单.在pytorch中提供了<code>torch.cuda.Event</code></p><p><a href="https://github.com/yifanlu0227/HEAL/blob/4882bd02514725fa5e2e5717d410de739f33790e/opencood/tools/profiler/params_calc.py">HEAL/opencood/tools/profiler/params_calc.py at 4882bd02514725fa5e2e5717d410de739f33790e · yifanlu0227/HEAL (github.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_throughput_cuda_event</span>(<span class="params">model, data</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start inference throughput performance test&quot;</span>)</span><br><span class="line">    run_num = <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;warm up ...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># warm up</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">            output = model(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;warm up done.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># synchronize 等待所有 GPU 任务处理完才返回 CPU 主线程</span></span><br><span class="line">    torch.cuda.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置用于测量时间的 cuda Event, 这是PyTorch 官方推荐的接口</span></span><br><span class="line">    starter, ender = torch.cuda.Event(enable_timing=<span class="literal">True</span>), torch.cuda.Event(enable_timing=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 初始化一个时间容器</span></span><br><span class="line">    run_num = <span class="number">200</span></span><br><span class="line">    timings = np.zeros((run_num,))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start testing ...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">            starter.record()</span><br><span class="line">            output = model(data)</span><br><span class="line">            ender.record()</span><br><span class="line">            torch.cuda.synchronize() <span class="comment"># 等待GPU任务完成</span></span><br><span class="line">            curr_time = starter.elapsed_time(ender) <span class="comment"># 从 starter 到 ender 之间用时,单位为毫秒</span></span><br><span class="line">            timings[i] = curr_time / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    infer_thro = run_num / timings.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;inference throughput (cuda event): &quot;</span>, infer_thro)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> infer_thro</span><br></pre></td></tr></table></figure><p>经过我自己测试,如果显存足够的情况下,很多时候直接使用time结果类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">    output = model(data)</span><br><span class="line">end_time = time.time()</span><br><span class="line">infer_thro = run_num / (end_time - start_time)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><p><a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p></li><li><p><a href="https://discuss.pytorch.org/t/correct-way-to-calculate-flops-in-model/67198/14">Correct way to calculate FLOPS in model - PyTorch Forums</a></p><p>以下是我看到的分析深度学习模型计算量和参数量的工具</p><ul><li><a href="https://pytorch.org/docs/stable/profiler.html">torch.profiler — PyTorch 2.4 documentation</a></li><li><a href="https://www.deepspeed.ai/tutorials/flops-profiler/">Flops Profiler - DeepSpeed</a></li><li><a href="https://github.com/facebookresearch/fvcore">facebookresearch/fvcore: Collection of common code that’s shared among different research projects in FAIR computer vision team. (github.com)</a> </li></ul></li></ol><p>profiler <a href="https://github.com/yifanlu0227/HEAL/tree/4882bd02514725fa5e2e5717d410de739f33790e/opencood/tools/profiler">HEAL/opencood/tools/profiler at 4882bd02514725fa5e2e5717d410de739f33790e · yifanlu0227/HEAL (github.com)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是大型软件、算法开发中容易被忽视同时也并不简单的一环,如何分析一个程序.这涉及到分析内存、使用一系列现有工具并进行可能冗长的测试. 但不管怎样,这是走向成熟应用关键的一步,&lt;/p&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
    <category term="profiler" scheme="https://www.sekyoro.top/tags/profiler/"/>
    
  </entry>
  
  <entry>
    <title>Go+HTMX: web开发降低心智负担的一种选择?</title>
    <link href="https://www.sekyoro.top/2024/07/27/go-htmx-web%E5%BC%80%E5%8F%91%E9%99%8D%E4%BD%8E%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85%E7%9A%84%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9/"/>
    <id>https://www.sekyoro.top/2024/07/27/go-htmx-web%E5%BC%80%E5%8F%91%E9%99%8D%E4%BD%8E%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85%E7%9A%84%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9/</id>
    <published>2024-07-27T02:35:43.000Z</published>
    <updated>2024-07-28T08:53:33.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>众所周知,一段时间前我一直在关注web开发框架,总的来说,大同小异. 如何进行快速开发小应用,是一个并不简单回答的问题.这里我给出一个解决方案:Go+HTMX.<br><span id="more"></span></p><p>这两个技术我不过多介绍,htmx顾名思义,在html上封了一层提供与后端交互的功能. 使用Go因为它的简洁且自带GC,不像c++和rust需要仔细小心管理内存,没有选用Java/C#也是因为后两者使用通常都要带上巨大的库(大型库会带来依赖上的安装、管理以及心智负担),在开发小应用时往往没有必要.  HTMX主要承担了一部分js的作用.</p><p>htmlx只有14k的大小,没有其他依赖,增强了html的功能. 再次说明,我介绍这个技术栈目的是为了快速开发中小应用,如果为了工作或是进一步学习,推荐Java/C#/Go等,再不济也是Python/PHP/Ruby.搭配vue/react/svelte/solid.</p><p>关于Go的web开发,常用Gin作为框架,主要写REST API和自带的模板引擎解析html,这里不多赘述.</p><p>下面介绍htmx的一些重要功能</p><h2 id="HTMX"><a href="#HTMX" class="headerlink" title="HTMX"></a>HTMX</h2><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>使用html的属性发送请求.</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Attribute</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-get/">hx-get</a></td><td style="text-align:left">Issues a <code>GET</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-post/">hx-post</a></td><td style="text-align:left">Issues a <code>POST</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-put/">hx-put</a></td><td style="text-align:left">Issues a <code>PUT</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-patch/">hx-patch</a></td><td style="text-align:left">Issues a <code>PATCH</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-delete/">hx-delete</a></td><td style="text-align:left">Issues a <code>DELETE</code> request to the given URL</td></tr></tbody></table></div><h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><p>通过<code>hx-trigger</code>设置触发动作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-post</span>=<span class="string">&quot;/mouse_entered&quot;</span> <span class="attr">hx-trigger</span>=<span class="string">&quot;mouseenter&quot;</span>&gt;</span></span><br><span class="line">    [Here Mouse, Mouse!]</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以设置mofiers和filters修改默认行为.</p><p>还可以使用轮询</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-get</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">hx-trigger</span>=<span class="string">&quot;every 2s&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-get</span>=<span class="string">&quot;/messages&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-trigger</span>=<span class="string">&quot;load delay:1s&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-swap</span>=<span class="string">&quot;outerHTML&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置indicator表明已经发出请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-get</span>=<span class="string">&quot;/click&quot;</span>&gt;</span></span><br><span class="line">    Click Me!</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;htmx-indicator&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/spinner.gif&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.htmx-request</span> <span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.htmx-request</span><span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当htmx发出请求时，它将把一个htmx-request类放到一个元素上(如果指定，可以是请求元素或另一个元素)。htmx-request类会使带有html-indicator类的子元素的不透明度变为1。</p><p>可以设置修改的元素.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-get</span>=<span class="string">&quot;/click&quot;</span> <span class="attr">hx-indicator</span>=<span class="string">&quot;#indicator&quot;</span>&gt;</span></span><br><span class="line">        Click Me!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;indicator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;htmx-indicator&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/spinner.gif&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>响应默认加载到请求的元素中,可以修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-get</span>=<span class="string">&quot;/trigger_delay&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-trigger</span>=<span class="string">&quot;keyup delay:500ms changed&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-target</span>=<span class="string">&quot;#search-results&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search-results&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>htmx提供了几种不同的方法来将返回的HTML交换到DOM.默认情况下,内容会替换目标元素的innerHTML.可以通过使用hx-swap属性来修改这个值:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>innerHTML</code></td><td style="text-align:left">the default, puts the content inside the target element</td></tr><tr><td style="text-align:left"><code>outerHTML</code></td><td style="text-align:left">replaces the entire target element with the returned content</td></tr><tr><td style="text-align:left"><code>afterbegin</code></td><td style="text-align:left">prepends the content before the first child inside the target</td></tr><tr><td style="text-align:left"><code>beforebegin</code></td><td style="text-align:left">prepends the content before the target in the target’s parent element</td></tr><tr><td style="text-align:left"><code>beforeend</code></td><td style="text-align:left">appends the content after the last child inside the target</td></tr><tr><td style="text-align:left"><code>afterend</code></td><td style="text-align:left">appends the content after the target in the target’s parent element</td></tr><tr><td style="text-align:left"><code>delete</code></td><td style="text-align:left">deletes the target element regardless of the response</td></tr><tr><td style="text-align:left"><code>none</code></td><td style="text-align:left">does not append content from response (<a href="https://htmx.org/docs/#oob_swaps">Out of Band Swaps</a> and <a href="https://htmx.org/docs/#response-headers">Response Headers</a> will still be processed)</td></tr></tbody></table></div><p>以上就是htmx中Ajax的基本使用,如果知道ajax的运作,那么使用就不会太难.</p><h3 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;Are you sure?&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-delete</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Delete My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-put</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Update My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个button继承了hx-confirm的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;Are you sure?&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-delete</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Delete My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-put</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Update My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;unset&quot;</span> <span class="attr">hx-get</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">        Cancel</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用unset取消</p><h3 id="增强表单和链接"><a href="#增强表单和链接" class="headerlink" title="增强表单和链接"></a>增强表单和链接</h3><p>HTML支持使用hx-boost属性“增强”常规HTML锚和表单.该属性将把所有锚标记和表单转换为AJAX请求,默认情况下,这些请求以页面主体为目标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-boost</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个div中的锚标记将向/blog发出一个AJAX GET请求，并将响应交换到body标记中</p><h3 id="配置响应处理"><a href="#配置响应处理" class="headerlink" title="配置响应处理"></a>配置响应处理</h3><p>htmx期望对它发出的AJAX请求的响应是HTML,通常是HTML片段(尽管与hx-select标记匹配的完整HTML文档也很有用).然后,HTML将返回的HTML交换到指定目标的文档中,并使用指定的交换策略.<br>有时您可能不希望在交换中执行任何操作,但仍然可能触发客户端事件.<br>对于这种情况,默认情况下,您可以返回204 - No Content响应代码，并且html将忽略响应的内容.<br>在服务器错误响应的事件中(例如404或501)，html将触发html:responseerror事件，你可以处理。<br>如果出现连接错误，将触发html:sendError事件。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">responseHandling: [</span><br><span class="line">     &#123;code:<span class="string">&quot;204&quot;</span>, swap: <span class="literal">false</span>&#125;,   <span class="comment">// 204 - No Content by default does nothing, but is not an error</span></span><br><span class="line">     &#123;code:<span class="string">&quot;[23]..&quot;</span>, swap: <span class="literal">true</span>&#125;, <span class="comment">// 200 &amp; 300 responses are non-errors and are swapped</span></span><br><span class="line">     &#123;code:<span class="string">&quot;[45]..&quot;</span>, swap: <span class="literal">false</span>, <span class="keyword">error</span>:<span class="literal">true</span>&#125;, <span class="comment">// 400 &amp; 500 responses are not swapped and are errors</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>可以配置下面这些选项:</p><ul><li><code>code</code> - a String representing a regular expression that will be tested against response codes.</li><li><code>swap</code> - <code>true</code> if the response should be swapped into the DOM, <code>false</code> otherwise</li><li><code>error</code> - <code>true</code> if htmx should treat this response as an error</li><li><code>ignoreTitle</code> - <code>true</code> if htmx should ignore title tags in the response</li><li><code>select</code> - A CSS selector to use to select content from the response</li><li><code>target</code> - A CSS selector specifying an alternative target for the response</li><li><code>swapOverride</code> - An alternative swap mechanism for the response</li></ul><h3 id="配置请求头和响应头"><a href="#配置请求头和响应头" class="headerlink" title="配置请求头和响应头"></a>配置请求头和响应头</h3><h4 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h4><p>htmx includes a number of useful headers in requests:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Header</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>HX-Boosted</code></td><td style="text-align:left">indicates that the request is via an element using <a href="https://htmx.org/attributes/hx-boost/">hx-boost</a></td></tr><tr><td style="text-align:left"><code>HX-Current-URL</code></td><td style="text-align:left">the current URL of the browser</td></tr><tr><td style="text-align:left"><code>HX-History-Restore-Request</code></td><td style="text-align:left">“true” if the request is for history restoration after a miss in the local history cache</td></tr><tr><td style="text-align:left"><code>HX-Prompt</code></td><td style="text-align:left">the user response to an <a href="https://htmx.org/attributes/hx-prompt/">hx-prompt</a></td></tr><tr><td style="text-align:left"><code>HX-Request</code></td><td style="text-align:left">always “true”</td></tr><tr><td style="text-align:left"><code>HX-Target</code></td><td style="text-align:left">the <code>id</code> of the target element if it exists</td></tr><tr><td style="text-align:left"><code>HX-Trigger-Name</code></td><td style="text-align:left">the <code>name</code> of the triggered element if it exists</td></tr><tr><td style="text-align:left"><code>HX-Trigger</code></td><td style="text-align:left">the <code>id</code> of the triggered element if it exists</td></tr></tbody></table></div><h4 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h4><ul><li><a href="https://htmx.org/headers/hx-location/"><code>HX-Location</code></a> - allows you to do a client-side redirect that does not do a full page reload</li><li><a href="https://htmx.org/headers/hx-push-url/"><code>HX-Push-Url</code></a> - pushes a new url into the history stack</li><li><code>HX-Redirect</code> - can be used to do a client-side redirect to a new location</li><li><code>HX-Refresh</code> - if set to “true” the client-side will do a full refresh of the page</li><li><a href="https://htmx.org/headers/hx-replace-url/"><code>HX-Replace-Url</code></a> - replaces the current URL in the location bar</li><li><code>HX-Reswap</code> - allows you to specify how the response will be swapped. See <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> for possible values</li><li><code>HX-Retarget</code> - a CSS selector that updates the target of the content update to a different element on the page</li><li><code>HX-Reselect</code> - a CSS selector that allows you to choose which part of the response is used to be swapped in. Overrides an existing <a href="https://htmx.org/attributes/hx-select/"><code>hx-select</code></a> on the triggering element</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger</code></a> - allows you to trigger client-side events</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger-After-Settle</code></a> - allows you to trigger client-side events after the settle step</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger-After-Swap</code></a> - allows you to trigger client-side events after the swap step</li></ul><p>htmx请求的顺序:</p><ul><li>元素被trigger<ul><li>收集需要发送的数据</li><li><code>htmx-request</code>类被放在元素上</li><li>通过AJAX异步地请求<ul><li>获得响应后与 <code>htmx-swapping</code>类地内容转换</li><li>可选的swap延迟</li><li>实际交换内容完成<ul><li><code>htmx-swapping</code> 类被移除</li><li><code>htmx-added</code> 类被添加到每个更改的元素上</li><li><code>htmx-settling</code> 类添加到target上</li><li>默认延迟</li><li>DOM完成</li><li><code>htmx-settling</code> 被移除</li><li><code>htmx-added</code>类被移除</li></ul></li></ul></li></ul></li></ul><h3 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h3><ol><li><a href="https://www.youtube.com/watch?v=jeT8m7490Pg">https://www.youtube.com/watch?v=jeT8m7490Pg</a></li><li><a href="https://htmx.org/"> htmx - high power tools for html</a>事实上,htmx是有争议的技术,但不妨碍它依旧很受欢迎</li><li><a href="https://golang-china.github.io/gopl-zh/ch1/ch1-01.html">Hello, World - Go语言圣经 (golang-china.github.io)</a></li><li><a href="https://golang.google.cn/learn/">Get Started - The Go Programming Language (google.cn)</a></li><li>More htmx examples<a href="https://htmx.org/examples/"> htmx ~ Examples</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知,一段时间前我一直在关注web开发框架,总的来说,大同小异. 如何进行快速开发小应用,是一个并不简单回答的问题.这里我给出一个解决方案:Go+HTMX.&lt;br&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
    <category term="htmx" scheme="https://www.sekyoro.top/tags/htmx/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2025-03-25T08:28:26.634Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TinyWebServer项目学习</title>
    <link href="https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2025/03/20/TinyHttpServer%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-20T09:46:11.000Z</published>
    <updated>2025-03-25T08:28:26.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>经典的C++ Linux网络编程项目.<br><span id="more"></span></p><blockquote><p>不相关的话:</p><p>C++后端相关项目集中体现在:Linux环境编程,网络编程,并发(多线程)编程</p><p>常见项目就是webserver以及基于moduo等库进行业务开发(聊天服务,结合mysql,redis)等.比如下面项目:</p><p><a href="https://zhuanlan.zhihu.com/p/688641400">从易到难，推荐9个适合练手的C++项目 - 知乎</a></p><p><a href="https://www.cnblogs.com/xiaokang-coding/p/18531816">应届生必看！23 个高质量 C++ 项目推荐，校招简历秒加分 - 江小康 - 博客园</a></p><p><a href="https://www.nowcoder.com/discuss/353157418395836416">我整理了10个可以写到简历上的C++项目_牛客网</a></p><p><a href="https://zhuanlan.zhihu.com/p/17138007124">GitHub项目推荐—适合练手的13个C++开源项目 - 知乎</a></p></blockquote><h2 id="并发同步方法"><a href="#并发同步方法" class="headerlink" title="并发同步方法"></a>并发同步方法</h2><p>在多线程并发条件下,对于共享资源,需要用锁机制解决.在c++标准中,有<code>mutex</code>,<code>condition_variable</code>以及新增的<code>barrier</code>,<code>latch</code>,<code>counting_semaphore</code>等机制.</p><p>这里使用了linux上的信号量<code>sem_t</code>和<code>pthread_mutex_t</code>锁机制.</p><h3 id="sem-t"><a href="#sem-t" class="headerlink" title="sem_t"></a>sem_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> waitSeconds)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(waitSeconds));</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem); <span class="comment">// 尝试获取信号量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; is running.\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem); <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 初始化信号量，初始值为2</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(task, <span class="string">&quot;A&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(task, <span class="string">&quot;B&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(task, <span class="string">&quot;C&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;sem); <span class="comment">// 销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>sem_wait</code> 函数用于等待一个信号量。它会尝试减少（减1）信号量的计数值。如果信号量的值大于0，则该函数会将信号量的值减1，并立即返回。</p><p>如果信号量的值为0，则调用 <code>sem_wait</code> 的线程或进程会被阻塞，直到另一个线程或进程通过调用 <code>sem_post</code> 增加了信号量的值，使得其大于0为止。</p><p>常用于表示“获取”一个资源或进入临界区。<strong>当信号量代表可用资源的数量时，<code>sem_wait</code> 可以理解为尝试占用一个资源。</strong>成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code></p><p>​    <code>sem_post</code>函数用于增加（加1）信号量的计数值，并通知可能正在等待该信号量的一个线程或进程。该函数总是成功地将信号量的值加1。</p><p>如果有其他线程或进程正在等待这个信号量（即因为信号量的值为0而被阻塞），那么其中一个等待的线程或进程会被唤醒并继续执行。常用于表示“释放”一个资源或离开临界区。<strong>当某个线程完成了对共享资源的操作后，可以通过调用 <code>sem_post</code> 来通知其他线程可以继续操作该资源</strong>。成功时返回 <code>0</code>,失败时返回 <code>-1</code> 并设置 <code>errno</code></p><h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITERATIONS 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">increment_counter</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 加锁</span></span><br><span class="line">        ++counter;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Mutex init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_mutex_t</code> 是 POSIX 线程（也称为 pthreads）库中用于实现互斥锁（mutex）的数据类型。互斥锁是一种同步机制，用于保护共享资源免受并发访问的影响，从而避免数据竞争和不一致的状态。</p><p>互斥锁：互斥锁是一种同步原语，用于确保在任何给定时间只有一个线程可以访问特定的代码段或共享资源。</p><p>初始化与销毁：互斥锁需要先初始化才能使用，并且在不再需要时应该被销毁以释放相关资源。</p><p>加锁与解锁：通过 <code>pthread_mutex_lock()</code> 和 <code>pthread_mutex_unlock()</code> 函数来控制对临界区的访问。</p><ol><li><p><strong>初始化互斥锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要初始化的互斥锁指针。</li><li><code>attr</code>: 互斥锁属性（通常可以传入 <code>NULL</code> 使用默认属性）。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>销毁互斥锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要销毁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>加锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要加锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li><li><p><strong>尝试加锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要尝试加锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，如果锁已经被其他线程持有则返回 <code>EBUSY</code>，失败返回其他错误码。</li></ul></li><li><p><strong>解锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mutex</code>: 要解锁的互斥锁指针。</li><li>返回值：成功返回 <code>0</code>，失败返回错误码。</li></ul></li></ol><h3 id="pthread-cond-t"><a href="#pthread-cond-t" class="headerlink" title="pthread_cond_t"></a>pthread_cond_t</h3><p>在 POSIX 线程（也称为 pthreads）中，条件变量（<code>pthread_cond_t</code>）是一种用于线程间通信的同步机制。条件变量允许一个线程等待某个条件成立，而另一个线程可以在满足条件时通知等待的线程继续执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = <span class="built_in">rand</span>() % <span class="number">100</span>; <span class="comment">// 生产随机数</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex); <span class="comment">// 缓冲区满，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(item);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_var); <span class="comment">// 通知消费者</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex); <span class="comment">// 缓冲区空，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        item = <span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond_var); <span class="comment">// 通知生产者</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumed: %d\n&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> prod_thread, cons_thread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond_var, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;prod_thread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cons_thread, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(prod_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cons_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond_var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>初始化条件变量</strong></p><ul><li><p>```c++<br>int pthread_cond_init(pthread_cond_t <em>cond, const pthread_condattr_t </em>attr);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 指向要初始化的条件变量。</span><br><span class="line"><span class="bullet">     -</span> <span class="code">`attr`</span>: 条件变量属性，通常设置为 <span class="code">`NULL`</span> 使用默认属性。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**销毁条件变量**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 要销毁的条件变量。</li><li>返回值：成功返回 <code>0</code>，错误则返回非零错误码。</li></ul></li></ul></li></ol><p>等待和通知</p><ol><li><p><strong>等待条件变量</strong></p><ul><li><p>```c++<br>int pthread_cond_wait(pthread_cond_t <em>cond, pthread_mutex_t </em>mutex);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 条件变量。</span><br><span class="line"><span class="bullet">     -</span> <span class="code">`mutex`</span>: 保护共享资源的互斥锁，必须是在调用前已经锁定的同一个互斥锁。</span><br><span class="line"><span class="bullet">     -</span> 功能：原子地解锁互斥锁并使当前线程进入等待状态，直到被其他线程通过 <span class="code">`pthread_cond_signal`</span> 或 <span class="code">`pthread_cond_broadcast`</span> 唤醒。唤醒后，在重新开始执行之前会自动重新获取互斥锁。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">**定时等待条件变量**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 条件变量。</li><li><code>mutex</code>: 保护共享资源的互斥锁。</li><li><code>abstime</code>: 绝对超时时间点，使用 <code>struct timespec</code> 定义。</li><li>功能：类似于 <code>pthread_cond_wait</code>，但是它会在指定的时间过后自动返回，即使条件尚未满足。</li><li>返回值：成功返回 <code>0</code>，超时返回 <code>ETIMEDOUT</code>，其他错误则返回相应的错误码。</li></ul></li></ul></li><li><p><strong>通知单个等待线程</strong></p><ul><li><p>```c++<br>int pthread_cond_signal(pthread_cond_t *cond);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">     -</span> <span class="code">`cond`</span>: 条件变量。</span><br><span class="line"><span class="bullet">     -</span> 功能：唤醒至少一个正在等待该条件变量的线程。如果有多个线程在等待，则具体唤醒哪一个由实现定义。</span><br><span class="line"><span class="bullet">     -</span> 返回值：成功返回 <span class="code">`0`</span>，错误则返回非零错误码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> <span class="strong">**广播通知所有等待线程**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```c++</span></span><br><span class="line"><span class="code">     int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br></pre></td></tr></table></figure><ul><li><code>cond</code>: 条件变量。</li><li>功能：唤醒所有正在等待该条件变量的线程。</li><li>返回值：成功返回 <code>0</code>，错误则返回非零错误码</li></ul></li></ul></li></ol><h2 id="异步日志写入"><a href="#异步日志写入" class="headerlink" title="异步日志写入"></a>异步日志写入</h2><p>文件读写是IO操作,会引起系统中断的耗时操作. 通过异步写入,</p><p>IO操作设计的阻塞/非阻塞与同步/异步区分:</p><ol><li><strong>阻塞 vs 非阻塞</strong>主要关注于如何处理未准备好数据的情况:是立即返回还是等待。</li><li><strong>同步 vs 异步</strong>则更多地涉及到整个I/O操作流程的设计理念:是否需要等待I/O操作完成才能继续执行。</li></ol><p>利用<strong>单例模式</strong>创建了日志类,这样每个线程都共享这个实例.</p><p>通过多线程写入文件,避免IO的阻塞.  如果使用异步写入,主线程将日志写入到一个阻塞列表,创建的读出线程读取这个阻塞列表并将内容写入文件. </p><p>这个过程涉及到生产者-消费者问题,在加入数据时,判断队列是否满,如果满则返回false表明不能再添加,同时唤醒条件变量等待的线程(也就是读取线程). 如果没满则添加数据,同时也唤醒读取线程.</p><p>当读取数据时,如果队列为空,则阻塞读取线程,释放锁,让写入线程写入阻塞列表(缓冲区). </p><p>所以异步日志创建时就会创建一个消费者线程用于读取数据并写入到文件. 设计一个缓冲区(阻塞队列),利用上面的并发同步方法,也就是一个生产者-消费者模型.</p><p>此外日志有根据日期写入到不同的文件,此外写入的行数超出要求的行数时会另外创建一个日志.</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>复用数据库的连接. 创建包含多个连接的连接池,初始化时根据账号密码以及数据库url创建连接存入list列表,这是个共享资源也需要使用锁进行保护. 这里使用信号量,根据连接数初始化信号量,每当获得一个连接,使用sem.wait(),信号量-1,信号量机制是当信号量为0时进行阻塞,否则减1. 当释放一个连接(将一个连接加入连接池),使用sem.post()信号量加1并唤醒阻塞线程. 对于一些共享资源,比如m_FreeConn和m_CurConn等变量进行锁保护.</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在I/O模型中，同步I/O和异步I/O主要的区别是内核向应用程序通知的是就绪事件还是完成事件，以及是由应用程序还是由内核来完成I/O的读写操作</p><blockquote><p>同步I/O：内核向应用程序通知就绪事件，由应用程序自身来完成I/O的读写操作<br>异步I/O：由内核来完成I/O的读写后向应用程序通知完成事件 </p></blockquote><p>在并发模式中，同步和异步的主要区别是<strong><em>\</em>功能完成的流程是否是顺序化的，是否需要等待**</strong> </p><blockquote><ul><li>同步：当遇到阻塞任务时，会一直等待，直到该任务处理完成，程序完全按照代码顺序执行；</li><li>异步：程序的执行需要由系统事件驱动，程序的执行是不确定的，没有顺序上的要求 </li></ul></blockquote><h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><h4 id="Reactor模式和Proactor模式"><a href="#Reactor模式和Proactor模式" class="headerlink" title="Reactor模式和Proactor模式"></a>Reactor模式和Proactor模式</h4><p>​    <strong>Reactor模式</strong>是一种事件驱动的设计模式，主要用于处理并发的输入操作（如网络连接或文件I/O）。它的主要思想是<strong>将所有I/O操作分派给一个专门的事件循环来处理，这个事件循环会监听多个事件源，并在相应的事件发生时调用对应的处理器（Handler）</strong>。这种模式非常适合于需要处理大量并发连接的应用程序，比如Web服务器。</p><blockquote><p>Reactor 模式的核心是使用事件循环监听多个文件描述符（如套接字），并在事件发生时调用相应的处理器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventHandler</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    fd_set read_fds; <span class="comment">// 监听的文件描述符集合</span></span><br><span class="line">    <span class="keyword">int</span> max_fd;      <span class="comment">// 最大文件描述符</span></span><br><span class="line">    std::vector&lt;EventHandler*&gt; handlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reactor</span>() : <span class="built_in">max_fd</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register_handler</span><span class="params">(<span class="keyword">int</span> fd, EventHandler* handler)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">FD_SET</span>(fd, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; max_fd) &#123;</span><br><span class="line">            max_fd = fd;</span><br><span class="line">        &#125;</span><br><span class="line">        handlers.<span class="built_in">push_back</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run_event_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            fd_set tmp_fds = read_fds;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;tmp_fds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Select error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_fd; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;tmp_fds)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> handler : handlers) &#123;</span><br><span class="line">                        handler-&gt;<span class="built_in">handle_event</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> :</span> <span class="keyword">public</span> EventHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(<span class="keyword">int</span> fd)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> bytes = <span class="built_in">read</span>(fd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Client disconnected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    <span class="keyword">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    sockaddr_in server_addr&#123;&#125;;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(server_fd, <span class="keyword">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;server_addr), <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line">    <span class="built_in">listen</span>(server_fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Reactor reactor;</span><br><span class="line">    ReadHandler read_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册服务器套接字</span></span><br><span class="line">    reactor.<span class="built_in">register_handler</span>(server_fd, &amp;read_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件循环</span></span><br><span class="line">    reactor.<span class="built_in">run_event_loop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>Proactor模式</strong>是一种异步的事件处理模式，与Reactor模式不同，它允许操作在后台执行，当操作完成时通知应用程序。通常，Proactor模式<strong>涉及到的操作如读写文件或网络I/O都是通过操作系统提供的异步I/O服务来实现</strong>的。然而，在某些不支持异步I/O的操作系统上，<strong>可以通过同步I/O结合多线程或者回调机制来模拟Proactor模式的效果。这意味着主线程可以提交I/O操作给一个工作线程池，然后继续处理其他任务</strong>，而工作线程会在I/O操作完成后通过某种方式（例如回调函数）通知主线程</p><blockquote><p>Proactor 模式依赖于异步 I/O 操作，通常由操作系统提供支持。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proactor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;aiocb*&gt; aio_controls; <span class="comment">// 异步 I/O 控制块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Proactor</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cb : aio_controls) &#123;</span><br><span class="line">            <span class="keyword">delete</span> cb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start_read</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">        aiocb* cb = <span class="keyword">new</span> <span class="built_in">aiocb</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cb, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(aiocb));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        cb-&gt;aio_fildes = fd;</span><br><span class="line">        cb-&gt;aio_buf = buffer;</span><br><span class="line">        cb-&gt;aio_nbytes = <span class="built_in"><span class="keyword">sizeof</span></span>(buffer) - <span class="number">1</span>;</span><br><span class="line">        cb-&gt;aio_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        aio_controls.<span class="built_in">push_back</span>(cb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">aio_read</span>(cb) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error starting async read.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async read started on fd: &quot;</span> &lt;&lt; fd &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_for_completion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cb : aio_controls) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">aio_error</span>(cb) == EINPROGRESS) &#123;</span><br><span class="line">                <span class="built_in">usleep</span>(<span class="number">1000</span>); <span class="comment">// 等待操作完成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ssize_t</span> bytes = <span class="built_in">aio_return</span>(cb);</span><br><span class="line">            <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Async read completed. Data: &quot;</span></span><br><span class="line">                          &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cb-&gt;aio_buf) &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Async read failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个文件进行异步读取</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Proactor proactor;</span><br><span class="line">    proactor.<span class="built_in">start_read</span>(fd); <span class="comment">// 开始异步读取</span></span><br><span class="line">    proactor.<span class="built_in">wait_for_completion</span>(); <span class="comment">// 等待完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>特性</th><th>Reactor 模式</th><th>Proactor 模式</th></tr></thead><tbody><tr><td><strong>核心机制</strong></td><td>同步 I/O，事件驱动</td><td>异步 I/O，操作系统支持</td></tr><tr><td><strong>适用场景</strong></td><td>高并发连接，如网络服务器</td><td>高性能 I/O 密集型应用</td></tr><tr><td><strong>复杂度</strong></td><td>较低，易于理解和实现</td><td>较高，需要操作系统支持异步 I/O</td></tr><tr><td><strong>效率</strong></td><td>受限于同步 I/O</td><td>更高效，I/O 操作在后台完成</td></tr><tr><td><strong>典型实现</strong></td><td><code>select</code>、<code>poll</code>、<code>epoll</code></td><td>POSIX AIO、Windows Overlapped I/O</td></tr></tbody></table></div><blockquote><ul><li>reactor模式中，主线程(<strong>I/O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I/O</strong>实现。</li><li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I/O</strong>实现。</li></ul></blockquote><h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><h4 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h4><p><strong>半同步/半异步（Half-Sync/Half-Async）模式</strong>是一种设计模式，用于处理不同类型的并发任务。它通过分离同步和异步的任务处理路径，使得系统能够更高效地管理资源并提高响应速度。这种模式特别适用于那些需要同时处理同步任务（如用户界面交互）和异步任务（如后台计算或I/O操作）的应用场景.</p><p><strong>同步层（Synchronous Layer）</strong>：负责处理需要立即响应的任务，例如用户界面的交互事件。这些任务通常要求快速响应以提供良好的用户体验。</p><p><strong>队列（Queue）</strong>：作为同步层和异步层之间的桥梁，用于传递消息或任务。同步层将任务放入队列中，异步层从队列中取出任务进行处理。</p><p><strong>异步层（Asynchronous Layer）</strong>：负责执行耗时较长的任务，比如文件I/O、网络通信或者复杂的计算。这些任务不会阻塞主线程，从而保证了系统的流畅性。</p><h4 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步/半反应堆模式"></a>半同步/半反应堆模式</h4><p><strong>半同步/半反应堆（Half-Sync/Half-Reactor）</strong>模式是一种混合的设计模式，它<strong>结合了同步和异步处理的优势来管理并发连接</strong>。这种模式通常用于服务器程序中，旨在提高系统的性能和可扩展性。</p><p><strong>Reactor部分</strong>：主要负责监听多个文件描述符（如套接字），并在相应的事件发生时（比如有新的连接请求或数据到达）通知对应的事件处理器。</p><ul><li>主线程运行一个事件循环，调用 <code>select</code>、<code>poll</code> 或者更高效的 <code>epoll</code> 等函数等待感兴趣的事件发生。</li><li>当检测到新的连接请求时，主线程接受该连接，并将其交给工作线程池中的某个线程处理。</li></ul><p><strong>Worker部分</strong>：每个工作线程独立地处理从主线程接收过来的具体连接上的读写操作。</p><ul><li>工作线程执行同步的I/O操作，这意味着它们会在读取或写入数据时阻塞，直到操作完成。</li><li>尽管如此，由于这些操作是在单独的线程中进行的，因此不会影响主线程对新连接的响应速度。</li></ul><h4 id="与半同步-半反应堆的区别"><a href="#与半同步-半反应堆的区别" class="headerlink" title="与半同步/半反应堆的区别"></a>与半同步/半反应堆的区别</h4><ul><li><strong>半同步/半反应堆</strong>：主要用于服务器程序中，其中主线程（Reactor部分）监听新的连接请求，然后将新建立的连接交给工作线程处理。这是一种专门针对网络编程的设计模式，强调的是如何有效地管理和分发多个并发连接。</li><li><strong>半同步/半异步模式</strong>：更加通用，不仅仅局限于网络编程。它可以应用于任何需要同时处理同步任务（如UI更新）和异步任务（如后台数据处理）的场景。其重点在于如何通过分离同步和异步的任务处理路径来优化系统性能和响应速度。</li></ul><p><a href="https://blog.csdn.net/qq_35423154/article/details/108930574?ops_request_misc=%7B%22request%5Fid%22%3A%22168103147416800192255531%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168103147416800192255531&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-108930574-null-null.142^v82^insert_down1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=半同步%2F半异步并发模式&amp;spm=1018.2226.3001.4187">Linux网络编程 | 并发模式：半同步/半异步模式、领导者/追随者模式_linux 网络编程 leadfollow模式-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/58860015">高山仰之可极，谈半同步/半异步网络并发模型 - 知乎</a></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>五种I/O模型</p><blockquote><ul><li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</li><li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li><li><strong>IO复用</strong>:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li><li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p><strong>注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。</strong></p></blockquote><p><strong>IO多路复用</strong>是一种允许单个进程监视多个文件描述符（如套接字、管道等）的技术，当其中任意一个文件描述符准备好进行读写操作时，该技术能够通知应用程序。这种方法可以显著提高服务器程序的性能，因为它避免了为每个连接创建单独线程或进程所带来的开销。</p><blockquote><p>单线程Polling API的常规用法是：</p><p>让Polling API监控服务端socket的状态，然后开始死循循环，循环过程中主要有三种逻辑分支：</p><ol><li>服务端socket的状态变为可读，即表示有客户端发起连接，此时就调用accept建立连接，得到一个客户端fd。将其加入到Polling API的监控集合，并标记其为可读。</li><li>客户端fd的状态变为可读，则调用read/recv从fd读取数据，然后执行业务逻辑，处理完，再将其加入到Polling API的监控集合，并标记其为可写。</li><li>客户端fd的状态变为可写，则调用write/send将数据发送给客户端。</li></ol></blockquote><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select</code>函数监视一组文件描述符，等待它们中的任何一个变为可读、可写或发生异常条件。</p><p>通过三个位图（fd_set类型）来分别表示需要监视的可读、可写及异常事件集合。</p><p>当调用<code>select</code>时，<strong>内核会阻塞当前进程，直到指定的文件描述符集合中的至少一个准备就绪</strong>。</p><p>返回值有响应的文件描述符个数.如果超时，则返回0；如果出错，则返回-1。</p><ol><li><p>在调用 <code>select</code> 之前，你需要将感兴趣的文件描述符添加到 <code>fd_set</code> 中（通过 <code>FD_SET</code>）。</p></li><li><p>当 <code>select</code> 返回时，<strong><code>fd_set</code> 中的内容会被更新，仅保留那些已经“就绪”的文件描述符</strong>。</p></li><li><p>换句话说，<code>select</code> 会清除未就绪的文件描述符，只留下那些可以进行读、写或异常处理的文件描述符。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">          fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>nfds</code>: 要监视的最大文件描述符加1。</li><li><code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>: 分别指向要监视的可读、可写及异常事件的文件描述符集合。</li><li><code>timeout</code>: 等待的时间限制，若设置为NULL则无限期等待。</li></ul><ol><li><code>FD_ZERO</code></li></ol><ul><li><p><strong>功能</strong>：清空一个 <code>fd_set</code> 集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_SET</code></li></ol><ul><li><p><strong>功能</strong>：将一个特定的文件描述符添加到一个 <code>fd_set</code> 集合中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">FD_SET(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_CLR</code></li></ol><ul><li><p><strong>功能</strong>：从一个 <code>fd_set</code> 集合中移除一个特定的文件描述符。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">FD_CLR(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>FD_ISSET</code></li></ol><ul><li><p><strong>功能</strong>：检查一个特定的文件描述符是否在某个 <code>fd_set</code> 集合中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">FD_ISSET(<span class="params">int</span> <span class="params">fd</span>, <span class="params">fd_set</span> <span class="operator">*</span><span class="params">set</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>fd_set数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    <span class="comment">// __FD_SETSIZE = 1024 表示fd_set是个包含一个1024bit数组的结构体</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><h4 id="select示例代码"><a href="#select示例代码" class="headerlink" title="select示例代码"></a>select示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fds, active_fds;</span><br><span class="line"> <span class="keyword">int</span> max_fd = sockfd;</span><br><span class="line"> std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; clients_fd;</span><br><span class="line"> <span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line"> <span class="built_in">FD_SET</span>(sockfd, &amp;read_fds);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 轮询select 直到有连接</span></span><br><span class="line">   timeval timeout&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">   read_fds = active_fds;</span><br><span class="line">   <span class="comment">// select阻塞,直到相应文件描述符就绪(可读,可写或异常)</span></span><br><span class="line">   <span class="comment">// 成功返回时(&gt;=1),fd_set内容更新,仅保留就绪的fd</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">   <span class="built_in">errif</span>(ret &lt; <span class="number">0</span>, <span class="string">&quot;select failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;read_fds)) &#123;</span><br><span class="line">     <span class="comment">// 服务器可读(有connect连接)</span></span><br><span class="line">     sockaddr_in client_addr;</span><br><span class="line">     <span class="keyword">socklen_t</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">     <span class="built_in">bzero</span>(&amp;client_addr, client_addr_len);</span><br><span class="line">     <span class="keyword">int</span> client_sockfd =</span><br><span class="line">         <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     <span class="built_in">FD_SET</span>(client_sockfd, &amp;active_fds);</span><br><span class="line">     max_fd = std::<span class="built_in">max</span>(client_sockfd, max_fd);</span><br><span class="line">     clients_fd.<span class="built_in">push_back</span>(client_sockfd);</span><br><span class="line"></span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;New connection, socket fd: &quot;</span> &lt;&lt; client_sockfd</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it = clients_fd.<span class="built_in">begin</span>(); it != clients_fd.<span class="built_in">end</span>();) &#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> client_fd = *it;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(client_fd, &amp;read_fds)) &#123;</span><br><span class="line">       <span class="comment">//客户端可读数据</span></span><br><span class="line">       <span class="comment">// 读取数据</span></span><br><span class="line">       <span class="keyword">char</span> read_bytes[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">       <span class="keyword">size_t</span> bytes_len = <span class="built_in">read</span>(client_fd, read_bytes, <span class="built_in"><span class="keyword">sizeof</span></span>(read_bytes));</span><br><span class="line">       <span class="keyword">if</span> (bytes_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;client closed...\n&quot;</span>;</span><br><span class="line">         <span class="built_in">close</span>(client_fd);</span><br><span class="line">         <span class="built_in">FD_CLR</span>(client_fd, &amp;active_fds);</span><br><span class="line">         it = clients_fd.<span class="built_in">erase</span>(it);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         std::string resp =</span><br><span class="line">             <span class="string">&quot;你好,你发送了&quot;</span> + std::<span class="built_in">string</span>(read_bytes, bytes_len);</span><br><span class="line">         <span class="built_in">errif</span>(<span class="built_in">write</span>(client_fd, resp.<span class="built_in">c_str</span>(), resp.<span class="built_in">size</span>()) == <span class="number">-1</span>,</span><br><span class="line">               <span class="string">&quot;write socket failed&quot;</span>);</span><br><span class="line">         ++it;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ++it;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;client_fd : clients_fd) &#123;</span><br><span class="line">   <span class="comment">// 关闭所有客户端</span></span><br><span class="line">   <span class="built_in">close</span>(client_fd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// close 关闭服务端</span></span><br><span class="line"> <span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>支持跨平台使用，几乎所有类Unix系统都支持。</li></ul><p><strong>缺点</strong></p><ul><li><strong>文件描述符集合大小有限制</strong>（通常为1024）。</li><li>每次调用都需要重新构建文件描述符集合。</li><li>效率较低，随着监听的文件描述符数量增加性能下降明显。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>poll</code>与<code>select</code>类似，但它使用了一个结构体数组来代替<code>select</code>中的位图。</p><p>这使得它可以处理更多数量的文件描述符，并且没有像<code>select</code>那样的固定上限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>fds</code>: 指向一个包含多个<code>pollfd</code>结构体的数组，每个结构体描述了一个文件描述符及其感兴趣的事件。</li><li><code>nfds</code>: 数组中元素的数量。</li><li><code>timeout</code>: 等待的时间限制，单位为毫秒。</li></ul><p>pollfd数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure describing a polling request.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> events;<span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> revents;<span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>fd</code></strong>：要监视的文件描述符。</p></li><li><p><code>events</code></p><p>：请求监视的事件类型，可以是以下标志的组合：</p><ul><li><code>POLLIN</code>：有数据可读。</li><li><code>POLLPRI</code>：有紧急数据可读。</li><li><code>POLLOUT</code>：准备好写数据。</li><li><code>POLLRDHUP</code>（自 Linux 2.6.17 起）：TCP连接被对端关闭，或对端关闭了写入一半的连接。</li><li><code>POLLERR</code>：发生错误。</li><li><code>POLLHUP</code>：挂起。</li><li><code>POLLNVAL</code>：无效请求；指定的文件描述符无效。</li></ul></li><li><p><strong><code>revents</code></strong>：实际发生的事件，由内核在 <code>poll</code> 调用返回时填充。</p></li></ul><p>事件类型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Event types that can be polled for.  These bits may be set in `events&#x27;</span></span><br><span class="line"><span class="comment">   to indicate the interesting event types; they will appear in `revents&#x27;</span></span><br><span class="line"><span class="comment">   to indicate the status of the file descriptor.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLIN0x001<span class="comment">/* There is data to read.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLPRI0x002<span class="comment">/* There is urgent data to read.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLOUT0x004<span class="comment">/* Writing now will not block.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Event types always implicitly polled for.  These bits need not be set in</span></span><br><span class="line"><span class="comment">   `events&#x27;, but they will appear in `revents&#x27; to indicate the status of</span></span><br><span class="line"><span class="comment">   the file descriptor.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLERR0x008<span class="comment">/* Error condition.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLHUP0x010<span class="comment">/* Hung up.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLNVAL0x020<span class="comment">/* Invalid polling request.  */</span></span></span><br></pre></td></tr></table></figure><h4 id="poll示例代码"><a href="#poll示例代码" class="headerlink" title="poll示例代码"></a>poll示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;pollfd&gt; poll_fds;</span><br><span class="line">pollfd server_pollfd;</span><br><span class="line">server_pollfd.fd = sockfd;</span><br><span class="line">server_pollfd.events = POLLIN; <span class="comment">// 设置事件</span></span><br><span class="line">poll_fds.<span class="built_in">push_back</span>(server_pollfd);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="built_in">poll</span>(poll_fds.<span class="built_in">data</span>(), poll_fds.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">errif</span>(ret &lt; <span class="number">0</span>, <span class="string">&quot;poll error&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (poll_fds.<span class="built_in">at</span>(<span class="number">0</span>).revents &amp; POLLIN) &#123;</span><br><span class="line">    <span class="comment">// 数据读入事件</span></span><br><span class="line">    <span class="comment">// serverfd可读,即可accept</span></span><br><span class="line">    sockaddr_in client_addr&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                           (<span class="keyword">socklen_t</span> *)&amp;addr_len);</span><br><span class="line">    <span class="built_in">errif</span>(client_fd == <span class="number">-1</span>, <span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pollfd client_pollfd;</span><br><span class="line">    client_pollfd.fd = client_fd;</span><br><span class="line">    client_pollfd.events = POLLIN;</span><br><span class="line">    poll_fds.<span class="built_in">push_back</span>(client_pollfd);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New connection, socket fd: &quot;</span> &lt;&lt; client_fd</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = poll_fds.<span class="built_in">begin</span>() + <span class="number">1</span>; it != poll_fds.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">char</span> bytes_read[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">    pollfd &amp;client_pollfd = *it;</span><br><span class="line">    <span class="keyword">size_t</span> read_bytes_len =</span><br><span class="line">        <span class="built_in">read</span>(client_pollfd.fd, bytes_read, <span class="built_in"><span class="keyword">sizeof</span></span>(bytes_read));</span><br><span class="line">    <span class="keyword">if</span> (read_bytes_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 关闭</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;client closed...\n&quot;</span>;</span><br><span class="line">      <span class="built_in">close</span>(client_pollfd.fd);</span><br><span class="line">      it = poll_fds.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// echo</span></span><br><span class="line">      std::string resp =</span><br><span class="line">          <span class="string">&quot;你好,你的请求是&quot;</span> + std::<span class="built_in">string</span>(bytes_read, read_bytes_len);</span><br><span class="line">      <span class="built_in">write</span>(client_pollfd.fd, resp.<span class="built_in">data</span>(), resp.<span class="built_in">size</span>());</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 关闭所有客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pfd : poll_fds) &#123;</span><br><span class="line">      <span class="built_in">close</span>(pfd.fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>不受文件描述符数量的限制。</li><li>对于大量文件描述符的情况比<code>select</code>更高效。</li></ul><p><strong>缺点</strong></p><ul><li>在大量文件描述符的情况下，效率仍然不高，因为每次调用都需要遍历整个文件描述符列表。</li></ul><p>对于大量文件描述符的情况，<code>poll</code> 的性能优于 <code>select</code>，因为它不需要每次调用前都重新初始化文件描述符集合。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul><li><code>epoll</code>是Linux特有的高级IO多路复用机制，旨在克服<code>select</code>和<code>poll</code>的局限性。</li><li><p>它采用事件驱动的方式，只有当某个文件描述符有事件发生时才会被通知，而不是每次都检查所有文件描述符的状态。</p></li><li><p><code>epoll_create1</code>: 创建一个新的epoll实例。</p></li><li><code>epoll_ctl</code>: 向epoll实例添加、修改或删除关注的文件描述符。</li><li><code>epoll_wait</code>: 等待事件的发生。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建epoll实例</span></span><br><span class="line"><span class="comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class="line"><span class="comment">   The &quot;size&quot; parameter is a hint specifying the number of file</span></span><br><span class="line"><span class="comment">   descriptors to be associated with the new instance.  The fd</span></span><br><span class="line"><span class="comment">   returned by epoll_create() should be closed with close().  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE</span></span><br><span class="line"><span class="comment">   parameter has been dropped.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 控制epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>当使用 <code>epoll_create</code> 或 <code>epoll_create1</code> 函数创建一个新的 <code>epoll</code> 实例时，<strong>Linux 内核会在内部创建一个“事件表”</strong>。<strong>这个事件表本质上是一个动态调整大小的数据结构，用来跟踪所有被注册到该 <code>epoll</code> 实例上的文件描述符及其感兴趣的事件类型</strong>（如可读、可写等）。通过这种方式，应用程序可以向内核注册多个文件描述符，并指定对每个文件描述符感兴趣的事件类型。</p></blockquote><p><strong>epoll_ctl</strong></p><ul><li><p><strong><code>epfd</code></strong>：指向由 <code>epoll_create</code> 或 <code>epoll_create1</code> 创建的 <code>epoll</code> 实例的文件描述符。</p></li><li><p><code>op</code></p><p>：指定要执行的操作类型，可以是以下值之一：</p><ul><li><strong><code>EPOLL_CTL_ADD</code></strong>：将新的文件描述符加入到 <code>epoll</code> 实例的监视列表中，并关联相应的事件。</li><li><strong><code>EPOLL_CTL_MOD</code></strong>：修改已经存在于 <code>epoll</code> 实例中的文件描述符所关注的事件。</li><li><strong><code>EPOLL_CTL_DEL</code></strong>：从 <code>epoll</code> 实例中移除一个文件描述符，不再监视其事件。</li></ul></li><li><p><strong><code>fd</code></strong>：要操作的目标文件描述符。</p></li><li><p><strong><code>event</code></strong>：指向 <code>struct epoll_event</code> 结构体的指针，包含与该文件描述符相关联的事件信息（当 <code>op</code> 是 <code>EPOLL_CTL_ADD</code> 或 <code>EPOLL_CTL_MOD</code> 时需要）。对于 <code>EPOLL_CTL_DEL</code> 操作，此参数可以为 <code>NULL</code>，因为此时仅关心移除文件描述符本身。</p></li></ul><p><strong>epoll_event结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>events</code></strong>：</p><ul><li>表示需要监视的事件类型。</li><li>它是一个位掩码（bitmask），可以是以下标志的组合：<ul><li><strong><code>EPOLLIN</code></strong>：表示文件描述符可读（有数据可读）。</li><li><strong><code>EPOLLOUT</code></strong>：表示文件描述符可写（可以写入数据）。</li><li><strong><code>EPOLLRDHUP</code></strong>：表示对端关闭了连接或关闭了写入方向（自 Linux 2.6.17 起支持）。</li><li><strong><code>EPOLLPRI</code></strong>：表示有紧急数据可读（例如带外数据）。</li><li><strong><code>EPOLLERR</code></strong>：表示发生了错误。</li><li><strong><code>EPOLLHUP</code></strong>：表示挂起（hang up），通常表示对端关闭了连接。</li><li><strong><code>EPOLLET</code></strong>：启用边缘触发模式（Edge-Triggered, ET）。默认是水平触发模式（Level-Triggered, LT）。</li><li><strong><code>EPOLLONESHOT</code></strong>：表示事件只会触发一次，之后需要重新添加到 <code>epoll</code> 实例中。</li></ul></li></ul></li><li><p><strong><code>data</code></strong>：</p><ul><li><p>这是一个联合体（union），允许用户将任意数据与文件描述符关联起来。</p></li><li><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>    *ptr;  <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="keyword">int</span>      fd;   <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> u32;  <span class="comment">// 32位无符号整数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;  <span class="comment">// 64位无符号整数</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>最常见的用法是通过 <code>fd</code> 字段存储文件描述符，以便在事件触发时快速定位对应的文件描述符。</p></li></ul></li></ul><h4 id="epoll示例代码"><a href="#epoll示例代码" class="headerlink" title="epoll示例代码"></a>epoll示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">errif</span>(epoll_fd == <span class="number">-1</span>, <span class="string">&quot;epoll creation failed&quot;</span>);</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENTS = <span class="number">10</span>;</span><br><span class="line"> epoll_event ev, events[MAX_EVENTS];</span><br><span class="line"> ev.events = POLLIN | EPOLLET; <span class="comment">// 水平触发模式</span></span><br><span class="line"> ev.data.fd = sockfd;</span><br><span class="line"> <span class="comment">// 添加服务端fd</span></span><br><span class="line"> ret = <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line"> <span class="built_in">errif</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ctl failed&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="comment">// 等待事件</span></span><br><span class="line">   <span class="keyword">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">errif</span>(nfds == <span class="number">-1</span>, <span class="string">&quot;epoll waut failed&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> ((events[<span class="number">0</span>].data.fd == sockfd) &amp;&amp; (events[<span class="number">0</span>].events &amp; POLLIN)) &#123;</span><br><span class="line">     <span class="comment">// accept就绪</span></span><br><span class="line">     sockaddr_in client_addr;</span><br><span class="line">     <span class="keyword">socklen_t</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">     <span class="keyword">int</span> client_fd =</span><br><span class="line">         <span class="built_in">accept</span>(sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     epoll_event ev;</span><br><span class="line">     ev.events = EPOLLIN | EPOLLET; <span class="comment">// 水平触发模式</span></span><br><span class="line">     ev.data.fd = client_fd;</span><br><span class="line">     <span class="comment">// 将客户端连接加入epoll实例</span></span><br><span class="line">     ret = <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;ev);</span><br><span class="line">     <span class="built_in">errif</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ctl failed&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_EVENTS; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (events[i].events &amp; POLLIN) &#123;</span><br><span class="line">       <span class="keyword">int</span> client_fd = events[i].data.fd;</span><br><span class="line">       <span class="comment">// read就绪</span></span><br><span class="line">       <span class="keyword">char</span> bytes_read[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">       <span class="keyword">size_t</span> bytes_read_len = <span class="built_in">read</span>(client_fd, bytes_read, <span class="built_in"><span class="keyword">sizeof</span></span>(bytes_read));</span><br><span class="line">       <span class="keyword">if</span> (bytes_read_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;client connection closed...\n&quot;</span>;</span><br><span class="line">         <span class="built_in">close</span>(client_fd);</span><br><span class="line">         <span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, <span class="literal">nullptr</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         std::string resp =</span><br><span class="line">             <span class="string">&quot;你好,你发送了:&quot;</span> + std::<span class="built_in">string</span>(bytes_read, bytes_read_len);</span><br><span class="line">         <span class="built_in">write</span>(client_fd, resp.<span class="built_in">data</span>(), resp.<span class="built_in">size</span>());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="built_in">close</span>(epoll_fd);</span><br></pre></td></tr></table></figure><ul><li>默认情况下，<code>epoll</code> 使用水平触发模式（Level-Triggered, LT），即只要文件描述符处于就绪状态，<code>epoll_wait</code> 就会一直返回。</li><li>通过设置 <code>EPOLLET</code> 标志，可以启用边缘触发模式（Edge-Triggered, ET）。在这种模式下，只有当文件描述符的状态发生变化时，<code>epoll_wait</code> 才会返回。</li></ul><p><strong>优点</strong></p><ul><li>高效地管理大量文件描述符。</li><li>只返回活跃的文件描述符，减少了不必要的上下文切换。</li><li>支持边缘触发（Edge Triggered）和水平触发（Level Triggered）两种模式。</li></ul><p><strong>缺点</strong></p><ul><li>仅适用于Linux操作系统，不具有跨平台兼容性。</li></ul><p><strong>注意事项</strong></p><ol><li><strong>边缘触发模式的使用</strong>：<ul><li>在边缘触发模式下，必须一次性读取完所有可用数据，否则可能会丢失事件。</li></ul></li><li><strong>错误处理</strong>：<ul><li>示例代码中包含了基本的错误处理，在实际应用中应更全面地处理各种异常情况。</li></ul></li><li><strong>缓冲区大小</strong>：<ul><li>确保 <code>BUFFER_SIZE</code> 足够大，以避免数据截断。</li></ul></li></ol><p>​    设置epoll触发事件时可以设置水平触发(LT)和边缘触发(ET).</p><p>如果使用 LT 模式，只要文件描述符处于就绪状态（例如，对于读操作而言，意味着有数据可读），每次调用 <code>epoll_wait()</code> 都会返回该文件描述符。这意味着<strong>即使没有完全读取所有可用的数据，在后续的 <code>epoll_wait()</code> 调用中，只要还有未处理的数据，这个文件描述符仍然会被标记为就绪</strong>。</p><p>​    ET 模式仅在文件描述符的状态发生变化时触发一次通知（即从不可读变为可读或反之）。这意味着如果你在一个 <code>epoll_wait()</code> 返回后没有完全处理完所有可用的数据，<strong>那么在下一次调用 <code>epoll_wait()</code> 之前，即使文件描述符仍然处于就绪状态，也不会再次收到通知。因此，你需要确保一次性读取尽可能多的数据直到没有更多数据为止</strong>。</p><ul><li><p>选择 LT 还是 ET 主要取决于你的应用需求</p><ul><li>如果你需要简单的实现，并且对偶尔的重复通知不敏感，LT 是更好的选择。</li><li>如果你追求高性能，并且能够保证每次都能高效地处理所有数据，ET 则可能更适合。</li></ul></li><li><p>通常建议</p><ul><li>对于大多数情况，默认使用 LT 模式即可满足需求。</li><li>在需要处理大量并发连接并且希望减少系统开销的情况下，可以考虑使用 ET 模式，但需要小心处理以避免错过事件。</li></ul><h4 id="LT-模式示例"><a href="#LT-模式示例" class="headerlink" title="LT 模式示例"></a><strong>LT 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line">event.data.fd = listen_sock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line">            <span class="comment">// 接受新连接...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理现有连接上的数据...</span></span><br><span class="line">            <span class="comment">// LT 模式下，如果有剩余数据未读，下次 epoll_wait 仍会通知</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ET-模式示例"><a href="#ET-模式示例" class="headerlink" title="ET 模式示例"></a><strong>ET 模式示例</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = listen_sock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_sock, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line">            <span class="comment">// 接受新连接...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ET 模式下，需要循环读取直到 EAGAIN 或 EWOULDBLOCK</span></span><br><span class="line">            <span class="keyword">while</span> ((nread = <span class="built_in">read</span>(events[i].data.fd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nread == <span class="number">-1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ET 模式的特点</strong>：只会在文件描述符状态发生变化时触发一次通知，因此需要开发者确保在每次事件触发时尽可能多地处理数据。</li><li>为什么需要 <code>while</code> 循环<ul><li>确保读取所有可用数据，避免遗漏。</li><li><strong>防止因为缓冲区大小限制或数据分段到达而导致未处理的数据残留</strong>。</li><li>提高数据处理的效率和可靠性。</li></ul></li></ul></li></ul><blockquote><p>在网络编程中，特别是在高并发场景下，以下情况可能导致数据未被完全读取：</p><ul><li><strong>TCP 流的特性</strong>：<ul><li>TCP 是面向流的协议，数据是以字节流的形式传输的，而不是固定大小的消息包。接收方可能会收到部分数据，也可能收到多个消息拼接在一起的数据。</li><li>即使当前已经触发了“可读”事件，你并不能假设一次 <code>read()</code> 调用就能读取到完整的数据块。</li></ul></li><li><strong>缓冲区的限制</strong>：<ul><li>每次调用 <code>read()</code> 时，操作系统内核会将数据从内核缓冲区复制到用户空间缓冲区。如果用户空间缓冲区不足以容纳所有数据，则只能读取一部分数据。</li><li>剩余的数据仍然存在于内核缓冲区中，但在 ET 模式下，如果没有新的事件触发，这些数据将不会被通知给应用程序。</li></ul></li></ul></blockquote><div class="table-container"><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td><strong>跨平台支持</strong></td><td>是</td><td>是</td><td>否（仅Linux）</td></tr><tr><td><strong>最大文件描述符数</strong></td><td>有限制（通常是1024）</td><td>无限制</td><td>无限制</td></tr><tr><td><strong>性能</strong></td><td>随文件描述符数量增加而降低</td><td>相对较好，但仍有改进空间</td><td>非常高效，适合高并发场景</td></tr><tr><td><strong>事件通知方式</strong></td><td>轮询所有文件描述符</td><td>轮询所有文件描述符</td><td>仅通知活跃的文件描述符</td></tr></tbody></table></div><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>实现了一个定时器,定时器包括截至时间,回调函数以及client_data.</p><p>超时的时候调用回调函数,执行将fd从epoll中去除并close(fd),user_count—的操作. 并实现定时器队列,按照定时器的截至事件升序.</p><p>webserver包含多个client_data,client_data包含fd,address以及定时器用于控制超时事件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WebServer::WebServer() &#123;</span><br><span class="line">  <span class="comment">// http_conn类对象</span></span><br><span class="line">  users = <span class="keyword">new</span> http_conn[MAX_FD]; <span class="comment">// 为每个连接创建一个http_conn和client_data对象</span></span><br><span class="line">  <span class="comment">// 用户数据</span></span><br><span class="line">  users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line">  <span class="comment">// root文件夹路径</span></span><br><span class="line">  <span class="keyword">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">  getcwd(server_path, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置文件根目录</span></span><br><span class="line">  <span class="keyword">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">  m_root = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">  <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关书籍和资料"><a href="#相关书籍和资料" class="headerlink" title="相关书籍和资料"></a>相关书籍和资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/689466361">《Linux高性能服务器编程》</a></li><li><a href="https://www.manongbook.com/linux/681.html">Linux多线程服务端编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/460399249">《TCP/IP网络编程》学习笔记 - 知乎</a></li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&amp;mid=2649274278&amp;idx=4&amp;sn=caa323faf0c51d882453c0e0c6a62282&amp;chksm=83ffbefeb48837e841a6dbff292217475d9075e91cbe14042ad6e55b87437dcd01e6d9219e7d&amp;cur_album_id=1339230165934882817&amp;scene=189#wechat_redirect">最新版Web服务器项目详解 - 02 半同步半反应堆线程池（上）</a></p><p>Unix环境高级编程</p><p>Unix网络编程</p><p>类似项目github上有很多</p><p><a href="https://github.com/forthespada/MyPoorWebServer">forthespada/MyPoorWebServer: 一款可运行的基于C++ 实现的WebServer服务器，基于《TCPIP网络编程》和《Linux高性能服务器编程》实现的服务器项目。</a></p><p><a href="https://github.com/linyacool/WebServer">linyacool/WebServer: A C++ High Performance Web Server</a></p><p><a href="https://github.com/Wlgls/30daysCppWebServer">Wlgls/30daysCppWebServer</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的C++ Linux网络编程项目.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
    <category term="webserver" scheme="https://www.sekyoro.top/tags/webserver/"/>
    
  </entry>
  
  <entry>
    <title>Java项目大赏(实习版)</title>
    <link href="https://www.sekyoro.top/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/"/>
    <id>https://www.sekyoro.top/2025/03/20/Java%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%B5%8F-%E5%AE%9E%E4%B9%A0%E7%89%88/</id>
    <published>2025-03-20T09:38:06.000Z</published>
    <updated>2025-03-20T09:58:04.849Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在准备实习,找一些<del>烂大街</del>经典项目练练手.<br><span id="more"></span></p><h2 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h2><h2 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h2><h3 id="基于Session的登陆"><a href="#基于Session的登陆" class="headerlink" title="基于Session的登陆"></a>基于Session的登陆</h3><p><img data-src="https://s2.loli.net/2025/03/20/VqbA8F34U17C9xZ.png" alt="image-20250320175751672"></p><h2 id="瑞吉外卖"><a href="#瑞吉外卖" class="headerlink" title="瑞吉外卖"></a>瑞吉外卖</h2><h2 id="谷粒商城"><a href="#谷粒商城" class="headerlink" title="谷粒商城"></a>谷粒商城</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在准备实习,找一些&lt;del&gt;烂大街&lt;/del&gt;经典项目练练手.&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://www.sekyoro.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP与HTTP编程</title>
    <link href="https://www.sekyoro.top/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.sekyoro.top/2025/03/12/TCP-IP%E4%B8%8EHTTP%E7%BC%96%E7%A8%8B/</id>
    <published>2025-03-12T07:05:02.000Z</published>
    <updated>2025-03-19T13:42:30.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>复习基础知识. TCP/IP以及HTTP是计算机网络以及互联网开发的基础.<br><span id="more"></span></p><p><a href="https://www.runoob.com/tcpip/tcpip-tutorial.html">TCP/IP 教程 | 菜鸟教程</a></p><p><a href="https://www.runoob.com/np/tcp-protocol.html">TCP 协议 | 菜鸟教程</a></p><p><a href="https://www.geeksforgeeks.org/tcp-ip-model/">TCP/IP Model - GeeksforGeeks</a></p><p><a href="https://www.w3school.com.cn/tcpip/index.asp">TCP/IP 教程</a></p><p><a href="https://liaoxuefeng.com/books/java/network/basic/index.html">网络编程基础 - Java教程 - 廖雪峰的官方网站</a></p><p>相关书籍:<a href="https://github.com/wengjianhong/Kunlun/tree/master/PDF">Kunlun/PDF at master · wengjianhong/Kunlun</a></p><p>Linux命令查看:<a href="https://www.man7.org/linux/man-pages/">Linux man pages online</a></p><p><a href="https://linux.die.net/">Linux Documentation</a></p><p><a href="https://www.kernel.org/doc/man-pages/">The Linux man-pages project</a></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP 是用于因特网 (Internet) 的通信协议。计算机通信协议是对那些计算机必须遵守以便彼此通信的的规则的描述。</p><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p><p>TCP/IP 指传输控制协议/网际协议（<strong>Transmission Control Protocol Internet Protocol</strong>）。</p><p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准</p><p><img data-src="https://s2.loli.net/2025/03/15/JdNpVR5weBxFmI2.png" alt="image-20250315132629613"></p><blockquote><p>通过数据链路层和传输层的数据都有限制,如图. 在传输层不能超过TCP最大报文段长度(MSS). 比如一次写入大于MSS的数据,再加上HTTP头部信息,超过了MSS后在传输层会将这些信息分段.</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/15/lxrdIhWqZcEs5tf.png" alt="image-20250315132914577"></p><blockquote><p>每个层会加上头部或头尾部</p></blockquote><p>TCP/IP协议栈属于操作系统(内核态)的行为,</p><p>应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发 数据的 TCP 和 UDP 协议，这两个传输协议会接受应⽤层的委托执⾏收发数据的操作。</p><p><img data-src="https://s2.loli.net/2025/03/15/aVJc2KbCXsxEvPh.png" alt="image-20250315164613174"></p><p>用户态通过使用socket库结合对应HTTP协议搭建应用程序</p><h4 id="传输层TCP协议"><a href="#传输层TCP协议" class="headerlink" title="传输层TCP协议"></a>传输层TCP协议</h4><blockquote><p>TCP数据包格式</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/15/GroHmCts5Z4WjJL.png" alt="image-20250315165319850"></p><p>​    ⾸先，源端⼝号和⽬标端⼝号是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤.</p><p>​     接下来有包的序号，这个是为了解决包乱序的问题。 还有应该有的是确认号，⽬的是确认发出去对⽅是否有收到.(超时重传,通过定时器和确认序号ack)</p><p>​    如果没有收到就应该重新发送，直到送达， 这个是为了解决丢包的问题。 接下来还有⼀些状态位。例如  SYN 是发起⼀个连接， ACK 是回复， RST 是重新连接， FIN 是结束连接等。TCP 是⾯向连接的，因⽽双⽅要维护连接的状态，这些带状态位的包的发送，会引起双⽅的状态 变更。 还有⼀个重要的就是窗⼝⼤⼩.(面向连接)</p><p>​    TCP 要做流量控制，通信双⽅各声明⼀个窗⼝（缓存⼤⼩），标识⾃⼰当前能够的处理能⼒，别发送的太快，撑死我，也别发的太慢，饿死我。 除了做流量控制以外.(流量控制,通过窗口大小的滑动窗口机制)</p><p>​    TCP还会做拥塞控制，对于真正的通路堵⻋不堵⻋，它⽆能为⼒，唯⼀能做的就是控制⾃⼰，也即控制发送的速度(TCP采用了几种算法来动态地调整发送速率以适应网络状况).</p><blockquote><ul><li><strong>流量控制</strong>专注于匹配发送方与接收方之间的处理能力，防止发送方发送超出接收方处理能力的数据量。</li><li><strong>拥塞控制</strong>则着眼于整个网络的状态，试图找到合适的发送速率，既不过度占用网络资源导致拥塞，也不过于保守浪费带宽。</li></ul></blockquote><ol><li>慢启动（Slow Start）</li></ol><p>当一个TCP连接开始时，发送方不知道网络的状态，也不知道接收方能够接受数据的速度。慢启动阶段通过指数增长的方式逐渐增加拥塞窗口（Congestion Window, cwnd）的大小，以便探测网络的容量。初始时，cwnd通常设置为一个小值（如1个最大段大小MSS）。每成功接收到一个ACK确认，cwnd就增加一个MSS。这个过程持续到遇到首个丢包事件或者达到慢启动阈值（ssthresh）。</p><ol><li>拥塞避免（Congestion Avoidance）</li></ol><p>一旦cwnd的值达到或超过ssthresh，TCP进入拥塞避免阶段。在这个阶段，cwnd的增长速度变缓，采用线性增长方式，即每次往返时间（RTT）只允许cwnd增加一个MSS/cwnd。这有助于更精细地探测网络的最大吞吐量，而不会像慢启动那样迅速使网络过载。</p><ol><li>快速重传（Fast Retransmit）</li></ol><p>快速重传机制用于在未超时的情况下检测到丢包。如果发送方连续收到三个对同一数据段的重复ACK，这意味着该数据段可能已经丢失，发送方将立即重传丢失的数据段，而不是等待定时器超时。这样做可以更快地恢复丢失的数据包，减少等待时间。</p><ol><li>快速恢复（Fast Recovery）</li></ol><p>快速恢复与快速重传配合使用。当发送方由于收到三次重复ACK而触发快速重传后，它会进入快速恢复状态。在此状态下，发送方不执行慢启动，而是调整ssthresh到当前cwnd的一半，并从那里继续尝试增大cwnd，直到不再收到重复的ACK为止。这有助于快速从丢包中恢复，而不必回到慢启动状态。</p><blockquote><p>连接时三次握手</p><p>这个所谓的「连接」，只是双⽅计算机⾥维护⼀个状态机，在连接建⽴的过程中，双⽅的状态变化时序图 </p></blockquote><p>在 HTTP 传输数据之前，⾸先需要 TCP 建⽴连接，TCP 连接的建⽴，通常称为三次握⼿。</p><p><img data-src="https://s2.loli.net/2025/03/15/ld7fpEhMHxOzgNt.png" alt="image-20250315165832577"></p><p>三次握⼿⽬的是保证双⽅都有发送和接收的能⼒。</p><p>使用netstat -antp,查看tcp连接状态</p><p><img data-src="https://s2.loli.net/2025/03/15/bQADsTaFn9R7oNt.png" alt="image-20250315173636652"></p><p><img data-src="https://s2.loli.net/2025/03/15/c7VGWhk6n3rS98C.png" alt="image-20250315181426136"></p><h4 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h4><p>TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</p><p><img data-src="https://s2.loli.net/2025/03/15/ne5z3l6mODxcG1J.png" alt="image-20250315182247041"></p><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为  TCP。 06 （⼗六进制）,表示协议为TCP</p><blockquote><p>在 Linux 操作系统,可以使⽤  route -n 命令查看当前系统的路由表</p></blockquote><p>IP数据包包括首部长度和总长度. 此外当IP数据包大于底层协议所允许的大小(MTU)时进行分片.</p><p>IP分片的主要特点：</p><ul><li><strong>标识（Identification）</strong>：所有分片都共享相同的标识值，以便目标主机可以识别这些分片属于同一个原始数据报。</li><li><strong>标志（Flags）</strong>：包含三个比特位，其中两个用于控制是否还有更多的分片以及是否允许分片。</li><li><strong>片偏移（Fragment Offset）</strong>：表示该分片在原始数据报中的位置，帮助接收端按照正确的顺序重组数据报。</li></ul><p>分片过程</p><ol><li>当一个IP数据包准备发送时，如果其大小超过了出站接口的MTU，则需要进行分片。</li><li>每个生成的分片<strong>都将包含源地址、目的地址、标识字段和标志字段等信息。</strong></li><li>除了最后一个分片外，其他所有分片都将填充到它们的最大长度，而最后一个分片可能小于最大长度。</li><li>接收方收到所有分片后，根据标识字段、标志字段和片偏移字段重组原始数据报</li></ol><p>⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。<strong>在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输</strong>。 ⼀般在 TCP/IP 通信⾥，MAC 包头的协议类型只使⽤： 0800 ： IP 协议 0806 ： ARP 协议</p><p>当不知道MAC地址时,需要  ARP 协议帮我们找到路由器的 MAC 地址。</p><blockquote><p>ARP 协议会在以太⽹中以⼴播的形式，对以太⽹所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC  地址告诉我”。 然后就会有⼈回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p></blockquote><p><strong>如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址</strong>。然后将这 个 MAC 地址写⼊ MAC 头部，MAC 头部就完成了。</p><p>操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间 就⼏分钟。 也就是说，在发包时： 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP  缓存中的地址。 ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询。</p><p>⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此需要将数字信息 转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。 负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序。 ⽹卡驱动获取⽹络包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符， 在末尾加上⽤于检测错误的帧校验序列</p><p><img data-src="https://s2.loli.net/2025/03/16/lRTEm9kAhZMtqD8.png" alt="image-20250316153840683"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是应用层协议,类似的应用层协议有FTP,SFTP,TELNET等. HTTP协议对于请求报文和响应报文有不同的格式要求. HTTP版本有1.0,1.1与2.0.</p><p><img data-src="https://s2.loli.net/2025/03/15/BpEqolHja4TALvS.png" alt="image-20250315154823886"></p><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><h3 id="IPV4与IPV6"><a href="#IPV4与IPV6" class="headerlink" title="IPV4与IPV6"></a>IPV4与IPV6</h3><h3 id="RPC与HTTP"><a href="#RPC与HTTP" class="headerlink" title="RPC与HTTP"></a>RPC与HTTP</h3><ul><li><strong>RPC（Remote Procedure Call，远程过程调用）</strong>:是一种协议，允许一个程序通过网络请求另一个地址空间中的子程序或服务，而无需了解底层网络细节。它旨在让开发者像调用本地函数一样调用远程服务。</li><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>:是一个用于传输超媒体文档的应用层协议，主要用于Web浏览器与Web服务器之间的通信。尽管最初设计是为了支持网页浏览，但HTTP也被广泛应用于构建RESTful API等服务接口</li></ul><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><ul><li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺 陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</li><li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次 握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。</li><li>两者的默认端⼝不⼀样，HTTP 默认端⼝号是 80，HTTPS 默认端⼝号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加⼊了  SSL/TLS 协议，可以解决安全⻛险： 信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。 校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴ 告。 身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p>代码随想录、阿秀、labuladong、小林coding、JavaGuide</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习基础知识. TCP/IP以及HTTP是计算机网络以及互联网开发的基础.&lt;br&gt;</summary>
    
    
    
    
    <category term="TCP/IP" scheme="https://www.sekyoro.top/tags/TCP-IP/"/>
    
    <category term="HTTP" scheme="https://www.sekyoro.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>mini-java-guide</title>
    <link href="https://www.sekyoro.top/2025/03/09/mini-java-guide/"/>
    <id>https://www.sekyoro.top/2025/03/09/mini-java-guide/</id>
    <published>2025-03-09T02:10:08.000Z</published>
    <updated>2025-03-27T15:41:17.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习很潮很流行的Java以及相关框架.<br><span id="more"></span></p><p><a href="https://liaoxuefeng.com/books/java/introduction/index.html">简介 - Java教程 - 廖雪峰的官方网站</a></p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java基础-1"><a href="#Java基础-1" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-java-lang"><a href="#1-java-lang" class="headerlink" title="1. java.lang.*"></a>1. java.lang.*</h3><p>这是默认导入的包，包含基本类和接口。</p><ul><li><strong>Object</strong>：所有类的超类。</li><li><strong>String</strong>：不可变字符串类，用于文本处理。</li><li><strong>StringBuilder/StringBuffer</strong>：可变字符串类，适用于频繁修改字符串的场景。<code>StringBuffer</code>是线程安全的版本。</li><li><strong>System</strong>：提供系统相关的信息和操作，如<code>System.out.println()</code>打印输出。</li><li><strong>Math</strong>：提供数学计算的方法，如三角函数、对数等。</li><li><strong>Integer, Double 等包装类</strong>：基本类型的对象表示形式，支持自动装箱/拆箱。</li></ul><h3 id="2-java-util"><a href="#2-java-util" class="headerlink" title="2. java.util.*"></a>2. java.util.*</h3><p>包含了集合框架、日期时间工具、随机数生成器等实用工具类。</p><ul><li><strong>Collection 接口及其实现类</strong>（如ArrayList, LinkedList, HashSet, TreeSet等）：提供了不同类型的集合实现。</li><li><strong>Map 接口及其实现类</strong>（如HashMap, TreeMap等）：键值对存储结构。</li><li><strong>Iterator</strong>：遍历集合的标准方式。</li><li><strong>Date, Calendar, LocalDate, LocalDateTime</strong>（Java 8+）：处理日期和时间。</li><li><strong>Random</strong>：生成伪随机数。</li><li><strong>Arrays</strong>：提供操作数组的各种静态方法。</li></ul><h3 id="3-java-io"><a href="#3-java-io" class="headerlink" title="3. java.io.*"></a>3. java.io.*</h3><p>提供输入输出流的支持，用于读写文件或进行网络通信。</p><ul><li><strong>InputStream/OutputStream</strong>：字节流基类。</li><li><strong>Reader/Writer</strong>：字符流基类。</li><li><strong>File</strong>：文件或目录路径名的抽象表示形式。</li><li><strong>BufferedReader/BufferedWriter, BufferedInputStream/BufferedOutputStream</strong>：提高I/O效率的缓冲类。</li></ul><h3 id="4-java-nio"><a href="#4-java-nio" class="headerlink" title="4. java.nio.*"></a>4. java.nio.*</h3><p>新的I/O API，提供了更高效的非阻塞I/O操作。</p><ul><li><strong>Path, Paths</strong>：用于处理文件系统路径。</li><li><strong>Files</strong>：提供对文件的操作方法。</li><li><strong>ByteBuffer</strong>及其他缓冲区类型：用于高效地管理字节序列。</li></ul><h3 id="5-java-net"><a href="#5-java-net" class="headerlink" title="5. java.net.*"></a>5. java.net.*</h3><p>网络编程相关的API。</p><ul><li><strong>URL, URI</strong>：统一资源定位符/标识符。</li><li><strong>URLConnection</strong>：与URL建立连接。</li><li><strong>Socket, ServerSocket</strong>：TCP/IP套接字编程的基础类。</li><li><strong>DatagramPacket, DatagramSocket</strong>：UDP协议的支持。</li></ul><h3 id="6-java-text"><a href="#6-java-text" class="headerlink" title="6. java.text.*"></a>6. java.text.*</h3><p>用于格式化和解析文本。</p><ul><li><strong>NumberFormat, DecimalFormat</strong>：数字格式化。</li><li><strong>DateFormat, SimpleDateFormat</strong>：日期格式化。</li><li><strong>MessageFormat</strong>：根据模式格式化消息。</li></ul><h3 id="7-java-time"><a href="#7-java-time" class="headerlink" title="7. java.time.*"></a>7. java.time.*</h3><p>Java 8引入的新日期时间API。</p><ul><li><strong>Instant</strong>：表示时间线上的一点。</li><li><strong>LocalDate, LocalTime, LocalDateTime</strong>：分别表示不带时区的日期、时间和日期时间。</li><li><strong>ZonedDateTime, OffsetDateTime</strong>：带有时区信息的日期时间。</li></ul><h3 id="8-并发相关"><a href="#8-并发相关" class="headerlink" title="8. 并发相关"></a>8. 并发相关</h3><ul><li><strong>Thread</strong>：创建和控制线程。</li><li><strong>Runnable</strong>：线程执行的目标接口。</li><li><strong>ExecutorService, Executors</strong>：更高级别的线程管理。</li><li><strong>Lock, ReentrantLock</strong>：比同步块更灵活的锁定机制。</li><li><strong>ConcurrentHashMap</strong>：线程安全的哈希表实现。</li></ul><h3 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h3><ul><li><strong>Optional</strong>（Java 8+）：避免空指针异常的一种设计模式。</li><li><strong>Stream API</strong>（Java 8+）：提供了一种高效且易于使用的集合元素处理方式。</li></ul><div class="table-container"><table><thead><tr><th>访问修饰符</th><th>同一类</th><th>同一包</th><th>子类（不同包）</th><th>全局</th></tr></thead><tbody><tr><td><code>public</code></td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td><code>protected</code></td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>默认</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td><code>private</code></td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></div><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>成员内部类,静态内部类,局部内部类,匿名内部类</p><p><img data-src="https://s2.loli.net/2025/03/19/XA1uEi8Q4GBOYeL.png" alt="image-20250319142346062"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">outerclass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String age;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">innerclass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is an inner class&quot;</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/oHwP9Ub47rKRhyu.png" alt="image-20250319142856906"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">innercls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is an inner class&quot;</span>);</span><br><span class="line">        System.out.println(innercls.<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img data-src="https://s2.loli.net/2025/03/19/BG9x3zCAEjU7IlX.png" alt="image-20250319144727002"></p><p><img data-src="https://s2.loli.net/2025/03/19/GyptQ1F3KcbhIZo.png" alt="image-20250319150803696"></p><h3 id="集合Collection与Map"><a href="#集合Collection与Map" class="headerlink" title="集合Collection与Map"></a>集合Collection与Map</h3><p>数组和集合的区别：</p><p>数组</p><ul><li><p><strong>固定大小</strong>：数组一旦创建，其大小是固定的，不能动态增加或减少元素。</p></li><li><p><strong>类型安全</strong>：数组可以是基本数据类型（如 <code>int[]</code>, <code>double[]</code>）或对象类型（如 <code>String[]</code>）。对于对象类型的数组，所有元素都必须是该类的实例或者 <code>null</code>。</p></li><li><p><strong>内存连续</strong>：数组中的元素在内存中是连续存储的，这使得访问速度非常快，因为可以通过计算偏移量直接访问任何元素（时间复杂度为 O(1)）。</p></li><li><p>声明方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个包含5个整数的数组</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;; <span class="comment">// 初始化时赋值</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ul><li>访问速度快，支持随机访问。</li><li>对于小规模、固定数量的数据集非常适合。</li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><strong>定义与特性</strong></p><ul><li><p><strong>动态大小</strong>：<code>List</code> 接口的主要实现类（如 <code>ArrayList</code>, <code>LinkedList</code>）允许动态添加和删除元素，这意味着你可以根据需要扩展或缩小列表的大小。</p></li><li><p><strong>接口与实现</strong>：<code>List</code> 是一个接口，常用的实现包括 <code>ArrayList</code> 和 <code>LinkedList</code>。<code>ArrayList</code> 底层基于数组实现，而 <code>LinkedList</code> 则是一个双向链表。</p></li><li><p><strong>类型安全</strong>：<code>List</code> 只能存储对象，不能直接存储基本数据类型（但可以使用自动装箱/拆箱功能处理基本数据类型）。</p></li><li><p>声明方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong></p><ul><li>动态大小，方便添加和删除元素。</li><li>提供了丰富的操作方法，比如 <code>add()</code>, <code>remove()</code>, <code>get()</code>, <code>indexOf()</code> 等等。</li><li>更好的抽象层次，代码更加灵活易读。</li></ul><p><strong>缺点</strong></p><ul><li>相比于数组，某些操作可能效率较低，例如在 <code>ArrayList</code> 中插入或删除中间位置的元素会导致其他元素移动；而在 <code>LinkedList</code> 中查找元素则需要从头或尾遍历整个列表。</li></ul><p>ArrayList使用数组实现,查询快,增删慢</p><p>LinkedList使用双向链表实现,查询慢,增删快,尤其对于首尾操作</p><p><img data-src="https://s2.loli.net/2025/03/18/JHyvrF3A1SiuIel.png" alt="image-20250318215401958"></p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p><img data-src="https://s2.loli.net/2025/03/18/VPxZDv3EGAcUpXs.png" alt="image-20250318220123427"></p><p>HashSet使用哈希表实现,增删改查性能较好 </p><p><img data-src="https://s2.loli.net/2025/03/18/zGuoR1B98kEKLxS.png" alt="image-20250318220818128"></p><p><img data-src="https://s2.loli.net/2025/03/18/cQr1mCLgliJtbvz.png" alt="image-20250318221151248"></p><p>HashSet去重主要依赖于两个关键方法：<code>hashCode()</code> 和 <code>equals()</code>。</p><ol><li><strong>hashCode() 方法</strong>：<ul><li>当你尝试将一个对象添加到 HashSet 中时，HashSet 会首先调用这个对象的 <code>hashCode()</code> 方法来计算该对象的哈希值。</li><li>这个哈希值决定了对象在内部哈希表中的存储位置（即所谓的“桶”）。</li></ul></li><li><strong>equals() 方法</strong>：<ul><li>如果两个对象有相同的哈希值（或者它们被分配到了同一个桶中），HashSet 将使用 <code>equals()</code> 方法来进一步检查这两个对象是否真正相等。</li><li>如果 <code>equals()</code> 返回 <code>true</code>，则认为这两个对象是重复的，新对象不会被添加到集合中。如果 <code>equals()</code> 返回 <code>false</code>，即使哈希值相同，这两个对象也被认为是不同的，并且都会被添加到集合中。</li></ul></li></ol><p>对于自定义类的对象，如果你希望它们能够正确地在 HashSet 中进行去重，你需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，以确保具有相同业务含义的对象返回相同的哈希码并且 <code>equals()</code> 方法也返回 <code>true</code>。</p><p>TreeSet底层基于红黑树,可排序,不重复,无索引</p><p><img data-src="https://s2.loli.net/2025/03/18/GrE4zd586Jh9jAO.png" alt="image-20250318231528714"></p><p><img data-src="https://s2.loli.net/2025/03/18/DvQmr3tiWezX2xq.png" alt="image-20250318234747847"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><img data-src="https://s2.loli.net/2025/03/19/wiUs3FnHfLKgjkQ.png" alt="image-20250319103421264"></p><p><img data-src="https://s2.loli.net/2025/03/19/zEqWugTiRUsaK7C.png" alt="image-20250319104523905"></p><p>Map的遍历方式</p><p><img data-src="https://s2.loli.net/2025/03/19/Dq6nC1eRwIlMUmS.png" alt="image-20250319110144222"></p><p><strong>使用 for-each 循环和 entrySet()</strong></p><p>这是最常用的遍历方式之一，因为它提供了对键和值的访问。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.<span class="keyword">Entry</span>&lt;String, Integer&gt; <span class="keyword">entry</span> : <span class="type">map.entrySet</span>()) &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">entry</span>.getKey() + <span class="string">&quot;: &quot;</span> + <span class="keyword">entry</span>.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器</strong></p><p>使用迭代器可以更灵活地控制遍历过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Java 8 的 Stream API</strong></p><p>通过 <code>stream()</code> 方法可以利用 Stream API 来遍历或进行其他操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach(entry -&gt; </span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者对于某些特定的操作，比如过滤、映射等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream()</span><br><span class="line">   .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">   .forEach(entry -&gt; System.out.println(entry.getKey()));</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/ycB948TkMLeEwmr.png" alt="image-20250319114156720"></p><p>Stream流包括中间方法和最终方法,中间方法使用filter,map,调用完成后会返回新的流</p><p><img data-src="https://s2.loli.net/2025/03/19/qfkja1eAIUKObEX.png" alt="image-20250319120025921"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">alist.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">alist.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = alist.stream().map((String a) -&gt; a + <span class="string">&quot;a&quot;</span>).toList();</span><br><span class="line">List&lt;Double&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.stream().filter(s-&gt; !s.isEmpty()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">list.stream().sorted(Comparator.comparingDouble(String::length).reversed()).forEach(System.out::println);</span><br><span class="line">blist.stream().sorted(Double::compare).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重 limit只需要一个参数 skip跳过前几个</span></span><br><span class="line">blist.stream().distinct().skip(<span class="number">1</span>).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成map</span></span><br><span class="line">list.stream().collect(Collectors.toMap(Function.identity(), String::length)).forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v));</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; a = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 合并两个流</span></span><br><span class="line">Stream.concat(a, integerStream).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="异常、泛型与集合框架"><a href="#异常、泛型与集合框架" class="headerlink" title="异常、泛型与集合框架"></a>异常、泛型与集合框架</h4><p>Java中异常的类继承体系</p><p><img data-src="https://s2.loli.net/2025/03/11/yhg79kQxwJiCBO6.png" alt="image-20250311153912955"></p><p>运行时异常(extends RuntimeException:数组索引越界</p><p>编译异常(extends Exception). 编译时异常需要通过try-catch或throw丢出异常进行处理,</p><p>运行时异常不需要特别处理</p><p>此外异常可以分为业务类和运行逻辑类,一些代码中的异常应该被catch然后向上抛给业务类或者直接处理. </p><p><img data-src="https://s2.loli.net/2025/03/11/XR4zx7ycNQiSBlt.png" alt="image-20250311175150716"></p><p>泛型允许编写可以<strong>处理不同类型数据的类、接口和方法，而无需在代码中明确指定具体类型</strong>。泛型提供了更强的类型检查，并且消除了对类型转换的需求，从而使得代码更加安全和易于维护。</p><p><strong>类型参数</strong>：在定义泛型类或方法时使用占位符（通常为大写字母如 <code>T</code>, <code>E</code>, <code>K</code>, <code>V</code> 等），代表实际应用中的类型。</p><ul><li><strong>类型安全</strong>：编译器会在编译期进行类型检查，减少运行时出现的 <code>ClassCastException</code> 错误。</li><li><strong>消除类型转换</strong>：由于类型信息在编译时已知，因此不需要显式的类型转换。</li></ul><h4 id="使用泛型类"><a href="#使用泛型类" class="headerlink" title="使用泛型类"></a>使用泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">integerBox.set(<span class="number">10</span>);</span><br><span class="line">Integer intValue = integerBox.get();</span><br><span class="line"></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">String strValue = stringBox.get();</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>你也可以定义泛型方法，即在方法级别上使用泛型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    String[] stringArray = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    printArray(intArray);</span><br><span class="line">    printArray(stringArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>&lt;T&gt;</code> 在方法签名前声明了类型参数，这样这个方法就可以接受任意类型的数组作为参数。</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>类似地，也可以定义泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringContainer</span> <span class="keyword">implements</span> <span class="title">Container</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 泛型是在 Java 5 中引入的，而在此之前已经存在了大量的 Java 代码库。如果直接在 JVM 层面实现泛型支持，那么这些现有的代码可能会因为缺乏泛型信息而不兼容。通过类型擦除，Java 编译器能够在编译时移除泛型类型信息，并将泛型代码转换为非泛型代码，这样就可以确保新旧代码可以无缝地一起工作</p></blockquote><p><strong>通配符</strong></p><p>有时可能需要编写能够与多种类型工作的代码，但并不需要知道这些类型的具体细节。这时可以使用通配符 <code>?</code>：</p><ul><li><strong>无界通配符</strong>：<code>&lt;?&gt;</code> 表示可以是任何类型。</li><li><strong>有界通配符</strong>：<code>&lt;? extends T&gt;</code> 和 <code>&lt;? super T&gt;</code> 分别表示类型必须是 <code>T</code> 或其子类，以及 <code>T</code> 或其父类。</li></ul><p><strong>泛型的优点</strong></p><ol><li><strong>类型安全</strong>：编译器可以在编译时进行更多的类型检查，减少运行时错误。</li><li><strong>消除强制类型转换</strong>：不再需要手动将对象转换回原始类型。</li><li><strong>提高代码重用性</strong>：通过泛型，相同的逻辑可以应用于不同的数据类型。</li></ol><p>Java集合是一种容器,类似于数组但集合的大小可变.</p><p><img data-src="https://s2.loli.net/2025/03/14/8tKapiLbw7csMlP.png" alt="image-20250314192425271"></p><p><img data-src="https://s2.loli.net/2025/03/14/ZL6IFGzBio5Pbc2.png" alt="image-20250314230501695"></p><h3 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h3><p><img data-src="https://s2.loli.net/2025/03/19/WxNStmTMp2D5viR.png" alt="image-20250319170141141"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sekyoro.tutorThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: workspace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: com.sekyoro.tutorThread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: threadDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/19 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">easyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a mini thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">miniCallable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">miniCallable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Thread et = <span class="keyword">new</span> easyThread();</span><br><span class="line">        et.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> miniThread()).start();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; mc = <span class="keyword">new</span> miniCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        Integer i = ft.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/8Dlxb1zAqTgOWyF.png" alt="image-20250319171222472"></p><p>线程同步解决线程安全问题</p><p><strong>同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/S8WiOA2HE5gwVUT.png" alt="image-20250319173439131"></p><p><strong>同步方法</strong></p><p><img data-src="https://s2.loli.net/2025/03/19/y1U9gKj6fHmab8k.png" alt="image-20250319173832373"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">          money -= m;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Lock锁</strong></p><p><img data-src="https://s2.loli.net/2025/03/19/bBamC6ND3n7TcEO.png" alt="image-20250319174259793"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>显式锁（Explicit Lock）</p><ul><li><p>ReentrantLock 类提供了比synchronized更灵活的锁操作，例如可中断的锁等待、尝试非阻塞获取锁、超时获取锁等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 受保护的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 确保释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>读写锁（ReadWriteLock）</li></ol><p>ReadWriteLock 接口 和 ReentrantReadWriteLock 实现类.允许多个读操作同时进行，但在写操作时排斥所有其他读写操作。适用于读多写少的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">rwl.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rwl.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>条件变量（Condition）</li></ol><p>Condition 接口与显式锁配合使用，提供类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    condition.await(); <span class="comment">// 相当于 wait()</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    condition.signal(); <span class="comment">// 相当于 notify()</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>StampedLock</li></ol><p>StampedLock 类是Java 8引入的一种新的锁类型，支持乐观读锁策略，适用于读多写少且大部分读操作不会发生冲突的情况。它提供了三种模式：写锁、悲观读锁和乐观读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> stamp = stampedLock.readLock(); <span class="comment">// 悲观读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stamp = stampedLock.writeLock(); <span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stampedLock.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> optimisticStamp = stampedLock.tryOptimisticRead(); <span class="comment">// 乐观读锁</span></span><br><span class="line"><span class="comment">// 验证并使用乐观读锁...</span></span><br><span class="line"><span class="keyword">if</span> (!stampedLock.validate(optimisticStamp)) &#123;</span><br><span class="line">    <span class="comment">// 如果验证失败，则需要重新获取悲观读锁或写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池</strong></p><ol><li>ThreadPoolExecutor创建线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程池</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用线程池处理任务</span></span><br><span class="line">Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="number">3</span>);</span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br><span class="line">pool.execute(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>)); <span class="comment">//提交任务</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/19/yTXM2Brukzw7IC8.png" alt="image-20250319205156594"></p><p><img data-src="https://s2.loli.net/2025/03/19/yIabTL2S9J4vDlX.png" alt="image-20250319205627740"></p><ol><li>利用Executors创建线程池</li></ol><p><img data-src="https://s2.loli.net/2025/03/19/A8KrfdjOShZTsnU.png" alt="image-20250319210516204"></p><p>利用ThreadPoolExecutor设置不同参数调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反射、注解与动态代理"><a href="#反射、注解与动态代理" class="headerlink" title="反射、注解与动态代理"></a>反射、注解与动态代理</h3><p>反射是指在运行时动态地获取类的信息以及操作对象的能力。通常情况下，Java 编译器会在编译期确定所有类型和成员变量的访问权限及调用方式，而反射则允许你在运行时进行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 直接通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 使用对象的 getClass() 方法</span></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">clazz = obj.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三: 通过全限定类名字符串</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的class类可以用来<strong>创建实例</strong>、<strong>访问字段</strong>、<strong>调用方法</strong>等</p><p>创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 假设 MyClass 有一个无参构造函数</span></span><br><span class="line">    Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定参数类型的构造函数</span></span><br><span class="line">    Constructor&lt;MyClass&gt; constructor = clazz.getConstructor(paramType.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    MyClass instance = constructor.newInstance(args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解（Annotations）</strong>是一种元数据形式，它提供了关于程序代码的额外信息，但这些信息并不直接改变程序的运行逻辑。注解自 Java 5 引入以来，已经成为 Java 开发中不可或缺的一部分，用于简化开发流程、提供配置信息、增强代码的功能等</p><ul><li><strong>定义</strong>：注解是接口的一种特殊形式，它通过 <code>@interface</code> 关键字来定义，并可以附加到类、方法、变量、参数、包声明等语言元素上。</li><li><strong>用途</strong>：主要用于编译时检查、运行时处理和生成源代码或文档。</li></ul><ol><li><strong>标记注解</strong>：没有成员变量，仅作为标记使用，如 <code>@Override</code>。</li><li><strong>单值注解</strong>：只有一个值，通常省略名称直接指定值，如 <code>@SuppressWarnings(&quot;unchecked&quot;)</code>。</li><li><strong>完整注解</strong>：包含多个成员变量，需要明确指定每个成员的值。</li></ol><p>元注解是指用来注解其他注解的注解，主要包括以下几个：</p><ul><li><code>@Retention</code>：定义了注解的存在阶段（SOURCE, CLASS, RUNTIME）。</li><li><code>@Target</code>：指定了注解可以应用的目标元素类型（TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE 等）。</li><li><code>@Documented</code>：表明这个注解应该被 javadoc 工具记录。</li><li><code>@Inherited</code>：允许子类继承父类中的注解。</li><li><code>@Repeatable</code>：从 Java 8 开始支持，表示相同的注解可以在同一地方多次使用。</li></ul><p><strong>注解的解析</strong></p><p>检查方法和类等是否包含对应注解,若包含则进行相关调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">annotationDemo annotationDemo = <span class="keyword">new</span> annotationDemo();</span><br><span class="line"> Class&lt;?&gt; aClass = annotationDemo.class;</span><br><span class="line"> Method[] methods = aClass.getMethods();</span><br><span class="line"> <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">     <span class="keyword">if</span> (method.isAnnotationPresent( MyTest.class)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             MyTest declaredAnnotation = method.getDeclaredAnnotation(MyTest.class);</span><br><span class="line">             method.invoke(annotationDemo);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>Proxy.newProxyInstance创建代理,参数包括类加载器,需要实现的接口,和代理需要做的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StarService <span class="title">createProxy</span><span class="params">(StarService starService)</span></span>&#123;</span><br><span class="line">        StarService o = (StarService)Proxy.newProxyInstance(ProxyUtils.class.getClassLoader(), starService.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">               String methodName = method.getName();</span><br><span class="line">               <span class="keyword">if</span>(<span class="string">&quot;sing&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;sing a song: &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;dance a dance&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">if</span>(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>  method.invoke(starService,args);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>类加载过程主要包括三个阶段：<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>。</p><ul><li><strong>加载</strong>：通过类的全限定名获取定义此类的二进制字节流，并将其转换为方法区中的运行时数据结构，在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象。</li><li><strong>链接</strong>：包括验证、准备和解析三个步骤。验证确保被加载类的正确性；准备则为类变量分配内存并设置默认初始值；解析是将类、接口、字段和方法的符号引用转为直接引用的过程。</li><li><strong>初始化</strong>：执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程，对静态变量和静态代码块进行初始化。</li></ul><p>Java 类加载器使用双亲委派模型来搜索类或资源。<strong>当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成</strong>，每一层的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器。<strong>只有当父类加载器无法加载该类时，子类加载器才会尝试自己加载</strong></p><p>Java 提供了三种内置的类加载器：</p><ul><li><strong>Bootstrap ClassLoader</strong>：这是最顶层的类加载器，由本地代码实现，通<strong>常用于加载核心 JDK 类库</strong>（如 <code>rt.jar</code>）。 无法直接访问,显示为null</li><li><strong>Extension ClassLoader</strong>：扩展类加载器，<strong>用来加载位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 JAR 包</strong>。 (目前使用PlatformClassLoader,加载 JDK 提供的平台模块中的类，例如 <code>java.sql</code>, <code>java.xml</code>, <code>javax.*</code> 等模块化的平台类。)</li><li><strong>Application ClassLoader</strong>：应用程序类加载器，<strong>负责加载用户类路径（ClassPath）上指定的类库</strong></li></ul><p>Java 提供了一些常用的方法来操作类加载器：</p><p><strong>(1) <code>loadClass(String name)</code></strong></p><p>加载指定名称的类或接口。如果已经加载过，则直接返回对应的 <code>Class</code> 对象；如果没有，则按照双亲委派机制尝试加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) <code>findClass(String name)</code></strong></p><p>查找指定名称的类。默认实现会抛出 <code>ClassNotFoundException</code> 异常，通常需要自定义类加载器覆盖此方法以提供具体的类查找逻辑。</p><p><strong>(3) <code>defineClass(byte[] b, int off, int len)</code></strong></p><p>将一个字节数组转换成一个类的 <code>Class</code> 对象。一般不直接调用，主要用于自定义类加载器。</p><p><strong>(4) <code>getResource(String name)</code> 和 <code>getResourceAsStream(String name)</code></strong></p><p>用于查找资源文件。前者返回资源的 URL，后者返回资源的输入流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL resourceUrl = getClass().getClassLoader().getResource(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>(5) <code>getParent()</code></strong></p><p>返回该类加载器的父类加载器。注意，Bootstrap ClassLoader 没有父类加载器，所以对于 Bootstrap ClassLoader 调用 <code>getParent()</code> 将返回 <code>null</code>。</p><p><strong>4. 自定义类加载器</strong></p><p>有时我们需要根据特定的需求来自定义类加载器。可以通过继承 <code>java.lang.ClassLoader</code> 并重写 <code>findClass</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name); <span class="comment">// 实现类数据加载逻辑</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="comment">// 加载类数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实现自定义类加载器的基本步骤：</p><ol><li><p>继承 <code>ClassLoader</code></p><ul><li>创建一个类并继承 <code>ClassLoader</code>。</li></ul></li><li><p>重写 <code>findClass()</code> 方法(遵从双亲委派机制)</p><ul><li>实现自定义的类加载逻辑。</li></ul></li><li><p>调用 <code>defineClass()</code> 方法</p><ul><li>将字节码转换为 <code>Class</code> 对象。</li></ul><p>class对象相同需要classloader相同,相同的classloader进行loadclass相同的类得到的class相同</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类的根路径</span></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取类的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Class not found: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptedClassData = decrypt(classData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义类</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, decryptedClassData, <span class="number">0</span>, decryptedClassData.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载类的字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String path = classPath + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">             ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            <span class="keyword">int</span> buffer;</span><br><span class="line">            <span class="keyword">while</span> ((buffer = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟解密过程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        <span class="comment">// 简单的异或解密</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = (<span class="keyword">byte</span>) (data[i] ^ <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义类加载器</span></span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">&quot;path/to/classes/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义类加载器加载类</span></span><br><span class="line">        Class&lt;?&gt; clazz = customClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Loaded class: &quot;</span> + clazz.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建实例并调用方法</span></span><br><span class="line">        Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>).invoke(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h4><p>线程上下文类加载器（Thread Context ClassLoader）是 Java 提供的一种机制，允许开发者在线程中设置和获取类加载器。这种机制主要用于解决某些特定场景下类加载的问题，尤其是在复杂的类层次结构或模块化系统中。</p><p><strong>线程上下文类加载器的作用</strong></p><ol><li><strong>解决类加载器隔离问题</strong>：<ul><li>在 Java 应用程序中，不同的类加载器可能会形成类加载器树，这导致了类加载器之间的隔离性。</li><li>例如，在 Web 容器或 OSGi 等环境中，不同应用或模块可能使用不同的类加载器来加载各自的类。在这种情况下，如果一个类需要加载另一个类加载器负责加载的类，则会遇到问题。</li><li>线程上下文类加载器提供了一种绕过双亲委派模型的方式，允许当前线程使用指定的类加载器来加载类。</li></ul></li><li><strong>支持框架和库的开发</strong>：<ul><li>许多框架和库（如 JNDI、JDBC 驱动等）依赖于线程上下文类加载器来加载必要的类。</li><li>这些框架通常不知道具体的类加载器，因此它们可以利用线程上下文类加载器来动态地加载所需的类。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadContextClassLoaderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取默认的上下文类加载器</span></span><br><span class="line">            ClassLoader defaultClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(<span class="string">&quot;默认的上下文类加载器: &quot;</span> + defaultClassLoader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个新的类加载器（例如自定义类加载器）</span></span><br><span class="line">            ClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置新的上下文类加载器</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(customClassLoader);</span><br><span class="line">            System.out.println(<span class="string">&quot;设置后的上下文类加载器: &quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用上下文类加载器加载类</span></span><br><span class="line">            Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载的类: &quot;</span> + clazz.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 实现类的查找逻辑</span></span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="comment">// 模拟从文件或其他来源读取类数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img data-src="https://s2.loli.net/2025/03/20/iZdH8kUa9LYAFQW.png" alt="image-20250320221417773"></p><p>程序计数器: 线程私有</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>判断对象可以回收</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>工作原理</p><ol><li><strong>初始化</strong>：每当创建一个新的对象时，该对象的引用计数器被初始化为1。</li><li><strong>增加引用</strong>：每当有新的引用指向这个对象时（例如，将对象赋值给另一个变量），该对象的引用计数加1。</li><li><strong>减少引用</strong>：每当某个引用不再指向该对象时（例如，变量超出作用域或重新赋值），该对象的引用计数减1。</li><li><strong>回收内存</strong>：当一个对象的引用计数降为0时，表示没有其他引用指向该对象，这时就可以立即回收该对象所占用的内存。</li></ol><p>缺点:</p><p><strong>无法处理循环引用</strong>：如果两个或多个对象相互引用形成环状结构，则即使这些对象实际上已经不可达，它们的引用计数也不会变为0，导致内存泄漏。为了克服这个问题，一些语言引入了弱引用（weak references）或专门的循环检测机制。</p><p><strong>多线程环境下的复杂性</strong>：在多线程环境下，对引用计数的修改需要同步操作，以防止竞态条件（race condition），这也增加了实现的复杂性和运行时的开销</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析的基本思想是从一组被称为“根节点”（root set）的对象开始，遍历所有可以通过这些根节点直接或间接引用到的对象，并将它们标记为存活。未被标记的对象则被认为是不可达的，可以被安全地回收。</p><blockquote><p>在命令行中输入 <code>jps</code> 可以列出所有由当前用户启动的 Java 进程的基本信息</p><p><code>-q</code>：仅输出 JVM 的进程 ID，不输出类名、jar 名等信息</p><p><code>-l</code>：输出主类的完整包名；如果进程执行的是 jar 文件，则输出 jar 文件的完整路径</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:[live,]format=b,file=&lt;filename&gt;.hprof &lt;pid&gt;</span><br></pre></td></tr></table></figure><ul><li><code>live</code>：如果指定了这个选项，则只转储存活的对象；如果不指定，则转储所有对象。</li><li><code>format=b</code>：表示输出格式为二进制，默认就是二进制格式，所以通常省略不写。</li><li><code>&lt;filename&gt;.hprof</code>：指定生成的堆转储文件的名字。</li><li><code>&lt;pid&gt;</code>：目标Java进程的进程ID。</li></ul><p>引用</p><p><img data-src="https://s2.loli.net/2025/03/20/BMyrksQT5S6xlqf.png" alt="image-20250320220503285"></p><p>强引用 软引用 弱引用</p><p>软引用:垃圾回收时且内存不足时会被回收掉</p><p>虚引用  引用队列</p><p>终结器引用</p><ul><li><strong>强引用</strong>：日常编程中最常用的引用类型，几乎所有对象都是通过强引用创建的。</li><li><strong>软引用</strong>：适用于缓存场景，当内存不足时，允许GC回收缓存数据。</li><li><strong>弱引用</strong>：适合于需要自动清理的资源管理场景，例如监听器或回调函数列表中的对象。</li><li><strong>虚引用</strong>：主要用于了解对象何时被垃圾回收，常用于做一些清理工作，比如清除本地内存、关闭文件等</li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p>标记-清除</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="Maven✨"><a href="#Maven✨" class="headerlink" title="Maven✨"></a>Maven✨</h2><p><a href="https://maven.apache.org/guides/getting-started/index.html">Maven Getting Started Guide – Maven</a></p><p><a href="https://www.runoob.com/maven/maven-tutorial.html">Maven 教程 | 菜鸟教程</a></p><p><a href="https://www.bilibili.com/video/BV1Ah411S7ZE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=177ef88aa6608bc3652c72d71b0aa098">黑马程序员Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven_哔哩哔哩_bilibili</a></p><blockquote><p>项目中源码目录,资源文件夹目录等都是maven设置的</p></blockquote><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">${basedir}</td><td style="text-align:left">存放pom.xml和所有的子目录</td></tr><tr><td style="text-align:left">${basedir}/src/main/java</td><td style="text-align:left">项目的java源代码</td></tr><tr><td style="text-align:left">${basedir}/src/main/resources</td><td style="text-align:left">项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td style="text-align:left">${basedir}/src/test/java</td><td style="text-align:left">项目的测试类，比如说Junit代码</td></tr><tr><td style="text-align:left">${basedir}/src/test/resources</td><td style="text-align:left">测试用的资源</td></tr><tr><td style="text-align:left">${basedir}/src/main/webapp/WEB-INF</td><td style="text-align:left">web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td style="text-align:left">${basedir}/target</td><td style="text-align:left">打包输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/classes</td><td style="text-align:left">编译输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/test-classes</td><td style="text-align:left">测试编译输出目录</td></tr><tr><td style="text-align:left">Test.java</td><td style="text-align:left">Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td style="text-align:left">~/.m2/repository</td><td style="text-align:left">Maven默认的本地仓库目录位置</td></tr></tbody></table></div><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p><div class="table-container"><table><thead><tr><th style="text-align:left">节点</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">project</td><td style="text-align:left">工程的根标签。</td></tr><tr><td style="text-align:left">modelVersion</td><td style="text-align:left">模型版本需要设置为 4.0。</td></tr><tr><td style="text-align:left">groupId</td><td style="text-align:left">这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td></tr><tr><td style="text-align:left">artifactId</td><td style="text-align:left">这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td></tr><tr><td style="text-align:left">version</td><td style="text-align:left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></td></tr></tbody></table></div><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他常用元素"><a href="#其他常用元素" class="headerlink" title="其他常用元素"></a>其他常用元素</h3><p><strong>properties</strong>: 定义项目中的一些属性变量:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repositories: 定义项目的依赖库:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>dependencyManagement</strong>: 用于管理依赖的版本，特别是在多模块项目中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>profiles: 用于定义不同的构建配置，可以根据不同的环境进行构建：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>development<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>production<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承: 通过parent元素，一个POM文件可以继承另一个POM文件的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>聚合: 通过modules元素，一个POM文件可以管理多个子模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2018/09/maven-package-build-phase.png" alt="img"></p><div class="table-container"><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">处理</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">验证 validate</td><td style="text-align:left">验证项目</td><td style="text-align:left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:left">编译 compile</td><td style="text-align:left">执行编译</td><td style="text-align:left">源代码编译在此阶段完成</td></tr><tr><td style="text-align:left">测试 Test</td><td style="text-align:left">测试</td><td style="text-align:left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left">包装 package</td><td style="text-align:left">打包</td><td style="text-align:left">将编译后的代码打包成可分发的格式，例如 JAR 或 WAR</td></tr><tr><td style="text-align:left">检查 verify</td><td style="text-align:left">检查</td><td style="text-align:left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:left">安装 install</td><td style="text-align:left">安装</td><td style="text-align:left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:left">部署 deploy</td><td style="text-align:left">部署</td><td style="text-align:left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table></div><p>为了完成 default 生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。</p><p>Maven 有以下三个标准的生命周期：</p><p><strong>1、Clean 生命周期：</strong></p><ul><li><strong>clean</strong>：删除目标目录中的编译输出文件。这通常是在构建之前执行的，以确保项目从一个干净的状态开始。</li></ul><p><strong>2、Default 生命周期（也称为 Build 生命周期）：</strong></p><ul><li><strong>validate</strong>：验证项目的正确性，例如检查项目的版本是否正确。</li><li><strong>compile</strong>：编译项目的源代码。</li><li><strong>test</strong>：运行项目的单元测试。</li><li><strong>package</strong>：将编译后的代码打包成可分发的格式，例如 JAR 或 WAR。</li><li><strong>verify</strong>：对项目进行额外的检查以确保质量。</li><li><strong>install</strong>：将项目的构建结果安装到本地 Maven 仓库中，以供其他项目使用。</li><li><strong>deploy</strong>：将项目的构建结果复制到远程仓库，以供其他开发人员或团队使用。</li></ul><p><strong>3、Site 生命周期：</strong></p><ul><li><strong>site</strong>：生成项目文档和站点信息。</li><li><strong>deploy-site</strong>：将生成的站点信息发布到远程服务器，以便共享项目文档。</li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>在 Maven 的术语中，仓库是一个位置（place）。</p><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。</p><p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。</p><p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p><p>Maven 仓库有三种类型：</p><ul><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ul><p>Maven 的本地仓库，<strong>在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建</strong>。</p><p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p><blockquote><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。</p></blockquote><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0    http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:/MyLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span> <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。</p><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p><p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p><p>中央仓库的关键概念：</p><ul><li>这个仓库由 Maven 社区管理。</li><li>不需要配置。</li><li>需要通过网络才能访问。</li></ul><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><p>举例说明，使用下面的 pom.xml，<strong>Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.common-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--自定义远程仓库--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。</p><p><strong>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件</strong>，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想使用其它代理仓库，可在 <strong><repositories></repositories></strong> 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在你的 pom.xml 文件 <strong><denpendencies></denpendencies></strong> 节点中加入你要引用的文件信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>[GROUP_ID]<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>[ARTIFACT_ID]<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>[VERSION]<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><strong><code>mvn clean</code></strong><ul><li>清理项目，删除 <code>target</code> 目录（该目录包含了编译和打包过程中生成的所有文件）。</li></ul></li><li><strong><code>mvn compile</code></strong><ul><li>编译项目的源代码。默认情况下，会查找 <code>src/main/java</code> 目录下的所有 <code>.java</code> 文件，并将编译后的 <code>.class</code> 文件输出到 <code>target/classes</code> 目录中。</li></ul></li><li><strong><code>mvn test</code></strong><ul><li>使用合适的单元测试框架（如 JUnit 或 TestNG）运行项目的测试代码。默认情况下，测试代码位于 <code>src/test/java</code> 目录下。</li></ul></li><li><strong><code>mvn package</code></strong><ul><li>将编译好的字节码打包成可分发的格式，例如 JAR 或 WAR 文件。这个命令首先执行 <code>compile</code> 和 <code>test</code>，然后将项目打包并存放在 <code>target</code> 目录中。</li></ul></li><li><strong><code>mvn install</code></strong><ul><li>安装打包好的构件到本地仓库（通常是用户主目录下的 <code>.m2/repository</code>），以便它可以被其他项目作为依赖使用。此命令还会执行 <code>package</code> 的所有步骤。</li></ul></li><li><strong><code>mvn deploy</code></strong><ul><li>在集成或发布阶段使用，用于将最终包复制到远程仓库，使得其他开发者或项目可以共享这个构件。</li></ul></li><li><strong><code>mvn site</code></strong><ul><li>生成关于项目的站点文档，包括测试覆盖率报告、依赖列表等信息。</li></ul></li><li><strong><code>mvn clean install</code></strong><ul><li>组合命令，先清理项目 (<code>clean</code>) 然后安装 (<code>install</code>) 到本地仓库。这是非常常见的组合，用于确保在干净环境下重新构建整个项目。</li></ul></li><li><strong><code>mvn dependency:tree</code></strong><ul><li>显示项目依赖树，有助于分析依赖冲突或了解项目依赖关系。</li></ul></li><li><strong><code>mvn archetype:generate</code></strong><ul><li>生成一个新的 Maven 项目结构，通过交互式的方式选择项目模板</li></ul></li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL✨"><a href="#MySQL✨" class="headerlink" title="MySQL✨"></a>MySQL✨</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一组操作的集合,不可分割的一个工作单位. 事务会把所有操作作为一个整体向系统提交或撤销操作,即这些操作要么同时成功,要么同时失败.</p><p>事务四大特性</p><ul><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不执行。</li><li><strong>一致性（Consistency）</strong>：事务应该将数据库从一种一致状态转换为另一种一致状态。</li><li><strong>隔离性（Isolation）</strong>：并发事务之间相互隔离，不会互相干扰。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，所做的更改将是永久性的，即使系统发生故障也不会丢失。</li></ul><h5 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h5><p>多个事务并发进行的问题</p><h6 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h6><p>一个事务读到另外一个事务还没有提交的数据</p><h6 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h6><p>一个事务先后读取同一条记录,但两次读取的数据不同,称之为不可重复读</p><h6 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h6><p>一个事务按照条件查询数据时,没有对应的数据行,但是在插入数据时,又发现这行数据已经存在</p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>MySQL 支持四种标准的事务隔离级别：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>:最低级别的隔离，允许脏读、不可重复读和幻读。</li><li><strong>读已提交（Read Committed）</strong>:防止脏读，但允许不可重复读和幻读。</li><li><strong>可重复读（Repeatable Read）</strong>:默认级别，防止脏读和不可重复读，但允许幻读。</li><li><strong>串行化（Serializable）</strong>:最高级别的隔离，完全防止脏读、不可重复读和幻读，但会降低并发性能。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">-- 或者</span><br><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p><strong>1. 默认情况下：事务需要显式提交</strong></p><ul><li>在 <code>START TRANSACTION</code> 开始一个事务后，所有对数据库的修改操作（如 <code>UPDATE</code>、<code>INSERT</code> 等）都只会暂时存在于事务的上下文中，而不会直接写入数据库。</li><li>这些更改对其他事务是不可见的（根据隔离级别），直到你显式调用 <code>COMMIT</code> 提交事务。</li><li>如果你调用 <code>ROLLBACK</code>，则所有的更改会被撤销，数据库恢复到事务开始前的状态。</li></ul><p><strong>2. 如果未提交且会话结束</strong></p><ul><li><p>如果你在事务中执行了更新语句，但没有显式调用COMMITROLLBACK</p><p>，然后会话意外终止（例如客户端断开连接），MySQL 的行为如下：</p><ul><li><strong>InnoDB 存储引擎</strong>（支持事务）：事务会被自动回滚，所有未提交的更改都会被撤销。</li><li><strong>MyISAM 存储引擎</strong>（不支持事务）：由于 MyISAM 不支持事务，所有操作会立即生效，无法回滚。</li></ul></li></ul><p><strong>3. autocommit 模式的影响</strong></p><ul><li>MySQL 默认开启了 <strong>autocommit 模式</strong>（<code>autocommit=1</code>）。在这种模式下，每条单独的 SQL 语句都会被视为一个独立的事务，并在执行后自动提交。</li><li>当你使用 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 时，会临时禁用 autocommit 模式，直到事务结束（通过 <code>COMMIT</code> 或 <code>ROLLBACK</code>）。</li><li>如果你没有显式提交事务，而会话结束时 autocommit 模式重新启用，InnoDB 会自动回滚未提交的事务。</li></ul><p><img data-src="https://s2.loli.net/2025/03/26/F7Ebo35RH6XIQft.png" alt="image-20250326191732721"></p><p><img data-src="https://s2.loli.net/2025/03/26/LjCFSxblAyBGEhd.png" alt="image-20250326192221989"></p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>join连接两个表</p><ul><li><strong>INNER JOIN</strong>：仅返回两个表中满足连接条件的记录。</li><li><strong>LEFT JOIN</strong>（或LEFT OUTER JOIN）：返回左表中的所有记录，以及右表中满足连接条件的记录。若右表无匹配记录则填充NULL。</li><li><strong>RIGHT JOIN</strong>（或RIGHT OUTER JOIN）：返回右表中的所有记录，以及左表中满足连接条件的记录。若左表无匹配记录则填充NULL。</li><li><strong>FULL JOIN</strong>（或FULL OUTER JOIN）：返回两个表中的所有记录，任何表中无匹配记录的部分用NULL填充。（注意：MySQL不直接支持此语法）</li><li><strong>CROSS JOIN</strong>：产生两个表的笛卡尔积。</li><li><strong>SELF JOIN</strong>：一个表与自身的连接，适用于查询具有层次结构的数据。</li></ul><p><code>%</code> 可以匹配任意长度的字符串（包括空字符串），而 <code>_</code> 总是代表一个单一字符.在SQL中，默认情况下并没有一个预设的转义字符用于 <code>LIKE</code> 查询中的通配符（如 <code>%</code> 和 <code>_</code>）转义。这意味着，如果你需要转义这些特殊字符，你必须明确指定一个转义字符，并通过 <code>ESCAPE</code> 关键字来定义它。</p><p>尽管没有默认的转义字符，但你可以选择一个不会出现在目标字符串中的字符作为转义字符。常用的转义字符包括反斜杠 <code>\</code> 或者感叹号 <code>!</code> 等。下面是如何使用 <code>ESCAPE</code> 来定义转义字符的例子：</p><p>如果想查找包含实际百分比符号 <code>%</code> 的记录，可以这样做：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;%\%%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>\%</code> 表示实际的百分号字符 <code>%</code> 而不是通配符。</li><li><code>ESCAPE &#39;\&#39;</code> 告诉数据库 <code>\</code> 是转义字符。</li></ul><h2 id="PostgresSQL"><a href="#PostgresSQL" class="headerlink" title="PostgresSQL"></a>PostgresSQL</h2><p><a href="https://www.postgresql.org/">PostgreSQL: The world’s most advanced open source database</a></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/docs/guides/">Start with Guides - Start with Guides</a></p><h1 id="持久层框架"><a href="#持久层框架" class="headerlink" title="持久层框架"></a>持久层框架</h1><h2 id="Mybatis✨"><a href="#Mybatis✨" class="headerlink" title="Mybatis✨"></a>Mybatis✨</h2><p><a href="https://mybatis.org/mybatis-3/zh_CN/index.html">MyBatis 3 | 简介 – mybatis</a></p><p><a href="https://www.bilibili.com/video/BV1VP4y1c7j7/">【尚硅谷】MyBatis零基础入门教程（细致全面，快速上手mybatis）_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1JP4y1Z73S/">MyBatis视频零基础入门到进阶，MyBatis全套视频教程源码级深入详解_哔哩哔哩_bilibili</a></p><p>持久层框架,简化JDBC开发,负责数据库的读写.</p><p>JDBC问题:硬编码 操作繁琐</p><h3 id="查询单表数据整体流程"><a href="#查询单表数据整体流程" class="headerlink" title="查询单表数据整体流程"></a>查询单表数据整体流程</h3><ol><li>创建表,插入数据</li><li>创建模块,导入maven</li><li>编写mybatis核心配置文件(替换连接信息,解决硬编码)</li><li>编写sql映射文件(统一管理sql语句)</li><li>编码: 定义POJO类  加载核心配置文件,获取sqlsessionfactory对象,执行sql语句</li></ol><h3 id="使用Mapper代理开发"><a href="#使用Mapper代理开发" class="headerlink" title="使用Mapper代理开发"></a>使用Mapper代理开发</h3><blockquote><p>创建mapper类,该类名称与命名空间相同,方法申明与mapper映射xml文件相同</p></blockquote><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——<strong>使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/09/S12tudvJjEeoXTp.png" alt="image-20250309134454871"></p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TypeAliases"><a href="#TypeAliases" class="headerlink" title="TypeAliases"></a>TypeAliases</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span><br><span class="line">  &lt;typeAlias <span class="built_in">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean,<strong>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</strong>。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typehandlers"><a href="#typehandlers" class="headerlink" title="typehandlers"></a>typehandlers</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p><h3 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  <span class="keyword">type</span>= Executor.class,</span><br><span class="line">  method = <span class="string">&quot;update&quot;</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,<span class="built_in">Object</span>.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="title">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">Object</span> intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    <span class="built_in">Object</span> returnObject = invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">setProperties</span>(<span class="params">Properties properties</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。</p><h3 id="xml映射器"><a href="#xml映射器" class="headerlink" title="xml映射器"></a>xml映射器</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 该命名空间的缓存配置。</li><li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li><li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li><del><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del></li><li><code>sql</code> – 可被其它语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><p>常用属性</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>parameterType</code></td><td>将会传入这条语句的参数的类全限定名或别名。<strong>这个属性是可选的，因为 MyBatis 可以根据语句中实际传入的参数计算出应该使用的类型处理器</strong>（TypeHandler），默认值为未设置（unset）。</td></tr><tr><td><del>parameterMap</del></td><td><del>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</del></td></tr><tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，<strong>如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型</strong>。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>resultMap</code></td><td><strong>对外部 resultMap 的命名引用</strong>。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr></tbody></table></div><p> 特殊字符处理,转义或CDATA区  </p><p>参数占位符:#{} ${}$       </p><h3 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h3><p>​     鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。</p><p><img data-src="https://s2.loli.net/2025/03/10/u1fMijOcWHJGRTF.png" alt="image-20250310172440304"></p><p><img data-src="https://s2.loli.net/2025/03/10/ckaRKM5JnPW9FEB.png" alt="image-20250310182221930"></p><p><strong>不需要使用 <code>@Param</code> 的情况</strong></p><ol><li><p><strong>单个参数</strong>：如果你的 Mapper 方法只接受一个参数，那么你不需要使用 <code>@Param</code> 注解。MyBatis 会自动将这个参数映射到 SQL 语句中的占位符。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectUserByUserName</span><span class="params">(<span class="keyword">String</span> username)</span></span>;</span><br></pre></td></tr></table></figure><p>在对应的 XML 映射文件中可以直接引用该参数：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUserByUserName&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>Java Bean 参数</strong>：如果你直接传递一个 Java Bean 对象作为参数，MyBatis 可以通过 OGNL 表达式访问 Bean 的属性，因此也不需要使用 <code>@Param</code>。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List<span class="tag">&lt;User&gt;</span> selectUserByCondition(<span class="keyword">User</span> <span class="title">user</span>);</span><br></pre></td></tr></table></figure><p>在 XML 文件中可以通过点符号访问属性：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUserByCondition&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username = #&#123;username&#125; <span class="keyword">AND</span> age = #&#123;age&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>需要使用 <code>@Param</code> 的情况</strong></p><ol><li><p><strong>多个简单类型参数</strong>：如果 Mapper 方法接受多个简单类型的参数（如 <code>int</code>, <code>String</code> 等），你需要使用 <code>@Param</code> 来为每个参数指定一个名称，以便在 SQL 语句中引用它们。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; selectUsersByAgeAndUsername(<span class="symbol">@Param</span>(<span class="string">&quot;age&quot;</span>) <span class="built_in">int</span> age, <span class="symbol">@Param</span>(<span class="string">&quot;username&quot;</span>) <span class="built_in">String</span> username)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在 XML 文件中可以这样引用这些参数：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUsersByAgeAndUsername&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = #&#123;age&#125; <span class="keyword">AND</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>为了提高代码可读性</strong>：即使只有一个参数，有时候为了增加代码的可读性和明确性，也可以选择使用 <code>@Param</code> 注解来命名参数。</p></li><li><p><strong>Map 类型参数</strong>：当使用 Map 传递参数时，通常也需要指定键名来访问值。在这种情况下，虽然不强制要求使用 <code>@Param</code>，但你可以通过 Map 的键来访问值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; selectUsersByConditions(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; params);</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUsersByConditions&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age = #&#123;age&#125; <span class="keyword">AND</span> username = #&#123;username&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li>如果是单个参数或者传递的是 Java Bean，则通常不需要使用 <code>@Param</code>。</li><li>当方法有多个简单类型参数时，必须使用 <code>@Param</code> 来为每个参数指定名称，以便在 SQL 语句中引用。</li><li>使用 <code>@Param</code> 还有助于提高代码的可读性和维护性，尤其是在参数较多或逻辑较为复杂的情况下。</li></ul><blockquote><p>Java Bean 是一种符合特定规范的 Java 类，主要用于封装数据。它是 Java 中的一种标准，旨在使对象更容易被复用和管理，尤其是在可视化开发工具中。一个典型的 Java Bean 通常具有以下特征：</p><p><strong>特征</strong></p><ol><li><strong>私有属性</strong>：类中的成员变量应该是私有的（<code>private</code>），这意味着它们不能直接从类外部访问。</li><li><strong>无参构造器</strong>：必须提供一个公共的无参构造函数（默认构造器），以便能够实例化对象而不需要传递任何参数。这是为了确保可以通过反射机制创建对象实例，比如在框架内部（如Spring, MyBatis）。</li><li><strong>getter 和 setter 方法</strong>：对于每个私有属性，应该提供公共的 getter（获取值）和 setter（设置值）方法。这允许外部代码安全地访问和修改这些属性的值。</li><li><strong>可序列化</strong>（可选）：如果需要在网络上传输对象或者保存到文件中，那么这个类应该实现 <code>Serializable</code> 接口。</li></ol></blockquote><p><img data-src="https://s2.loli.net/2025/03/10/odIl2cm87SBxpk3.png" alt="image-20250310110128114"></p><h3 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h3><p>返回结果如果包含多个值,可以使用map.</p><p>如果使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.someapp.model;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getHashedPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashedPassword</span><span class="params">(String hashedPassword)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashedPassword = hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。</p><p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.someapp.model.User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.someapp.model.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL 映射 XML 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这些情况下，<strong>MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上</strong>。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as &quot;id&quot;,</span><br><span class="line">    user_name           as &quot;userName&quot;,</span><br><span class="line">    hashed_password     as &quot;hashedPassword&quot;</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 <code>ResultMap</code>。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">  select user_id, user_name, hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>sql元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sometable&quot;</span>&gt;</span></span><br><span class="line">  $&#123;prefix&#125;Table</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;someinclude&quot;</span>&gt;</span></span><br><span class="line">  from</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;$&#123;include_target&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    field1, field2, field3</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;someinclude&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Some&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;include_target&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sometable&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在INSERT和UPDATE时,可以获取自增的字段值.设置useGeneratedKeys和<code>keyProperty</code></p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>useGeneratedKeys</code></td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr></tbody></table></div><ul><li><strong><code>&lt;insert&gt;</code></strong>：用于插入新记录，返回受影响的行数或通过配置获取自增主键。</li><li><strong><code>&lt;update&gt;</code></strong>：用于更新现有记录，返回受影响的行数。</li><li><strong><code>&lt;delete&gt;</code></strong>：用于删除记录，返回受影响的行数。</li></ul><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><p><img data-src="https://s2.loli.net/2025/03/10/NjzLtSgZ9UKIQWC.png" alt="image-20250310114956563"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值</p><blockquote><p>可以使用mybatisx插件提升开发效率</p></blockquote><p><strong>相关视频</strong></p><ol><li><a href="https://www.bilibili.com/video/BV1MT4y1k7wZ/">黑马mybatis教程全套视频教程，2天Mybatis框架从入门到精通_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1G5411H7F8">快速上手mybatis</a></li><li><a href="https://www.bilibili.com/video/BV1VP4y1c7j7">MyBatis零基础入门教程</a></li></ol><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p><a href="https://www.geeksforgeeks.org/hibernate-native-sql/?ref=next_article_top">Hibernate - Native SQL - GeeksforGeeks</a></p><p><a href="https://docs.jboss.org/hibernate/orm/6.5/quickstart/html_single/#hibernate-gsg-tutorial-annotations-entity">Getting Started with Hibernate</a></p><p><strong>maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.6.10.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>配置文件hibernate.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Database connection settings</span></span><br><span class="line"><span class="meta">hibernate.connection.url</span>=<span class="string">jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1</span></span><br><span class="line"><span class="meta">hibernate.connection.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">hibernate.connection.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Echo all executed SQL to console</span></span><br><span class="line"><span class="meta">hibernate.show_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.format_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.highlight_sql</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Automatically export the schema</span></span><br><span class="line"><span class="meta">hibernate.hbm2ddl.auto</span>=<span class="string">create</span></span><br></pre></td></tr></table></figure><p><strong>创建注解实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>   </span><br><span class="line"><span class="meta">@Table(name = &quot;Events&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span>   </span><br><span class="line"><span class="meta">@GeneratedValue</span>   </span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(name = &quot;eventDate&quot;)</span>   </span><br><span class="line"><span class="keyword">private</span> LocalDateTime date;</span><br><span class="line">    <span class="comment">//实体其他字段默认被认为是持久的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用sessionFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A SessionFactory is set up once for an application!</span></span><br><span class="line">    <span class="keyword">final</span> StandardServiceRegistry registry =</span><br><span class="line">            <span class="keyword">new</span> StandardServiceRegistryBuilder()</span><br><span class="line">                    .build();     </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sessionFactory =</span><br><span class="line">                <span class="keyword">new</span> MetadataSources(registry)             </span><br><span class="line">                        .addAnnotatedClass(Event.class)   </span><br><span class="line">                        .buildMetadata()                  </span><br><span class="line">                        .buildSessionFactory();           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// The registry would be destroyed by the SessionFactory, but we</span></span><br><span class="line">        <span class="comment">// had trouble building the SessionFactory so destroy it manually.</span></span><br><span class="line">        StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory.inTransaction(session -&gt; &#123;   </span><br><span class="line">    session.persist(<span class="keyword">new</span> Event(<span class="string">&quot;Our very first event!&quot;</span>, now()));   </span><br><span class="line">    session.persist(<span class="keyword">new</span> Event(<span class="string">&quot;A follow up event&quot;</span>, now()));</span><br><span class="line">&#125;);</span><br><span class="line">    sessionFactory.inTransaction(session -&gt; &#123;</span><br><span class="line">    session.createSelectionQuery(<span class="string">&quot;from Event&quot;</span>, Event.class)   </span><br><span class="line">            .getResultList()   </span><br><span class="line">            .forEach(event -&gt; out.println(<span class="string">&quot;Event (&quot;</span> + event.getDate() + <span class="string">&quot;) : &quot;</span> + event.getTitle()));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是native hibernate APIs</p><p>此外还可以使用JPA标准APIs</p><blockquote><p>5.x版本的hibernate使用cfg和hbm提供映射,但新版本已经不用了.</p></blockquote><p>&gt;</p><blockquote><p>JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。</p><p>需要注意的是JPA统一了Java应用程序访问ORM框架的规范</p><p><strong>JPA为我们提供了以下规范：</strong></p><ol><li>ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中</li><li>JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了</li><li>JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</li></ol></blockquote><h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><blockquote><p>Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p><p>Spring Data JPA是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。</p></blockquote><p><a href="https://docs.spring.io/spring-data/jpa/reference/repositories/core-concepts.html">Core concepts :: Spring Data JPA</a></p><p>Spring Data JPA往往搭配Spring以及SpringBoot使用.</p><p><strong>使用注解创建POJO类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>声明仓库接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">save</span><span class="params">(Person person)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;Person&gt; <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用仓库</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增加自定义的CRUD方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>; <span class="comment">// 根据名字查找用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照相关规范生成相应JPQL查询.</p><p>基本原则</p><ol><li><strong>实体属性作为基础</strong>：查询方法通常基于实体类中的属性名称构建。例如，如果你有一个 <code>User</code> 实体，并且这个实体有一个 <code>name</code> 属性，你可以创建一个以 <code>findByName</code> 开头的方法来查找具有特定名称的所有用户。</li><li><strong>关键词用于指定操作</strong>：在方法名中使用特定的关键字可以指定你想要执行的操作类型（如查找、计数等）以及查询条件（如等于、包含等）。</li></ol><p>对于更复杂的查询需求，如果方法名约定不能满足要求，可以使用 <code>@Query</code> 注解直接定义JPQL或原生SQL查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用原生SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)</span></span><br><span class="line"><span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="消息组件"><a href="#消息组件" class="headerlink" title="消息组件"></a>消息组件</h1><h2 id="Redis✨"><a href="#Redis✨" class="headerlink" title="Redis✨"></a>Redis✨</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>Redis 的主要特性</strong></p><ul><li><strong>高性能</strong>：所有数据都存储在内存中，读写速度非常快。</li><li><strong>持久化</strong>：支持 RDB 和 AOF 两种方式将内存中的数据保存到硬盘上，以防止数据丢失。</li><li><strong>复制功能</strong>：支持主从复制，可以提高系统的可用性和扩展性。</li><li><strong>事务支持</strong>：通过 MULTI, EXEC, DISCARD 和 WATCH 等命令实现简单的事务管理。</li><li><strong>发布订阅模式</strong>：支持 Pub/Sub 消息传递模式。</li><li><strong>Lua 脚本支持</strong>：允许用户执行自定义逻辑，保证原子性。</li><li><strong>键过期时间</strong>：可以为每个键设置生存时间，过期后自动删除。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis 主要支持以下几种数据类型：</p><ul><li><strong>string（字符串）:</strong> 基本的数据存储单元，可以存储字符串、整数或者浮点数。</li><li><strong>hash（哈希）:</strong>一个键值对集合，可以存储多个字段。</li><li><strong>list（列表）:</strong>一个简单的列表，可以存储一系列的字符串元素。</li><li><strong>set（集合）:</strong>一个无序集合，可以存储不重复的字符串元素。</li><li><strong>zset(sorted set：有序集合):</strong> 类似于集合，但是每个元素都有一个分数（score）与之关联。</li><li><strong>位图（Bitmaps）：</strong>基于字符串类型，可以对每个位进行操作。</li><li><strong>超日志（HyperLogLogs）：</strong>用于基数统计，可以估算集合中的唯一元素数量。</li><li><strong>地理空间（Geospatial）：</strong>用于存储地理位置信息。</li><li><strong>发布/订阅（Pub/Sub）：</strong>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。</li><li><strong>流（Streams）：</strong>用于消息队列和日志存储，支持消息的持久化和时间排序。</li><li><strong>模块（Modules）：</strong>Redis 支持动态加载模块，可以扩展 Redis 的功能。</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>基本编码方式是RAW,基于简单动态字符串实现. 存储上限512MB.</p><p>如果存储的SDS长度小于44字节,则会采用EMBSTR,此时object head与SDSS是连续空间.</p><p>如果是整数值,并且在LONG_MAX之内,采用INT编码.不需要SDS部分,ptr直接指向整数.</p><p><img data-src="https://s2.loli.net/2025/03/26/sjPGpMUlIBCfXrg.png" alt="image-20250326102935636"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object encoding key <span class="comment"># 查询编码方式</span></span><br></pre></td></tr></table></figure><h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><p>从首、尾操作元素的列表</p><p><img data-src="https://s2.loli.net/2025/03/26/ALHs6CkcYGnB8me.png" alt="image-20250326103337835"></p><p><img data-src="https://s2.loli.net/2025/03/26/4JMB7i9FwZpSLVW.png" alt="image-20250326104058671"></p><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><p>单列集合,不保证有序性,保证元素唯一,求交集、并集和差集.</p><p>set采用HT编码(Dict),key用来存储元素,value统一为null.</p><p>当存储的所有数据为整数,并且元素数量不超过set-max-intset-entries时,Set会采用IntSet编码,节省内存.</p><p><img data-src="https://s2.loli.net/2025/03/26/sKmpPezAdXafgn4.png" alt="image-20250326105453513"></p><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>每个元素指定一个score值</p><p><img data-src="https://s2.loli.net/2025/03/26/UhEFYszHKGQjTBt.png" alt="image-20250326111021533"></p><p><img data-src="https://s2.loli.net/2025/03/26/8d5MsA1VqQovZXc.png" alt="image-20250326111516132"></p><p><img data-src="https://s2.loli.net/2025/03/26/n8DoQbwTMVa5FZY.png" alt="image-20250326112849287"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><img data-src="https://s2.loli.net/2025/03/26/4BPamIhnFEviQWy.png" alt="image-20250326113333031"></p><p><img data-src="https://s2.loli.net/2025/03/26/D25tMOAiSJjCx1n.png" alt="image-20250326113448318"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓冲中和数据库中都不存在,这样缓存永远不会起作用,这些请求直接访问数据库.</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>对于查询结果为空的数据，也可以将其缓存起来（通常设置较短的过期时间），这样当同样的请求再次到来时，可以直接从缓存中获取结果而不需要访问数据库。</p><p><img data-src="https://s2.loli.net/2025/03/25/Xij1Npoe8xrqcS3.png" alt="image-20250325171102410"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存获取数据</span></span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果缓存未命中，则尝试从数据库获取</span></span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对于不存在的数据也进行缓存，但设置较短的过期时间</span></span><br><span class="line">        cache.put(key, <span class="string">&quot;NULL&quot;</span>, SHORT_EXPIRE_TIME);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点:实现简单,维护方便</p><p>缺点:额外的内存消耗,可能造成短期的不一致</p><h4 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h4><p>使用布隆过滤器可以在内存中高效地判断一个元素是否在一个集合中。它通过多个哈希函数将元素映射到位数组中的几个点，设置这些点为1。查询时，只要有一个对应的位不是1，就可以确定该元素不在集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例伪代码</span></span><br><span class="line">BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), expectedInsertions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载所有可能存在的key到布隆过滤器中</span></span><br><span class="line"><span class="keyword">for</span> (String key : allPossibleKeys) &#123;</span><br><span class="line">    bloomFilter.put(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bloomFilter.mightContain(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/axN3ZGnYCrV2dt1.png" alt="image-20250325173115631"></p><p>在实际应用中，你可以在查询之前先用布隆过滤器检查是否存在该键，只有当布隆过滤器认为该键可能存在时，才去数据库查询并更新缓存。</p><ul><li><strong>优点</strong>：节省空间且查询速度快。</li><li><strong>缺点</strong>：有一定的误判率，即可能存在某些元素实际上不在集合中却被认为存在的假阳性情况，但对于缓存穿透问题来说，这通常是可接受的。</li></ul><p>其他方法</p><p> <strong>接口限流与用户行为分析</strong></p><p><strong>合理的缓存策略设计</strong></p><p><img data-src="https://s2.loli.net/2025/03/25/Aaehzxr8njmpCbq.png" alt="image-20250325175340534"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某个时间段内，<strong>大量的缓存数据同时过期失效，导致大量请求直接打到后端数据库或其他数据源上</strong>，造成服务器负载急剧增加，甚至可能导致系统崩溃的现象。这种情况通常发生在缓存层突然不可用或者缓存策略设计不合理时。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><strong>设置不同的缓存过期时间</strong></li></ol><p>随机化过期时间,为避免大量缓存同时过期，可以在设定缓存的有效期时加入一定的随机性。例如，原本所有缓存的有效期都是1小时，现在可以设置成1小时±5分钟，这样可以分散缓存失效的时间点。</p><ol><li><strong>双缓存机制</strong></li></ol><p>实现两个级别的缓存，一级缓存用于快速响应请求，二级缓存则在一级缓存失效时提供支持。当一级缓存中的数据过期后，仍然可以从二级缓存中获取数据，从而减轻对数据库的压力。</p><p><strong>其他</strong></p><p>利用Redis集群提高服务可用性</p><p>给缓存业务添加降级限流策略</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指一个非常热门的key，在缓存失效的瞬间，大量的请求同时访问这个key，由于此时缓存中没有该数据（已经过期或被删除），这些请求会直接打到数据库上，导致数据库压力骤增。这种情况类似于“击穿”了缓存层，直接冲击后端存储。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>1,  互斥锁</p><p>使用互斥锁可以在缓存失效时只允许一个线程去查询数据库并更新缓存，其他线程等待该线程完成后再从缓存中读取数据。这种方法能有效避免大量线程同时访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String lockKey = <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 缓存未命中</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey.intern()) &#123; <span class="comment">// 使用字符串内部池作为锁对象</span></span><br><span class="line">            value = cache.get(key); <span class="comment">// 再次检查缓存，防止其他线程已经填充了缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                value = db.query(key); <span class="comment">// 查询数据库</span></span><br><span class="line">                cache.put(key, value); <span class="comment">// 更新缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/I2n1hxzA8XteQP5.png" alt="image-20250325205849705"></p><p>利用<code>setnx</code>实现互斥逻辑.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> solvePassthrough(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 查询缓存是否存在</span></span><br><span class="line">    <span class="keyword">String</span> s = redisTemplate.opsForValue().<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在直接返回</span></span><br><span class="line">        <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不存在 s==null,表示不存在</span></span><br><span class="line">        <span class="comment">// 2. 缓存不存在，尝试拿锁</span></span><br><span class="line">        Boolean b = tryLock(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="comment">//3. 拿到锁，查询数据库</span></span><br><span class="line">            <span class="comment">//&quot;select * from table where key = &quot; + key;</span></span><br><span class="line">            <span class="keyword">String</span> result = <span class="string">&quot;result&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据库查询 没找到数据</span></span><br><span class="line">                <span class="comment">// 设置空缓存对象 避免缓存穿透</span></span><br><span class="line">                redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">key</span>, <span class="string">&quot;&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                unlock(<span class="built_in">key</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 查询数据库后，将数据放入缓存</span></span><br><span class="line">            redisTemplate.opsForValue().<span class="built_in">set</span>(<span class="built_in">key</span>, result, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//5. 释放锁</span></span><br><span class="line">            unlock(<span class="built_in">key</span>);</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4. 没有拿到锁,等待重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> solvePassthrough(<span class="built_in">key</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(<span class="built_in">key</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Boolean tryLock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Boolean b = redisTemplate.opsForValue().setIfAbsent(<span class="built_in">key</span>, <span class="string">&quot;1&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    redisTemplate.delete(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.逻辑过期</p><p>对于一些极其重要的热点数据，可以考虑将其缓存设置为永不过期。但是这种方式需要配合后台异步任务定期刷新缓存中的数据，以确保数据的时效性。</p><p><img data-src="https://s2.loli.net/2025/03/25/2FKGxVs6pUu5d3g.png" alt="image-20250325205936982"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个后台任务定期执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshHotData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String hotKey = <span class="string">&quot;hot_data&quot;</span>;</span><br><span class="line">    Object newValue = db.query(hotKey); <span class="comment">// 从数据库获取最新数据</span></span><br><span class="line">    cache.put(hotKey, newValue); <span class="comment">// 更新缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在业务逻辑中获取数据时，直接从缓存读取即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getHotData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(<span class="string">&quot;hot_data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以增加过期时间,在业务层进行判断,如果实际已经过期(此时Redis中仍有数据,因为没有超过TTL). 则创建线程更新数据并写入缓存(加锁),原本线程返回过期数据.</p></blockquote><p><img data-src="https://s2.loli.net/2025/03/25/KnfBu1UqX9DrAEW.png" alt="image-20250325182959630"></p><h3 id="内存持久化"><a href="#内存持久化" class="headerlink" title="内存持久化"></a>内存持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份</p><p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。</p><p>basave会fork主进程得到子进程,子进程共享主进程的内存数据,完成fork后读取内存数据写入RDB文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING </span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/UYWLnOzjM3FitKD.png" alt="image-20250325220031131"></p><p><img data-src="https://s2.loli.net/2025/03/25/vSzoKf3ibdCDQw2.png" alt="image-20250325220501005"></p><p><img data-src="https://s2.loli.net/2025/03/25/ObYogUBk1F5Xi3C.png" alt="image-20250325220624058"></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>APPEND ONLY  MODE</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span> APPEND ONLY MODE <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line">appendonly <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/03/25/eVhk1jS2WB9H7Za.png" alt="image-20250325221116370"></p><p>使用<code>bgrewriteaof</code>节省AOF文件,因为记录的AOF命令可能多余(比如后面的更新了前面的值)</p><p><img data-src="https://s2.loli.net/2025/03/25/KvqyuzAp4XeFJE8.png" alt="image-20250325222257850"></p><p><img data-src="https://s2.loli.net/2025/03/25/hL2vHmQEdOAuocX.png" alt="image-20250325222328632"></p><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 提供了一种简单的事务机制，它<strong>允许用户将多个命令打包成一个事务进行执行</strong>。与传统数据库中的事务不同<strong>，Redis 的事务并不支持回滚（rollback）操作</strong>。</p><p>Redis 事务的关键命令</p><ul><li><strong>MULTI</strong>：标记一个事务块的开始。一旦调用了 <code>MULTI</code> 命令，客户端会进入事务模式，在这种模式下所有的后续命令都会被放入队列中等待执行，而不是立即执行。</li><li><strong>EXEC</strong>：执行所有在 <code>MULTI</code> 和 <code>EXEC</code> 之间的命令。当调用 <code>EXEC</code> 时，Redis 会顺序地执行事务队列中的每个命令，并返回每个命令的结果。</li><li><strong>DISCARD</strong>：取消事务，放弃执行事务队列中的所有命令并退出事务模式。</li><li><p><strong>WATCH</strong>：用于监控一个或多个键，如果这些键在事务执行之前被其他客户端修改了，则事务会被中断，<code>EXEC</code> 返回 <code>nil</code> 表示事务未成功执行。这为 Redis 提供了一种乐观锁机制。</p></li><li><p><strong>原子性</strong>：虽然 Redis 的事务保证了命令序列要么全部执行，要么一个都不执行，但是 Redis 并不支持回滚功能。这意味着如果有任何命令执行失败，其余命令仍将继续执行。</p></li><li><strong>乐观锁</strong>：通过 <code>WATCH</code> 命令实现的乐观锁机制可以在一定程度上解决并发修改的问题。例如，在对某个键进行修改前先 <code>WATCH</code> 它，然后执行一系列的操作，最后通过 <code>EXEC</code> 提交事务。如果在这期间有其他客户端修改了该键，则当前事务将被中断，<code>EXEC</code> 将返回 <code>nil</code>。</li></ul><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">... <span class="comment"># 其他客户端可能在此期间修改了 mykey</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey newValue</span><br><span class="line">EXEC <span class="comment"># 如果 mykey 在 WATCH 后被修改过，EXEC 将返回 nil</span></span><br></pre></td></tr></table></figure><h2 id="RabbitMQ✨"><a href="#RabbitMQ✨" class="headerlink" title="RabbitMQ✨"></a>RabbitMQ✨</h2><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h1 id="网络编程框架"><a href="#网络编程框架" class="headerlink" title="网络编程框架"></a>网络编程框架</h1><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h1 id="Spring家族✨"><a href="#Spring家族✨" class="headerlink" title="Spring家族✨"></a>Spring家族✨</h1><p>Spring提供依赖注入(DI),控制反转(IOC),面向切面编程等,为Java开发提供便利.而SpringMVC提供了比纯Servlet更好的开发体验.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.MyServlets;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 2025/3/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By proanimer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Servlet实现web请求响应</span></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: workspace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>: org.example.MyServlets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: MyServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: proanimer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/10 20:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;MyServlet&quot;, urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(PrintWriter out = resp.getWriter()) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;title&gt;MyServlet&lt;/title&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h1&gt;MyServlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p><a href="https://spring.io/quickstart">Spring | Quickstart</a></p><p><a href="https://www.cainiaojc.com/spring/spring-tutorial.html">Spring 教程 - Spring教程 - 菜鸟教程</a></p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><blockquote><p>依赖注入（DI）是 IoC 的一种特殊形式，其中对象仅通过构造函数参数、工厂方法参数或在对象实例构建或从工厂方法返回后设置的属性来定义其依赖（即它们与之一起工作的其他对象）。IoC 容器在创建 bean 时注入这些依赖。这个过程本质上是 bean 本身通过直接构建类或如Service Locator pattern等机制控制其依赖的实例化或位置的反向（因此得名，控制反转）。</p></blockquote><p>Spring 框架支持多种配置方式，包括<strong>基于 XML 的配置</strong>、<strong>基于注解的配置</strong>以及<strong>基于 Java 配置类</strong>的配置。</p><blockquote><p>spring6.x版本官方文档已经不再详细说xml配置,主流是java配置类.</p></blockquote><ul><li><strong>XML 配置</strong>：适用于传统的 Spring 应用程序，提供了对 Spring 容器的详细控制。</li><li><strong>注解配置</strong>：减少了 XML 配置的需求，使得代码更加简洁，但可能不如 XML 配置那样直观地看到整个应用程序的结构。</li><li><strong>Java 配置类</strong>：提供了一种类型安全的方式来配置 Spring 应用程序，尤其适合新的项目或微服务架构。</li></ul><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基石。 <code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。</p><blockquote><p>Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，比如<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p></blockquote><p><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li>更容易与 Spring 的 AOP 功能集成</li><li>消息资源处理（用于国际化）</li><li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li></ul><p>简而言之， <code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集</p><p><strong>ApplicationContext容器实现类</strong>：</p><div class="table-container"><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td><strong>ClassPathXmlApplicationContext</strong></td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td><strong>AnnotationConfigApplicationContext</strong></td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table></div><p>IoC 容器的基本职责包括：</p><ul><li>实例化 Bean。</li><li>设置 Bean 的属性值和生命周期回调。</li><li>管理 Bean 之间的依赖关系。</li><li>控制 Bean 的作用域（如 singleton, prototype 等）。</li></ul><p>Spring 提供了两种类型的 IoC 容器：</p><ul><li><strong>BeanFactory</strong>：提供了基础的功能来管理和操作 Bean，适合资源受限的环境。</li><li><strong>ApplicationContext</strong>：扩展了 <code>BeanFactory</code>，增加了事件发布、国际化支持、AOP 集成等功能，适用于大多数应用场合。</li></ul><p>通常情况下，开发者更倾向于使用 <code>ApplicationContext</code>，因为它提供了更多的功能和便利性。</p><p><strong>2. ApplicationContext 的实现类</strong></p><p>Spring 提供了几种 <code>ApplicationContext</code> 的实现类，每种都有其特定的应用场景：</p><ul><li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的 XML 文件加载 Bean 定义。</li><li><strong>FileSystemXmlApplicationContext</strong>：从文件系统中指定位置的 XML 文件加载 Bean 定义。</li><li><strong>AnnotationConfigApplicationContext</strong>：用于基于 Java 注解的配置，不依赖于 XML 文件。</li><li><strong>WebApplicationContext</strong>：专为 Web 应用设计，支持 Servlet 上下文，并且可以方便地集成到 Web 应用程序中。</li></ul><p><strong>3. Bean 定义</strong></p><p>在 Spring 中，Bean 定义是描述如何创建一个 Bean 的元数据。可以通过以下方式定义 Bean：</p><ul><li><strong>XML 配置文件</strong>：传统方式，通过 XML 文件定义 Bean 及其依赖关系。</li><li><strong>注解</strong>：例如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等，配合 <code>@Autowired</code> 或构造函数注入。</li><li><strong>Java 配置类</strong>：使用 <code>@Configuration</code> 和 <code>@Bean</code> 注解定义 Bean。</li></ul><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;constructor-arg&gt;</code> 标签用于在 XML 配置文件中定义构造函数注入所需的参数。通过该标签，你可以指定将哪些值或 Bean 注入到目标类的构造函数中。<code>&lt;constructor-arg&gt;</code> 支持多个属性来帮助精确地匹配和注入依赖，主要包括 <code>name</code>, <code>value</code>, <code>index</code>, 和 <code>type</code> 等属性。下面详细介绍这些属性的意义：</p><ol><li><code>name</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的名字。</p></li><li><p><strong>适用场景</strong>：当目标类的构造函数使用命名参数时，可以通过 <code>name</code> 属性明确指定要注入哪个参数。不过需要注意的是，Spring 在早期版本中并不直接支持按名称注入构造参数，而是根据类型和顺序（索引）进行匹配。从 Spring 3.0 开始，如果使用 CGLIB 来增强字节码，则可以支持基于名称的构造函数注入。</p></li><li><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;paramName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;someValue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>value</code></li></ol><ul><li><p><strong>用途</strong>：直接为基本数据类型或 String 类型的构造函数参数提供值。</p></li><li><p><strong>适用场景</strong>：适用于需要传递简单类型的值作为构造函数参数的情况。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, World!&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里”Hello, World!”将被作为第一个参数传递给ExampleClass的构造函数。</p></li></ul><ol><li><code>index</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的位置索引，以确定向哪个参数注入值。</p></li><li><p><strong>适用场景</strong>：当你有多个构造函数参数并且想要精确控制哪个参数接收哪个值时非常有用。</p></li><li><p><strong>注意事项</strong>：索引是从 0 开始的。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;First Argument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>type</code></li></ol><ul><li><p><strong>用途</strong>：指定构造函数参数的数据类型，帮助 Spring 容器更准确地选择合适的构造函数（特别是在存在重载构造函数的情况下）。</p></li><li><p><strong>适用场景</strong>：当你有多个同名但不同类型的构造函数参数时，或者你需要确保特定类型的值被注入时使用。</p></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;String Argument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>Java配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRepository <span class="title">myRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRepositoryImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用构造函数注入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl(myRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ClientService&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>利用工厂类的静态方法</p><h4 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h4><p>利用工厂的实例方法</p><p>首先定义工厂 Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ServiceFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后，使用这个工厂 Bean 的方法来创建目标 Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;serviceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里假设 <code>ServiceFactory</code> 类中有一个名为 <code>createClientServiceInstance</code> 的方法，用于创建并返回一个新的 <code>ClientService</code> 实例。</p><p><strong>注解方式创建工厂Bean</strong></p><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ZoneId</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String zone = <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZoneId <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p><p><strong>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了</strong>。</p><h4 id="实例化后设置属性"><a href="#实例化后设置属性" class="headerlink" title="实例化后设置属性"></a>实例化后设置属性</h4><p>这是最常见的 Bean 实例化方式之一，在 Bean 被实例化之后，通过 setter 方法设置其属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;property1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;property2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;anotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ExampleBean</code> 有两个属性 <code>property1</code> 和 <code>property2</code>，它们分别通过 <code>set</code> 方法被赋值</p><h4 id="注解Annotation配置"><a href="#注解Annotation配置" class="headerlink" title="注解Annotation配置"></a>注解Annotation配置</h4><p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p><p>可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p><p><code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p><h4 id="使用Java配置类"><a href="#使用Java配置类" class="headerlink" title="使用Java配置类"></a>使用Java配置类</h4><h4 id="Bean的声明周期管理"><a href="#Bean的声明周期管理" class="headerlink" title="Bean的声明周期管理"></a>Bean的声明周期管理</h4><p><strong>Bean 生命周期的基本流程</strong></p><p>一个典型的 Spring Bean 生命周期包括以下几个步骤：</p><ol><li><strong>实例化</strong>：根据配置元数据（如 XML 配置、Java 注解或 Java 配置类），Spring 容器首先实例化 Bean。</li><li><strong>设置属性值</strong>：将 Bean 实例化后，Spring 会为该 Bean 设置属性值和其他依赖注入。</li><li><strong>初始化前</strong>：如果实现了 <code>Aware</code> 系列接口（例如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code>），则调用这些接口的方法，让 Bean 能够感知其环境信息。</li><li><strong>BeanPostProcessor 前处理</strong>：如果存在实现了 <code>BeanPostProcessor</code> 接口的 Bean，则调用其 <code>postProcessBeforeInitialization</code> 方法。这是对所有 Bean 都适用的一个扩展点。</li><li><strong>初始化</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，则调用 <code>afterPropertiesSet()</code> 方法。</li><li>如果指定了 <code>&lt;bean&gt;</code> 元素的 <code>init-method</code> 属性或使用了 <code>@PostConstruct</code> 注解，则调用指定的初始化方法。</li></ul></li><li><strong>BeanPostProcessor 后处理</strong>：接着再次调用实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization</code> 方法。</li><li><strong>使用阶段</strong>：此时 Bean 已经准备好并可以被应用程序使用了。</li><li><strong>销毁阶段</strong>：<ul><li>当容器关闭时，如果 Bean 实现了 <code>DisposableBean</code> 接口，则调用 <code>destroy()</code> 方法。</li><li>如果指定了 <code>&lt;bean&gt;</code> 元素的 <code>destroy-method</code> 属性或使用了 <code>@PreDestroy</code> 注解，则调用指定的销毁方法。</li></ul></li></ol><p><strong>2. 控制 Bean 生命周期的关键接口和注解</strong></p><ul><li><strong><code>Aware</code> 系列接口</strong>：用于让 Bean 感知到容器的一些信息。<ul><li><code>BeanNameAware</code>: 获取 Bean 的名称。</li><li><code>BeanFactoryAware</code>: 获取 BeanFactory。</li><li><code>ApplicationContextAware</code>: 获取 ApplicationContext。</li></ul></li><li><strong><code>BeanPostProcessor</code> 接口</strong>：提供两个方法用于前后处理 Bean 初始化逻辑。<ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code> 在初始化之前调用。</li><li><code>postProcessAfterInitialization(Object bean, String beanName)</code> 在初始化之后调用。</li></ul></li><li><strong><code>InitializingBean</code> 接口</strong>：提供 <code>afterPropertiesSet()</code> 方法，在所有属性设置完成后执行自定义初始化逻辑。</li><li><strong><code>DisposableBean</code> 掀口</strong>：提供 <code>destroy()</code> 方法，在容器关闭时执行清理工作。</li><li><strong>注解支持</strong>：<ul><li><code>@PostConstruct</code>：标注在方法上，表示这是一个初始化方法。</li><li><code>@PreDestroy</code>：标注在方法上，表示这是一个销毁方法。</li></ul></li></ul><p>在 Spring 框架中，Bean 的作用域（Scope）决定了 Bean 实例的作用范围和生命周期。Spring 提供了多种内置的作用域类型，每种类型适用于不同的场景。理解这些作用域可以帮助你更好地控制 Bean 的行为，确保它们在应用程序中的正确使用。</p><p><strong>1. 常见的 Bean 作用域</strong></p><p><strong>(1) Singleton（单例）</strong></p><ul><li><strong>默认作用域</strong>：如果未指定作用域，默认为 <code>singleton</code>。</li><li><strong>行为</strong>：Spring 容器在整个应用上下文中只会创建一个该类型的 Bean 实例，并且所有对该 Bean 的请求都会返回这个唯一的实例。</li><li><strong>适用场景</strong>：大多数情况下，特别是对于无状态的服务类，如服务层、数据访问层等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或通过注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) Prototype（原型）</strong></p><ul><li><strong>行为</strong>：每次对 Bean 的请求都会创建一个新的实例。</li><li><strong>适用场景</strong>：当需要每次获取到的是一个新的对象实例时使用，例如命令对象、Web 控制器等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或通过注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有Request,Session和Application等作用域.</p><h4 id="选择性实例化Bean"><a href="#选择性实例化Bean" class="headerlink" title="选择性实例化Bean"></a>选择性实例化Bean</h4><p>选择性实例化 Bean 是指根据某些条件动态决定是否创建某个 Bean 实例。Spring 提供了多种机制来实现这种功能，例如使用注解、配置文件或编程方式</p><p><strong>使用 <code>@Conditional</code> 注解</strong></p><p><code>@Conditional</code> 是 Spring 中的一个核心注解，用于根据特定条件决定是否加载某个 Bean。</p><p><strong>(1) 工作原理</strong></p><ul><li><code>@Conditional</code> 接受一个实现了 <code>Condition</code> 接口的类作为参数。</li><li>在运行时，Spring 会调用 <code>Condition</code> 的 <code>matches()</code> 方法，如果返回 <code>true</code>，则加载该 Bean；否则跳过。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Condition;</span><br><span class="line">import org.springframework.context.annotation.ConditionContext;</span><br><span class="line">import org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line">// 自定义条件类</span><br><span class="line">public class MyCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 检查系统属性 &quot;my.condition&quot; 是否为 true</span><br><span class="line">        return Boolean.parseBoolean(System.getProperty(&quot;my.condition&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置类</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Conditional;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(MyCondition.class)</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加载 MyBean</span></span><br><span class="line">java -jar app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 MyBean</span></span><br><span class="line">java -Dmy.condition=<span class="literal">true</span> -jar app.jar</span><br></pre></td></tr></table></figure><p><code>@Profile</code> 是 Spring 中的一种更简单的条件加载机制，它根据当前激活的环境（profile）来决定是否加载某个 Bean。</p><p><strong>(1) 工作原理</strong></p><ul><li>每个 <code>@Profile</code> 注解可以指定一个或多个 profile 名称。</li><li>只有当这些 profile 被激活时，对应的 Bean 才会被加载。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">devBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">&quot;Development Environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">prodBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">&quot;Production Environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 测试</strong></p><p>启动程序时，可以通过指定激活的 profile 来加载不同的 Bean：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活开发环境</span></span><br><span class="line">java -Dspring.profiles.active=dev -jar app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活生产环境</span></span><br><span class="line">java -Dspring.profiles.active=prod -jar app.jar</span><br></pre></td></tr></table></figure><p><strong>使用 FactoryBean 动态创建 Bean</strong></p><p><code>FactoryBean</code> 是 Spring 提供的一种接口，用于动态创建 Bean 实例。</p><p><strong>(1) 工作原理</strong></p><ul><li>实现 <code>FactoryBean</code> 接口，并重写 <code>getObject()</code> 方法。</li><li>在运行时，Spring 会调用 <code>getObject()</code> 方法来获取实际的 Bean 实例。</li></ul><p><strong>(2) 示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">MyBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactory</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Bean creation is disabled!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyBean.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBeanFactory <span class="title">myBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanFactory(Boolean.getBoolean(<span class="string">&quot;factory.bean.enabled&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何实现依赖注入"><a href="#如何实现依赖注入" class="headerlink" title="如何实现依赖注入"></a>如何实现依赖注入</h3><p>依赖注入是 IoC 的一种实现方式，允许对象定义其依赖关系而不必自行创建或查找依赖的对象。Spring 支持三种依赖注入类型：</p><ul><li><strong>构造器注入</strong>：通过构造函数参数注入依赖。</li><li><strong>Setter 方法注入</strong>：通过 setter 方法注入依赖。</li><li><strong>字段注入</strong>：直接在字段上使用 <code>@Autowired</code> 注解进行注入。</li></ul><p>当 Spring 应用启动时，IoC 容器会根据 <code>@Autowired</code> 注解的信息去寻找相应的 Bean 并将其注入到目标对象中。以下是几种常见的注入方式：</p><ol><li><strong>构造函数注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自 Spring 4.3 起可以省略，如果只有一个构造函数的话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceUser</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中，Spring 将会查找类型为 <code>MyService</code> 的 Bean，并将其注入到 <code>ServiceUser</code> 类的构造函数中。</li></ul><ol><li><strong>字段注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService; <span class="comment">// 直接注入 MyService 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字段注入是最简单的形式，但它可能会导致难以进行单元测试，因为它绕过了类的构造函数。</li></ul><ol><li><strong>Setter 方法注入</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Setter 方法注入适合于那些可选依赖或希望在运行时更改依赖的情况</li></ul><p><strong>Bean 查找规则</strong></p><p>Spring 容器按照以下顺序尝试解析依赖：</p><ol><li><strong>类型匹配</strong>：首先<strong>基于参数类型</strong>查找匹配的 Bean。</li><li><strong>名称匹配</strong>：如果<strong>有多个相同类型的 Bean 存在，则根据参数名作为 Bean 名称进行匹配</strong>。</li><li><strong>限定符（Qualifiers）</strong>：当存在多个相同类型的 Bean 且名称也不足以区分时，可以使用 <code>@Qualifier</code> 注解指定确切的 Bean 名称</li></ol><p>如果你希望给 Bean 指定一个不同于方法名的名称，可以通过 <code>@Bean</code> 注解的 <code>name</code> 属性来实现或者 <code>@Qualifier</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;zoneZ&quot;)</span></span><br><span class="line"><span class="function">ZoneId <span class="title">createZoneOfZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;zoneUTC8&quot;)</span></span><br><span class="line"><span class="function">ZoneId <span class="title">createZoneOfUTC8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Autowired</code> 标记的构造函数、字段或方法会被 Spring 容器扫描，并尝试找到匹配的 Bean 来注入。如果找到多个匹配的 Bean，则可能需要通过 <code>@Qualifier</code> 注解来指定具体的 Bean。</p><p>Spring 提供了多种注解用于实现依赖注入。以下是常用的注入注解及其用途：</p><p><strong>1. 核心注入注解</strong></p><p><strong>(1) <code>@Autowired</code></strong></p><ul><li><strong>作用</strong>：自动注入依赖对象。</li><li>位置:<ul><li>构造器</li><li>方法（如 setter 方法）</li><li>字段</li><li>参数</li></ul></li><li>特点<ul><li><strong>默认按类型（byType）</strong>进行匹配。</li><li>如果有多个相同类型的 Bean，则会抛出异常，需要结合 <code>@Qualifier</code> 使用。 注解用在构造器,setter,属性上和方法参数上</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入 UserRepository</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) <code>@Qualifier</code></strong></p><ul><li><strong>作用</strong>：当存在多个相同类型的 Bean 时，指定要注入的具体 Bean。</li><li><strong>配合</strong>：通常与 <code>@Autowired</code> 配合使用。</li><li><strong>特点</strong>：<strong>通过名称（byName）</strong>来限定注入的 Bean。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userRepositoryV1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV1</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;userRepositoryV2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userRepositoryV1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 注入 UserRepositoryV1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) <code>@Primary</code></strong></p><ul><li><strong>作用</strong>：<strong>标记一个 Bean 为首选 Bean，当有多个相同类型的 Bean 时优先注入该 Bean</strong>。</li><li><strong>特点</strong>：无需显式使用 <code>@Qualifier</code>，简化配置。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV1</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryV2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入 UserRepositoryV1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) <code>@Resource</code></strong></p><ul><li><strong>作用</strong>：JSR-250 规范提供的注解，用于注入依赖。</li><li>特点<ul><li><strong>默认按名称（byName）</strong>进行匹配。</li><li><strong>如果未找到匹配的名称，则按类型（byType）匹配</strong>。</li></ul></li><li><strong>区别</strong>：<code>@Resource</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。(推荐Resource而不是Autowired)  注解用在属性上和setter上.</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userRepository&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 按名称注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(5) <code>@Inject</code></strong></p><ul><li><strong>作用</strong>：JSR-330 规范提供的注解，功能类似于 <code>@Autowired</code>。</li><li>特点:<ul><li>默认按类型（byType）进行匹配。</li><li>需要引入 <code>javax.inject</code> 包。</li></ul></li><li><strong>区别</strong>：<code>@Inject</code> 是 Java 的标准注解，而 <code>@Autowired</code> 是 Spring 的注解。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 自动注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 高级注入注解</strong></p><p><strong>(6) <code>@Value</code></strong></p><ul><li><strong>作用</strong>：注入简单的值（如字符串、数字）、系统属性或配置文件中的值。</li><li><strong>特点</strong>：支持占位符 <code>$&#123;&#125;</code> 和 SpEL 表达式 <code>#&#123;&#125;</code>。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName; <span class="comment">// 注入配置文件中的 app.name</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;2 + 3&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum; <span class="comment">// 注入表达式的计算结果 (2 + 3 = 5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(7) <code>@ConfigurationProperties</code></strong></p><ul><li><strong>作用</strong>：批量注入配置文件中的属性到一个 Java 对象中。</li><li><strong>特点</strong>：适合处理复杂的配置结构。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件 (<code>application.properties</code>)：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.version</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p><strong>(8) <code>@Lookup</code></strong></p><ul><li><strong>作用</strong>：用于方法注入，每次调用方法时都会返回一个新的 Bean 实例。</li><li><strong>场景</strong>：适用于原型（Prototype）作用域的 Bean。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeBean</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PrototypeBean <span class="title">getPrototypeBean</span><span class="params">()</span></span>; <span class="comment">// 每次调用返回新的实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 其他相关注解</strong></p><p><strong>(9) <code>@Required</code></strong></p><ul><li><strong>作用</strong>：标记某个 setter 方法必须注入值，否则抛出异常。</li><li><strong>注意</strong>：从 Spring 5 开始已被废弃，推荐使用构造器注入或 <code>@Autowired(required = true)</code>。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(10) <code>@Lazy</code></strong></p><ul><li><strong>作用</strong>：延迟加载 Bean，只有在第一次使用时才会被创建。</li><li><strong>特点</strong>：可以减少启动时间，适用于不常用的功能。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBean</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LazyBean lazyBean; <span class="comment">// 延迟加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><div class="table-container"><table><thead><tr><th>注解</th><th>功能描述</th><th>特点</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td>自动注入依赖，按类型匹配</td><td>默认按类型，支持配合 <code>@Qualifier</code> 使用</td></tr><tr><td><code>@Qualifier</code></td><td>指定要注入的 Bean 名称</td><td>按名称匹配</td></tr><tr><td><code>@Primary</code></td><td>标记首选 Bean</td><td>简化多 Bean 场景下的注入</td></tr><tr><td><code>@Resource</code></td><td>按名称或类型注入</td><td>JSR-250 标准注解</td></tr><tr><td><code>@Inject</code></td><td>按类型注入</td><td>JSR-330 标准注解</td></tr><tr><td><code>@Value</code></td><td>注入简单值或配置文件中的值</td><td>支持占位符和 SpEL</td></tr><tr><td><code>@ConfigurationProperties</code></td><td>批量注入配置文件中的属性</td><td>适合复杂配置</td></tr><tr><td><code>@Lookup</code></td><td>方法注入，每次返回新实例</td><td>适用于原型作用域</td></tr><tr><td><code>@Required</code></td><td>强制要求注入</td><td>已废弃，推荐使用其他方式</td></tr><tr><td><code>@Lazy</code></td><td>延迟加载 Bean</td><td>减少启动时间</td></tr></tbody></table></div><h3 id="AOP的底层原理"><a href="#AOP的底层原理" class="headerlink" title="AOP的底层原理"></a>AOP的底层原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p><p> AOP 的几个核心概念：</p><ul><li><strong>切面（Aspect）</strong>：一个模块化的关注点，例如日志记录、事务管理等。</li><li><strong>连接点（Join Point）</strong>：程序执行过程中的某个特定点，例如方法调用或异常抛出。</li><li><strong>通知（Advice）</strong>：在连接点执行的动作，分为前置通知、后置通知、环绕通知等。</li><li><strong>切入点（Pointcut）</strong>：定义哪些连接点会被通知。</li><li><strong>目标对象（Target Object）</strong>：被代理的对象。</li><li><strong>代理对象（Proxy Object）</strong>：由 AOP 框架创建的包装目标对象的对象。</li></ul><p>如果<strong>目标对象实现了接口，Spring 默认使用 JDK 动态代理</strong>。JDK 动态代理<strong>通过反射机制创建代理对象，并拦截方法调用</strong>。</p><p>如果目标对象没有实现接口，Spring 使用 CGLIB 动态代理。<strong>CGLIB 通过继承目标类并重写其方法来创建代理对象</strong>。</p><ul><li>CGLIB 是一个基于字节码生成的库，它通过 ASM 库操作字节码生成子类。</li><li>子类会覆盖父类的方法，并在方法调用前后插入自定义逻辑。</li></ul><p>Spring AOP 封装了动态代理的细节，开发者只需关注切面和通知的定义。</p><p><strong>(1) 定义切面和通知</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging before method execution...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 配置 Spring AOP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 启用 AOP 支持</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        Service service = context.getBean(Service.class);</span><br><span class="line">        service.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring AOP 的底层依赖于动态代理技术。</li><li>如果目标对象实现了接口，则使用 JDK 动态代理。</li><li>如果目标对象未实现接口，则使用 CGLIB 动态代理。</li></ul><h3 id="如何管理事务"><a href="#如何管理事务" class="headerlink" title="如何管理事务"></a>如何管理事务</h3><h3 id="如何处理循环依赖"><a href="#如何处理循环依赖" class="headerlink" title="如何处理循环依赖"></a>如何处理循环依赖</h3><p>在 Spring 中，<strong>循环依赖</strong>是指两个或多个 Bean 在初始化过程中相互依赖。例如：</p><ul><li><strong>Bean A</strong> 依赖于 <strong>Bean B</strong>；</li><li><strong>Bean B</strong> 又依赖于 <strong>Bean A</strong>。</li></ul><p>Spring 容器通过一些机制来处理循环依赖问题，但并不是所有类型的循环依赖都能被解决</p><p>循环依赖可以分为以下几种情况：</p><p><strong>(1) 构造函数注入的循环依赖</strong></p><p>当两个 Bean 使用构造函数注入时，如果它们之间存在循环依赖，则 Spring 无法解决这种循环依赖，会抛出 <code>BeanCurrentlyInCreationException</code> 异常。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanB</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，Spring 无法创建任何一个 Bean，因为它们互相依赖且都需要完全初始化后才能使用</p><p><strong>(2) Setter 方法或字段注入的循环依赖</strong></p><p>当两个 Bean 使用 setter 方法或字段注入时，Spring 可以解决这种循环依赖。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 能够通过提前暴露未完全初始化的 Bean 来解决这种循环依赖。</p><p><strong>Spring 处理循环依赖的机制</strong></p><p>Spring 容器通过三级缓存（singleton caches）和提前暴露未完全初始化的 Bean 来解决循环依赖问题。</p><p><strong>(1) 单例 Bean 的三级缓存</strong></p><p>Spring 容器维护了三个缓存来管理单例 Bean 的生命周期：</p><ol><li>一级缓存（singletonObjects）<ul><li>存储已经完全初始化完成的 Bean。</li><li>当 Bean 完全初始化后，会从二级缓存移动到一级缓存。</li></ul></li><li>二级缓存（earlySingletonObjects）<ul><li>存储未完全初始化但已经被提前暴露的 Bean。</li><li>当一个 Bean 正在初始化但还未完成时，Spring 会将其放入二级缓存中，以便其他 Bean 可以引用它。</li></ul></li><li>三级缓存（singletonFactories）<ul><li>存储 Bean 的工厂对象（ObjectFactory），用于动态生成未完全初始化的 Bean。</li><li>当需要提前暴露一个 Bean 时，Spring 会先将其工厂对象放入三级缓存。</li></ul></li></ol><p><strong>(2) 提前暴露未完全初始化的 Bean</strong></p><p>当 Spring 发现一个 Bean 正在初始化且有其他 Bean 需要引用它时，Spring 会提前暴露该 Bean 的实例（即使它还未完全初始化）。这通过以下步骤实现：</p><ol><li>创建 Bean 实例（调用构造函数）。</li><li>将 Bean 实例的工厂对象放入三级缓存。</li><li>如果需要提前暴露，将工厂对象生成的 Bean 放入二级缓存。</li><li>其他 Bean 可以从二级缓存中获取该未完全初始化的 Bean。</li><li>当 Bean 完全初始化后，将其移入一级缓存。</li></ol><p>这种方式适用于基于 setter 方法或字段注入的循环依赖。</p><p><strong>3. 为什么构造函数注入的循环依赖无法解决？</strong></p><p>构造函数注入要求 Bean 必须在完全初始化后才能被使用。因此，当两个 Bean 通过构造函数相互依赖时，Spring 无法满足它们的初始化顺序要求。以下是具体原因：</p><ol><li><strong>Bean A</strong> 需要 <strong>Bean B</strong> 的完全初始化实例。</li><li><strong>Bean B</strong> 需要 <strong>Bean A</strong> 的完全初始化实例。</li><li>由于两者都处于“正在初始化”状态，Spring 无法完成任意一方的初始化。</li></ol><p>一个 Bean 被认为是<strong>完全初始化</strong>的，当它已经通过了所有的初始化步骤，并且可以安全地用于应用程序中。这些步骤通常包括：</p><ul><li><strong>实例化</strong>：创建 Bean 的实例。</li><li><strong>属性填充</strong>：为 Bean 的属性设置值或注入依赖（通过构造函数、setter 方法或字段注入）。</li><li><strong>Aware 接口回调</strong>：如果 Bean 实现了特定的 <code>Aware</code> 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code> 等），Spring 会调用相应的方法，让 Bean 能够访问到容器的相关信息。</li><li><strong>初始化方法调用</strong>：如果有定义初始化方法（通过 <code>@PostConstruct</code> 注解或 <code>&lt;bean&gt;</code> 元素中的 <code>init-method</code> 属性），Spring 会在该阶段调用这些方法。</li></ul><p>​    一旦所有这些步骤都完成了，这个 Bean 就被认为是完全初始化的，并被放入 Spring 容器的一级缓存（singletonObjects）中，供其他组件使用。</p><p>一个 Bean 被认为是<strong>未完全初始化</strong>的，是指它正处于初始化过程中的某个中间状态。例如，在某些情况下，Bean 已经被实例化并注入了一些依赖，但尚未完成所有的初始化步骤（比如还没有调用初始化方法）。这种状态下，Bean 还不能完全满足其契约要求，因此可能不适合直接使用。</p><p>​    在处理循环依赖时，Spring 使用一种称为“提前暴露”的机制来解决 Setter 或字段注入引起的循环依赖问题。具体来说，当 Spring 正在初始化一个 Bean A 时，如果发现另一个 Bean B 需要引用 Bean A，而此时 Bean A 尚未完全初始化，Spring 会将 Bean A 提前暴露出来，尽管它还未经过全部的初始化步骤。这种提前暴露的 Bean 只完成了实例化和部分依赖注入，但尚未执行 Aware 接口回调、初始化方法等后续步骤。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h4><blockquote><p>拦截器</p><p>过滤器</p></blockquote><p><a href="https://springdoc.cn/spring-mvc-tutorial/">Spring MVC 教程 - spring 中文网</a></p><p>Spring 框架中处理模型（Model）- 视图（View）- 控制器（Controller）或 MVC 模式的一个模块。它结合了 MVC 模式的所有优点和 Spring 的便利性。</p><p>Spring 使用其 <code>DispatcherServlet</code> 前控制器模式实现 MVC。</p><p>简而言之，<code>DispatcherServlet</code> 是将请求路由到预定目的地的主要控制器。Model 只是应用的数据，而视图则由各种模板引擎来表示。</p><p>包含spring的依赖同时使用servlet等实现MVC架构的Web开发.</p><p>servlet如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springmvc的示例代码如下.</p><p>要通过 Java 配置类启用 Spring MVC 支持，只需添加 <code>@EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      InternalResourceViewResolver bean = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//bean.setViewClass(JstlView.class); in older version</span></span><br><span class="line">      bean.setPrefix(<span class="string">&quot;/WEB-INF/view/&quot;</span>);</span><br><span class="line">      bean.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将设置 MVC 项目所需的基本支持，如注册处理器、映射器、类型转换器、验证支持、消息转换器和异常处理。本例中注册了一个 <code>ViewResolver</code> Bean，它从 <code>/WEB-INF/view</code> 目录返回 <code>.jsp</code> 视图。可以注册视图控制器（ViewController），使用 <code>ViewControllerRegistry</code> 在 URL 和视图名称之间创建直接映射。这样，两者之间就不需要任何 Controller 了。</p><p>如果想自定义扫描 Controller 类，可以使用 <code>@ComponentScan</code> 注解，并指定包含 Controller 的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123; &quot;com.baeldung.web.controller&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了引导应用加载该配置，还需要一个 Initializer 类：</p><blockquote><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(<span class="keyword">final</span> ServletContext sc)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigWebApplicationContext root = </span><br><span class="line">          <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        </span><br><span class="line">        root.scan(<span class="string">&quot;com.baeldung&quot;</span>);</span><br><span class="line">        sc.addListener(<span class="keyword">new</span> ContextLoaderListener(root));</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic appServlet = </span><br><span class="line">          sc.addServlet(<span class="string">&quot;mvc&quot;</span>, <span class="keyword">new</span> DispatcherServlet(<span class="keyword">new</span> GenericWebApplicationContext()));</span><br><span class="line">        appServlet.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        appServlet.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回应用级别的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 返回与 DispatcherServlet 相关的配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">// 设置 DispatcherServlet 的 URL 映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个基本的 Controller 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sample&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sample&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的 JSP 资源是 <code>sample.jsp</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the body of the sample view<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于 <code>JSP</code> 的视图文件位于项目的 <code>/WEB-INF</code> 文件夹下，因此只有 Spring 才能访问它们，而不能直接通过 URL 访问。</p><p>也可以使用纯 XML 配置来代替上述 Java 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baeldung.web.controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/view/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想使用纯 XML 配置，还需要添加一个 <code>web.xml</code> 文件来引导应用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/dispatcher-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><p><a href="https://springdoc.cn/spring-boot/">Spring Boot 中文文档</a></p><p><a href="https://spring.io/">Spring | Home</a></p><p>pring Boot 是对 Spring 平台的补充，它能让你轻松上手并创建独立的生产级应用。Spring Boot 的目的不是取代 Spring，而是让使用 Spring 变得更快、更简单。</p><p><strong>pring Boot Starte</strong></p><p>Spring Boot 提供了便捷的 Starter 依赖，这是一种依赖描述符，可以为特定功能引入所有必要的技术。</p><p>这样做的好处是，不再需要为每个依赖项指定版本，而是让 Starter 管理依赖。</p><p>最快捷的入门方法是在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-parent</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就能解决依赖管理问题。</p><p><strong>Spring Boot 入口点</strong></p><p>使用 Spring Boot 构建的每个应用都需定义 main 入口点。</p><p>这通常是一个 Java 类，带有 main 方法，并用 <code>@SpringBootApplication</code> 进行注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解添加了以下其他注解：</p><ul><li><code>@Configuration</code> 将类标记为 bean 定义的来源。</li><li><code>@EnableAutoConfiguration</code> 会告诉框架根据 classpath 上的依赖自动添加 Bean。</li><li><code>@ComponentScan</code> 会扫描与 Application 类相同包或其子包中的其他配置和 Bean。</li></ul><p>有了 Spring Boot，就可以使用 Thymeleaf 或 JSP 设置前端，而无需使用定义的 <code>ViewResolver</code>。在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-thymeleaf</code> 依赖后，Thymeleaf 就会启用，无需额外配置。</p><h3 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h3><h1 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h1><h2 id="slf4j✨"><a href="#slf4j✨" class="headerlink" title="slf4j✨"></a>slf4j✨</h2><p><a href="https://logback.qos.ch/apidocs/index.html">Overview (Logback-Parent 1.5.15 API)</a></p><p>SLF4J为各种日志框架（例如 java.util.logging、logback、log4j）提供了一个简单的门面或抽象，允许用户在部署时插入所需的日志框架。</p><h2 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h2><p><a href="https://logback.qos.ch/">Logback Home</a></p><p>Logback 旨在作为流行的 log4j 项目的继任者，从 log4j 1.x 停止的地方继续发展。</p><p>Logback 的架构相当通用，以便在不同情况下应用。目前，logback 分为三个模块，分别是 logback-core、logback-classic 和 logback-access。</p><p>logback -core模块为其他两个模块奠定了基础。logback-classic模块可以看作是 log4j 1.x 的改进版本。此外，logback-classic模块原生实现了 SLF4J API，因此您可以轻松地在logaback和其他日志框架（如 log4j 1.x 或 java.util.logging（JUL））之间切换。</p><h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p><a href="https://logging.apache.org/log4j/2.12.x/">Log4j – Apache Log4j 2 - Apache Log4j 2</a></p><p>Apache Log4j 2 是 Log4j 的升级版本，在性能上对前一代 Log4j 1.x 进行了显著提升，并提供了许多 Logback 中的改进，同时修复了 Logback 架构中的一些固有缺陷。</p><h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><p>POJO</p><p>VO</p><p>PO</p><p>DAO</p><p>DTO</p><p>BO</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习很潮很流行的Java以及相关框架.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux网络编程入门</title>
    <link href="https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://www.sekyoro.top/2025/02/27/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-27T07:01:15.000Z</published>
    <updated>2025-03-25T08:17:51.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).<br><span id="more"></span></p><h2 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h2><h3 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h3><blockquote><p><strong>PF_INET</strong>：指的是协议族（Protocol Family），强调的是协议相关的概念。</p><p><strong>AF_INET</strong>：指的是地址族（Address Family），关注的是地址格式。</p><p>虽然在许多实现中 <code>PF_INET</code> 和 <code>AF_INET</code> 可以互换使用，但理论上它们代表不同的概念。为了保持代码的清晰性和一致性，推荐的做法是在创建套接字时使用 <code>AF_INET</code> 来指代地址族，而保留 <code>PF_INET</code> 用于协议族相关的上下文。不过，由于历史原因和广泛接受的习惯，这种区别在实践中往往被忽略。</p></blockquote><p>在进行网络编程时，<code>sockaddr_in</code>、<code>sockaddr</code> 和 <code>addrinfo</code> 是三个不同的数据结构，它们各自有不同的用途和特点。</p><p><strong>sockaddr</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 地址族（如AF_INET, AF_INET6）</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">// 地址信息，具体格式取决于地址族</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>用途</strong>：</p><ul><li>这是一个<strong>通用的套接字地址结构体</strong>，用于表示任何类型的套接字地址。它不特定于任何一种协议或地址家族。</li><li>它通常作为函数参数传递，以便支持多种不同类型的地址族（例如IPv4、IPv6等）。</li></ul></li><li><p><strong>局限性</strong>：</p><ul><li>因为它的<code>sa_data</code>字段是固定大小的字符数组，所以在处理复杂或长度不定的地址信息时不够灵活。</li></ul></li></ul><p><strong>sockaddr_in</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">// 地址族，必须设置为AF_INET</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">// 端口号（使用htons()转换为网络字节序）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IPv4地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>]; <span class="comment">// 填充0以使结构体大小与sockaddr相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr; <span class="comment">// 32位IPv4地址（网络字节序）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>用途</strong>：</p><ul><li><strong>专门用于IPv4地址的套接字地址结构体</strong>。</li><li>提供了明确的字段来存储端口号和IP地址，使得处理IPv4地址更加直观和方便。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>相较于<code>sockaddr</code>，它提供了更具体的字段，便于操作IPv4地址和端口信息。</li></ul></li></ul><p><strong>sockaddr_in6</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;<span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;<span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>addrinfo</strong></p><ul><li><p><strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>              ai_flags;     <span class="comment">// AI_PASSIVE, AI_CANONNAME, etc.</span></span><br><span class="line">    <span class="keyword">int</span>              ai_family;    <span class="comment">// AF_INET, AF_INET6, AF_UNSPEC</span></span><br><span class="line">    <span class="keyword">int</span>              ai_socktype;  <span class="comment">// SOCK_STREAM, SOCK_DGRAM</span></span><br><span class="line">    <span class="keyword">int</span>              ai_protocol;  <span class="comment">// 使用的协议</span></span><br><span class="line">    <span class="keyword">socklen_t</span>        ai_addrlen;   <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">// 地址信息</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">// 主机规范名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">// 下一个addrinfo结构指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/02/27/azvYs7B46VeOAfb.png" alt="image-20250227150905975"></p></li><li><p><strong>用途</strong>：</p><ul><li><code>addrinfo</code> 结构体由 <code>getaddrinfo()</code> 函数返回，旨在<strong>提供一个统一的方式来处理不同类型的地址信息（包括IPv4和IPv6），并简化了主机名和服务名解析的过程</strong>。</li><li>它可以包含多个结果（通过<code>ai_next</code>链表连接），允许应用程序选择最适合其需求的结果。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>支持现代互联网中常见的IPv4和IPv6地址。</li><li>能够处理复杂的配置需求，如指定被动监听（AI_PASSIVE）、获取规范主机名等。</li><li>更加灵活和强大，适合需要跨平台兼容性和灵活性的应用程序。</li></ul></li></ul><p><strong>sockaddr_storage</strong></p><p><code>sockaddr_storage</code> 是一个在 <code>&lt;netinet/in.h&gt;</code> 或 <code>&lt;sys/socket.h&gt;</code> 头文件中定义的数据结构，旨在提供一个足够大的缓冲区来存储任何类型的套接字地址（包括 IPv4、IPv6 等）。它解决了由于不同协议族的地址结构大小不一致所带来的问题，例如 <code>sockaddr_in</code> 和 <code>sockaddr_in6</code> 分别用于 IPv4 和 IPv6 地址，它们有不同的大小。</p><p><strong>定义与用途</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> ss_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="comment">// 其余字段未指定，实现定义以确保足够的空间和对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>ss_family</strong>：这是唯一标准化的字段，表示地址族（如 <code>AF_INET</code> 对应 IPv4，<code>AF_INET6</code> 对应 IPv6）。</li><li><strong>其他字段</strong>：这些字段的具体定义依赖于实现，主要是为了确保 <code>sockaddr_storage</code> 能够容纳所有可能的套接字地址类型，并且保持正确的内存对齐。这意味着它的大小至少要能容纳最大的套接字地址结构（比如 <code>sockaddr_in6</code>）。</li></ul><p><strong>主要特点</strong></p><ol><li><strong>统一性</strong>：通过使用 <code>sockaddr_storage</code>,可以编写更加通用的代码，避免直接处理特定于协议的地址结构（如 <code>sockaddr_in</code> 或 <code>sockaddr_in6</code>），从而提高代码的可移植性和灵活性。</li><li><strong>大小保证</strong>：<code>sockaddr_storage</code> 的大小被设计为足以容纳系统支持的所有套接字地址结构，这使得它可以安全地转换为任何特定的套接字地址类型。</li><li><strong>对齐要求</strong>：除了大小之外，<code>sockaddr_storage</code> 还满足了所有套接字地址结构的对齐要求，这对于高效访问数据至关重要。</li></ol><p><strong>总结</strong></p><ul><li><strong><code>sockaddr</code></strong>：是一个通用的套接字地址结构体，适用于所有地址族。由于其设计较为通用，实际应用中常被特定于某种地址族的结构体替代，如<code>sockaddr_in</code>。</li><li><strong><code>sockaddr_in</code></strong>：专用于IPv4地址，提供了对IPv4地址和端口的具体支持，易于理解和使用。</li><li><strong><code>addrinfo</code></strong>：提供了一个更高级别的抽象，能够处理IPv4和IPv6地址，并且支持更多的选项和灵活性。它是推荐的方式来进行现代网络编程中的地址解析和套接字创建，特别是当你需要同时支持IPv4和IPv6时。</li></ul><p><strong>socketpair</strong></p><p><code>socketpair</code> 是一个用于创建一对互联的套接字描述符的系统调用，它允许在同一主机上的两个进程之间进行双向通信。通常，这些套接字被用于父子进程间的通信，但它们也可以用于任何需要双向（全双工）通信通道的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>domain</code>：指定协议族，通常是 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code>（本地通信），但在某些实现中也可能支持其他域如 <code>AF_INET</code>。</li><li><code>type</code>：指定套接字类型，常见的有 <code>SOCK_STREAM</code>（提供有序、可靠、双向的连接）和 <code>SOCK_DGRAM</code>（数据报套接字）。</li><li><code>protocol</code>：指定使用的协议，通常为 <code>0</code>，表示使用默认协议。</li><li><code>sv</code>：指向一个包含两个整数元素的数组，这两个整数将作为返回的套接字描述符。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功时，返回 <code>0</code> 并在 <code>sv</code> 数组中填充两个有效的套接字描述符。</li><li>失败时，返回 <code>-1</code> 并设置 <code>errno</code>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sv[<span class="number">2</span>]; <span class="comment">// 存储两个套接字描述符</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MSG_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一对套接字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sv) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">0</span>]); <span class="comment">// 关闭不需要的套接字端</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">&quot;Hello from child process!&quot;</span>;</span><br><span class="line">        <span class="built_in">write</span>(sv[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg) + <span class="number">1</span>); <span class="comment">// 发送消息给父进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">1</span>]); <span class="comment">// 关闭不需要的套接字端</span></span><br><span class="line">        <span class="keyword">ssize_t</span> bytes_read = <span class="built_in">read</span>(sv[<span class="number">0</span>], buffer, MSG_SIZE); <span class="comment">// 从子进程接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message from child: %s\n&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(sv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址二进制与点分十进制转换"><a href="#地址二进制与点分十进制转换" class="headerlink" title="地址二进制与点分十进制转换"></a>地址二进制与点分十进制转换</h3><p>在网络编程中，有时需要将点分十进制表示的IPv4地址（如<code>&quot;192.168.1.1&quot;</code>）转换成32位无符号整数形式以便于处理或计算。在C语言中，可以使用以下函数来实现这种转换：</p><ul><li><strong><code>inet_addr</code></strong>: 这是一个简单的函数，用于将点分十进制格式的IPv4地址转换为网络字节序的32位长整型值。然而，<strong>它不支持IPv6，并且如果输入无效，则返回<code>INADDR_NONE</code></strong></li><li><strong><code>inet_aton</code></strong>: 此函数不仅将点分十进制的IPv4地址转换为二进制形式，还会检查输入的有效性。它接受一个指向<code>in_addr</code>结构的指针作为第二个参数，并在此结构中填充相应的数值。<strong>如果转换成功，返回非零值；否则返回0</strong></li><li><strong><code>inet_pton</code></strong>: 这是一个更为现代和推荐使用的函数，支持IPv4和IPv6地址的转换。对于IPv4，它的第二个参数是一个指向<code>struct in_addr</code>类型的指针，对于IPv6，则是指向<code>struct in6_addr</code>类型的指针<strong>。如果转换成功，返回1</strong>；如果输入格式不正确，则返回0；如果遇到系统错误，则返回-1。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th><code>inet_addr</code></th><th><code>inet_aton</code></th></tr></thead><tbody><tr><td><strong>输入格式</strong></td><td>点分十进制字符串</td><td>点分十进制字符串</td></tr><tr><td><strong>输出格式</strong></td><td>返回 <code>in_addr_t</code>（32 位整数）</td><td>填充 <code>struct in_addr</code> 结构体</td></tr><tr><td><strong>错误处理</strong></td><td>错误时返回 <code>INADDR_NONE</code></td><td>错误时返回 <code>0</code></td></tr><tr><td><strong>线程安全性</strong></td><td>安全</td><td>安全</td></tr><tr><td><strong>推荐程度</strong></td><td>不推荐（已过时）</td><td>推荐</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数名</th><th>输入格式</th><th>输出格式</th><th>支持的地址类型</th><th>线程安全性</th></tr></thead><tbody><tr><td><code>inet_pton</code></td><td>字符串</td><td>二进制</td><td>IPv4 和 IPv6</td><td>安全</td></tr><tr><td><code>inet_aton</code></td><td>字符串</td><td>二进制</td><td>仅 IPv4</td><td>安全</td></tr><tr><td><code>inet_ntop</code></td><td>二进制</td><td>字符串</td><td>IPv4 和 IPv6</td><td>安全</td></tr><tr><td><code>inet_ntoa</code></td><td>二进制</td><td>字符串</td><td>仅 IPv4</td><td>不安全</td></tr></tbody></table></div><h3 id="端口字节序转换"><a href="#端口字节序转换" class="headerlink" title="端口字节序转换"></a>端口字节序转换</h3><p>在网络编程中，处理不同系统间的数据传输时，经常需要将数据在主机字节序（Host Byte Order）和网络字节序（Network Byte Order）之间进行转换。这是因为不同的计算机架构可能使用不同的字节序来存储多字节数据类型，如整数。为了确保数据在网络上传输的一致性，通常采用大端字节序（Big Endian），也被称作网络字节序</p><p>针对这种需求，有几组常用的函数用于在主机字节序和网络字节序之间进行转换：</p><ol><li><strong><code>htonl</code> 和 <code>htons</code></strong>：这两个函数分别用于将32位整型（<code>long</code>）和16位整型（<code>short</code>）从主机字节序转换为网络字节序。<ul><li><code>htonl(uint32_t hostlong)</code>: Host to Network Long</li><li><code>htons(uint16_t hostshort)</code>: Host to Network Short</li></ul></li><li><strong><code>ntohl</code> 和 <code>ntohs</code></strong>：与上述相反，这两个函数用于将32位和16位整型从网络字节序转换为主机字节序。<ul><li><code>ntohl(uint32_t netlong)</code>: Network to Host Long</li><li><code>ntohs(uint16_t netshort)</code>: Network to Host Short</li></ul></li></ol><p>为了保证网络通信的兼容性，通常采用大端字节序（Big Endian），也称为网络字节序，来表示跨网络传输的数据。</p><p><strong>需要转换为网络字节序的数据类型</strong></p><ol><li><strong>端口号</strong>：端口号通常是16位的整数，在发送之前应该从主机字节序转换为网络字节序。</li><li><strong>IP地址</strong>：虽然IP地址通常以字符串形式表示（例如“192.168.0.1”），但在某些情况下，你可能会处理32位整型的IPv4地址或128位的IPv6地址。对于这些情况，如果需要直接操作整型值，则应确保它们是网络字节序。</li><li><strong>序列号、确认号等TCP头部字段</strong>：这些字段都是32位的整数，用于TCP协议中的状态跟踪和数据流控制，因此也需要转换为网络字节序。</li><li><strong>其他自定义协议中的多字节字段</strong>：如果你设计了一个自定义的应用层协议，并且该协议包含多字节整数字段（如长度指示符、版本号等），那么这些字段也应该按照网络字节序进行编码。</li></ol><h3 id="设置套接字等选项"><a href="#设置套接字等选项" class="headerlink" title="设置套接字等选项"></a>设置套接字等选项</h3><p><code>setsockopt</code> 是一个用于设置套接字选项的函数，它允许开发者对套接字的行为进行精细控制。通过 <code>setsockopt</code>，可以调整套接字的各种属性，例如<strong>地址复用</strong>、<strong>接收/发送缓冲区大小</strong>、超时时间等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><strong><code>sockfd</code></strong>:<ul><li>套接字描述符。</li><li>指定要设置选项的目标套接字。</li></ul></li><li><strong><code>level</code></strong>:<ul><li>选项所属的协议层。</li><li>常见值包括：<ul><li><code>SOL_SOCKET</code>: 套接字通用选项（如地址复用、广播等）。</li><li><code>IPPROTO_TCP</code>: TCP 协议相关选项。</li><li><code>IPPROTO_IP</code>: IP 协议相关选项。</li><li><code>IPPROTO_IPV6</code>: IPv6 相关选项。</li></ul></li></ul></li><li><strong><code>optname</code></strong>:<ul><li>具体的选项名称。</li><li>根据 <code>level</code> 的不同，可以选择不同的选项。</li></ul></li><li><strong><code>optval</code></strong>:<ul><li>指向选项值的指针。</li><li>选项值的具体类型和格式取决于 <code>optname</code>。</li></ul></li><li><strong><code>optlen</code></strong>:<ul><li><code>optval</code> 缓冲区的大小（以字节为单位）</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><ol><li><strong><code>SO_REUSEADDR</code></strong></li></ol><ul><li><strong>作用</strong>: 允许绑定到已被占用的地址和端口。</li><li><strong>场景</strong>: 通常用于避免因端口被占用而导致服务器无法启动的问题。</li></ul><p><strong>2. <code>SO_REUSEPORT</code></strong></p><ul><li><strong>作用</strong>: 允许多个进程或线程绑定到同一个端口。</li><li><strong>场景</strong>: 适用于多线程或多进程服务器模型。</li><li><strong>注意</strong>: 需要与 <code>SO_REUSEADDR</code> 配合使用</li></ul><p><strong>3. <code>SO_RCVBUF</code> 和 <code>SO_SNDBUF</code></strong></p><ul><li><p>作用</p><p>:</p><ul><li><code>SO_RCVBUF</code>: 设置接收缓冲区大小。</li><li><code>SO_SNDBUF</code>: 设置发送缓冲区大小。</li></ul></li></ul><p><strong>4. <code>SO_BROADCAST</code></strong></p><ul><li><strong>作用</strong>: 启用广播功能。</li><li><strong>场景</strong>: 用于 UDP 广播通信</li></ul><p><strong>5. <code>SO_KEEPALIVE</code></strong></p><ul><li><strong>作用</strong>: 启用 TCP 的保活机制。</li><li><strong>场景</strong>: 检测长时间空闲的连接是否仍然有效。</li></ul><p><strong>6. <code>SO_LINGER</code></strong></p><ul><li><strong>作用</strong>: 控制关闭套接字时的行为。</li><li><strong>场景</strong>: 当需要确保所有数据在关闭前被发送时。</li></ul><p><strong>7. <code>TCP_NODELAY</code></strong></p><ul><li><strong>作用</strong>: 禁用 Nagle 算法，减少小数据包的延迟。</li><li><strong>场景</strong>: 对于实时性要求较高的应用（如在线游戏、实时聊天）。</li></ul><h3 id="设置文件描述符选项"><a href="#设置文件描述符选项" class="headerlink" title="设置文件描述符选项"></a>设置文件描述符选项</h3><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>fd</code></strong>：目标文件描述符。</p></li><li><p><code>cmd</code></p><p>：指定要执行的操作类型，常见的命令包括：</p><ul><li><strong><code>F_GETFL</code></strong>：获取文件描述符的状态标志。</li><li><strong><code>F_SETFL</code></strong>：设置文件描述符的状态标志。</li><li><strong><code>F_GETFD</code></strong>：获取文件描述符的文件描述符标志。</li><li><strong><code>F_SETFD</code></strong>：设置文件描述符的文件描述符标志。</li><li><strong><code>F_DUPFD</code></strong>：复制文件描述符。</li><li><strong><code>F_DUPFD_CLOEXEC</code></strong>：复制文件描述符并设置 <code>FD_CLOEXEC</code> 标志。</li></ul></li><li><p><strong><code>arg</code></strong>：可选参数，具体取决于 <code>cmd</code> 的值。例如，在使用 <code>F_SETFL</code> 时，<code>arg</code> 是新的状态标志</p></li></ul><p>在网络编程中，将套接字设置为非阻塞模式是一种常见的优化手段。非阻塞模式允许在尝试读取或写入数据时立即返回，而不会阻塞进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符设置为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取当前文件描述符的标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_GETFL failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 O_NONBLOCK 标志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl F_SETFL failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非阻塞模式下：</p><ul><li>如果没有数据可读，<code>read()</code> 或 <code>recv()</code> 会立即返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li><li>如果无法立即写入数据，<code>write()</code> 或 <code>send()</code> 也会返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li></ul><p>文件状态标志可以通过 <code>fcntl(fd, F_GETFL)</code> 获取当前设置，并通过 <code>fcntl(fd, F_SETFL, flags)</code> 修改。</p><ul><li><strong><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></strong>：打开文件的模式（只读、只写、读写），通常在打开文件时确定，不能通过 <code>F_SETFL</code> 修改。</li><li><strong><code>O_APPEND</code></strong>：每次写入时将数据追加到文件末尾。</li><li><strong><code>O_NONBLOCK</code></strong>：设置非阻塞模式。对于文件或设备，这意味着尝试的操作（如读取或写入）如果无法立即完成，则会立即返回而不是阻塞等待。在网络编程中，这通常用于套接字以实现异步I/O。</li><li><strong><code>O_ASYNC</code></strong>：当I/O可用时发送信号（通常是 <code>SIGIO</code>）给进程。此功能允许进程异步地处理I/O事件。</li><li><strong><code>O_DSYNC</code> 和 <code>O_SYNC</code></strong>：要求同步写入。<code>O_DSYNC</code> 确保数据同步写入磁盘，而 <code>O_SYNC</code> 还包括文件元数据的同步写入。</li></ul><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><p>信号是操作系统向进程发送的一种异步通知机制，用于告知进程某个事件已经发生。信号可以被视为一种软件中断，它会打断进程的正常执行流程。</p><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p><strong><code>signal()</code> 函数</strong></p><p>这是最基本的信号处理函数，用于设置对指定信号的处理方式。然而，它不如 <code>sigaction</code> 灵活和可靠。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>signum</code>：要捕获或忽略的信号编号。</li><li><code>handler</code>：信号处理函数指针，或者 <code>SIG_DFL</code>（默认处理）、<code>SIG_IGN</code>（忽略）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_sigint</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 SIGINT (Ctrl+C) 的处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, handle_sigint) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Unable to set handler for SIGINT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Process running...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 定义了许多标准信号，例如：</p><ul><li><code>SIGINT</code>（2）：由用户按下 <code>Ctrl+C</code> 触发，通常用于终止进程。</li><li><code>SIGTERM</code>（15）：请求终止进程的信号。</li><li><code>SIGKILL</code>（9）：强制终止进程的信号，无法被捕获或忽略。</li><li><code>SIGSEGV</code>（11）：段错误（访问非法内存地址）。</li><li><code>SIGCHLD</code>（17）：子进程状态改变时发送给父进程的信号。</li><li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>：用户自定义信号。</li></ul><p>信号可以通过以下几种方式触发：</p><p><strong>(1) 用户输入</strong></p><ul><li>按下 <code>Ctrl+C</code> 会向当前前台进程发送 <code>SIGINT</code> 信号。</li><li>按下 <code>Ctrl+\</code> 会向当前前台进程发送 <code>SIGQUIT</code> 信号。</li></ul><p><strong>(2) 系统调用</strong></p><p>通过系统调用 <code>kill</code> 或 <code>raise</code> 可以向进程发送信号：</p><ul><li><code>kill(pid_t pid, int sig)</code>：向指定进程 ID 的进程发送信号。</li><li><code>raise(int sig)</code>：向当前进程自身发送信号。</li></ul><p><strong>(3) 硬件异常</strong></p><p>当进程访问非法内存地址时，操作系统会发送 <code>SIGSEGV</code> 信号；当进行非法指令操作时，可能会发送 <code>SIGILL</code> 信号。</p><p><strong>(4) 软件触发</strong></p><p>通过调用 <code>alarm</code> 函数可以设置定时器，超时时会向进程发送 <code>SIGALRM</code> 信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, handler); <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>); <span class="comment">// 设置 3 秒后发送 SIGALRM 信号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for the alarm signal...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pause</span>(); <span class="comment">// 挂起进程，等待信号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p><code>sigaction</code> 是 POSIX 标准定义的一种机制，用于定义进程对特定信号的响应行为。它提供了一种比 <code>signal()</code> 更加灵活和强大的方式来处理信号。<code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。</p><p><code>sigaction</code> 提供了比 <code>signal()</code> 更加精细和强大的信号处理功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><code>signum</code>：信号编号。</li><li><code>act</code>：指向包含新动作的 <code>struct sigaction</code> 结构体的指针。</li><li><code>oldact</code>：如果非空，则保存旧的动作。</li></ul></li></ul><p><strong><code>struct sigaction</code> 结构体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_handler)(<span class="keyword">int</span>);             <span class="comment">// 信号处理函数</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">// 用于带有附加信息的信号处理函数</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;                       <span class="comment">// 在执行信号处理器期间需要阻塞的信号集合</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;                      <span class="comment">// 控制信号处理的行为标志</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>     (*sa_restorer)(<span class="keyword">void</span>);           <span class="comment">// 已废弃，不应使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sigaction</code> 结构体用于指定如何处理信号、信号处理程序的属性以及信号掩码等信息。</p><p><strong>字段说明</strong></p><ul><li><strong><code>sa_handler</code></strong>：<ul><li>这是一个指向信号处理函数的指针，或者可以设置为 <code>SIG_DFL</code>（默认信号处理）或 <code>SIG_IGN</code>（忽略信号）。</li></ul></li><li><strong><code>sa_sigaction</code></strong>：<ul><li>当 <code>sa_flags</code> 中设置了 <code>SA_SIGINFO</code> 标志时，此字段将作为信号处理函数使用。与 <code>sa_handler</code> 不同，<code>sa_sigaction</code> 可以接收更多信息，包括一个指向 <code>siginfo_t</code> 结构的指针（包含有关信号的详细信息）和一个指向处理器上下文的指针（通常不使用）。</li></ul></li><li><strong><code>sa_mask</code></strong>：<ul><li>定义了一个信号集，在调用信号处理程序之前，这些信号会被加入到当前的信号屏蔽字中。这意味着在执行信号处理程序期间，这些信号会被暂时阻塞。</li></ul></li><li><strong><code>sa_flags</code></strong>：<ul><li>控制信号处理的行为。常见的标志包括：<ul><li><strong><code>SA_RESTART</code></strong>：如果信号中断了某个系统调用，则自动重启该系统调用（而不是返回错误）。</li><li><strong><code>SA_NOCLDSTOP</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，如果设置了此标志，则子进程停止或恢复时不会发送 <code>SIGCHLD</code> 信号给父进程。</li><li><strong><code>SA_NOCLDWAIT</code></strong>：仅对 <code>SIGCHLD</code> 信号有效，阻止创建僵尸进程。</li><li><strong><code>SA_SIGINFO</code></strong>：指示使用 <code>sa_sigaction</code> 字段中的信号处理函数，而非 <code>sa_handler</code>。这允许访问扩展的信号信息。</li></ul></li></ul></li><li><strong><code>sa_restorer</code></strong>：<ul><li>这个字段已废弃，不应该被使用。</li></ul></li></ul><p><strong>使用示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d\n&quot;</span>, signum);</span><br><span class="line">    <span class="comment">// 打印更多关于信号的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Signal code: %d\n&quot;</span>, info-&gt;si_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化结构体</span></span><br><span class="line">    act.sa_sigaction = handler;</span><br><span class="line">    act.sa_flags = SA_SIGINFO; <span class="comment">// 使用带有额外参数的信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充信号掩码，这里我们不限制任何额外的信号</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 SIGINT 的信号处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for SIGINT (Ctrl+C)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起进程，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pause</span>(); <span class="comment">// 等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p><code>stat</code> 函数是 Unix 和类 Unix 操作系统（如 Linux）中的一个系统调用，用于获取文件或文件系统对象的相关信息。它通过填充一个 <code>struct stat</code> 结构体来提供文件的元数据，包括文件大小、权限、创建时间等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>pathname</code>：要查询的文件或目录的路径。</li><li><code>statbuf</code>：指向一个 <code>struct stat</code> 结构体的指针，该结构体将被用来存储文件的状态信息。</li></ul></li><li><strong>返回值</strong>：<ul><li>成功时返回 <code>0</code>。</li><li>失败时返回 <code>-1</code> 并设置 <code>errno</code> 来指示错误类型。</li></ul></li></ul><p>除了 <code>stat</code>，还有其他几个类似的函数可以用于不同的场景：</p><ul><li><p><strong><code>fstat</code></strong>：与 <code>stat</code> 类似，但它接受一个文件描述符而不是路径名作为第一个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>lstat</code></strong>：与 <code>stat</code> 类似，但如果目标是一个符号链接（symlink），它会返回符号链接本身的信息，而不是它指向的目标文件的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>struct stat</code> 包含了大量的关于文件的信息。以下是一些常用的字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">// 文件所在设备的标识符</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">// inode 编号</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">// 文件类型和访问权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">// 硬链接数量</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">// 文件所有者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">// 文件所有者的组 ID</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">// 如果文件是一个设备文件，则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">// 文件系统的 I/O 块大小</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">// 分配给文件的块数</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_atime;       <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_mtime;       <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="keyword">time_t</span>    st_ctime;       <span class="comment">// 最后状态改变时间（在 Unix 中通常为元数据更改时间）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>struct stat</code> 的 <code>st_mode</code> 字段中，文件类型和权限信息被编码在一起。可以通过位操作提取这些信息：</p><ul><li><strong>文件类型</strong>：<ul><li><code>S_IFMT</code>：文件类型的掩码。</li><li><code>S_IFDIR</code>：目录。</li><li><code>S_IFCHR</code>：字符设备。</li><li><code>S_IFBLK</code>：块设备。</li><li><code>S_IFREG</code>：普通文件。</li><li><code>S_IFIFO</code>：命名管道（FIFO）。</li><li><code>S_IFLNK</code>：符号链接。</li><li><code>S_IFSOCK</code>：套接字。</li></ul></li><li><strong>权限</strong>：<ul><li><code>S_IRUSR</code>, <code>S_IWUSR</code>, <code>S_IXUSR</code>：用户（拥有者）的读、写、执行权限。</li><li><code>S_IRGRP</code>, <code>S_IWGRP</code>, <code>S_IXGRP</code>：组的读、写、执行权限。</li><li><code>S_IROTH</code>, <code>S_IWOTH</code>, <code>S_IXOTH</code>：其他人的读、写、执行权限。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sb.st_mode &amp; S_IFMT) == S_IFREG &amp;&amp; (sb.st_mode &amp; S_IRUSR)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a regular file with read permission for the owner.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>mmap</code> 是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，用于<strong>将文件或设备的内存映射到进程的地址空间</strong>。这种机制允许程序以类似于访问内存的方式访问文件内容，从而简化了文件操作，并且可以提高性能，特别是在处理大文件时。</p><ul><li><strong>文件映射</strong>：将文件的内容映射到进程的虚拟内存中，使得可以通过指针直接访问文件的数据，而不需要通过常规的文件 I/O 操作（如 <code>read</code> 和 <code>write</code>）。</li><li><strong>共享内存</strong>：允许多个进程共享同一块内存区域，实现高效的进程间通信（IPC）。</li><li><strong>匿名映射</strong>：创建不与任何文件关联的内存映射，适用于需要动态分配大块内存的情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>addr</code>：建议的映射起始地址（通常设为 <code>NULL</code>，让系统选择合适的地址）。</li><li><code>length</code>：映射区域的大小（字节数）。</li><li>prot：指定映射区域的保护标志（如可读、可写、可执行等）。<ul><li><code>PROT_READ</code>：映射区域可读。</li><li><code>PROT_WRITE</code>：映射区域可写。</li><li><code>PROT_EXEC</code>：映射区域可执行。</li></ul></li><li>flags：控制映射区域的行为。<ul><li><code>MAP_SHARED</code>：映射区域会被多个进程共享，修改会反映到文件中。</li><li><code>MAP_PRIVATE</code>：创建私有副本，修改不会影响原文件。</li><li><code>MAP_ANONYMOUS</code>：映射匿名内存（不与文件关联）。</li></ul></li><li><code>fd</code>：要映射的文件描述符（对于匿名映射，应设置为 <code>-1</code>）。</li><li><code>offset</code>：从文件开头开始的偏移量（必须是页面大小的倍数）。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时返回指向映射区域的指针。</li><li>失败时返回 <code>MAP_FAILED</code>（通常定义为 <code>(void *) -1</code>），并设置 <code>errno</code>。</li></ul></li><li><p><strong><code>munmap</code></strong>：解除内存映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>msync</code></strong>：同步内存映射区域到文件或设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解析传入参数"><a href="#解析传入参数" class="headerlink" title="解析传入参数"></a>解析传入参数</h2><p>Linux中<code>getopt</code> 是一个用于解析命令行选项的标准 C 库函数。它使得程序能够处理以短格式（如 <code>-a</code>, <code>-b value</code>）提供的命令行参数。<code>getopt</code> 函数及其扩展版本 <code>getopt_long</code> 为开发者提供了便捷的方式来解析和处理命令行选项。</p><h4 id="get-opt函数"><a href="#get-opt函数" class="headerlink" title="get_opt函数"></a>get_opt函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><code>argc</code> 和 <code>argv</code>：分别是从 <code>main</code> 函数传递过来的参数计数和参数数组。</li><li><code>optstring</code>：包含程序所支持的选项字符组成的字符串。如果某个选项需要参数，则在该选项字符后加上冒号（<code>:</code>），表示该选项需要一个值。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时，返回下一个选项字符。</li><li>当所有选项都已处理完毕，返回 <code>-1</code>。</li><li>如果遇到无效选项或缺少必需的参数，返回 <code>?</code> 并设置 <code>optopt</code> 变量为无效选项字符。</li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li><code>optind</code>：指向下一个要处理的 <code>argv</code> 元素的索引。</li><li><code>optarg</code>：<strong>指向当前选项的参数</strong>（如果有）。</li><li><code>opterr</code>：控制 <code>getopt</code> 是否打印错误消息，默认为 1（开启）。</li><li><code>optopt</code>：存储无效选项字符或缺失参数的选项字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;ab:c&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -a\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -b with value %s\n&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Option -c\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (optopt == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Option -b requires an argument.\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Unknown option character `\\x%x&#x27;.\n&quot;</span>, optopt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理非选项参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = optind; index &lt; argc; index++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non-option argument: %s\n&quot;</span>, argv[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="getopt-long-函数"><a href="#getopt-long-函数" class="headerlink" title="getopt_long 函数"></a><code>getopt_long</code> 函数</h4><p>对于支持长格式选项（如 <code>--option</code>, <code>--option=value</code>）的应用程序，可以使用 <code>getopt_long</code> 函数。</p><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><strong>函数原型</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> *shortopts, <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><p><code>shortopts</code>：与 <code>getopt</code> 相同，定义短格式选项。</p></li><li><p>longopts指向描述长格式选项的struct option</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 长格式选项名</span></span><br><span class="line">    <span class="keyword">int</span>         has_arg; <span class="comment">// 是否需要参数，可能值：no_argument, required_argument, optional_argument</span></span><br><span class="line">    <span class="keyword">int</span>        *flag;    <span class="comment">// 若不为 NULL，函数将此指针指向的变量设为 val；若为 NULL，函数返回 val</span></span><br><span class="line">    <span class="keyword">int</span>         val;     <span class="comment">// 返回给 `getopt_long` 的值或设置到 `flag` 指向的变量中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>longindex</code>：如果非 <code>NULL</code>，则指向一个变量，该变量接收匹配的长选项在 <code>longopts</code> 数组中的索引。</p></li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功时，返回匹配选项的字符（对于短选项）或 <code>val</code> 字段的值（对于长选项）。</li><li>当所有选项都已处理完毕，返回 <code>-1</code>。</li><li>对于无效选项或缺少必需的参数，返回 <code>?</code>。</li></ul></li><li><p><strong><code>getopt</code></strong>：适用于处理短格式选项的简单场景。通过指定一个选项字符串来定义允许的选项及是否需要参数。</p></li><li><strong><code>getopt_long</code></strong>：扩展了 <code>getopt</code>，支持长格式选项，并允许更灵活地配置每个选项的行为（是否需要参数、如何处理等）。</li></ul><h2 id="分散-聚集IO"><a href="#分散-聚集IO" class="headerlink" title="分散/聚集IO"></a>分散/聚集IO</h2><p>分散/聚集 I/O（Scatter/Gather I/O）是一种<strong>允许在单次系统调用中处理多个数据缓冲区的技术</strong>。它特别适用于需要处理多个不连续的数据块的应用场景，如网络通信、数据库操作等。通过分散/聚集 I/O，可以减少系统调用的次数，提高性能和效率。</p><h4 id="分散-I-O（Scatter-I-O）"><a href="#分散-I-O（Scatter-I-O）" class="headerlink" title="分散 I/O（Scatter I/O）"></a>分散 I/O（Scatter I/O）</h4><p>分散读取（Scatter Read）指的是从一个输入源（例如文件或套接字）读取数据，并将这些数据分散到多个缓冲区中。这种技术通常用于接收长度未知的数据流，并将其分割成多个部分存储在不同的缓冲区中。</p><h4 id="聚集-I-O（Gather-I-O）"><a href="#聚集-I-O（Gather-I-O）" class="headerlink" title="聚集 I/O（Gather I/O）"></a>聚集 I/O（Gather I/O）</h4><p>聚集写入（Gather Write）则是指将多个缓冲区中的数据收集起来，然后一次性写入到输出目标（例如文件或套接字）。这种方法可以简化编程模型，并且通过减少系统调用的数量来提高性能。</p><p>在 Unix 和类 Unix 系统（如 Linux）中，分散/聚集 I/O 主要通过 <code>readv</code> 和 <code>writev</code> 系统调用来实现。</p><p><strong><code>readv</code> 和 <code>writev</code> 函数</strong></p><ul><li><strong><code>readv</code></strong>：从文件描述符读取数据并分散到多个缓冲区。</li><li><strong><code>writev</code></strong>：从多个缓冲区收集数据并写入到文件描述符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>  *iov_base;    <span class="comment">// 指向缓冲区的指针</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">// 缓冲区长度（字节数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">6</span>]; <span class="comment">// 存储 &quot;Hello,&quot;</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">8</span>]; <span class="comment">// 存储 &quot; World!\n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf1);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> read_bytes = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;readv&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf1[<span class="built_in"><span class="keyword">sizeof</span></span>(buf1)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保 buf1 是以 null 结尾的字符串</span></span><br><span class="line">    buf2[<span class="built_in"><span class="keyword">sizeof</span></span>(buf2)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保 buf2 是以 null 结尾的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: &#x27;%s&#x27; and &#x27;%s&#x27;\n&quot;</span>, read_bytes, buf1, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP流程"><a href="#TCP流程" class="headerlink" title="TCP流程"></a>TCP流程</h2><p><strong>TCP Server</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (struct sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="keyword">if</span> ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (<span class="keyword">socklen_t</span> *)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">        close(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端数据</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(new_socket, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    send(new_socket, response, <span class="built_in">strlen</span>(response), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response sent to client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(new_socket);</span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TCP Client</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="keyword">int</span> valread = read(sock, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP流程"><a href="#UDP流程" class="headerlink" title="UDP流程"></a>UDP流程</h2><p><strong>UDP Server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  sockaddr_in servaddr, cliaddr;</span><br><span class="line">  <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *response = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line">  <span class="comment">// 创建套接字 SOCK_DGRAM</span></span><br><span class="line">  <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  <span class="built_in">memset</span>(&amp;cliaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定地址和端口</span></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端绑定套接字后 直接开始读了</span></span><br><span class="line">  <span class="comment">// 接收客户端数据</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">recvfrom</span>(sockfd, (<span class="keyword">char</span> *)buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">  buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送响应</span></span><br><span class="line">  <span class="built_in">sendto</span>(sockfd, (<span class="keyword">const</span> <span class="keyword">char</span> *)response, <span class="built_in">strlen</span>(response), <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">const</span> struct sockaddr *)&amp;cliaddr, len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Response sent to client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP Client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建套接字</span></span><br><span class="line">  <span class="keyword">if</span> ((sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置服务器地址</span></span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">  servaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 IP 地址转换为二进制形式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建套接字 后直接发送消息 需要连接的地址,不需要connect</span></span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  <span class="built_in">sendto</span>(sockfd, (<span class="keyword">const</span> <span class="keyword">char</span> *)message, <span class="built_in">strlen</span>(message), <span class="number">0</span>,</span><br><span class="line">         (<span class="keyword">const</span> struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Message sent to server.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收响应</span></span><br><span class="line">  <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">recvfrom</span>(sockfd, (<span class="keyword">char</span> *)buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;servaddr, &amp;len);</span><br><span class="line">  buffer[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Server: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="在windows上的异步I-O机制"><a href="#在windows上的异步I-O机制" class="headerlink" title="在windows上的异步I/O机制"></a>在windows上的异步I/O机制</h3><p>异步 I/O（Asynchronous I/O）是一种高效的机制，用于处理文件、网络套接字等设备的输入输出操作.Windows 提供了多种实现异步 I/O 的方式，包括 <strong>Overlapped I/O</strong> 和 <strong>I/O Completion Ports (IOCP)</strong>。</p><h4 id="Overlapped-I-O"><a href="#Overlapped-I-O" class="headerlink" title="Overlapped I/O"></a><strong>Overlapped I/O</strong></h4><p><strong>概述</strong></p><p>Overlapped I/O 是 Windows 提供的一种异步 I/O 机制，它通过使用 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。这种机制适用于文件操作和套接字通信。</p><ul><li>如果一个文件句柄或套接字是以重叠（Overlapped）模式打开的，则可以对其进行异步操作。</li><li>异步操作完成后，可以通过以下方式通知应用程序：<ul><li>使用事件对象（Event Object）。</li><li>调用回调函数（Completion Routine）。</li><li>使用 I/O 完成端口（IOCP）。</li></ul></li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读写文件或套接字。</li><li><strong><code>GetOverlappedResult</code></strong>：检查异步操作的状态。</li><li><strong><code>CancelIoEx</code></strong>：取消挂起的异步 I/O 操作。</li></ul><p><strong>示例代码</strong></p><p>以下是一个使用 Overlapped I/O 进行异步文件读取的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                  <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,                   <span class="comment">// 打开文件用于读取</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                  <span class="comment">// 打开已存在的文件</span></span><br><span class="line">        FILE_FLAG_OVERLAPPED,           <span class="comment">// 启用 Overlapped I/O</span></span><br><span class="line">        <span class="literal">NULL</span>                            <span class="comment">// 无模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    OVERLAPPED overlapped = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    overlapped.hEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>); <span class="comment">// 创建事件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, buffer, <span class="keyword">sizeof</span>(buffer), <span class="literal">NULL</span>, &amp;overlapped)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() != ERROR_IO_PENDING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            CloseHandle(overlapped.hEvent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    WaitForSingleObject(overlapped.hEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    <span class="keyword">if</span> (GetOverlappedResult(hFile, &amp;overlapped, &amp;bytesRead, FALSE)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, bytesRead, bytesRead, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetOverlappedResult failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(overlapped.hEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileRead();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Overlapped I/O 是 Windows 中最基础的异步 I/O 实现方式之一。它通过 <code>OVERLAPPED</code> 结构体来标记一个 I/O 操作是否为异步。</li><li>当使用重叠模式打开文件或套接字时，可以发起异步操作，并且在操作完成前继续执行其他代码。</li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>CreateFile</code></strong>：创建或打开文件时指定 <code>FILE_FLAG_OVERLAPPED</code> 标志以启用重叠模式。</li><li><strong><code>ReadFile</code> / <code>WriteFile</code></strong>：用于读取或写入数据。对于异步操作，最后一个参数应指向一个有效的 <code>OVERLAPPED</code> 结构体。</li><li><strong><code>GetOverlappedResult</code></strong>：获取异步操作的结果。</li><li><strong><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></strong>：等待异步操作完成。</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在 Windows 中，回调函数通常通过 <code>ReadFileEx</code> 或 <code>WriteFileEx</code> 函数注册，而不是直接使用 <code>ReadFile</code> 或 <code>WriteFile</code>。</p><p>回调函数的原型必须符合以下格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">CompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,       <span class="comment">// 错误码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered, <span class="comment">// 转移的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped        <span class="comment">// OVERLAPPED 结构体指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 注册回调函数</strong></p><ul><li><code>ReadFileEx</code> 和 <code>WriteFileEx</code> 是专门用于异步 I/O 并支持回调函数的 API。</li><li>它们需要一个有效的 <code>OVERLAPPED</code> 结构体，并且文件句柄必须以重叠模式打开（即带有 <code>FILE_FLAG_OVERLAPPED</code> 标志）。</li><li><p>异步操作完成后，操作系统会调用指定的回调函数。</p></li><li><p>回调函数是一种轻量级的异步 I/O 处理方式，通过 <code>ReadFileEx</code> 和 <code>WriteFileEx</code> 函数注册回调函数，在操作完成后自动调用。</p></li><li>这种方式要求线程进入可提醒等待状态（Alertable Wait State），例如使用 <code>SleepEx</code> 函数。</li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>ReadFileEx</code> / <code>WriteFileEx</code></strong>：用于启动异步 I/O 操作并注册回调函数。</li><li><strong><code>SleepEx</code></strong>：使当前线程进入可提醒等待状态，以便能够接收异步通知。</li></ul><p><strong>3. 示例代码</strong></p><p>以下是一个使用回调函数处理异步文件读取的完整示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数定义</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">FileIOCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwErrorCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumberOfBytesTransfered,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwErrorCode == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous read completed successfully.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Number of bytes read: %d\n&quot;</span>, dwNumberOfBytesTransfered);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Asynchronous read failed with error code: %d\n&quot;</span>, dwErrorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileReadWithCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                  <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,                   <span class="comment">// 打开文件用于读取</span></span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// 不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                           <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                  <span class="comment">// 打开已存在的文件</span></span><br><span class="line">        FILE_FLAG_OVERLAPPED,           <span class="comment">// 启用 Overlapped I/O</span></span><br><span class="line">        <span class="literal">NULL</span>                            <span class="comment">// 无模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    OVERLAPPED overlapped = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动异步读取操作</span></span><br><span class="line">    BOOL result = ReadFileEx(</span><br><span class="line">        hFile,                          <span class="comment">// 文件句柄</span></span><br><span class="line">        buffer,                         <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="keyword">sizeof</span>(buffer),                 <span class="comment">// 要读取的字节数</span></span><br><span class="line">        &amp;overlapped,                    <span class="comment">// OVERLAPPED 结构体</span></span><br><span class="line">        FileIOCompletionRoutine         <span class="comment">// 回调函数</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ReadFileEx failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    SleepEx(INFINITE, TRUE); <span class="comment">// 进入可提醒等待状态，使回调函数得以执行</span></span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileReadWithCallback();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="I-O-Completion-Ports-IOCP"><a href="#I-O-Completion-Ports-IOCP" class="headerlink" title="I/O Completion Ports (IOCP)"></a>I/O Completion Ports (IOCP)</h4><p><strong>概述</strong></p><p>I/O Completion Ports（简称 IOCP）是 Windows 提供的一种高性能的异步 I/O 机制，特别适合于需要处理大量并发连接的服务器程序。IOCP 的核心思想是<strong>将多个 I/O 操作绑定到一个完成端口,并由一个线程池来处理完成的通知</strong>。</p><ul><li>IOCP 的优点：<ul><li>高效地管理多个并发 I/O 操作。</li><li>自动负载均衡，多个工作线程可以高效协作。</li><li>支持大规模并发连接。</li></ul></li></ul><p><strong>关键函数</strong></p><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建或关联一个完成端口。</li><li><strong><code>PostQueuedCompletionStatus</code></strong>：向完成端口队列提交自定义的完成包。</li><li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中获取完成通知。</li></ul><p><strong>示例代码</strong></p><p>以下是一个简单的 IOCP 示例，展示如何使用 IOCP 处理异步文件读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OVERLAPPED overlapped;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">&#125; IO_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    HANDLE hCompletionPort = (HANDLE)lpParam;</span><br><span class="line">    DWORD bytesTransferred;</span><br><span class="line">    ULONG_PTR completionKey;</span><br><span class="line">    LPOVERLAPPED pOverlapped;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BOOL result = GetQueuedCompletionStatus(</span><br><span class="line">            hCompletionPort, &amp;bytesTransferred, &amp;completionKey, &amp;pOverlapped, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result || bytesTransferred == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Operation failed or completed.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IO_CONTEXT *context = (IO_CONTEXT *)pOverlapped;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, bytesTransferred, bytesTransferred, context-&gt;buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncFileReadWithIOCP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,</span><br><span class="line">        GENERIC_READ,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hCompletionPort) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create completion port. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CreateIoCompletionPort(hFile, hCompletionPort, (ULONG_PTR)hFile, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, hCompletionPort, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create worker thread. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        CloseHandle(hCompletionPort);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IO_CONTEXT context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    context.overlapped.Offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, context.buffer, <span class="keyword">sizeof</span>(context.buffer), <span class="literal">NULL</span>, &amp;context.overlapped)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() != ERROR_IO_PENDING) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed. Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">            CloseHandle(hFile);</span><br><span class="line">            CloseHandle(hCompletionPort);</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hCompletionPort);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncFileReadWithIOCP();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键函数</strong></p><ul><li><strong><code>CreateIoCompletionPort</code></strong>：创建一个新的完成端口或将其与现有句柄关联。</li><li><strong><code>PostQueuedCompletionStatus</code></strong>：手动向完成端口队列中添加状态信息。</li><li><strong><code>GetQueuedCompletionStatus</code></strong>：从完成端口队列中检索下一个已完成的操作的状态。</li></ul><p><strong>3. 对比 Overlapped I/O 和 IOCP</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>Overlapped I/O</th><th>IOCP</th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>小规模异步操作</td><td>大规模并发 I/O 操作</td></tr><tr><td><strong>性能</strong></td><td>较低</td><td>更高</td></tr><tr><td><strong>复杂度</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>线程管理</strong></td><td>需要手动管理线程</td><td>自动管理线程池</td></tr><tr><td><strong>扩展性</strong></td><td>有限</td><td>非常强</td></tr></tbody></table></div><p><strong>4. 总结</strong></p><ul><li><strong>Overlapped I/O</strong>：适合小型应用或需要简单异步 I/O 的场景，易于实现但扩展性较差。</li><li><p><strong>IOCP</strong>：适合高性能服务器程序，支持大规模并发连接，具有更高的效率和扩展性，但实现起来更复杂。</p></li><li><p><strong>简单场景</strong>：如果您的应用只需要简单的异步 I/O 操作，Overlapped I/O 可能是最容易实现的选择。</p></li><li><strong>高并发场景</strong>：如果您正在开发一个需要处理大量并发连接的应用程序（如 Web 服务器），那么 IOCP 是最佳选择，因为它提供了更好的性能和扩展性。</li><li><strong>轻量级需求</strong>：如果希望避免复杂的线程管理并且对性能的要求不是极高，可以考虑使用回调函数的方式。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;c++在网络编程中特别普及,特别是Linux服务器编程. 相关书籍也有很多,这里简单介绍一下(结合AI总结).&lt;br&gt;</summary>
    
    
    
    
    <category term="c++" scheme="https://www.sekyoro.top/tags/c/"/>
    
    <category term="Linux网络编程" scheme="https://www.sekyoro.top/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>learn opengl(3)</title>
    <link href="https://www.sekyoro.top/2025/01/26/learn-opengl-3/"/>
    <id>https://www.sekyoro.top/2025/01/26/learn-opengl-3/</id>
    <published>2025-01-26T13:44:23.000Z</published>
    <updated>2025-02-07T14:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>高级光照<br><span id="more"></span></p><h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p>之前使用的光照模型是普通Phong模型,在计算镜面光时通过反射光向量和观察向量的夹角确定镜面光强度. 当角度大于90°时取0. 但这样可能会噪声在90°边缘出现明显断层.</p><p><img data-src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_phong_limit.png" alt="img"></p><p>当物体的反光度非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了. 也就是说,当pow()中的幂律比较小的时候,当反射光与观察向量夹角比较小的时候镜面光就非常强,在夹角接近90°时就接近0了,会出现这种尖锐的断层.</p><p>James F. Blinn在风氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与风氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p><p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</p><p>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与风氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</p><p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了,镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> lightDir   = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> viewDir    = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), shininess);</span><br><span class="line"><span class="type">vec3</span> specular = lightColor * spec;</span><br></pre></td></tr></table></figure><p>Blinn-Phong与风氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而风氏模型测量的是观察方向与反射向量间的夹角。除此之外，风氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和风氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择风氏着色时反光度分量的2到4倍。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(blinn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">16.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h2><p>一旦我们计算出场景的最终像素颜色，我们便需要在显示器上显示它们。在数字成像的早期，大多数显示器都是阴极射线管（CRT）显示器。这些显示器具有一个物理特性，即输入电压加倍并不会导致亮度加倍。输入电压加倍会导致亮度等于大约 2.2 的指数关系，这被称为显示器的gamma。巧合的是，这也与人测量亮度的方法非常接近，因为亮度也是以类似的（倒数）功率关系显示的。</p><p>因为人眼更习惯看暗色的变化,相同的变化在亮色中对于人眼来说不那么明显(非线性的增长)，所以显示器（至今仍）使用功率关系来显示输出颜色，以便将原始的物理亮度颜色映射到顶部刻度中的非线性亮度颜色</p><p>这种显示器非线性映射确实为我们眼睛提供了更令人满意的亮度结果，但在渲染图形时存在一个问题：我们在应用程序中配置的所有颜色和亮度选项都是基于我们从显示器上感知到的，因此所有选项实际上都是非线性亮度/颜色选项</p><p><img data-src="https://learnopengl.com/img/advanced-lighting/gamma_correction_gamma_curves.png" alt="Gamme curves"></p><p>点线表示线性空间中的颜色/光值，实线表示显示器显示的颜色空间。如果我们在线性空间中加倍一个颜色，其结果确实是值的两倍。例如，取一个光的颜色向量（0.5，0.0，0.0），它代表半暗红色光。如果我们在线性空间中加倍这种光，它就会变成（1.0，0.0，0.0），如图所示。然而，原始颜色在显示器上显示为（0.218，0.0，0.0），如图所示。问题从这里开始出现：一旦我们在线性空间中加倍深红色光，它在显示器上的亮度实际上会超过 4.5 倍</p><p>我们一直假设我们在线性空间中工作，<strong>但实际上我们一直在监视器的输出空间中工作，所以我们配置的所有颜色和光照变量都不是物理上正确的，而只是在我们的显示器上看起来（某种程度上）正确</strong>。因此，我们通常将光照值设置得比应有的要亮得多（因为显示器会使其变暗），这导致大多数线性空间计算都是不正确的。请注意，显示器（CRT）和线性图表都是从同一位置开始和结束的；是显示过程中变暗的中间值。因为颜色是根据显示器的输出配置的，所以在线性空间中的所有中间（照明）计算在物理上都是不正确的。随着更先进的照明算法的实施，这一点变得更加明显</p><p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p><p>场景应用伽玛校正有两种方法：</p><ul><li>通过使用 OpenGL 内置的 sRGB 帧缓冲区支持。</li><li>通过在片段着色器中自行进行gamma校正。</li></ul><p>第一个选项可能是最简单的，但也给了你更少的控制。通过启用 GL_FRAMEBUFFER_SRGB，你告诉 OpenGL 每个后续的绘制命令应该在将颜色存储在颜色缓冲区之前，首先对颜色进行伽玛校正（从 sRGB 颜色空间）。sRGB 是一种颜色空间，大致对应于 2.2 的伽玛值，并且是大多数设备的标准。启用 GL_FRAMEBUFFER_SRGB 后，OpenGL 会在每次片段着色器运行后自动对所有后续帧缓冲区执行伽玛校正，包括默认帧缓冲区</p><p>开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_FRAMEBUFFER_SRGB);</span><br></pre></td></tr></table></figure><p>从现在起，您的渲染图像将进行伽玛校正,这是通过硬件完成的。在使用这种方法（以及另一种方法）时，您应该记住的是，伽玛校正（同样）将颜色从线性空间转换为非线性空间，因此您只应在最后和最终步骤进行伽玛校正非常重要。如果您在最终输出之前对颜色进行伽玛校正，所有后续对这些颜色的操作都将基于错误值。例如，如果您使用多个帧缓冲区，您可能希望中间结果在帧缓冲区之间保持在线性空间中，并且只有最后一个帧缓冲区在发送到显示器之前应用伽玛校正。</p><p>第二种方法需要做更多的工作，但同时也让我们完全控制伽玛操作。我们在每个相关片段着色器运行结束时应用伽玛校正，以确保最终颜色在发送到显示器之前得到伽玛校正：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do super fancy lighting in linear space</span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// apply gamma correction</span></span><br><span class="line">    <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    FragColor.rgb = <span class="built_in">pow</span>(fragColor.rgb, <span class="type">vec3</span>(<span class="number">1.0</span>/gamma));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的问题在于，为了保持一致性，你必须对每个对最终输出有贡献的片段着色器应用伽玛校正。如果你有十几个用于多个对象的片段着色器，你必须将这些伽玛校正代码添加到每个着色器中。一个更简单的解决方案是在你的渲染循环中引入一个后处理阶段，并在后处理的四边形上作为最后一步应用伽玛校正，你只需做一次。</p><h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><p>一些纹理创作者基于屏幕/monitor修改颜色,这种颜色就是在非线性空间sRGB下被gamma2.2修改过的,如果对这些纹理进行gamma矫正就可能会导致过亮. 所以必须确保纹理的颜色空间和最终需要的颜色空间一致.</p><p>个解决方案是重校，或把这些sRGB纹理在进行任何颜色值的计算前变回线性空间。我们可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">vec3 diffuseColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(diffuse, texCoords).rgb, <span class="built_in">vec3</span>(gamma));</span><br></pre></td></tr></table></figure><p>为每个sRGB空间的纹理做这件事非常烦人。幸好，OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是GL_SRGB和GL_SRGB_ALPHA内部纹理格式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_SRGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure><p>如果还打算在你的纹理中引入alpha元素，必究必须将纹理的内部格式指定为GL_SRGB_ALPHA。</p><p><strong>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。</strong>比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。<strong>而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了</strong>。指定sRGB纹理时要当心。</p><p>将diffuse纹理定义为sRGB纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次gamma校正</p><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0</span> / (distance * distance);</span><br></pre></td></tr></table></figure><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> attenuation = <span class="number">1.0</span> / distance;</span><br></pre></td></tr></table></figure><p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果</p><p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0/distance2)2.2(1.0/distance2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0/distance)2.2=1.0/distance2.2(1.0/distance)2.2=1.0/distance2.2。这和物理公式是很相似的。双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。</p><blockquote><p>在基础光照教程中讨论的更高级的那个衰减方程在有gamma校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行gamma校正的场景中当然需要不同的参数）。</p></blockquote><p>总而言之<strong>，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数(使用线性)的原因</strong></p><h2 id="阴影映射"><a href="#阴影映射" class="headerlink" title="阴影映射"></a>阴影映射</h2><p>阴影是由于遮挡导致的光的缺失。当光源的光线因为被其他物体遮挡而没有照射到物体上时，该物体处于阴影中。<strong>阴影为有光照的场景增添了极大的真实感，并使观众更容易观察物体之间的空间关系</strong>。它们为我们场景和物体提供了更深的立体感。</p><p>大多数视频游戏使用的一种既有效又易于实现的技术是阴影映射。阴影映射不难理解，对性能的影响不大，并且很容易扩展到更高级的算法(如全向阴影映射和级联阴影映射)</p><p>阴影映射背后的思想非常简单：我们从光源的角度渲染场景，从光源的角度看到的一切都是被照亮的，而我们看不到的一切都必须处于阴影中。想象一个地板部分和光源之间有一个大箱子的情况。由于光源在朝这个方向看时会看到这个箱子而不是地板部分，所以那个特定的地板部分应该处于阴影中</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;高级光照&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>入门vscode插件开发</title>
    <link href="https://www.sekyoro.top/2025/01/20/%E5%85%A5%E9%97%A8vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://www.sekyoro.top/2025/01/20/%E5%85%A5%E9%97%A8vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2025-01-19T16:16:29.000Z</published>
    <updated>2025-02-07T14:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在插件开发上,有Chorme浏览器插件,有开发工具插件. 在开发工具插件中,有visual studio,jetbrains以及vscode,其中vscode插件开发也是非常流行.这里简单入门介绍一下.<br><span id="more"></span></p><h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx --package yo --package generator-code -- yo code</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>yeoman是创建应用的脚手架,generator-code是vscode项目生成器. 有了这两者开发vscode插件就非常方便了.</p><h2 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h2><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest | Visual Studio Code Extension API</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mini-news&quot;</span>,</span><br><span class="line">  <span class="string">&quot;displayName&quot;</span>: <span class="string">&quot;mini-news&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;engines&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;vscode&quot;</span>: <span class="string">&quot;^1.96.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;categories&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Other&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;activationEvents&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./extension.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;contributes&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;command&quot;</span>: <span class="string">&quot;mini-news.hihi&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;mini-news:info&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint .&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pretest&quot;</span>: <span class="string">&quot;npm run lint&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;vscode-test&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@types/vscode&quot;</span>: <span class="string">&quot;^1.96.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/mocha&quot;</span>: <span class="string">&quot;^10.0.10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/node&quot;</span>: <span class="string">&quot;20.x&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint&quot;</span>: <span class="string">&quot;^9.16.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vscode/test-cli&quot;</span>: <span class="string">&quot;^0.0.10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vscode/test-electron&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于插件的配置,重要的属性比如<code>name</code>,<code>displayname</code>,<code>publisher</code>等,目前版本(&gt;1.74.0)<code>activationEvents</code>不需要额外配置,此外还有<code>contributions</code>用于配置扩展功能<a href="https://code.visualstudio.com/api/references/contribution-points">Contribution Points | Visual Studio Code Extension API</a></p><p>contribution包括commands,menus,configuration,keybinds等等</p><h3 id="extension-js"><a href="#extension-js" class="headerlink" title="extension.js"></a>extension.js</h3><p>扩展入口文件,暴露<code>activate</code>和<code>deactivate</code>.<code>activate</code> 在您注册的激活事件发生时执行。 <code>deactivate</code> 在您的扩展被停用之前给您一个清理的机会。对于许多扩展，可能不需要显式清理，并且可以删除 <code>deactivate</code> 方法。然而，如果扩展需要在 VS Code 关闭或扩展被禁用或卸载时执行操作使用<code>deactivate</code>.</p><p>通过<code>context.subscriptions.push</code>添加功能,通过vscode.xx.registerxx注册功能并在contribution中指定.</p><h2 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义注释内容</span></span><br><span class="line"><span class="keyword">const</span> COMMENT = <span class="string">&#x27;// This is a comment added by the extension\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册命令</span></span><br><span class="line">    <span class="keyword">const</span> disposable = vscode.commands.registerCommand(<span class="string">&#x27;extension.toggleComment&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line">        <span class="keyword">if</span> (!editor) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 没有活动的编辑器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">document</span> = editor.document;</span><br><span class="line">        <span class="keyword">const</span> firstLine = <span class="built_in">document</span>.lineAt(<span class="number">0</span>); <span class="comment">// 获取第一行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查第一行是否已经是注释</span></span><br><span class="line">        <span class="keyword">if</span> (firstLine.text === COMMENT.trim()) &#123;</span><br><span class="line">            <span class="comment">// 如果是注释，则删除</span></span><br><span class="line">            editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> range = <span class="keyword">new</span> vscode.Range(firstLine.range.start, firstLine.range.end);</span><br><span class="line">                editBuilder.delete(range);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是注释，则添加</span></span><br><span class="line">            editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                editBuilder.insert(firstLine.range.start, COMMENT);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;contributes&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;commands&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;extension.toggleComment&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Toggle Comment&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;keybindings&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;extension.toggleComment&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;ctrl+alt+c&quot;</span>, <span class="comment">// 自定义快捷键</span></span><br><span class="line">                <span class="attr">&quot;mac&quot;</span>: <span class="string">&quot;cmd+alt+c&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;when&quot;</span>: <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-hello-world.html">VSCode插件开发全攻略（二）HelloWord - 我是小茗同学 - 博客园</a></li><li><a href="https://code.visualstudio.com/api/get-started/your-first-extension">Your First Extension | Visual Studio Code Extension API</a></li><li><a href="https://github.com/microsoft/vscode-extension-samples/tree/main">microsoft/vscode-extension-samples: Sample code illustrating the VS Code extension API.</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-common-api.html">VSCode插件开发全攻略（九）常用API总结 - 我是小茗同学 - 博客园</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在插件开发上,有Chorme浏览器插件,有开发工具插件. 在开发工具插件中,有visual studio,jetbrains以及vscode,其中vscode插件开发也是非常流行.这里简单入门介绍一下.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Lua给neovim写插件</title>
    <link href="https://www.sekyoro.top/2025/01/18/%E7%BB%99neovim%E5%86%99%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.sekyoro.top/2025/01/18/%E7%BB%99neovim%E5%86%99%E6%8F%92%E4%BB%B6/</id>
    <published>2025-01-18T09:32:40.000Z</published>
    <updated>2025-02-07T14:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在使用neovim和LazyVim配置写代码,感觉很不错. 得益于neovim简单的功能和强大的第三方生态,可以很简单的写出一个插件. 这里根据官方文档搭配lazyvim等资料写一个简单插件.<br><span id="more"></span></p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>lua语法本身并不复杂,参考教程</p><ul><li><a href="https://learnxinyminutes.com/lua/">Learn Lua in Y Minutes</a></li><li><a href="http://lua-users.org/">lua-users.org</a></li><li><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></li><li><a href="https://w3schools.tech/tutorial/lua/index">Welcome to Lua: Your First Step into Programming - Lua Tutorial - W3schools</a></li><li><a href="https://www.lua.org/pil/contents.html#contents">Programming in Lua (first edition)</a></li></ul><p>相关项目</p><ul><li><a href="https://github.com/uhub/awesome-lua">uhub/awesome-lua: A curated list of awesome Lua frameworks, libraries and software.</a></li><li><a href="https://amd-nick.github.io/awesome-lua/">All In One Simple List | awesome lua</a></li><li><a href="https://love2d.org/">LÖVE - Free 2D Game Engine</a> 2D游戏引擎</li></ul><h4 id="表与模块"><a href="#表与模块" class="headerlink" title="表与模块"></a>表与模块</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">l1 = &#123;a=<span class="number">2</span>,b=<span class="number">4</span>&#125;</span><br><span class="line">l2 = &#123;a=<span class="number">2</span>,b=<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(l1,&#123;<span class="built_in">__add</span>=<span class="function"><span class="keyword">function</span><span class="params">(f1,f2)</span></span> </span><br><span class="line">        sum = &#123;&#125;</span><br><span class="line">        sum.a = f1.a + f2.a</span><br><span class="line">        sum.b = f1.b + f2.b</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">-- Values of __index,add, .. are called metamethods.</span></span><br><span class="line"><span class="comment">-- Full list. Here a is a table with the metamethod.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- __add(a, b)                     for a + b</span></span><br><span class="line"><span class="comment">-- __sub(a, b)                     for a - b</span></span><br><span class="line"><span class="comment">-- __mul(a, b)                     for a * b</span></span><br><span class="line"><span class="comment">-- __div(a, b)                     for a / b</span></span><br><span class="line"><span class="comment">-- __mod(a, b)                     for a % b</span></span><br><span class="line"><span class="comment">-- __pow(a, b)                     for a ^ b</span></span><br><span class="line"><span class="comment">-- __unm(a)                        for -a</span></span><br><span class="line"><span class="comment">-- __concat(a, b)                  for a .. b</span></span><br><span class="line"><span class="comment">-- __len(a)                        for #a</span></span><br><span class="line"><span class="comment">-- __eq(a, b)                      for a == b</span></span><br><span class="line"><span class="comment">-- __lt(a, b)                      for a &lt; b</span></span><br><span class="line"><span class="comment">-- __le(a, b)                      for a &lt;= b</span></span><br><span class="line"><span class="comment">-- __index(a, b)  &lt;fn or a table&gt;  for a.b</span></span><br><span class="line"><span class="comment">-- __newindex(a, b, c)             for a.b = c</span></span><br><span class="line"><span class="comment">-- __call(a, ...)                  for a(...)</span></span><br><span class="line"><span class="keyword">local</span> Dog = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:new</span><span class="params">()</span></span></span><br><span class="line">    newObj = &#123;name=<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(newObj,<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog:makeSound</span><span class="params">()</span></span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;I say &#x27;</span> .. <span class="built_in">self</span>.sound)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">LoudDog = Dog:new()                          </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoudDog:makeSound</span><span class="params">()</span></span></span><br><span class="line">  s = <span class="built_in">self</span>.sound .. <span class="string">&#x27; &#x27;</span>                      </span><br><span class="line">  <span class="built_in">print</span>(s .. s .. s)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Suppose the file mod.lua looks like this:</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sayMyName</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hrunkner&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.sayHello</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Why hello there&#x27;</span>)</span><br><span class="line">  sayMyName()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Another file can use mod.lua&#x27;s functionality:</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span>(<span class="string">&#x27;mod&#x27;</span>)</span><br><span class="line"><span class="comment">-- require&#x27;s return values are cached so a file is</span></span><br><span class="line"><span class="comment">-- run at most once, even when require&#x27;d many times.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Suppose mod2.lua contains &quot;print(&#x27;Hi!&#x27;)&quot;.</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="built_in">require</span>(<span class="string">&#x27;mod2&#x27;</span>)  <span class="comment">-- Prints Hi!</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="built_in">require</span>(<span class="string">&#x27;mod2&#x27;</span>)  <span class="comment">-- Doesn&#x27;t print; a=b.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- dofile is like require without caching:</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">--&gt; Hi!</span></span><br><span class="line"><span class="built_in">dofile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">--&gt; Hi! (runs it again)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- loadfile loads a lua file but doesn&#x27;t run it yet.</span></span><br><span class="line">f = <span class="built_in">loadfile</span>(<span class="string">&#x27;mod2.lua&#x27;</span>)  <span class="comment">-- Call f() to run it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- load is loadfile for strings.</span></span><br><span class="line"><span class="comment">-- (loadstring is deprecated, use load instead)</span></span><br><span class="line">g = <span class="built_in">loadstring</span>(<span class="string">&#x27;print(343)&#x27;</span>)  <span class="comment">-- Returns a function.</span></span><br><span class="line">g()  <span class="comment">-- Prints out 343; nothing printed before now.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h4><p>重要的库: io,string.os,table,math</p><div class="table-container"><table><thead><tr><th>库</th><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>string</td><td>string.upper(s)</td><td>Converts s to uppercase</td></tr><tr><td></td><td>string.lower(s)</td><td>Converts s to lowercase</td></tr><tr><td></td><td>string.len(s)</td><td>Returns the length of s</td></tr><tr><td>math</td><td>math.max(x, …)</td><td>Returns the maximum value among its arguments</td></tr><tr><td></td><td>math.min(x, …)</td><td>Returns the minimum value among its arguments</td></tr><tr><td></td><td>math.random([m [, n]])</td><td>Generates a random number</td></tr><tr><td>table</td><td>table.insert(t, [pos,] value)</td><td>Inserts value into t at position pos</td></tr><tr><td></td><td>table.remove(t [, pos])</td><td>Removes from t the element at position pos</td></tr><tr><td></td><td>table.sort(t [, comp])</td><td>Sorts table elements in a given order</td></tr></tbody></table></div><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>在 Lua 中，<code>require</code> 函数用于加载和初始化模块。它会按照一定的顺序搜索指定的模块，并根据配置从不同的目录中加载模块文件。具体来说，<code>require</code> 的查找路径由 <code>package.path</code> 和 <code>package.cpath</code> 两个变量定义。</p><p> <code>package.path</code></p><ul><li><p><strong>用途</strong>：用于指定 Lua 模块（<code>.lua</code> 文件）的搜索路径。</p></li><li><p><strong>默认值</strong>：在不同平台和 Lua 版本上，默认值可能有所不同，但通常类似于以下格式：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package.path = &#x27;<span class="string">./</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span> -- 当前目录下的 <span class="string">.lua</span> 文件</span><br><span class="line">               &#x27;<span class="string">./</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span> -- 当前目录下的子目录中的 init.lua 文件</span><br><span class="line">               &#x27;<span class="string">/usr/local/share/lua/5.4/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/share/lua/5.4/</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">/init.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">./lua/</span>?<span class="string">.lua</span>;&#x27; <span class="string">..</span></span><br><span class="line">               &#x27;<span class="string">./lua/</span>?<span class="string">/init.lua</span>&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式说明</strong>：</p><ul><li><code>?</code> 是一个占位符，代表模块名。</li><li><code>?/init.lua</code> 表示如果模块名是目录，则尝试加载该目录下的 <code>init.lua</code> 文件。</li></ul></li></ul><ol><li><code>package.cpath</code></li></ol><ul><li><p><strong>用途</strong>：用于指定 C 模块（即使用 C 或 C++ 编写的模块，通常是 <code>.so</code> 或 <code>.dll</code> 文件）的搜索路径。</p></li><li><p><strong>默认值</strong>：同样地，这取决于平台和 Lua 版本，但一般包括如下路径：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package.cpath = &#x27;<span class="string">./</span>?<span class="string">.so</span>;&#x27; <span class="string">..</span> -- 当前目录下的共享库文件</span><br><span class="line">              &#x27;<span class="string">./</span>?<span class="string">.dll</span>;&#x27; <span class="string">..</span> -- Windows 上的动态链接库文件</span><br><span class="line">              &#x27;<span class="string">./loadall.so</span>;&#x27; <span class="string">..</span> -- 加载所有符号的共享库</span><br><span class="line">              &#x27;<span class="string">/usr/local/lib/lua/5.4/</span>?<span class="string">.so</span>;&#x27; <span class="string">..</span></span><br><span class="line">              &#x27;<span class="string">/usr/local/lib/lua/5.4/loadall.so</span>;&#x27;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式说明</strong>：</p><ul><li><code>?</code> 同样作为模块名的占位符。</li><li>其他部分指定了操作系统特定的库文件扩展名。</li></ul></li></ul><ol><li><code>package.preload</code></li></ol><p>除了上述路径外，<code>require</code> 还会在 <code>package.preload</code> 表中查找是否已经预加载了相应的模块。如果找到了匹配项，则直接返回对应的函数而不进行文件系统搜索</p><h2 id="Neovim的基本功能"><a href="#Neovim的基本功能" class="headerlink" title="Neovim的基本功能"></a>Neovim的基本功能</h2><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p><img data-src="https://s2.loli.net/2025/01/18/bfXs3tq7xK8vAWL.png" alt="image-20250118174705262" style="zoom:50%;" /></p><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>Nvim 支持使用 init.vim 或 init.lua 作为配置文件，但不能同时使用这两个文件。 该文件应放在config目录中、<br>对于 Linux、BSD 或 macOS，该目录通常为 ~/.config/nvim，而对于<br>/AppData/Local/nvim/（Windows）。 请注意，可以在 init.vim 中使用 Lua<br>中使用 Lua，在 init.lua 中使用 Vimscript。 如果想在启动时自动运行任何其他 Lua 脚本，那么<br>只需将其放入运行时路径中的 plugin/。</p><h3 id="nvim中的lua"><a href="#nvim中的lua" class="headerlink" title="nvim中的lua"></a>nvim中的lua</h3><p><a href="https://neovim.io/doc/user/lua-guide.html">Lua-guide - Neovim docs</a></p><h4 id="vim-g"><a href="#vim-g" class="headerlink" title="vim.g"></a>vim.g</h4><p><code>vim.g</code> 是一个 Lua 表，它提供了对全局变量的访问。通过 <code>vim.g</code>，你可以设置或读取任何定义在全局命名空间中的变量。这对于配置插件或共享状态信息非常有用，因为全局变量可以在整个会话期间保持不变，并且可以在不同的脚本之间传递数据。</p><h4 id="vim-cmd"><a href="#vim-cmd" class="headerlink" title="vim.cmd"></a>vim.cmd</h4><p>执行vimscript</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim.cmd(<span class="string">&#x27;echo 42&#x27;</span>)</span><br><span class="line">vim.cmd(<span class="string">[[</span></span><br><span class="line"><span class="string">  augroup My_group</span></span><br><span class="line"><span class="string">    autocmd!</span></span><br><span class="line"><span class="string">    autocmd FileType c setlocal cindent</span></span><br><span class="line"><span class="string">  augroup END</span></span><br><span class="line"><span class="string">]]</span>)</span><br><span class="line"><span class="comment">-- Ex command :echo &quot;foo&quot;</span></span><br><span class="line"><span class="comment">-- Note string literals need to be double quoted.</span></span><br><span class="line">vim.cmd(<span class="string">&#x27;echo &quot;foo&quot;&#x27;</span>)</span><br><span class="line">vim.cmd &#123; cmd = <span class="string">&#x27;echo&#x27;</span>, args = &#123; <span class="string">&#x27;&quot;foo&quot;&#x27;</span> &#125; &#125;</span><br><span class="line">vim.cmd.echo(&#123; args = &#123; <span class="string">&#x27;&quot;foo&quot;&#x27;</span> &#125; &#125;)</span><br><span class="line">vim.cmd.echo(<span class="string">&#x27;&quot;foo&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="vim-opt"><a href="#vim-opt" class="headerlink" title="vim.opt"></a>vim.opt</h4><p><code>vim.opt</code> 是另一个 Lua 表，但它专注于编辑器的选项配置。它允许用户以一种结构化的方式设置和查询 Vim/Neovim 的各种行为参数。与传统的 <code>:set</code> 命令相比，<code>vim.opt</code> 提供了一个更加直观和易于维护的方式来管理和调整编辑器的行为.可以指定选项的作用范围，比如 <code>vim.o</code> 对于全局选项，<code>vim.bo</code> 对于缓冲区特定选项，<code>vim.wo</code> 对于窗口特定选项</p><blockquote><p>一个特殊的接口 vim.opt，可以方便地与 Lua 中的列表和映射样式选项进行交互：它允许以 Lua 表格的形式访问它们，并提供面向对象的方法来添加和删除条目</p></blockquote><p>In Lua using <code>vim.o</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.o.wildignore = <span class="string">&#x27;*.o,*.a,__pycache__&#x27;</span></span><br></pre></td></tr></table></figure><p>In Lua using <code>vim.opt</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.opt.wildignore = &#123; <span class="string">&#x27;*.o&#x27;</span>, <span class="string">&#x27;*.a&#x27;</span>, <span class="string">&#x27;__pycache__&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="vim-api"><a href="#vim-api" class="headerlink" title="vim.api"></a>vim.api</h4><p><a href="https://neovim.io/doc/user/lua.html#vim.api">vim.api</a></p><p>vim.api.{func}(<code>&#123;...&#125;</code>)<br>调用带有参数 {…} 的 Nvim API 函数 {func}。 示例：调用 “nvim_get_current_line()” API 函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(vim.api.nvim_get_current_line()))</span><br></pre></td></tr></table></figure><h4 id="vim-fn"><a href="#vim-fn" class="headerlink" title="vim.fn"></a>vim.fn</h4><p><code>vim.fn</code> 是一个特别设计用来桥接 Vimscript 和 Lua 的接口。它使得开发者能够在 Lua 脚本中调用所有可用的 Vim 内置函数。</p><ul><li>执行系统命令并捕获输出：<code>local output = vim.fn.system(&#39;uname -a&#39;)</code></li><li>获取当前文件名：<code>local filename = vim.fn.expand(&#39;%&#39;)</code></li><li>访问环境变量：<code>local path = vim.fn.getenv(&#39;PATH&#39;)</code></li></ul><p>Neovim会默认从某个目录中加载<code>init.lua</code>,路径如下</p><div class="table-container"><table><thead><tr><th>OS</th><th>PATH</th></tr></thead><tbody><tr><td>Linux, MacOS</td><td><code>$XDG_CONFIG_HOME/nvim</code>, <code>~/.config/nvim</code></td></tr><tr><td>Windows (cmd)</td><td><code>%localappdata%\nvim\</code></td></tr><tr><td>Windows (powershell)</td><td><code>$env:LOCALAPPDATA\nvim\</code></td></tr></tbody></table></div><h4 id="vim-system"><a href="#vim-system" class="headerlink" title="vim.system"></a>vim.system</h4><p>vim.system({cmd}, {opts}, {on_exit})<br> 运行系统命令，如果 {cmd} 无法运行，则抛出错误信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> on_exit = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span></span><br><span class="line">      <span class="built_in">print</span>(obj.code)</span><br><span class="line">      <span class="built_in">print</span>(obj.signal)</span><br><span class="line">      <span class="built_in">print</span>(obj.<span class="built_in">stdout</span>)</span><br><span class="line">      <span class="built_in">print</span>(obj.<span class="built_in">stderr</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Runs asynchronously:</span></span><br><span class="line">    vim.system(&#123;<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;, &#123; text = <span class="literal">true</span> &#125;, on_exit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Runs synchronously:</span></span><br><span class="line">    <span class="keyword">local</span> obj = vim.system(&#123;<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;, &#123; text = <span class="literal">true</span> &#125;):wait()</span><br><span class="line">    <span class="comment">-- &#123; code = 0, signal = 0, stdout = &#x27;hello&#x27;, stderr = &#x27;&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="vim-uv-vim-loop"><a href="#vim-uv-vim-loop" class="headerlink" title="vim.uv vim.loop"></a>vim.uv vim.loop</h4><p>vim.uv暴露 Nvim 用于网络、文件系统和进程管理的 libUV 库的 “luv” Lua 绑定.</p><p><code>vim.uv</code> 是 Neovim 提供的一个接口，它封装了 libuv 库的功能。libuv 是一个用于异步 I/O 的多平台支持库，最初为 Node.js 开发，但因其高效性和跨平台特性而被广泛采用。通过 <code>vim.uv</code>，Neovim 用户和插件开发者可以直接访问底层的文件系统、网络和其他系统操作功能，从而实现更复杂的应用逻辑或优化性能关键部分</p><h4 id="vim-env"><a href="#vim-env" class="headerlink" title="vim.env"></a>vim.env</h4><p>编辑器会话中定义的环境变量</p><h4 id="vim-schedule"><a href="#vim-schedule" class="headerlink" title="vim.schedule"></a>vim.schedule</h4><p>通过事件循环执行函数,避免阻塞</p><h4 id="vim-lsp"><a href="#vim-lsp" class="headerlink" title="vim.lsp"></a>vim.lsp</h4><p>Nvim 支持语言服务器协议 （LSP），这意味着它充当 LSP 服务器的客户端，并包含一个 Lua 框架 <code>vim.lsp</code> 用于构建增强的 LSP 工具</p><h4 id="vim-tbl-deep-extend"><a href="#vim-tbl-deep-extend" class="headerlink" title="vim.tbl_deep_extend"></a>vim.tbl_deep_extend</h4><p>Neovim 提供的一个用于深度合并 Lua 表的函数。它允许你将一个或多个表的内容递归地合并到目标表中，而不会简单地覆盖原有的键值对。这对于配置管理、插件开发以及其他需要合并多层级数据结构的场景非常有用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tbl<span class="constructor">_deep_extend(<span class="params">strategy</span>, <span class="params">target</span>, <span class="params">source1</span>, <span class="params">source2</span>, <span class="operator">...</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>strategy</p><p>：指定合并策略，可以是以下之一：</p><ul><li><code>&quot;force&quot;</code>：强制覆盖目标表中的现有键值。</li><li><code>&quot;keep&quot;</code>：保留目标表中的现有键值，不被源表覆盖。</li><li><code>&quot;error&quot;</code>：如果遇到冲突（即同一个键存在于目标和源表中），则抛出错误。</li></ul></li><li><p><strong>target</strong>：目标表，即将要接收合并结果的表。</p></li><li><p><strong>source1, source2, …</strong>：一个或多个源表，它们的内容将被合并到目标表中。</p></li></ul><h2 id="kickstart"><a href="#kickstart" class="headerlink" title="kickstart"></a>kickstart</h2><p>kickstart是配置nvim很好的一个参考.  <strong>要点</strong>:勤用<code>:help</code>,<code>:help lua-guide</code>,可以查阅neovim提供的lua函数</p><h4 id="配置全局变量与选项-vim-g-amp-amp-vim-opt"><a href="#配置全局变量与选项-vim-g-amp-amp-vim-opt" class="headerlink" title="配置全局变量与选项(vim.g&amp;&amp;vim.opt)"></a>配置全局变量与选项(vim.g&amp;&amp;vim.opt)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Set &lt;space&gt; as the leader key</span></span><br><span class="line"><span class="comment">-- See `:help mapleader`</span></span><br><span class="line"><span class="comment">--  <span class="doctag">NOTE:</span> Must happen before plugins are loaded (otherwise wrong leader will be used)</span></span><br><span class="line">vim.g.mapleader = <span class="string">&#x27; &#x27;</span></span><br><span class="line">vim.g.maplocalleader = <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set to true if you have a Nerd Font installed and selected in the terminal</span></span><br><span class="line">vim.g.have_nerd_font = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- [[ Setting options ]]</span></span><br><span class="line"><span class="comment">-- See `:help vim.opt`</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> You can change these options as you wish!</span></span><br><span class="line"><span class="comment">--  For more options, you can see `:help option-list`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Make line numbers default</span></span><br><span class="line">vim.opt.number = <span class="literal">true</span></span><br><span class="line"><span class="comment">-- You can also add relative line numbers, to help with jumping.</span></span><br><span class="line"><span class="comment">--  Experiment for yourself to see if you like it!</span></span><br><span class="line"><span class="comment">-- vim.opt.relativenumber = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Enable mouse mode, can be useful for resizing splits for example!</span></span><br><span class="line">vim.opt.mouse = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Don&#x27;t show the mode, since it&#x27;s already in the status line</span></span><br><span class="line">vim.opt.showmode = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2025/01/18/1Awh4k7BIx63Cq2.png" alt="image-20250118233131109" style="zoom:50%;" /></p><h4 id="快捷键-keymap"><a href="#快捷键-keymap" class="headerlink" title="快捷键(keymap)"></a>快捷键(keymap)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Basic Keymaps ]]</span></span><br><span class="line"><span class="comment">--  See `:help vim.keymap.set()`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Clear highlights on search when pressing &lt;Esc&gt; in normal mode</span></span><br><span class="line"><span class="comment">--  See `:help hlsearch`</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;nohlsearch&lt;CR&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Diagnostic keymaps</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;leader&gt;q&#x27;</span>, vim.diagnostic.setloclist, &#123; desc = <span class="string">&#x27;Open diagnostic [Q]uickfix list&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exit terminal mode in the builtin terminal with a shortcut that is a bit easier</span></span><br><span class="line"><span class="comment">-- for people to discover. Otherwise, you normally need to press &lt;C-\&gt;&lt;C-n&gt;, which</span></span><br><span class="line"><span class="comment">-- is not what someone will guess without a bit more experience.</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> This won&#x27;t work in all terminal emulators/tmux/etc. Try your own mapping</span></span><br><span class="line"><span class="comment">-- or just use &lt;C-\&gt;&lt;C-n&gt; to exit terminal mode</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;&lt;Esc&gt;&lt;Esc&gt;&#x27;</span>, <span class="string">&#x27;&lt;C-\\&gt;&lt;C-n&gt;&#x27;</span>, &#123; desc = <span class="string">&#x27;Exit terminal mode&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TIP: Disable arrow keys in normal mode</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;left&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use h to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;right&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use l to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;up&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use k to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br><span class="line"><span class="comment">-- vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;down&gt;&#x27;, &#x27;&lt;cmd&gt;echo &quot;Use j to move!!&quot;&lt;CR&gt;&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="指令执行-autocmd"><a href="#指令执行-autocmd" class="headerlink" title="指令执行(autocmd)"></a>指令执行(autocmd)</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Basic Autocommands ]]</span></span><br><span class="line"><span class="comment">--  See `:help lua-guide-autocommands`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Highlight when yanking (copying) text</span></span><br><span class="line"><span class="comment">--  Try it with `yap` in normal mode</span></span><br><span class="line"><span class="comment">--  See `:help vim.highlight.on_yank()`</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&#x27;TextYankPost&#x27;</span>, &#123;</span><br><span class="line">  desc = <span class="string">&#x27;Highlight when yanking (copying) text&#x27;</span>,</span><br><span class="line">  group = vim.api.nvim_create_augroup(<span class="string">&#x27;kickstart-highlight-yank&#x27;</span>, &#123; clear = <span class="literal">true</span> &#125;),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.highlight.on_yank()</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  command = <span class="string">&quot;echo &#x27;Entering a C or C++ file&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Same autocommand written with a Lua function instead</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;Entering a C or C++ file&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- User event triggered by MyPlugin</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;User&quot;</span>, &#123;</span><br><span class="line">  pattern = <span class="string">&quot;MyPlugin&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;My Plugin Works!&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>自动命令是 Vim 命令或 Lua 函数，每当触发一个或多个事件触发时自动执行的 Vim 命令或 Lua 函数。<br>读取或写入文件，或创建窗口时自动执行。 可以通过Lua使用Nvim API 访问。</p><h4 id="安装包管理器"><a href="#安装包管理器" class="headerlink" title="安装包管理器"></a>安装包管理器</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Install `lazy.nvim` plugin manager ]]</span></span><br><span class="line"><span class="comment">--    See `:help lazy.nvim.txt` or https://github.com/folke/lazy.nvim for more info</span></span><br><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath <span class="string">&#x27;data&#x27;</span> .. <span class="string">&#x27;/lazy/lazy.nvim&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (vim.uv <span class="keyword">or</span> vim.loop).fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> lazyrepo = <span class="string">&#x27;https://github.com/folke/lazy.nvim.git&#x27;</span></span><br><span class="line">  <span class="keyword">local</span> out = vim.fn.system &#123; <span class="string">&#x27;git&#x27;</span>, <span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--filter=blob:none&#x27;</span>, <span class="string">&#x27;--branch=stable&#x27;</span>, lazyrepo, lazypath &#125;</span><br><span class="line">  <span class="keyword">if</span> vim.v.shell_error ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&#x27;Error cloning lazy.nvim:\n&#x27;</span> .. out)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">---@diagnostic disable-next-line: undefined-field</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br></pre></td></tr></table></figure><p><code>vim.fn.stdpath</code> 用于获取标准路径的绝对路径。它可以帮助你轻松找到配置文件、数据文件或缓存文件所在的目录，这对于编写可移植的脚本和插件非常有用。</p><p><strong>kind</strong>：指定要查询的标准路径类型，可以是以下字符串之一：</p><ul><li><code>&quot;config&quot;</code>：配置文件的位置。通常对应于 <code>$XDG_CONFIG_HOME/nvim</code> 或 <code>$HOME/.config/nvim</code>。</li><li><code>&quot;data&quot;</code>：用户特定的数据文件位置。通常对应于 <code>$XDG_DATA_HOME/nvim</code> 或 <code>$HOME/.local/share/nvim</code>。</li><li><code>&quot;cache&quot;</code>：缓存文件的位置。通常对应于 <code>$XDG_CACHE_HOME/nvim</code> 或 <code>$HOME/.cache/nvim</code>。</li><li><code>&quot;state&quot;</code>：状态文件的位置（如 swap 文件、undo 文件等）。通常与 <code>data</code> 目录相同，但在某些情况下可能会有所不同</li></ul><p>v:shell_error最后一条 shell 命令的结果。  非零时，表示最后一条shell 命令出错。 当为零时，表示没有问题。只有当 shell 向 Vim 返回错误代码时才会起作用。当命令无法执行时，通常使用 -1。 执行。  只读。</p><p>Vim/Neovim 使用 <code>rtp</code> 来定位各种类型的文件，如：</p><ul><li>插件 (<code>plugin/*.vim</code>)</li><li>脚本 (<code>autoload/*.vim</code>, <code>ftplugin/*.vim</code>)</li><li>语法定义 (<code>syntax/*.vim</code>)</li><li>颜色方案 (<code>colors/*.vim</code>)</li><li>文档 (<code>doc/*.txt</code>)</li><li><p>其他配置文件</p></li><li><p><strong>加载顺序</strong>：当有多个相同名称的文件存在于不同的目录中时，会按照 <code>rtp</code> 中列出的顺序依次查找并加载第一个找到的文件。这意味着较早出现在 <code>rtp</code> 中的目录具有更高的优先级。</p></li></ul><p>配置插件管理</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [[ Configure and install plugins ]]</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  To check the current status of your plugins, run</span></span><br><span class="line"><span class="comment">--    :Lazy</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  You can press `?` in this menu for help. Use `:q` to close the window</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--  To update plugins you can run</span></span><br><span class="line"><span class="comment">--    :Lazy update</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- <span class="doctag">NOTE:</span> Here is where you install your plugins.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;lazy&#x27;</span>).setup(&#123;</span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can be added with a link (or for a github repo: &#x27;owner/repo&#x27; link).</span></span><br><span class="line">  <span class="string">&#x27;tpope/vim-sleuth&#x27;</span>, <span class="comment">-- Detect tabstop and shiftwidth automatically</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can also be added by using a table,</span></span><br><span class="line">  <span class="comment">-- with the first argument being the link and the following</span></span><br><span class="line">  <span class="comment">-- keys can be used to configure plugin behavior/loading/etc.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- Use `opts = &#123;&#125;` to force a plugin to be loaded.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Here is a more advanced example where we pass configuration</span></span><br><span class="line">  <span class="comment">-- options to `gitsigns.nvim`. This is equivalent to the following Lua:</span></span><br><span class="line">  <span class="comment">--    require(&#x27;gitsigns&#x27;).setup(&#123; ... &#125;)</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- See `:help gitsigns` to understand what the configuration keys do</span></span><br><span class="line">  &#123; <span class="comment">-- Adds git related signs to the gutter, as well as utilities for managing changes</span></span><br><span class="line">    <span class="string">&#x27;lewis6991/gitsigns.nvim&#x27;</span>,</span><br><span class="line">    opts = &#123;</span><br><span class="line">      signs = &#123;</span><br><span class="line">        add = &#123; text = <span class="string">&#x27;+&#x27;</span> &#125;,</span><br><span class="line">        change = &#123; text = <span class="string">&#x27;~&#x27;</span> &#125;,</span><br><span class="line">        delete = &#123; text = <span class="string">&#x27;_&#x27;</span> &#125;,</span><br><span class="line">        topdelete = &#123; text = <span class="string">&#x27;‾&#x27;</span> &#125;,</span><br><span class="line">        changedelete = &#123; text = <span class="string">&#x27;~&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- <span class="doctag">NOTE:</span> Plugins can also be configured to run Lua code when they are loaded.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- This is often very useful to both group configuration, as well as handle</span></span><br><span class="line">  <span class="comment">-- lazy loading plugins that don&#x27;t need to be loaded immediately at startup.</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- For example, in the following configuration, we use:</span></span><br><span class="line">  <span class="comment">--  event = &#x27;VimEnter&#x27;</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- which loads which-key before all the UI elements are loaded. Events can be</span></span><br><span class="line">  <span class="comment">-- normal autocommands events (`:help autocmd-events`).</span></span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  <span class="comment">-- Then, because we use the `opts` key (recommended), the configuration runs</span></span><br><span class="line">  <span class="comment">-- after the plugin has been loaded as `require(MODULE).setup(opts)`.</span></span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">-- Useful plugin to show you pending keybinds.</span></span><br><span class="line">    <span class="string">&#x27;folke/which-key.nvim&#x27;</span>,</span><br><span class="line">    event = <span class="string">&#x27;VimEnter&#x27;</span>, <span class="comment">-- Sets the loading event to &#x27;VimEnter&#x27;</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="comment">-- delay between pressing a key and opening which-key (milliseconds)</span></span><br><span class="line">      <span class="comment">-- this setting is independent of vim.opt.timeoutlen</span></span><br><span class="line">      delay = <span class="number">0</span>,</span><br><span class="line">      icons = &#123;</span><br><span class="line">        <span class="comment">-- set icon mappings to true if you have a Nerd Font</span></span><br><span class="line">        mappings = vim.g.have_nerd_font,</span><br><span class="line">        <span class="comment">-- If you are using a Nerd Font: set icons.keys to an empty table which will use the</span></span><br><span class="line">        <span class="comment">-- default which-key.nvim defined Nerd Font icons, otherwise define a string table</span></span><br><span class="line">        keys = vim.g.have_nerd_font <span class="keyword">and</span> &#123;&#125; <span class="keyword">or</span> &#123;</span><br><span class="line">          Up = <span class="string">&#x27;&lt;Up&gt; &#x27;</span>,</span><br><span class="line">          Down = <span class="string">&#x27;&lt;Down&gt; &#x27;</span>,</span><br><span class="line">          Left = <span class="string">&#x27;&lt;Left&gt; &#x27;</span>,</span><br><span class="line">          Right = <span class="string">&#x27;&lt;Right&gt; &#x27;</span>,</span><br><span class="line">          C = <span class="string">&#x27;&lt;C-…&gt; &#x27;</span>,</span><br><span class="line">          M = <span class="string">&#x27;&lt;M-…&gt; &#x27;</span>,</span><br><span class="line">          D = <span class="string">&#x27;&lt;D-…&gt; &#x27;</span>,</span><br><span class="line">          S = <span class="string">&#x27;&lt;S-…&gt; &#x27;</span>,</span><br><span class="line">          CR = <span class="string">&#x27;&lt;CR&gt; &#x27;</span>,</span><br><span class="line">          Esc = <span class="string">&#x27;&lt;Esc&gt; &#x27;</span>,</span><br><span class="line">          ScrollWheelDown = <span class="string">&#x27;&lt;ScrollWheelDown&gt; &#x27;</span>,</span><br><span class="line">          ScrollWheelUp = <span class="string">&#x27;&lt;ScrollWheelUp&gt; &#x27;</span>,</span><br><span class="line">          NL = <span class="string">&#x27;&lt;NL&gt; &#x27;</span>,</span><br><span class="line">          BS = <span class="string">&#x27;&lt;BS&gt; &#x27;</span>,</span><br><span class="line">          Space = <span class="string">&#x27;&lt;Space&gt; &#x27;</span>,</span><br><span class="line">          Tab = <span class="string">&#x27;&lt;Tab&gt; &#x27;</span>,</span><br><span class="line">          F1 = <span class="string">&#x27;&lt;F1&gt;&#x27;</span>,</span><br><span class="line">          F2 = <span class="string">&#x27;&lt;F2&gt;&#x27;</span>,</span><br><span class="line">          F3 = <span class="string">&#x27;&lt;F3&gt;&#x27;</span>,</span><br><span class="line">          F4 = <span class="string">&#x27;&lt;F4&gt;&#x27;</span>,</span><br><span class="line">          F5 = <span class="string">&#x27;&lt;F5&gt;&#x27;</span>,</span><br><span class="line">          F6 = <span class="string">&#x27;&lt;F6&gt;&#x27;</span>,</span><br><span class="line">          F7 = <span class="string">&#x27;&lt;F7&gt;&#x27;</span>,</span><br><span class="line">          F8 = <span class="string">&#x27;&lt;F8&gt;&#x27;</span>,</span><br><span class="line">          F9 = <span class="string">&#x27;&lt;F9&gt;&#x27;</span>,</span><br><span class="line">          F10 = <span class="string">&#x27;&lt;F10&gt;&#x27;</span>,</span><br><span class="line">          F11 = <span class="string">&#x27;&lt;F11&gt;&#x27;</span>,</span><br><span class="line">          F12 = <span class="string">&#x27;&lt;F12&gt;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Document existing key chains</span></span><br><span class="line">      spec = &#123;</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;c&#x27;</span>, group = <span class="string">&#x27;[C]ode&#x27;</span>, mode = &#123; <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;x&#x27;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;d&#x27;</span>, group = <span class="string">&#x27;[D]ocument&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;r&#x27;</span>, group = <span class="string">&#x27;[R]ename&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;s&#x27;</span>, group = <span class="string">&#x27;[S]earch&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;w&#x27;</span>, group = <span class="string">&#x27;[W]orkspace&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;t&#x27;</span>, group = <span class="string">&#x27;[T]oggle&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;leader&gt;h&#x27;</span>, group = <span class="string">&#x27;Git [H]unk&#x27;</span>, mode = &#123; <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;v&#x27;</span> &#125; &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="NvChad"><a href="#NvChad" class="headerlink" title="NvChad"></a>NvChad</h2><p>比kickstart更复杂一点,但也很容易上手. 其配置也是类似,首先包括全局变量、设置选项以及环境变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"><span class="keyword">local</span> o = vim.o</span><br><span class="line"><span class="keyword">local</span> g = vim.g</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------------------- options ------------------------------------------</span></span><br><span class="line">o.laststatus = <span class="number">3</span></span><br><span class="line">o.showmode = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">o.clipboard = <span class="string">&quot;unnamedplus&quot;</span></span><br><span class="line">o.cursorline = <span class="literal">true</span></span><br><span class="line">o.cursorlineopt = <span class="string">&quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Indenting</span></span><br><span class="line">o.expandtab = <span class="literal">true</span></span><br><span class="line">o.shiftwidth = <span class="number">2</span></span><br><span class="line">o.smartindent = <span class="literal">true</span></span><br><span class="line">o.tabstop = <span class="number">2</span></span><br><span class="line">o.softtabstop = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">opt.fillchars = &#123; eob = <span class="string">&quot; &quot;</span> &#125;</span><br><span class="line">o.ignorecase = <span class="literal">true</span></span><br><span class="line">o.smartcase = <span class="literal">true</span></span><br><span class="line">o.mouse = <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Numbers</span></span><br><span class="line">o.number = <span class="literal">true</span></span><br><span class="line">o.numberwidth = <span class="number">2</span></span><br><span class="line">o.ruler = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- disable nvim intro</span></span><br><span class="line">opt.shortmess:append <span class="string">&quot;sI&quot;</span></span><br><span class="line"></span><br><span class="line">o.signcolumn = <span class="string">&quot;yes&quot;</span></span><br><span class="line">o.splitbelow = <span class="literal">true</span></span><br><span class="line">o.splitright = <span class="literal">true</span></span><br><span class="line">o.timeoutlen = <span class="number">400</span></span><br><span class="line">o.undofile = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- interval for writing swap file to disk, also used by gitsigns</span></span><br><span class="line">o.updatetime = <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- go to previous/next line with h,l,left arrow and right arrow</span></span><br><span class="line"><span class="comment">-- when cursor reaches end/beginning of line</span></span><br><span class="line">opt.whichwrap:append <span class="string">&quot;&lt;&gt;[]hl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- disable some default providers</span></span><br><span class="line">g.loaded_node_provider = <span class="number">0</span></span><br><span class="line">g.loaded_python3_provider = <span class="number">0</span></span><br><span class="line">g.loaded_perl_provider = <span class="number">0</span></span><br><span class="line">g.loaded_ruby_provider = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- add binaries installed by mason.nvim to path</span></span><br><span class="line"><span class="keyword">local</span> is_windows = vim.fn.has <span class="string">&quot;win32&quot;</span> ~= <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> sep = is_windows <span class="keyword">and</span> <span class="string">&quot;\\&quot;</span> <span class="keyword">or</span> <span class="string">&quot;/&quot;</span></span><br><span class="line"><span class="keyword">local</span> delim = is_windows <span class="keyword">and</span> <span class="string">&quot;;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;:&quot;</span></span><br><span class="line">vim.env.PATH = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123; vim.fn.stdpath <span class="string">&quot;data&quot;</span>, <span class="string">&quot;mason&quot;</span>, <span class="string">&quot;bin&quot;</span> &#125;, sep) .. delim .. vim.env.PATH</span><br></pre></td></tr></table></figure><p>快捷键</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> map = vim.keymap.set</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-b&gt;&quot;</span>, <span class="string">&quot;&lt;ESC&gt;^i&quot;</span>, &#123; desc = <span class="string">&quot;move beginning of line&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-e&gt;&quot;</span>, <span class="string">&quot;&lt;End&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move end of line&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;Left&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move left&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;Right&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move right&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;Down&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;Up&gt;&quot;</span>, &#123; desc = <span class="string">&quot;move up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;h&quot;</span>, &#123; desc = <span class="string">&quot;switch window left&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;l&quot;</span>, &#123; desc = <span class="string">&quot;switch window right&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;j&quot;</span>, &#123; desc = <span class="string">&quot;switch window down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;k&quot;</span>, &#123; desc = <span class="string">&quot;switch window up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;Esc&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;noh&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general clear highlights&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-s&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;w&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general save file&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-c&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;%y+&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;general copy whole file&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;n&quot;</span>, <span class="string">&quot;&lt;cmd&gt;set nu!&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle line number&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;rn&quot;</span>, <span class="string">&quot;&lt;cmd&gt;set rnu!&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle relative number&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ch&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvCheatsheet&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;toggle nvcheatsheet&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fm&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;conform&quot;</span>).<span class="built_in">format</span> &#123; lsp_fallback = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;general format file&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- global lsp mappings</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ds&quot;</span>, vim.diagnostic.setloclist, &#123; desc = <span class="string">&quot;LSP diagnostic loclist&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- tabufline</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;enew&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;buffer new&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;tab&gt;&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer goto next&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-tab&gt;&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).prev()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer goto prev&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;x&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.tabufline&quot;</span>).close_buffer()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;buffer close&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Comment</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="string">&quot;gcc&quot;</span>, &#123; desc = <span class="string">&quot;toggle comment&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="string">&quot;gc&quot;</span>, &#123; desc = <span class="string">&quot;toggle comment&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- nvimtree</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-n&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvimTreeToggle&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;nvimtree toggle window&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;e&quot;</span>, <span class="string">&quot;&lt;cmd&gt;NvimTreeFocus&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;nvimtree focus window&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- telescope</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fw&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope live_grep&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope live grep&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fb&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope buffers&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find buffers&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fh&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope help_tags&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope help page&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ma&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope marks&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find marks&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fo&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope oldfiles&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find oldfiles&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;fz&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope current_buffer_fuzzy_find&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find in current buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;cm&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope git_commits&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope git commits&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;gt&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope git_status&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope git status&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;pt&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope terms&lt;CR&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope pick hidden term&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;th&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;nvchad.themes&quot;</span>).<span class="built_in">open</span>()</span><br><span class="line"><span class="keyword">end</span>, &#123; desc = <span class="string">&quot;telescope nvchad themes&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;ff&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope find_files&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;telescope find files&quot;</span> &#125;)</span><br><span class="line">map(</span><br><span class="line">  <span class="string">&quot;n&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;leader&gt;fa&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;cmd&gt;Telescope find_files follow=true no_ignore=true hidden=true&lt;CR&gt;&quot;</span>,</span><br><span class="line">  &#123; desc = <span class="string">&quot;telescope find all files&quot;</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- terminal</span></span><br><span class="line">map(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;&lt;C-x&gt;&quot;</span>, <span class="string">&quot;&lt;C-\\&gt;&lt;C-N&gt;&quot;</span>, &#123; desc = <span class="string">&quot;terminal escape terminal mode&quot;</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>autocmd</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> autocmd = vim.api.nvim_create_autocmd</span><br><span class="line"></span><br><span class="line"><span class="comment">-- user event that loads after UIEnter + only if file buf is there</span></span><br><span class="line">autocmd(&#123; <span class="string">&quot;UIEnter&quot;</span>, <span class="string">&quot;BufReadPost&quot;</span>, <span class="string">&quot;BufNewFile&quot;</span> &#125;, &#123;</span><br><span class="line">  group = vim.api.nvim_create_augroup(<span class="string">&quot;NvFilePost&quot;</span>, &#123; clear = <span class="literal">true</span> &#125;),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="keyword">local</span> file = vim.api.nvim_buf_get_name(args.buf)</span><br><span class="line">    <span class="keyword">local</span> buftype = vim.api.nvim_get_option_value(<span class="string">&quot;buftype&quot;</span>, &#123; buf = args.buf &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> vim.g.ui_entered <span class="keyword">and</span> args.event == <span class="string">&quot;UIEnter&quot;</span> <span class="keyword">then</span></span><br><span class="line">      vim.g.ui_entered = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> file ~= <span class="string">&quot;&quot;</span> <span class="keyword">and</span> buftype ~= <span class="string">&quot;nofile&quot;</span> <span class="keyword">and</span> vim.g.ui_entered <span class="keyword">then</span></span><br><span class="line">      vim.api.nvim_exec_autocmds(<span class="string">&quot;User&quot;</span>, &#123; pattern = <span class="string">&quot;FilePost&quot;</span>, modeline = <span class="literal">false</span> &#125;)</span><br><span class="line">      vim.api.nvim_del_augroup_by_name <span class="string">&quot;NvFilePost&quot;</span></span><br><span class="line"></span><br><span class="line">      vim.schedule(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        vim.api.nvim_exec_autocmds(<span class="string">&quot;FileType&quot;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> vim.g.editorconfig <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;editorconfig&quot;</span>).<span class="built_in">config</span>(args.buf)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="LazyVim"><a href="#LazyVim" class="headerlink" title="LazyVim"></a>LazyVim</h2><p>neovim的插件编写<a href="https://miguelcrespo.co/posts/how-to-write-a-neovim-plugin-in-lua">How to write a neovim plugin in lua</a>与使用lazyvim不同但有相似点</p><ul><li><a href="https://dev.to/iamgoncaloalves/how-i-developed-my-first-neovim-plugin-a-step-by-step-guide-1lcb#:~:text=Make changes to your plugin code. Save the,changes by running %3AHelloWorld or using the keymapping.">How I Developed My First Neovim Plugin: A Step-by-Step Guide - DEV Community</a></li><li><a href="https://dev.to/vonheikemen/lazynvim-plugin-configuration-3opi">Lazy.nvim: plugin configuration - DEV Community</a></li><li><a href="https://www.reddit.com/r/neovim/comments/z0ihuf/are_there_any_good_starter_templates_for_writing/"> r/neovim —- Are there any good starter templates for writing Neovim plugins? : r/neovim</a></li><li><a href="https://github.com/LazyVim/LazyVim/discussions/1129">LazyVim local development · LazyVim/LazyVim · Discussion #1129</a></li><li><a href="https://github.com/LazyVim/LazyVim/discussions/2202">Loading local plugins · LazyVim/LazyVim · Discussion #2202</a></li><li><a href="https://miguelcrespo.co/posts/how-to-write-a-neovim-plugin-in-lua">How to write a neovim plugin in lua</a></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── plugin</span><br><span class="line">│  └── plugin-<span class="keyword">file</span>.<span class="keyword">lua</span></span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│  └── main-<span class="keyword">file</span>.<span class="keyword">lua</span></span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>plugin和 lua 文件夹是特例，其含义如下：</p><ul><li>plugin 文件夹 该文件夹中的所有文件将在 Neovim 启动时立即执行，如果想设置keymap或autocmd而不管用户是否需要该插件</li><li>lua 文件夹 在大多数情况下，lua 文件夹是您的插件代码所在的文件夹，只有在用户明确需要您的插件时才会执行这些代码，例如 require(‘scratch-buffer’)</li></ul><h4 id="插件代码该放哪"><a href="#插件代码该放哪" class="headerlink" title="插件代码该放哪"></a>插件代码该放哪</h4><p>对于普通neovim插件,可以放在lua文件夹下,通过neovim加载配置路径中的<code>init.lua</code>通过<code>require</code>加载</p><p>而在lazyvim中,添加spec.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(&#123;</span><br><span class="line">  spec = &#123;</span><br><span class="line">    <span class="comment">-- add lazyvim and import its plugins</span></span><br><span class="line">    &#123; <span class="string">&quot;lazyvim/lazyvim&quot;</span>, import = <span class="string">&quot;lazyvim.plugins&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;coderunner&quot;</span>, dir = <span class="string">&quot;~/appdata/local/nvim/lua/plugins/coderunner&quot;</span>, dev = <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">-- import/override with your plugins</span></span><br><span class="line">    &#123; import = <span class="string">&quot;plugins&quot;</span> &#125;,</span><br><span class="line">    &#123; import = <span class="string">&quot;lazyvim.plugins.extras.linting.eslint&quot;</span> &#125;,</span><br><span class="line">    &#123; import = <span class="string">&quot;lazyvim.plugins.extras.formatting.prettier&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- by default, only lazyvim plugins will be lazy-loaded. your custom plugins will load during startup.</span></span><br><span class="line">    <span class="comment">-- if you know what you&#x27;re doing, you can set this to `true` to have all your custom plugins lazy-loaded by default.</span></span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- it&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your neovim install.</span></span><br><span class="line">    version = <span class="literal">false</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123; colorscheme = &#123; <span class="string">&quot;tokyonight&quot;</span>, <span class="string">&quot;habamax&quot;</span> &#125; &#125;,</span><br><span class="line">  checker = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>, <span class="comment">-- check for plugin updates periodically</span></span><br><span class="line">    notify = <span class="literal">false</span>, <span class="comment">-- notify on update</span></span><br><span class="line">  &#125;, <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">  performance = &#123;</span><br><span class="line">    rtp = &#123;</span><br><span class="line">      <span class="comment">-- disable some rtp plugins</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwplugin&quot;,</span></span><br><span class="line">        <span class="string">&quot;tarplugin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tohtml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tutor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zipplugin&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新启动 Neovim 或运行 :Lazy sync 来加载插件.有了这种设置，您就可以轻松迭代您的插件： 1.  更改插件代码。  2.  保存文件。  3.  在 Neovim 中运行 :Lazy reload plugin-name 重新加载插件。  4.  运行 :HelloWorld 或使用关键映射测试更改。   此工作流程可实现快速开发和测试，而无需不断重启 Neovim 或手动获取文件。</p><p>可以直接使用的nvim配置,lazyvim会自动加载预定义的autocmd,keymaps和options.<a href="https://lazy.folke.io/spec">🔌 Plugin Spec | lazy.nvim</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~/.config/nvim</span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── autocmds.<span class="keyword">lua</span></span><br><span class="line">│   │   ├── keymaps.<span class="keyword">lua</span></span><br><span class="line">│   │   ├── lazy.<span class="keyword">lua</span></span><br><span class="line">│   │   └── <span class="keyword">options</span>.<span class="keyword">lua</span></span><br><span class="line">│   └── plugins</span><br><span class="line">│       ├── spec1.<span class="keyword">lua</span></span><br><span class="line">│       ├── **</span><br><span class="line">│       └── spec2.<span class="keyword">lua</span></span><br><span class="line">└── init.<span class="keyword">lua</span></span><br></pre></td></tr></table></figure><p>写本地插件时直接在plugins目录中即可. 添加插件时可用的选项</p><p>Defaults merging rules:</p><ul><li>cmd：命令列表将使用您的自定义命令进行扩展</li><li>event：事件列表将使用您的自定义事件进行扩展</li><li>FT：文件类型列表将扩展为自定义文件类型</li><li>keys：键盘映射列表将使用您的自定义键盘映射进行扩展</li><li>opts：自定义 opts 将与默认 opts 合并</li><li>dependencies：依赖项列表将使用您的自定义依赖项进行扩展</li><li><strong>任何其他属性都将覆盖默认值</strong></li></ul><p>对于 <code>ft</code> ， <code>event</code> ， <code>keys</code> ， <code>cmd</code> 和 <code>opts</code> 您还可以指定一个 <code>values</code> 函数，该函数可以更改默认值，或返回要使用的新值.除此之外,还有init,config函数. Lua 插件遵循一个常见的约定，它们有一个名为 <code>setup</code> 的函数暴露的 Lua 模块。所以当使用 <code>opts</code> 时，是在告诉 lazy.nvim 该插件遵循该约定。因此，lazy.nvim 会将那个 <code>opts</code> 属性传递给插件的 <code>setup</code> 函数。</p><p>使用lazyvim写插件的debug方式<a href="https://lazy.folke.io/usage">🚀 Usage | lazy.nvim</a></p><h3 id="小案例-插件重载器"><a href="#小案例-插件重载器" class="headerlink" title="小案例 插件重载器"></a>小案例 插件重载器</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- init.lua</span></span><br><span class="line"><span class="keyword">local</span> utils = <span class="built_in">require</span>(<span class="string">&quot;utils&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPlugins</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> plugins = <span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).plugins()</span><br><span class="line">utils.createwin(plugins)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.setup</span><span class="params">(opts)</span></span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;Reload&quot;</span>, showPlugins, &#123;</span><br><span class="line">desc = <span class="string">&quot;Reload plugins&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- utils.lua</span></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.createwin</span><span class="params">(items)</span></span></span><br><span class="line"><span class="keyword">local</span> width = <span class="number">40</span></span><br><span class="line"><span class="keyword">local</span> height = #items + <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> row = <span class="built_in">math</span>.<span class="built_in">floor</span>(vim.o.<span class="built_in">lines</span> / <span class="number">2</span>) - <span class="built_in">math</span>.<span class="built_in">floor</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> col = <span class="built_in">math</span>.<span class="built_in">floor</span>(vim.o.columns / <span class="number">2</span>) - <span class="built_in">math</span>.<span class="built_in">floor</span>(width / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> bufnr = vim.api.nvim_create_buf(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;bufhidden&quot;</span>, <span class="string">&quot;wipe&quot;</span>, &#123; buf = bufnr &#125;)</span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">ipairs</span>(items) <span class="keyword">do</span></span><br><span class="line">vim.api.nvim_buf_set_lines(bufnr, i - <span class="number">1</span>, i, <span class="literal">false</span>, &#123; item.name &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;modifiable&quot;</span>, <span class="literal">false</span>, &#123; buf = bufnr &#125;)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;readonly&quot;</span>, <span class="literal">true</span>, &#123; buf = bufnr &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> win_id = vim.api.nvim_open_win(bufnr, <span class="literal">true</span>, &#123;</span><br><span class="line">relative = <span class="string">&quot;editor&quot;</span>,</span><br><span class="line">width = width,</span><br><span class="line">height = height,</span><br><span class="line">row = row,</span><br><span class="line">col = col,</span><br><span class="line">style = <span class="string">&quot;minimal&quot;</span>,</span><br><span class="line">border = <span class="string">&quot;rounded&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">vim.api.nvim_set_option_value(<span class="string">&quot;winhl&quot;</span>, <span class="string">&quot;Normal:Normal,FloatBorder:FloatBorder&quot;</span>, &#123; win = win_id &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> current_line = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> ns_id = vim.api.nvim_create_namespace(<span class="string">&quot;highlight_current_line&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">highlight_and_move_cursor</span><span class="params">()</span></span></span><br><span class="line">vim.api.nvim_buf_clear_namespace(bufnr, ns_id, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> current_line &gt;= <span class="number">1</span> <span class="keyword">and</span> current_line &lt;= #items <span class="keyword">then</span></span><br><span class="line">vim.api.nvim_buf_add_highlight(bufnr, ns_id, <span class="string">&quot;Visual&quot;</span>, current_line - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">vim.api.nvim_win_set_cursor(win_id, &#123; current_line, <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">highlight_and_move_cursor()</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">handle_keys</span><span class="params">(key)</span></span></span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;k&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;&lt;Up&gt;&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> current_line &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">current_line = current_line - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> key == <span class="string">&quot;j&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;&lt;Down&gt;&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> current_line &lt; #items <span class="keyword">then</span></span><br><span class="line">current_line = current_line + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> key == <span class="string">&quot;CR&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> plugin_name = items[current_line].name</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;reload plugin:&quot;</span>, plugin_name)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy.core.loader&quot;</span>).reload(plugin_name)</span><br><span class="line"><span class="comment">-- 关闭窗口</span></span><br><span class="line">vim.api.nvim_win_close(win_id, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">highlight_and_move_cursor()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;CursorMoved&quot;</span> &#125;, &#123;</span><br><span class="line">buffer = bufnr,</span><br><span class="line">desc = <span class="string">&quot;highlight the line which cursor is on&quot;</span>,</span><br><span class="line">callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> cur_line = vim.api.nvim_win_get_cursor(win_id)[<span class="number">1</span>]</span><br><span class="line">vim.api.nvim_buf_add_highlight(bufnr, ns_id, <span class="string">&quot;Visual&quot;</span>, cur_line - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">current_line = cur_line</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 辅助函数用于设置按键映射</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">set_keymap</span><span class="params">(key, action)</span></span></span><br><span class="line">vim.keymap.set(<span class="string">&quot;n&quot;</span>, key, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">handle_keys(action)</span><br><span class="line"><span class="keyword">end</span>, &#123;</span><br><span class="line">buffer = bufnr,</span><br><span class="line">noremap = <span class="literal">true</span>,</span><br><span class="line">silent = <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 设置按键映射</span></span><br><span class="line">set_keymap(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;k&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;j&quot;</span>, <span class="string">&quot;j&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;Up&gt;&quot;</span>, <span class="string">&quot;Up&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;Down&gt;&quot;</span>, <span class="string">&quot;Down&quot;</span>)</span><br><span class="line">set_keymap(<span class="string">&quot;&lt;CR&gt;&quot;</span>, <span class="string">&quot;CR&quot;</span>)</span><br><span class="line"><span class="comment">-- 允许用户通过 q 键关闭窗口，仅限于当前缓冲区</span></span><br><span class="line">vim.keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;&lt;Cmd&gt;close&lt;CR&gt;&quot;</span>, &#123; buffer = bufnr, noremap = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用neovim和LazyVim配置写代码,感觉很不错. 得益于neovim简单的功能和强大的第三方生态,可以很简单的写出一个插件. 这里根据官方文档搭配lazyvim等资料写一个简单插件.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>协同感知算法(四):大模型、多模态以及新趋势</title>
    <link href="https://www.sekyoro.top/2025/01/10/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E5%9B%9B-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%A5%E5%8F%8A%E6%96%B0%E8%B6%8B%E5%8A%BF/"/>
    <id>https://www.sekyoro.top/2025/01/10/%E5%8D%8F%E5%90%8C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E5%9B%9B-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%A5%E5%8F%8A%E6%96%B0%E8%B6%8B%E5%8A%BF/</id>
    <published>2025-01-10T15:08:12.000Z</published>
    <updated>2025-03-08T12:59:28.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这半年要论AI哪些方向最火,那关键词必然包括多模态,AI Agent,RAG等等(事实上已经火了一轮开始冷饭热炒了),一些做之前基础大模型的公司基本开始转向做应用甚至其他方向了. 这里整理一些关于AI Agents的知识和相关基础框架,并结合多智能体协同感知看看有哪些能做的结合.<br><span id="more"></span></p><h2 id="视觉语言模型"><a href="#视觉语言模型" class="headerlink" title="视觉语言模型"></a>视觉语言模型</h2><p>引用lilianweng的博客,视觉语言模型可以粗略分为四类:<br>1.将图像转换为可以与标记嵌入联合训练的嵌入特征(将图像转为可以与语言编码的特征一起训练的特征)<br>2.学习作为冻结、预训练语言模型前缀的良好图像嵌入(训练图像特征作为冻结的预训练语言模型的输入前缀)<br>3.使用专门设计的交叉注意力机制将视觉信息融合到语言模型的层中(使用交叉注意力融合视觉信息到大模型中)<br>4.无需训练即可结合视觉和语言模型</p><h3 id="同时训练图像和文本"><a href="#同时训练图像和文本" class="headerlink" title="同时训练图像和文本"></a>同时训练图像和文本</h3><p>VisualBERT将文本输入和图像区域同时输入 BERT，使其能够<strong>通过自注意力机制发现图像和文本之间的内部对齐</strong>。<br>在训练时同时输入图像和文本,mask相关文本并加上图像的相关信息,任务是预测遮挡的信息同时提供两个标题区分哪个与图像相关.<br><img data-src="https://s2.loli.net/2025/01/11/rF7sJIdcoWnBZhv.png" alt="image-20250111165850291"><br>与 BERT 中的文本嵌入类似，VisualBERT 中的每个视觉嵌入也总结了三种类型的嵌入，即<strong>分词特征</strong>、<strong>分割嵌入</strong>和<strong>位置嵌入</strong>，具体来说：</p><ol><li><p>一种通过卷积神经网络计算出的图像边界区域的视觉特征向量</p></li><li><p>一个表示嵌入是否用于视觉而非文本的段嵌入</p></li><li><p>一种用于对齐边界区域顺序的位置嵌入</p></li></ol><p>SimVLM是一种简单的前缀语言模型，其中前缀序列的处理方式类似于 BERT 的双向注意力，但主要的文本输入序列只有因果注意力类似于 GPT。图像被编码为前缀标记，以便模型可以完全消耗视觉信息，然后以自回归方式生成相关文本。<br>SimVLM 将图像分割成更小的块，形成一个平铺的 1D 块序列。他们使用由 ResNet 的前 3 个块组成的卷积阶段来提取上下文化的块，这种设置被发现比简单的线性投影效果更好。<br>  这种方法的学习目标更像是通过视觉信息前缀,通过transformer结构进行自回归学习,这也是它与前者较大的差距.  因此通过图像编码器编码图像特征然后通过掩码语言建模(Masked Language Modeling)(类似完形填空)或自回归学习训练原本的大语言模型使其拥有视觉能力.</p><h3 id="学习图像嵌入"><a href="#学习图像嵌入" class="headerlink" title="学习图像嵌入"></a>学习图像嵌入</h3><p>如果不想在适应处理视觉信号时更改语言模型参数,那么可以学习一个与语言模型兼容的图像嵌入空间。<br>受前缀或提示调整的启发，Frozen和 ClipCap<strong>仅在训练期间更新视觉模块的参数</strong>，以生成可以与预训练的冻结语言模型一起工作的图像嵌入。两者都使用对齐的图像标题数据集进行训练，以根据图像和先前的文本标记生成下一个文本标记。通过冻结 LM 参数，保留了强大的语言能力。此外，尽管这种设置是在有限的图像标题数据上训练的，但它们在测试时也可以依赖语言模型的知识库。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/Frozen-arch.png" alt="img"></p><p>从框架图看来就是只是用了一个视觉编码器将得到的embedding与预训练固定参数的text encoder和大模型同时训练更新视觉编码器<br>ClipCap 依靠 CLIP 进行视觉编码，但它需要由光映射网络处理，以便将图像嵌入向量转换为与预训练 LM 相同的语义空间。该网络将 CLIP 嵌入向量映射到一系列嵌入向量中，每个向量与 GPT2 中的单词嵌入具有相同的维度。增加前缀大小有助于提高性能。CLIP 视觉编码器和 LM 在训练期间都会被冻结，并且只学习映射网络。<br>ClipCap学习的是一个映射网络,它同时利用了预训练的CLIP和大模型<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/ClipCap-arch.png" alt="img"></p><h3 id="交叉注意力混合视觉和文本信息"><a href="#交叉注意力混合视觉和文本信息" class="headerlink" title="交叉注意力混合视觉和文本信息"></a>交叉注意力混合视觉和文本信息</h3><p><strong>VisualGPT</strong>采用self-resurrecting的编码器-解码器注意力机制,用少量的域内图像文本数据快速适应预训练的LM<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/VisualGPT.png" alt="img" style="zoom:67%;" /><br>设I为视觉编码器的输入,H为LM解码器的隐藏状态. 引入激活单元通过两个互补门来控制预训练语言信息和视觉组件之间混合.</p><script type="math/tex; mode=display">\begin{array}{c}B^{\text {vs }} \otimes \operatorname{EncDecattn}(H, I)+B^{\text {in }} \otimes H \\\text { where } B^{\text {vs }}[i, j]=\sigma(H[i, j])[\sigma(H[i, j])>\tau] \\B^{\text {ban }}[i, j]=(1-\sigma(H[i, j])] \neq[1-\sigma(H[i, j])>\tau]\end{array}</script><p>每层decoder通过门控制单元混合不同的输入.<br><strong>VC-GPT</strong> 将预训练的视觉转换器(CLIP-ViT)作为视觉编码器和预训练的 LM 作为语言解码器相结合。CLIP-ViT 将一系列图像块作为输入和输出，并输出每个块的表示。为避免灾难性的遗忘，<strong>VC-GPT 不是将视觉信息直接注入 GPT2，而是在视觉编码器和语言解码器的输出之上引入了额外的交叉注意力层</strong>。然后， <em>一个自集成</em> 模块线性组合单模型语言解码器 logits h^G^和跨模型视觉语言融合模块 logitsh^fuse^ 自集成模块对于性能很重要<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/VC-GPT.png" alt="img"><br>MERLOT接受了 600 万个 YouTube 视频的训练，并转录了语音 （YT-Temporal-180M），以学习空间（帧级）和时间（视频级）目标，并在微调时在 VQA 和视觉推理任务上表现出强大的表现。每个视频被拆分为多个片段,每个片段从中间的图像帧和关联的单词。图像由学习的图像编码器编码，单词使用学习的嵌入进行编码。然后，两者在一个联合的vision-language transformer中一起编码。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/MERLOT.png" alt="img"></p><ol><li>遮罩语言建模(MLM)，因为在视频中有许多重复的关键字或填充词。</li><li>对比帧-标题匹配使用联合视觉-语言转换器中的纯语言部分。每个帧 I~t~和 caption w~t~ 的匹配表示形式被视为正面示例，而负面示例来自小批量中的所有其他帧-标题对。</li><li>时间重新排序学习时间推理:打乱随机i帧,并将段级位置嵌入替换为随机且唯一的位置嵌入。随机位置嵌入被学习,允许模型以正确排序的帧为条件取消这些 “’shuffled’” 帧。</li></ol><p>Flamingo （ Alayrac et al. 2022） 是一种视觉语言模型，它接受与图像/视频交错的文本并输出自由格式的文本。Flamingo 通过基于 transformer 的映射器连接预训练的 LM 和预训练的视觉编码器（即 CLIP 图像编码器）。为了更有效地整合视觉信号，Flamingo 采用基于 Perceiver 的架构，从大量视觉输入特征中生成数百个标记，然后使用与 LM 层交错的交叉注意力层将视觉信息融合到语言解码过程中。训练目标是自回归的 NLL 损失。Perceiver 重采样器从图像/视频输入的视觉编码器接收时空特征，以生成固定大小的视觉标记。冻结的 LM 配备了新初始化的交叉注意力层，这些层在预训练的 LM 层之间交错。因此LM 可以生成以上述视觉标记为条件的文本。</p><p>与 ClipCap 类似，两个预训练模型在训练期间都会被冻结，因此 Flamingo 仅经过训练才能将现有的强大语言和视觉模型和谐地连接在一起。ClipCap 和 Flamingo 的主要区别在于，前者将图像嵌入视为 LM 的简单前缀，而后者使用门控交叉注意力密集层来融合图像信息。此外，Flamingo 包含的训练数据比 ClipCap 多得多。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/Flamingo.png" alt="img"><br>为了轻松处理带有交错图像的文本，Flamingo 中的遮罩设计为文本标记仅交叉关注与最后一个前图像对应的视觉标记，从而大大减少了某个文本标记可以看到的视觉标记的数量。他们发现这比允许文本标记直接处理所有前面的图像效果更好。文本仍然可以处理所有以前的图像，因为文本编码器中存在因果自我注意依赖关系。此设计可以处理上下文中任意数量的图像。从互联网上抓取了 4300 万个网页，名为 MultiModal MassiveWeb （M3W) 数据集，其中包含带有交错图像的文本。此外，Flamingo 还在配对的图像/文本和视频/文本数据集上进行了训练，包括 ALIGN、LTIP 和 VTP。</p><p>CoCa捕捉到了对比学习和图像到标题生成的优点。它是一个联合训练的模型，在 CLIP 风格的表示上具有对比损失，在图像描述上具有生成损失，在各种多模态评估任务上实现了 SoTA 零样本转移。<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/CoCa-arch.png" alt="img" style="zoom: 67%;" /><br>CoCa 是从头开始预训练的,使用 Web 规模的替代文本数据 ALIGN 和注释图像，将所有标签视为 JTB-3B 中的文本<br><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/CoCa.png" alt="img"></p><h3 id="无训练方法"><a href="#无训练方法" class="headerlink" title="无训练方法"></a>无训练方法</h3><p>可以通过将预训练的语言和视觉模型拼接在一起来解决视觉语言任务,而无需训练任何其他参数。</p><p>MAGiC 根据名为 magic score 的基于 CLIP 的分数进行引导解码，以对下一个标记进行采样，而无需微调。鼓励生成的文本与给定图像相关，同时仍与先前生成的文本保持一致.与其他无监督方法相比，MAGiC 具有不错的性能，但与有监督方法仍然存在很大差距. MAGiC核心就是更改了采样方式,第t步采样的token会通过基于CLIP的分数计算与图像编码相似的值.</p><p><img data-src="https://s2.loli.net/2025/01/12/Knk9qHblQgwALuv.png" alt="image-20250112122938693"></p><p>​    对于基于知识的 VQA 任务，PICa首先将图像转换为标题或标签，然后使用少数镜头示例提示 GPT3 提供答案。图像标题或标记由某些现有模型（例如 VinVL）或 Azure 标记 API 提取。GPT3 被认为是一个非结构化的隐式知识库. </p><p>​    苏格拉底模型是一个框架,通过语言(提示)将不同模态的多个预训练模型组合成一个模型，而无需进一步训练。在这里，语言被认为是不同模型可以交换信息的中间表示。关键思想是使用多模型多模态提示，其中非语言模型的输出入到语言提示中，然后用于 LM 进行推理. SM 可以生成图像字幕，首先使用 VLM 对不同的地点类别、对象类别、图像类型和人数进行零拍摄预测;然后将 VLM 填充的语言提示输入到因果 LM 中以生成候选字幕。Socratic 方法在图像字幕方面与 ClipCap 的性能仍然存在差距，但考虑到它不涉及任何培训，因此相当不错。 简单来说就是将不同模态模型,比如vision-language model,language model,audio-language model结合在一起,通过一种相对固定的prompt template通信,SM 可以生成图像字幕，首先使用 VLM 对不同的地点类别、对象类别、图像类型和人数进行零拍摄预测;然后将 VLM 填充的语言提示输入到因果 LM 中以生成候选字幕</p><p><img data-src="https://lilianweng.github.io/posts/2022-06-09-vlm/SM-caption-example.png" alt="img"></p><h2 id="大模型驱动的Agents"><a href="#大模型驱动的Agents" class="headerlink" title="大模型驱动的Agents"></a>大模型驱动的Agents</h2><p>​    多个大模型之间协作增强输出并设计一些类似模仿一个系统中负责不同功能的组件组成Agent. 目前许多大模型公司在做应用时都是往这个方向发展.在 LLM 驱动的自主代理系统中，LLM 充当代理的大脑，并辅以几个关键组件：</p><p>​    <strong>规划</strong>:子目标和分解：智能体将大型任务分解为较小的、可管理的子目标，从而能够高效处理复杂任务。反思和完善：智能体可以对过去的行为进行自我批评和自我反省，从错误中吸取教训并为未来的步骤进行改进，从而提高最终结果的质量。(任务分解和完善行为)</p><p>​     <strong>记忆</strong>: 短期记忆：所有的上下文学习（参见提示工程）都是利用模型的短期记忆来学习的。长期记忆：这为代理提供了在较长时间内保留和调用（无限）信息的能力，通常是通过利用外部向量存储和快速检索。</p><p>   <strong>工具使用</strong>:智能体学习调用外部 API 以获取模型权重中缺少的额外信息（通常在预训练后很难更改），包括当前信息、代码执行能力、对专有信息源的访问等</p><p><img data-src="https://lilianweng.github.io/posts/2023-06-23-agent/agent-overview.png" alt="img"></p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><h4 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h4><p>Chain of Thoughts已成为提高模型在复杂任务上性能的标准提示技术。该模型被指示 “逐步思考”，以利用更多的测试时计算将困难的任务分解为更小、更简单的步骤。CoT 将大任务转化为多个可管理的任务，并阐明对模型思维过程的解释<br>Tree of Thoughts通过在每一步探索多种推理可能性来扩展 CoT。它首先<strong>将问题分解为多个思考步骤，每个步骤生成多个思考，从而创建一个树状结构。</strong>搜索过程可以是 BFS（广度优先搜索）或 DFS（深度优先搜索），每个状态都由分类器（通过提示）或多数投票进行评估。<br>任务分解可以通过以下方式完成：（1） 由 LLM 使用简单的提示，如 <code>&quot;Steps for XYZ.\n1.&quot;</code> ， <code>&quot;What are the subgoals for achieving XYZ?&quot;</code> ， （2） 通过使用特定于任务的指令;例如 <code>&quot;Write a story outline.&quot;</code> 用于写小说，或 （3）人工输入<br>另一种非常不同的方法 LLM+P （ Liu et al. 2023） 涉及依靠外部经典规划师进行长期规划。这种方法利用规划域定义语言 （PDDL） 作为中间接口来描述规划问题。在这个过程中， LLM （1） 将问题翻译成 “问题 PDDL”，然后 （2） 请求经典规划师基于现有的 “领域 PDDL” 生成 PDDL 计划，最后 （3） 将 PDDL 计划翻译回自然语言。从本质上讲，规划步骤外包给外部工具，假设特定领域的 PDDL 和合适的规划器可用，这在某些机器人设置中很常见，但在许多其他领域中并不常见</p><h4 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h4><p>自我反省允许自主智能体通过改进过去的行动决策和纠正以前的错误来迭代改进。它在不可避免地需要试错的实际任务中起着至关重要的作用。<br>    ReAct通过将动作空间扩展为特定于任务的离散动作和语言空间的组合，将推理和行动整合到 LLM 中。前者使 LLM 能够与环境交互（例如使用维基百科搜索 API），而后者则提示 LLM 以自然语言生成推理轨迹。<br>    Reflexion 是一个框架，用于为智能体提供动态记忆和自我反思能力，以提高推理技能。Reflexion具有标准的 RL 设置，其中奖励模型提供简单的二进制奖励，操作空间遵循ReAct中的设置，其中特定于任务的操作空间通过语言进行扩充，以支持复杂的推理步骤。在每个操作a~t~之后，智能体会计算启发式 h~t~,并且可以根据自我反思结果选择性地决定重置环境以开始新的试用。<br><img data-src="https://lilianweng.github.io/posts/2023-06-23-agent/reflexion.png" alt="img"><br>    启发式函数确定轨迹何时效率低下或包含幻觉，何时应停止。低效的规划是指花费太长时间而没有成功的轨迹。幻觉被定义为遇到一系列连续的相同动作，这些动作导致在环境中进行相同的观察。<br>    自我反思是通过向 LLM 展示两张照片的例子来创建的，每个例子都是一对（失败的轨迹，指导计划中未来变化的理想反思）。然后将反射添加到 agent 的工作内存中，最多三个，用作查询 LLM 的上下文。<br><strong>Chain of Hindsight</strong>鼓励模型通过明确呈现一系列过去的输出来改进自己的输出，每个输出都带有反馈注释.CoH 的理念是在上下文中呈现连续改进的产出的历史，并训练模型顺应趋势以产生更好的产出。算法蒸馏将相同的想法应用于强化学习任务中的跨集轨迹，其中算法被封装在一个长期受历史条件限制的策略中。考虑到代理与环境交互多次，并且每次代理都会变得更好，AD 会将此学习历史记录连接起来，并将其馈送到模型中。</p><h3 id="记忆模块"><a href="#记忆模块" class="headerlink" title="记忆模块"></a>记忆模块</h3><p>三种类型的记忆</p><ol><li>感官记忆：这是记忆的最早阶段，提供在原始刺激结束后保留感官信息（视觉、听觉等）印象的能力。感官记忆通常最多只持续几秒钟。子类别包括图标记忆（视觉）、回声记忆（听觉）和触觉记忆（触觉</li><li>短期记忆 （STM） 或工作记忆：它存储我们目前知道的和执行复杂认知任务（如学习和推理）所需的信息。短期记忆被认为具有大约 7 项的容量 （Miller 1956） 并持续 20-30 秒。</li><li>长期记忆 （LTM）：长期记忆可以存储信息非常长的时间，从几天到几十年不等，具有基本上无限的存储容量。LTM 有两种亚型：<br> 显性 / 陈述性记忆：这是对事实和事件的记忆，指的是那些可以被有意识地回忆起来的记忆，包括情景记忆（事件和经历）和语义记忆（事实和概念）<br> 内隐/程序记忆：这种类型的记忆是无意识的，涉及自动执行的技能和例程，例如骑自行车或在键盘上打字。<br> 感官记忆作为原始输入（包括文本、图像或其他模态）的学习嵌入表示;<br> 短期记忆作为上下文学习。它简短而有限，因为它受 Transformer 的有限上下文窗口长度的限制。<br> 长期内存作为代理在查询时可以处理的外部向量存储，可通过快速检索访问。<h4 id="最大内积搜索"><a href="#最大内积搜索" class="headerlink" title="最大内积搜索"></a>最大内积搜索</h4>​    外部存储器可以缓解有限注意力持续时间的限制。标准做法是将信息的嵌入表示保存到可以支持快速最大内积搜索 （MIPS） 的向量存储数据库中。为了优化检索速度，常见的选择是近似最近邻 （ANN） 算法，以返回大约 k 个前 k 个最近邻，以牺牲一点准确性损失来换取巨大的加速<br>​    LSH（Locality-Sensitive Hashing）：它引入了一个哈希函数，<strong>以便将相似的输入项以高概率映射到相同的存储桶</strong>，其中存储桶的数量远小于输入的数量<br>​    ANNOY （Approximate Nearest Neighbors Oh Yeah）：核心数据结构是随机投影树，这是一组二叉树，其中每个非叶节点代表一个将输入空间分成两半的超平面，每个叶子存储一个数据点。树是独立且随机构建的，因此在某种程度上，它模仿了哈希函数。ANNOY 搜索发生在所有树中，以迭代搜索最接近查询的一半，然后聚合结果。这个想法与 KD 树非常相关，但更具可扩展性。<br>​    HNSW（分层可导航小世界）：它的灵感来自小世界网络的思想，其中大多数节点可以在少量步骤内被任何其他节点到达;例如社交网络的“六度分离”功能。HNSW 构建了这些小世界图的分层，其中底层包含实际数据点。中间的图层创建快捷方式以加快搜索速度。在执行搜索时，HNSW 从顶层的随机节点开始，并导航到目标。当它无法更靠近时，它会向下移动到下一层，直到到达底层。上层的每次移动都可能覆盖数据空间中的很长一段距离，而下层的每一次移动都会提高搜索质量。<br><strong>FAISS</strong>（meta相似性搜索）：它的运行基于以下假设：在高维空间中，节点之间的距离遵循高斯分布，因此应该存在数据点的聚类。<strong>FAISS 通过将向量空间划分为多个聚类，然后在聚类内优化量化来应用向量量化。Search 首先查找具有粗略量化的候选集群，然后进一步查找具有更精细量化的每个集群。</strong></li></ol><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>工具的使用是人类的一个显著特征。我们创造、修改和利用外部物体来做超出我们身体和认知极限的事情。为 LLMs 配备外部工具可以显着扩展模型功能。<br>HuggingGPT 是一个以 ChatGPT 作为任务规划器的框架，根据模型描述选择 HuggingFace 平台中可用的模型，并根据执行结果总结响应. 系统调用包括任务规划,模型选择,任务执行,生成响应.<br>API-Bank 是评估工具增强 LLMs 性能的基准。它包含 53 个常用的 API 工具、一个完整的工具增强 LLM 工作流程，以及 264 个带注释的对话，涉及 568 个 API 调用。API 的选择非常多样化，包括搜索引擎、计算器、日历查询、智能家居控制、日程管理、健康数据管理、帐户身份验证工作流程等。因为 API 数量众多，所以 LLM 首先要有 API 搜索引擎，找到合适的 API 进行调用，然后用相应的文档进行调用。</p><h2 id="协同感知中的LLM"><a href="#协同感知中的LLM" class="headerlink" title="协同感知中的LLM"></a>协同感知中的LLM</h2><p>最近有一系列的工作使用LLM与协同感知、自动驾驶结合(也有使用VLM的,方法类似).这里简单介绍一些相关工作.</p><h3 id="V2V-LLM-Vehicle-to-Vehicle-Cooperative-Autonomous-Driving-with-Multi-Modal-Large-Language-Models"><a href="#V2V-LLM-Vehicle-to-Vehicle-Cooperative-Autonomous-Driving-with-Multi-Modal-Large-Language-Models" class="headerlink" title="V2V-LLM: Vehicle-to-Vehicle Cooperative Autonomous Driving with  Multi-Modal Large Language Models"></a>V2V-LLM: Vehicle-to-Vehicle Cooperative Autonomous Driving with  Multi-Modal Large Language Models</h3><p>当前的自动驾驶车辆主要依靠其单独的传感器来了解周围的场景并规划未来的轨迹，当传感器发生故障或被遮挡时可能是不可靠的。为了解决这个问题，通过车辆到车辆( Vehicle-to-Vehicle，V2V )通信的协作感知方法已经被提出，但<strong>它们往往侧重于检测和跟踪。这些方法如何有助于整体的协作规划性能仍未得到充分的研究</strong>。</p><p>受最近使用大语言模型( Large Language Models，LLMs )构建自动驾驶系统的进展的启发,提出了一种新的问题设置,将LLM集成到协作自动驾驶中，并提出了车对车问答( Vehicle-to- Vehicle Question-Answering，V2V-QA )数据集和基准测试集.</p><p>还提出了基线方法Vehicle-to-Vehicle Large Language Model ( V2V-LLM )，它使用一个LLM来融合来自多个连接的自动驾驶车辆( CAV )的感知信息，并回答与驾驶相关的问题：grounding,notable objected identification, and planning.</p><p>实验结果表明,提出的V2VLLM可以作为一个有前途的统一模型架构来执行协作自动驾驶中的各种任务，并且优于使用不同融合方法的其他基线方法。工作也开创了一个新的研究方向，可以提高未来自动驾驶系统的安全性。</p><p>无人驾驶车辆在日常运行中的感知和规划系统严格依赖于其本地的LiDAR传感器和相机来探测附近的显著目标并进行规划.<strong>当传感器被附近的大型物体遮挡时，这种方法可能会遇到安全问题</strong>。在这种情况下，自动驾驶车辆无法准确地检测到所有附近的显著目标，使得后续的轨迹规划结果不可靠。</p><p><img data-src="https://s2.loli.net/2025/03/01/b3Rwruo2Nqjl9Qc.png" alt="image-20250301190916782"></p><p>为了解决这个安全问题，最近的研究提出了通过车车通信( V2V )通信的协作感知算法。在协同驾驶场景中，多个邻近行驶的智能网联汽车( Connected Autonomous Vehicles，CAVs )通过V2V通信共享彼此的感知信息。然后将接收到的来自多个CAV的感知数据进行融合，以产生更好的整体检测结果。</p><p>所有CAV与LLM共享各自的感知信息。任何CAV都可以以自然语言的形式向LLM提问，以获取对驾驶安全有用的信息。</p><p>为了研究这个问题，首先创建了车辆到车辆问答( V2V-QA )数据集，该数据集基于V2V4Real的自动驾驶协作感知数据集。</p><p>车-车大语言模型( V2V-LLM )用于协同自动驾驶.每个CAV提取自己的感知特征，并与V2V-LLM共享。V2V-LLM融合场景级特征图和对象级特征向量，然后进行视觉和语言理解，为V2V-QA中输入的驾驶相关问题提供答案。</p><p>还将V2V - LLM与其他基线方法对应的不同特征融合方法：不融合、早期融合和中间融合进行了比较。结果表明，V2V - LLM在较重要的目标识别和规划任务中取得了最好的性能，在grounding任务中取得了次优的性能，</p><p><img data-src="https://s2.loli.net/2025/03/01/JaKvA2B4yOdxcSP.png" alt="image-20250301204106243"></p><p>对于V2V4Real数据集的每一帧，创建了5种不同类型的问答对，包括3种类型的背景问题，1种类型的显著对象识别问题和1种类型的规划问题。这些QAs是针对协同驾驶场景设计的。为了生成这些问答对的实例，使用V2V4Real 的ground-truth边界框注释、每个CAV的ground - truth轨迹和个体检测结果作为源信息。然后根据前述实体和文本模板之间的几何关系使用不同的手动设计的规则来生成的问答对</p><p>作者设计了几种不同类型的问答对作为数据集,这个数据集也是多模态数据集.</p><p><strong>Q1</strong> Grounding at a reference location</p><p>在这种类型的问题中，要求LLM来识别是否存在一个对象占据了特定的查询2D位置。如果是，则期望LLM提供物体的中心位置。否则，LLM应该表示在参考位置处没有任何信息。为了生成这类问答对的实例，我们使用背景-真值框的中心位置和每个CAV的单个检测结果框作为问题中的查询位置。这样，我们可以更专注于评估各个模型对潜在的假阳性和假阴性检测结果的协同接地能力。</p><p><strong>Q2</strong> Grounding behind a reference object at a location</p><p>当一个CAV的视场被一个邻近的大物体遮挡时，该CAV可能希望根据所有CAV的融合感知信息，请求中心化的LLM来判断遮挡大物体后面是否存在物体。如果是这样的话，LLM预计将返回对象的位置，询问CAV可能需要更多的防御性驾驶或调整其规划。否则，LLM应该表明参照对象背后没有任何东西。为了生成这类问答对的实例，使用每个检测结果框的中心位置作为这些问题中的查询位置。根据询问的CAV与参考物体的相对位姿画出一个扇形区域，并在该区域中选择距离最近的真实物体作为答案。</p><p><strong>Q3</strong> Grounding behind a reference object in a direction</p><p>进一步在语言和空间理解能力上对LLM提出了挑战，将Q2的参考2D位置替换为参考方向关键字。为了生成这类QA对的实例，首先在一个CAV的6个方向中各得到一个最接近的检测结果框作为参考对象。然后在Q2中遵循相同的数据生成方法，在相应的扇形区域中得到最接近的ground-truth box作为答案。</p><p><strong>Q4</strong> Notable object identification</p><p>前述的真值任务可以看作自动驾驶管道中的中间任务。自动驾驶车辆更关键的能力包括识别规划的未来轨迹附近的显著目标和调整未来规划以避免潜在的碰撞。在显著性物体识别问题中，从地面-真值轨迹中提取了6个未来3秒的路标点作为问题中的参考未来路标点。然后，在参考未来轨迹的10米范围内最多得到3个最近的地面真实物体作为答案。</p><p><strong>Q5</strong> 规划</p><p>与上述QA类型相比，规划是自动驾驶系统最重要的输出，因为自动驾驶汽车的最终目标是安全地通过复杂的环境，避免未来的任何潜在碰撞。为了生成规划QAs，我们从每个CAV的真实未来轨迹中提取6个均匀分布在未来3秒内的未来航路点作为答案。由于一些原因，V2V - QA的规划任务也比其他基于NuScenes的LLM驱动的相关工作更具有挑战性。首先，我们在协同驾驶场景中支持多辆CAV。LLM模型需要提供不同的答案，这取决于哪个CAV要求其建议的未来轨迹，而先前的工作只需要生成单个自动驾驶车辆的规划结果。其次，V2V-QA是基于V2V4Real的，它包括城市和高速公路两种驾驶场景。在这两种不同的环境中，车辆的运动模式有很大的不同。相反，基于Nu Scenes的LLM驾驶研究只需要考虑城市驾驶场景。</p><p><img data-src="https://s2.loli.net/2025/03/01/6Rit5JYmheqW82P.png" alt="image-20250301212424018"></p><h3 id="AGENTSCODRIVER-Large-Language-Model-Empowered-Collaborative-Driving-with-Lifelong-Learning"><a href="#AGENTSCODRIVER-Large-Language-Model-Empowered-Collaborative-Driving-with-Lifelong-Learning" class="headerlink" title="AGENTSCODRIVER: Large Language Model  Empowered Collaborative Driving with Lifelong  Learning"></a>AGENTSCODRIVER: Large Language Model  Empowered Collaborative Driving with Lifelong  Learning</h3><p>智能网联汽车和无人驾驶近来发展迅速。然而，目前的自动驾驶系统主要基于数据驱动的方法，<strong>在可解释性、泛化性和持续学习能力方面表现出明显的不足。此外，单车自动驾驶系统缺乏与其他车辆协作和协商的能力，这对驾驶安全和效率至关重要</strong>。为了有效地解决这些问题，利用大型语言模型( LLMs )开发了一个新的框架，称为AGENTSCODRIVER，以使多车辆能够进行协同驾驶。</p><p>AGENTSCODRIVER由5个模块组成：<strong>观察模块、推理引擎、认知记忆模块、强化反射模块和通信模块</strong>。它可以通过与驾驶环境的不断交互，随时间推移积累知识、教训和经验，从而使实现终身学习成为可能。此外，通过利用通信模块，不同智能体可以交换信息，实现复杂驾驶环境下的协商与协作。进行了大量的实验，并显示了AGENTSCODRIVER相对于现有方法的优越性。</p><p><img data-src="https://s2.loli.net/2025/03/01/U5HNZpuxPMXJIzd.png" alt="image-20250301212736505"></p><p>AGENTSCODRIVER的体系结构由5个模块组成：观测模块、推理引擎、存储模块、增强反射模块和通信模块。推理引擎、通信模块和增强反射模块利用LLMs生成消息和最终决策</p><p><strong>Observation Module</strong></p><p>为了使智能体能够进行协作，CAV感知其周围环境并提取必要的信息用于下游的高阶任务推理是很重要的，因此为智能体开发了一个观测模块来编码其周围的场景，并提取其有用的高层信息，如车道数和周围车辆的位置和速度。然后将这些观察结果输入到智能体的推理引擎中进行分析并做出决策。它们也被用来从记忆模块中回忆相关的记忆</p><p><strong>Reasoning Engine</strong></p><p>推理是人类最基本、最重要的能力之一，对于人类做出日常的、复杂的决策具有重要的意义。传统的数据驱动方法直接利用感知信息(例如,目标检测结果和语义分割结果)进行最终的驾驶决策(例如,左转或右转,加速和减速)，缺乏可解释性，无法处理复杂场景和长尾情况。受人类推理能力的启发，我们提出了一个CAV智能体的推理引擎，它由三个步骤组成：1 )提示生成，2 )推理过程，3 )运动规划。</p><p><strong>Memory Module</strong></p><p>记忆对于一个人来说是非常重要的。当一个人驾驶汽车时，他或她会使用常识，例如遵守交通规则和回忆过去的经验来做出决定。为了将这种能力灌输给智能体，我们提出了智能体的记忆模块，该模块由三部分组成：常识记忆、经验记忆和结构化文本存储的反思记忆。常识性记忆包含了驾驶的常识性知识，如交通规则等。经验记忆包含过去的驾驶场景和相应的决策。反射记忆包含反射模块的反馈。智能体可以从存储模块中检索相关的内存，使其可用于决策。</p><p><strong>Reinforcement Reflection</strong></p><p>一个人要想成为某一领域的专家，就必须从过去的经历中学习，这意味着他必须有能力反思自己过去的错误，并分析其背后的原因。对于智能体来说，拥有这样的反思能力对于保持正确的操作和安全驾驶也是至关重要的。基于这些观察，提出了强化反射，它有两个模块：一个评估器和一个反射器。评价者(记为E )像评判者一样对agent的输出进行打分，反射者(记为R )可以对agent的行为进行反思，并生成分析结果来改进agent的行为。</p><p><img data-src="https://s2.loli.net/2025/03/01/K8GL6CWQgoEzJXl.png" alt="image-20250301214528445"></p><p><strong>Communication Module</strong></p><p>协作Agent之间的有效通信是至关重要的。通过相互之间的通信，将扩大智能体的观测范围。分别考虑两个智能体的观测值o1和o2，如果两个智能体相互交换观测信息，则两个智能体的观测值将扩展到o1∪o2。此外，沟通对于代理人之间相互协商并做出更好的决策也是至关重要的。例如，考虑一个智能体正在驾驶一辆汽车，并且想要超越前车。如果智能体与前车进行通信，则前车的智能体学习到后方车辆的意图，进而可以做出更好的决策，避免潜在的碰撞。</p><h3 id="Towards-Interactive-and-Learnable-Cooperative-Driving-Automation-a-Large-Language-Model-Driven-Decision-Making-Framework"><a href="#Towards-Interactive-and-Learnable-Cooperative-Driving-Automation-a-Large-Language-Model-Driven-Decision-Making-Framework" class="headerlink" title="Towards Interactive and Learnable Cooperative Driving Automation: a Large Language Model-Driven Decision-Making Framework"></a>Towards Interactive and Learnable Cooperative Driving Automation: a Large Language Model-Driven Decision-Making Framework</h3><p>目前，智能网联汽车( Connected Autonomous Vehicles，CAVs )已经开始在世界各地进行开放道路测试，但其在复杂场景下的安全和效率表现仍不尽如人意。协同驾驶利用CAV的连通能力实现大于其部分之和的协同作用，使其成为提高复杂场景下CAV性能的一种有前途的方法。然而，缺乏交互和持续学习能力限制了当前的协同驾驶到单场景应用和特定的协同驾驶自动化( Cooperative Driving Automation，CDA )。</p><p>为了应对这些挑战，本文提出了一种可交互和学习的LLM驱动的协同驾驶框架CoDrivingLLM，以实现全场景和全CDA。</p><p><img data-src="https://s2.loli.net/2025/03/01/1IqhDjUavQlOLou.png" alt="image-20250301215707384"></p><p>首先，由于大语言模型( Large Language Models，LLMs )不擅长处理数学计算，<strong>引入环境模块，基于语义决策更新车辆位置，从而避免直接LLM控制车辆位置可能带来的误差</strong>。其次，基于SAE J3216标准定义的CDA的四个层次，提出了基于思维链( Chain-of- Thought，COT )的推理模块，包括<strong>状态感知、意图共享、协商和决策</strong>，增强了LLMs在多步推理任务中的稳定性。</p><p>然后，在推理过程中，通过冲突协调者来管理集中的冲突解决。最后，通过引入记忆模块和使用提取增强生成，赋予CAVs从过去经验中学习的能力。</p><p><img data-src="https://s2.loli.net/2025/03/01/GZoEUBPHJ4lnSMR.png" alt="image-20250301215538196"></p><p><img data-src="https://s2.loli.net/2025/03/01/7N1apvPSXFcDfOo.png" alt="image-20250301221105318"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://lilianweng.github.io/posts/2023-06-23-agent/">LLM Powered Autonomous Agents | Lil’Log</a></li><li><a href="https://lilianweng.github.io/posts/2022-06-09-vlm/">Generalized Visual Language Models | Lil’Log</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这半年要论AI哪些方向最火,那关键词必然包括多模态,AI Agent,RAG等等(事实上已经火了一轮开始冷饭热炒了),一些做之前基础大模型的公司基本开始转向做应用甚至其他方向了. 这里整理一些关于AI Agents的知识和相关基础框架,并结合多智能体协同感知看看有哪些能做的结合.&lt;br&gt;</summary>
    
    
    
    
    <category term="collaborative perception" scheme="https://www.sekyoro.top/tags/collaborative-perception/"/>
    
  </entry>
  
  <entry>
    <title>学习桌面开发先进经验,从WPF看起</title>
    <link href="https://www.sekyoro.top/2025/01/10/%E5%AD%A6%E4%B9%A0%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%88%E8%BF%9B%E7%BB%8F%E9%AA%8C%EF%BC%8C%E4%BB%8EWPF%E7%9C%8B%E8%B5%B7/"/>
    <id>https://www.sekyoro.top/2025/01/10/%E5%AD%A6%E4%B9%A0%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%88%E8%BF%9B%E7%BB%8F%E9%AA%8C%EF%BC%8C%E4%BB%8EWPF%E7%9C%8B%E8%B5%B7/</id>
    <published>2025-01-10T11:48:31.000Z</published>
    <updated>2025-02-07T14:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在桌面开发上,我已经尝试过许多框架和组合,比如Qt/PyQt,Electron,Flutter,Winform. 如今跨平台风气正盛,包括MAUI,Flutter以及Kotlin MultiPlatform(KMP)等等都风头正盛. 但我的理解是作为个人开发,很多时候并不需要写跨平台的桌面应用,不如写原生的.</p><p> 目前我的理解是:</p><ol><li>需要仔细思考产品跨平台的必要性,跨平台并不是free launch. </li><li>C++的桌面程序框架也有很多,但许多人因为语言问题放弃了,着实可惜.由于c++的高性能和gl图形库诞生许多简单的GUI,比如<a href="https://github.com/TimoSalomaki/awesome-dear-imgui">awesome-dear-imgui</a>和<a href="https://www.raylib.com/">raylib</a></li><li>Qt框架不只是GUI,拿他跟其他UI库比较不公平.它提供了包括网络库在内的功能,而这本身就是C++相比其他现代语言在标准库和生态的差距. 此外Qt还有结合JS的QML,QWebEngine一堆技术.</li><li>使用Web技术开发桌面应用的开发体验仍然有待提升,目前React Native发展正盛,也是得益于前端的蓬勃生态.</li><li>c++、Rust编写程序有相对更高的性能,可以写成库供其他语言的UI应用调用.  </li><li>微软目前还是在基于XAML的桌面应用开发上发力,MAUI和WinUI3是微软主推的,在win11以及将来都是windows桌面开发重点,Avalonia也很不错</li><li><a href="https://www.lazarus-ide.org/">Lazarus</a>可以用于C++桌面应用的快速开发,此外还有C++ builder社区版<a href="https://blog.ismisv.com/2019/05/try-cpp-builder-ce/">试用C++ Builder社区版 </a></li><li>Flutter,KMP(包括jetpack compose)以及SwiftUI的写法类似(移动端应用写法),不同与xaml也不是同于new对象. 它们都是从移动端技术向跨平台应用发展折射到桌面开发的,一些技术栈和思想和做Qt、Winform的人可能不太相同(Web技术也是).</li></ol><p>这里我从WPF入手学一点基础,由此可以向WinUI3,Uno,MAUI以及Avalonia桌面应用开发发展(后三者是跨平台框架).</p><span id="more"></span><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>对于桌面应用框架,我有几点个人的偏好和思考.</p><ol><li>虽然说对于有经验的程序员并不会因为编程语言问题而不去学习某个框架,毕竟桌面应用是一个domain的知识,这独立于保存语言.但实际这依然会对应用的生态影响,比如Dart语言使用人数相对较少,势必会对第三方库的生态造成影响,使得许多用户不敢深度使用,大企业就更别说了. 相比来说,React Native和Electron就完全可以借用web技术和生态,用户增长趋势稳定</li><li>UI的写法虽然各个框架不同,但完全都能理解并且不会对编写程序有过多影响。目前UI的写法有类似<strong>QtWidgets和Winforms直接new对象</strong>,相对更原始,但控制性还挺高. 还有Flutter,Jetpack Compose,<a href="https://www.jetbrains.com/kotlin-multiplatform/">Kotlin Multiplatform and Compose Multiplatform</a>这种是通过代码但是是<strong>嵌套声明式</strong>的写法,还有微软超爱的<strong>XAML写法和Qt Qml声明式</strong>写法,此外有web开发的大手,通过嵌入浏览器内核的<strong>html,css写法</strong>. 这些写法各有优劣,理性看待便是.</li><li>在渲染性能上,除了electron之外,其他框架大多数时候都没有什么太大的性能问题.而且electron只是使用web技术做桌面应用的一个例子罢了,此外还有<a href="https://tauri.app/">Tauri 2.0 | Tauri</a>,<a href="https://github.com/chromiumembedded/cef">chromiumembedded/cef: Chromium Embedded Framework (CEF). </a>,<a href="https://sciter.com/">sciter – Multiplatform HTML/CSS/JavaScript UI Engine for Desktop and Mobile Application</a>,<a href="https://pywebview.flowrl.com/">pywebview</a>等等此外在跨平台图形绘制上,有像Flutter通过统一的绘制引擎保证一致性的,有在不同操作系统上使用不同绘制库实现的.</li><li>跨平台框架是个伪问题,或者说这个问题不是从解决实际问题出发的。许多时候都要认真思考一下跨平台应用的开发成本</li><li>鉴于许多桌面应用其实基本主流用户都在windows上,而windows原生应用,比如微软的技术就有非常多桌面框架(Winforms,WPF,UWP,WinUI),但许多开发者都担心微软又会立马抛弃,目前MAUI,Blazor,WinUI3这些技术是微软主推的,此外社区也有<a href="https://platform.uno/">Uno</a>和<a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/introduction-to-xaml">Avalonia </a>跨平台技术. 这也导致微软没有构建起良好的社区氛围,大公司的<a href="https://tech.creaders.net/2012/07/04/1166968.html">官僚气息</a>、决策的朝令夕改使得开发者并不好受。希望目前微软能在技术上稳定下来<a href="https://dotnet.microsoft.com/en-us/learn">Learning center | .NET</a>,构建好技术文档和社区资源吸引开发者.</li></ol><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ol><li><a href="https://github.com/sudhakar3697/awesome-electron-alternatives">sudhakar3697/awesome-electron-alternatives: A curated list of awesome Electron alternatives.</a></li><li><a href="https://github.com/robloo/PublicDocs/blob/master/XAMLFrameworkComparison.md">PublicDocs/XAMLFrameworkComparison.md at master · robloo/PublicDocs</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在桌面开发上,我已经尝试过许多框架和组合,比如Qt/PyQt,Electron,Flutter,Winform. 如今跨平台风气正盛,包括MAUI,Flutter以及Kotlin MultiPlatform(KMP)等等都风头正盛. 但我的理解是作为个人开发,很多时候并不需要写跨平台的桌面应用,不如写原生的.&lt;/p&gt;
&lt;p&gt; 目前我的理解是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要仔细思考产品跨平台的必要性,跨平台并不是free launch. &lt;/li&gt;
&lt;li&gt;C++的桌面程序框架也有很多,但许多人因为语言问题放弃了,着实可惜.由于c++的高性能和gl图形库诞生许多简单的GUI,比如&lt;a href=&quot;https://github.com/TimoSalomaki/awesome-dear-imgui&quot;&gt;awesome-dear-imgui&lt;/a&gt;和&lt;a href=&quot;https://www.raylib.com/&quot;&gt;raylib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Qt框架不只是GUI,拿他跟其他UI库比较不公平.它提供了包括网络库在内的功能,而这本身就是C++相比其他现代语言在标准库和生态的差距. 此外Qt还有结合JS的QML,QWebEngine一堆技术.&lt;/li&gt;
&lt;li&gt;使用Web技术开发桌面应用的开发体验仍然有待提升,目前React Native发展正盛,也是得益于前端的蓬勃生态.&lt;/li&gt;
&lt;li&gt;c++、Rust编写程序有相对更高的性能,可以写成库供其他语言的UI应用调用.  &lt;/li&gt;
&lt;li&gt;微软目前还是在基于XAML的桌面应用开发上发力,MAUI和WinUI3是微软主推的,在win11以及将来都是windows桌面开发重点,Avalonia也很不错&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt;可以用于C++桌面应用的快速开发,此外还有C++ builder社区版&lt;a href=&quot;https://blog.ismisv.com/2019/05/try-cpp-builder-ce/&quot;&gt;试用C++ Builder社区版 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flutter,KMP(包括jetpack compose)以及SwiftUI的写法类似(移动端应用写法),不同与xaml也不是同于new对象. 它们都是从移动端技术向跨平台应用发展折射到桌面开发的,一些技术栈和思想和做Qt、Winform的人可能不太相同(Web技术也是).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我从WPF入手学一点基础,由此可以向WinUI3,Uno,MAUI以及Avalonia桌面应用开发发展(后三者是跨平台框架).&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>前端运行时、打包与构建简单介绍</title>
    <link href="https://www.sekyoro.top/2025/01/09/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.sekyoro.top/2025/01/09/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-09T07:49:05.000Z</published>
    <updated>2025-01-09T14:57:52.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对比前两年,今年前端的工具进展相比可能确实慢了一些. 但还是有许多新的工具以及一些常用工具的新版本. 这里简单介绍一些在开发中关于js一些工具使用.</p><span id="more"></span><h2 id="JS三大运行时"><a href="#JS三大运行时" class="headerlink" title="JS三大运行时"></a>JS三大运行时</h2><p>js可以操作浏览器DOM以及浏览器提供的Web API等,这些都是在强大的浏览器下的功能. 除此之外还有最常用的node和较新的bun,Deno.</p><p>Deno和Bun的优点在于速度和对一些新特性,比如对typescript的支持更快.</p><p>此外Bun还致力于打造整个开发生态而不只是一个运行时。</p><h3 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h3><p>最近deno迎来2.0</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greet(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno main.ts</span><br></pre></td></tr></table></figure><h3 id="Bun"><a href="#Bun" class="headerlink" title="Bun"></a>Bun</h3><p>最近bun迎来1.1. 它提供一整套js和ts的开发工具,使用Bun作为运行时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bun run index.tsx </span><br></pre></td></tr></table></figure><h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>npm,yarn以及pnpm都是常用的包管理器,除此之外,还有bun install以及包管理器的管理器corepack. bun install是bun提供的包管理器,而Corepack是node官方做的包括npm,yarn,pnpm的管理器,目前新版的node是自带corepack并且应该是未来的新使用方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corepack <span class="built_in">enable</span></span><br><span class="line">corepack use yarn@latest</span><br></pre></td></tr></table></figure><p>同时会在<code>package.json</code>中写入对应<code>`packageManager</code>字段</p><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><p>打包工具(Bundler)主要目的是<code>compiles small pieces of code into something larger and more complex</code>,包括js,css以及图像等静态文件.</p><blockquote><p>打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web 应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle</p></blockquote><h3 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h3><p><img data-src="https://s2.loli.net/2025/01/09/Rf7M9ecZYbOSyTC.png" alt="image-20250109201151034"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-exact --save-dev esbuild</span><br><span class="line">.\node_modules\.bin\esbuild --version</span><br><span class="line">.\node_modules\.bin\esbuild app.jsx --bundle --outfile=out.js <span class="comment"># 命令行</span></span><br></pre></td></tr></table></figure><p>esbuild优势是速度快,本身支持js,css,ts,jsx</p><p>通过配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;esbuild app.jsx --bundle --outfile=out.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为浏览器js打包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16</span><br></pre></td></tr></table></figure><p>默认情况下，打包器为浏览器输出代码，因此不需要额外的配置即可开始。对于开发构建，使用——sourcemap来启用源映射，而对于生产构建，使用——minify来启用最小化。</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev parcel</span><br></pre></td></tr></table></figure><p>类似esbuild,但功能更多,比如同时支持commonjs和ES模块的输出.</p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p>rollup是将小的代码片段编译成更大、更复杂的代码，例如库或应用程序。它使用 JavaScript 的 ES6 版本中包含的新标准化代码模块格式。</p><p><strong>它适合ES模块编写的js打包</strong></p><p>Vite目前使用的打包工具,但马上将被换为RollDown. rollup突出一个使用简洁方便</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup index.js -o bundle.js -f cjs</span><br></pre></td></tr></table></figure><p>此外也可以配置文件<code>rollup.config.mjs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// rollup.config.mjs</span><br><span class="line">// ---cut-start---</span><br><span class="line">/** @type &#123;import(&#x27;rollup&#x27;).RollupOptions&#125; */</span><br><span class="line">// ---cut-end---</span><br><span class="line">export default &#123;</span><br><span class="line">input: &#x27;src/main.js&#x27;,</span><br><span class="line">output: &#123;</span><br><span class="line">file: &#x27;bundle.js&#x27;,</span><br><span class="line">format: &#x27;cjs&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c</span><br></pre></td></tr></table></figure><h3 id="RollDown"><a href="#RollDown" class="headerlink" title="RollDown"></a>RollDown</h3><p><a href="https://rolldown.rs/guide/">Introduction | Rolldown</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -D rolldown</span><br><span class="line">.<span class="regexp">/node_modules/</span>.bin<span class="regexp">/rolldown src/m</span>ain.js --<span class="keyword">file</span> bundle.js</span><br></pre></td></tr></table></figure><p>看起来跟esbuild,rollup没有很大差异.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-rolldown-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rolldown src/main.js --file bundle.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rolldown&quot;</span>: <span class="string">&quot;^1.0.0-beta.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-rolldown-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rolldown -c&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;rolldown&quot;</span>: <span class="string">&quot;^1.0.0-beta.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rspack"><a href="#Rspack" class="headerlink" title="Rspack"></a>Rspack</h3><p>更新的工具,包含RsBuild,Rspress等生态.</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>相对来说构建工具的包含概念更大,让更类似于一个项目启动器,可以负责整个项目开发各个阶段的整合,一些具体的处理可能需要使用一些打包、混淆压缩以及热更新.</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>webpack有自带的许多loader<a href="https://www.webpackjs.com/concepts/loaders/">loader</a>以及插件<a href="https://www.webpackjs.com/concepts/plugins/">plugin </a>,功能强大,但配置相对复杂.目前使用Vite更多.</p><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用loader,loader 用于对模块的源代码进行转换。loader 可以使你在 <code>import</code> 或 “load(加载)” 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许直接在 JavaScript 模块中 <code>import</code> CSS 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader ts-loade</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: <span class="string">&#x27;css-loader&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, use: <span class="string">&#x27;ts-loader&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>Vite开箱即用,支持许多预设</p><p>插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm add -D @vitejs/plugin-legacy</span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-legacy&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    legacy(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&#x27;defaults&#x27;</span>, <span class="string">&#x27;not IE 11&#x27;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Rsbuild"><a href="#Rsbuild" class="headerlink" title="Rsbuild"></a>Rsbuild</h3><p><img data-src="https://assets.rspack.dev/rsbuild/assets/rsbuild-1-0-build-tools.png" alt="img"></p><p>可以将 Rsbuild 理解为一个现代化的 Create React App 或 Vue CLI，它与这些工具的主要区别在于：</p><ul><li>底层的打包工具由 Webpack 替换为 Rspack，提供 5 ~ 10 倍的构建性能。</li><li>与前端 UI 框架解耦，并通过 <a href="https://rsbuild.dev/zh/plugins/list/index">插件</a> 来支持所有 UI 框架，包括 React、Vue、Svelte、Solid 等。</li><li>提供更好的扩展性，你可以通过 <a href="https://rsbuild.dev/zh/config/index">配置</a>、 <a href="https://rsbuild.dev/zh/plugins/dev/index">插件 API</a> 和 <a href="https://rsbuild.dev/zh/api/start/index">JavaScript API</a> 来灵活地扩展 Rsbuild。</li></ul><h3 id="Farm"><a href="#Farm" class="headerlink" title="Farm"></a>Farm</h3><p>引用官方的话,Farm类似Webpack和Vite但更快. farm <code>resolve, load, transform</code> 所有 <code>asset(js/jsx/ts/tsx、css/sass/less、html、静态资源、json 等)</code>，并将它们打包成一系列<code>可部署文件</code>。 Farm 是一个速度极快的构建工具，可帮助您构建更快的 <code>web/nodejs</code> 应用程序。</p><h2 id="转码器"><a href="#转码器" class="headerlink" title="转码器"></a>转码器</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>babel用于ES2015+以上的ECMAScripit在较低版本的浏览器上兼容,此外也支持jsx和es模块转换</p><p>babel配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: <span class="string">&quot;3.6.5&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SWC"><a href="#SWC" class="headerlink" title="SWC"></a>SWC</h3><p>Vite中所使用的代码转换器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D @swc/cli @swc/core</span><br><span class="line">npx swc ./file.js</span><br></pre></td></tr></table></figure><p>转译工具和构建工具的使用都不复杂,swc也支持配置支持浏览器,转换模块,压缩. 配置<code>.swcrc</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;https://swc.nodejs.cn/schema.json&quot;,</span><br><span class="line">  &quot;module&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;commonjs&quot;,</span><br><span class="line"> </span><br><span class="line">    // These are defaults.</span><br><span class="line">    &quot;strict&quot;: false,</span><br><span class="line">    &quot;strictMode&quot;: true,</span><br><span class="line">    &quot;lazy&quot;: false,</span><br><span class="line">    &quot;noInterop&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Oxc"><a href="#Oxc" class="headerlink" title="Oxc"></a>Oxc</h3><p>与Rolldown类似,属于Vue,Vite生态圈. 它本身是一个提供了许多工具的总成,包括lint,parser,transformer和resolver</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">oxlint -c</span> </span><br></pre></td></tr></table></figure><p>此外值得一提的是考虑使用<a href="https://biomejs.dev/guides/getting-started/">Biome</a>作为prettier的替代工具,因为前者速度更快.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;对比前两年,今年前端的工具进展相比可能确实慢了一些. 但还是有许多新的工具以及一些常用工具的新版本. 这里简单介绍一些在开发中关于js一些工具使用.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Dive into fine-tuning methods for SD</title>
    <link href="https://www.sekyoro.top/2025/01/02/Dive-into-fine-tuning-methods-for-SD/"/>
    <id>https://www.sekyoro.top/2025/01/02/Dive-into-fine-tuning-methods-for-SD/</id>
    <published>2025-01-02T02:08:06.000Z</published>
    <updated>2025-03-08T12:58:01.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文生图和图生图应用已经出现一段时间了,目前常用的应用就是根据用户需求修改图片,事实上这就是一种自定义. 因为需要模型重新生成整张图或者部分图,要么通过prompt、reference image,也就是改变输入的方式;要么通过修改模型,也就是微调模型的方式. 因此诞生出了许多微调模型的方式,目前常用的微调库是<a href="https://github.com/huggingface/peft">huggingface/peft: 🤗 PEFT</a>. 针对AI绘图应用的微调技术,倒是可以推出一道清晰的发展线. 这里简单整理一下.</p><span id="more"></span><h2 id="Before-LoRA"><a href="#Before-LoRA" class="headerlink" title="Before LoRA"></a>Before LoRA</h2><p>在大名鼎鼎的LoRA之前,绘画相关的微调技术主要有Textual Inversion<a href="https://arxiv.org/pdf/2208.01618">2208.01618</a>和DreamBooth<a href="https://arxiv.org/pdf/2208.12242">2208.12242</a>. 此外还有改变输入以及嵌入向量的Prefix Tuning<a href="https://arxiv.org/abs/2101.00190">Prefix-Tuning: Optimizing Continuous Prompts for Generation</a>和Prompt Tuning<a href="https://arxiv.org/abs/2104.08691">The Power of Scale for Parameter-Efficient Prompt Tuning</a>,由于与AI绘图相关微调联系不大,这里不深入.</p><h3 id="Textual-Inversion"><a href="#Textual-Inversion" class="headerlink" title="Textual Inversion"></a>Textual Inversion</h3><p>​    文本到图像的模型为通过自然语言指导创作提供了前所未有的自由。然而，如何行使这种自由来生成特定独特概念的图像，修改它们的外观，或将它们组成新的角色和新的场景，尚不清楚。</p><p>​    只使用用户提供的一个概念的3 - 5张图像，<strong>比如一个对象或一个样式，在一个冻结的文本到图像模型的嵌入空间中，我们学习通过新的”词”来表示它</strong>。这些”词”可以组合成自然语言句子，以直观的方式指导个性化创作。作者发现单个词嵌入足以捕获独特和多样的概念。</p><p>​    将新概念引入模型的难点: 将新概念引入大规模模型往往是困难的。为每个新概念重新训练一个具有扩展数据集的模型是非常昂贵的，<strong>对少数例子进行微调通常会导致灾难性的遗忘</strong>。<strong>更多的度量方法在面对新概念时冻结模型并训练转换模块以适应其输出。然而，这些方法仍然容易遗忘先验知识，或者与新学习的概念融合时面临困难。</strong></p><p>​    提出<strong>通过在预训练的文本到图像模型的文本嵌入空间中寻找新词来克服这些挑战</strong>。考虑文本编码过程的第一阶段。在这里输入字符串首先被转换为一组token(词元,理解为词典中的不可再分的词)。然后将每个token替换为自己的嵌入向量，这些向量通过下游模型进行反馈。<strong>目标是寻找新的嵌入向量来表示新的、特定的概念</strong>。</p><p>​    用一个新的词(pseudo-word)表示一个新的嵌入向量，我们用S <em>表示。然后这个词像其他任何词一样被处理，并且可以用于为生成模型合成新的文本查询。因此，可以要求”一张沙滩上的S </em>照片”、”一幅挂在墙上的S <em>油画”，甚至可以组成两个概念，如”一幅S </em> 1的S * 2的画”。</p><p>​    重要的是，这个过程没有触及生成模型。在这样做的过程中，我们保留了在新任务上微调视觉和语言模型时通常会丢失的丰富的文本理解和泛化能力。</p><p>​    为了找到这些词，将任务定为求逆运算,<strong>给出了一个固定的预训练文本-图像模型和一个描述概念的小( 3-5 )图像集。目标是找到一个单词嵌入，这样’ A photo of S * ‘形式的句子将导致从我们的小集合中重建图像。这种嵌入是通过一个优化过程找到的，我们称之为”文本倒置”。</strong></p><p><img data-src="https://s2.loli.net/2025/01/02/B3wYEMNog5KPLa7.png" alt="image-20250102112045813"></p><p>具体来说,首先选取若干张相关概念的照片,假设pikachu,对应输入的prompt类似An image of pikachu, A photo of pikachu,然后就照着LDM训练的方式在原本的预训练大模型上继续训练即可.</p><h3 id="DreamBooth"><a href="#DreamBooth" class="headerlink" title="DreamBooth"></a>DreamBooth</h3><p><img data-src="https://s2.loli.net/2025/01/02/CjIZsPOXFoLDYai.png" alt="image-20250102121433867"></p><p>​    DreamBooth的目的和Textual Inversion类似,扩展模型的语言-视觉词典，使其能够将新词与用户想要生成的特定主题绑定在一起。    </p><p>​    给定一个主体的几幅图像，目标是将主体植入模型的输出域，使其能够用唯一的标识符进行合成。为此提出一种技术，用稀有的标记标识符表示给定的主题，并微调一个预训练的、基于扩散的文本到图像框架。</p><p>​    给定一个对象的3 - 5图像，微调一个文本到图像的扩散模型，输入图像与一个包含唯一标识符且对象所属类名为( e.g . , ‘ A [ V ] dog ‘)的文本提示配对，并行地应用一个特定于类的先验保存损失，该损失利用了模型在类上的语义先验，并鼓励它使用文本提示中的类名生成属于该对象类的多样实例。</p><p>​    相比于textual inversion,它对模型而不只是embedding进行了微调,同时增加了新的损失, 对于同类但不同具体实例的图像进行训练.</p><script type="math/tex; mode=display">\begin{array}{l} \mathbb{E}_{\mathbf{x}, \mathbf{c}, \epsilon, \epsilon^{\prime}, t}\left[w_{t}\left\|\hat{\mathbf{x}}_{\theta}\left(\alpha_{t} \mathbf{x}+\sigma_{t} \boldsymbol{\epsilon}, \mathbf{c}\right)-\mathbf{x}\right\|_{2}^{2}+\right. \\\left.\lambda w_{t^{\prime}}\left\|\hat{\mathbf{x}}_{\theta}\left(\alpha_{t^{\prime}} \mathbf{x}_{\mathrm{pr}}+\sigma_{t^{\prime}} \epsilon^{\prime}, \mathbf{c}_{\mathrm{pr}}\right)-\mathbf{x}_{\mathrm{pr}}\right\|_{2}^{2}\right]\end{array}</script><h2 id="LoRA-era"><a href="#LoRA-era" class="headerlink" title="LoRA era"></a>LoRA era</h2><p>如果说上面几种方法都集中通过新的输入修改embedding,那么LoRA就是修改其中涉及重要计算模块的部分,比如Linear或Conv层  .</p><p>LoRA作为AI绘画模型微调技术不得不提的一环,一经提出就带来了一股LoRA潮<a href="https://towardsdatascience.com/an-overview-of-the-lora-family-515d81134725">An Overview of the LoRA Family. LoRA, DoRA, AdaLoRA, Delta-LoRA, and… | by Dorian Drost | Towards Data Science</a>. </p><p>此外LoRA也可以结合上面的修改embedding方法达到更好的效果.</p><h3 id="LoRA"><a href="#LoRA" class="headerlink" title="LoRA"></a>LoRA</h3><p><img data-src="https://s2.loli.net/2025/01/02/FogSW1IwGdLzfVK.png" alt="image-20250102132811471"></p><p>神经网络包含许多执行矩阵乘法的密集层。这些层中的权重矩阵通常具有满秩。在适应特定任务时，Aghajanyan等研究表明，<strong>预训练的语言模型具有较低的”特征维度”(rank)，即使随机投影到较小的子空间，仍然可以高效地学习</strong>。受此启发，<strong>假设权重的更新在适应过程中也具有较低的”内在秩”</strong>。对于一个预训练的权重矩阵W^0^∈R^d×k^，用一个低秩分解W~0~ + $\Delta$W = W~0~ + BA来约束它的更新，其中B∈R^d×r^，A∈R^r×k^，秩为r=min( d , k)。在训练过程中，W^0^被冻结，不接受梯度更新，而A和B包含可训练参数。</p><p>​    注意W~0~和∆W = BA都乘以相同的输入，并且它们各自的输出向量按位求和。</p><p>对于h = W~0~x，修正前向传递得到h = W~0~x +∆W x = W~0~x + BAx</p><p>​    对A使用随机高斯初始化，对B使用零初始化，因此在训练开始时，W = BA为零。然后用α/r对∆W x进行缩放，其中α为r中的常数。</p><p>​    在使用Adam进行优化时，如果对初始化进行适当的缩放，则调整α与调整学习率大致相同。因此，简单地将α设置为r，并不对其进行调整。这种缩放有助于减少当我们改变r时重新调整超参数的需要.</p><p>​    在训练时,加上lora,冻结预训练模型,训练一个包含A和B的MLP,它更新参数时需要减去这个模型的参数</p><p>​    测试时,模型的权重要加上LoRA的参数.</p><p>​    LoRA本身修改了微调时更新权重的方式,将更新的权重放到了一个可拆卸的模块中,同时由于只搭配预训练大模型中的某部分,使得微调过程更短,训练周期更短.</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>参考<a href="https://github.com/microsoft/LoRA/blob/main/loralib/layers.py">LoRA/loralib/layers.py at main · microsoft/LoRA</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoRALayer</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self, </span></span></span><br><span class="line"><span class="params"><span class="function">        r: <span class="built_in">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        lora_alpha: <span class="built_in">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        lora_dropout: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        merge_weights: <span class="built_in">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        self.r = r</span><br><span class="line">        self.lora_alpha = lora_alpha</span><br><span class="line">        <span class="comment"># Optional dropout</span></span><br><span class="line">        <span class="keyword">if</span> lora_dropout &gt; <span class="number">0.</span>:</span><br><span class="line">            self.lora_dropout = nn.Dropout(p=lora_dropout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.lora_dropout = <span class="keyword">lambda</span> x: x</span><br><span class="line">        <span class="comment"># Mark the weight as unmerged</span></span><br><span class="line">        self.merged = <span class="literal">False</span></span><br><span class="line">        self.merge_weights = merge_weights</span><br></pre></td></tr></table></figure><p>对于Embedding,Linear以及Conv层有不同的具体实现. 但总体来说,在训练时,通过减去B@A更新参数. 在测试时权重加上LoRA层.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span>(<span class="params">nn.Linear, LoRALayer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 in_features: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 out_features: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 r: <span class="built_in">int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 lora_alpha: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 lora_dropout: <span class="built_in">float</span> = <span class="number">0.</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 fan_in_fan_out: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="comment"># Set this to True if the layer to replace stores weight like (fan_in, fan_out)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                 merge_weights: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 **kwargs</span>):</span></span><br><span class="line">        nn.Linear.__init__(self, in_features, out_features, **kwargs)</span><br><span class="line">        LoRALayer.__init__(self, r=r, lora_alpha=lora_alpha, lora_dropout=<span class="number">0</span>, merge_weights=merge_weights)</span><br><span class="line">        self.fan_in_fan_out = fan_in_fan_out</span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="number">0</span>:</span><br><span class="line">            self.lora_A = nn.Parameter(self.weight.new_zeros((r, in_features)))</span><br><span class="line">            self.lora_B = nn.Parameter(self.weight.new_zeros((out_features, r)))</span><br><span class="line">            self.scaling = self.lora_alpha / self.r</span><br><span class="line">            self.weight.requires_grad = <span class="literal">False</span> <span class="comment"># 禁止梯度更新</span></span><br><span class="line">        self.reset_parameters()</span><br><span class="line">        <span class="keyword">if</span> fan_in_fan_out:</span><br><span class="line">            self.weight.data = self.weight.data.transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LyCORIS"><a href="#LyCORIS" class="headerlink" title="LyCORIS"></a>LyCORIS</h3><p><a href="https://arxiv.org/abs/2309.14859">2309.14859] Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation</a></p><p>提出了一系列用在Stable Diffusion中基于LoRA的微调方式并设计了benchmark测试</p><p><img data-src="https://s2.loli.net/2025/01/02/KEoVxDuY3IiJOar.png" alt="image-20250102152745443"></p><p>主要包括LoHA和LoKr,其实光看图就很容易明白. LoHA另外引入一套BA,并通过点乘得到最终的更新,论文解释这种方法得到的矩阵的秩大于一般的低秩分解. 而LoKr就直接使用矩阵直积了.</p><p>这方面还有很多魔改的各种微调,就不一一介绍了.</p><h2 id="Adapters-for-preserving-Identity"><a href="#Adapters-for-preserving-Identity" class="headerlink" title="Adapters for preserving Identity"></a>Adapters for preserving Identity</h2><p>Adapter的实现和LoRA有类似点,但提出的目的不同与LoRA:LoRA强调用户拿几张个人照片让模型学习新的权重同时不过于遗忘已有知识,而Adapter的场景更偏向适应与融合. </p><h3 id="IP-Adapter"><a href="#IP-Adapter" class="headerlink" title="IP-Adapter"></a>IP-Adapter</h3><p><a href="https://github.com/tencent-ailab/IP-Adapter?tab=readme-ov-file">tencent-ailab/IP-Adapter: The image prompt adapter is designed to enable a pretrained text-to-image diffusion model to generate images with image prompt.</a></p><p><img data-src="https://s2.loli.net/2025/01/02/sItZgfVkolGeN4b.png" alt="image-20250102155440556"></p><p>针对现有的文本到图像扩散模型，提出了一种基于解耦交叉注意力策略的轻量级图像提示自适应方法IP-Adapter。</p><p>在图像编码器之后加入新的权重参数进行编码,并将编码后的特征用于训练一个新的cross attention layer. 论文的关键创新就是引入cross attention将图像特征用来微调模型.</p><p>给定图像特征c~i~，新的交叉注意力Z′′的输出计算如下</p><script type="math/tex; mode=display">\mathbf{Z}^{\prime \prime}=\operatorname{Attention}\left(\mathbf{Q}, \mathbf{K}^{\prime}, \mathbf{V}^{\prime}\right)=\operatorname{Softmax}\left(\frac{\mathbf{Q}\left(\mathbf{K}^{\prime}\right)^{\top}}{\sqrt{d}}\right) \mathbf{V}^{\prime}</script><p>其中Q=ZW~q~,Z是文本编码后的特征,K^’^=cW~k~,c是图像特征,V=cV~v~</p><p><img data-src="https://s2.loli.net/2025/01/02/RAhWYImDw6H2cpM.png" alt="image-20250102161435821"></p><h3 id="InstantID"><a href="#InstantID" class="headerlink" title="InstantID"></a>InstantID</h3><p><a href="https://github.com/instantX-research/InstantID?tab=readme-ov-file">instantX-research/InstantID: InstantID: Zero-shot Identity-Preserving Generation in Seconds 🔥</a></p><p><img data-src="https://s2.loli.net/2025/01/02/pBcPXm7JDOZL6It.png" alt="image-20250102155632207"></p><p>首先，采用人脸编码器代替CLIP提取语义人脸特征，并使用可训练的投影层将其投影到文本特征空间。将投影后的特征作为人脸嵌入。然后，引入解耦交叉注意力的轻量级自适应模块，以支持图像作为提示。最后提出IdentityNet对参考人脸图像中的复杂特征进行编码，并附加弱空间控制。在IdentityNet中，生成过程完全由人脸嵌入引导，无需任何文本信息。只更新新增加的模块，而预训练的文本到图像模型保持冻结，以确保灵活性。经过训练，用户可以自由地生成任意风格的高保真度的ID保持图像。</p><h2 id="Towards-Video-Diffusion-Models"><a href="#Towards-Video-Diffusion-Models" class="headerlink" title="Towards Video Diffusion Models"></a>Towards Video Diffusion Models</h2><p> <a href="https://github.com/ChenHsing/Awesome-Video-Diffusion-Models">CSUR] A Survey on Video Diffusion Models</a></p><p>生成图像已经不够了,可以通过prompt生成连续的多张图片,这样可以组成GIF甚至更长更高质量的视频.</p><p>比如<strong>AnimateDiff</strong></p><p><img data-src="https://s2.loli.net/2025/01/02/WEG5I47BVre3yA1.png" alt="image-20250102140534169"></p><h2 id="训练LoRA"><a href="#训练LoRA" class="headerlink" title="训练LoRA"></a>训练LoRA</h2><p>线性层中的lora</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoraInjectedLinear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self, in_features, out_features, bias=<span class="literal">False</span>, r=<span class="number">4</span>, dropout_p=<span class="number">0.1</span>, scale=<span class="number">1.0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="built_in">min</span>(in_features, out_features):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f&quot;LoRA rank <span class="subst">&#123;r&#125;</span> must be less or equal than <span class="subst">&#123;<span class="built_in">min</span>(in_features,out_features)&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">        self.r = r</span><br><span class="line">        self.linear = nn.Linear(in_features, out_features, bias)</span><br><span class="line">        self.lora_down = nn.Linear(in_features, r, bias=<span class="literal">False</span>)</span><br><span class="line">        self.dropout = nn.Dropout(dropout_p)</span><br><span class="line">        self.lora_up = nn.Linear(r, out_features, bias=<span class="literal">False</span>)</span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.selector = nn.Identity()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  init ΔW = A*B</span></span><br><span class="line">        nn.init.normal_(self.lora_down.weight, std=<span class="number">1</span> / r)</span><br><span class="line">        nn.init.zeros_(self.lora_up.weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            self.linear(<span class="built_in">input</span>)</span><br><span class="line">            + self.dropout(self.lora_up(self.selector(self.lora_down(<span class="built_in">input</span>))))</span><br><span class="line">            * self.scale</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">realize_as_lora</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lora_up.weight.data * self.scale, self.lora_down.weight.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_selector_from_diag</span>(<span class="params">self, diag: torch.Tensor</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> diag.shape == (self.r,)</span><br><span class="line">        self.selector = nn.Linear(self.r, self.r, bias=<span class="literal">False</span>)</span><br><span class="line">        self.selector.weight.data = (</span><br><span class="line">            torch.diag(diag)</span><br><span class="line">            .to(self.lora_up.weight.device)</span><br><span class="line">            .to(self.lora_up.weight.dtype)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>卷积中的lora</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoraInjectedConv2d</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        in_channels: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        out_channels: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        kernel_size: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        stride=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        padding=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dilation=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        groups: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        bias: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        r: <span class="built_in">int</span> = <span class="number">4</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        dropout_p: <span class="built_in">float</span> = <span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        scale: <span class="built_in">float</span> = <span class="number">1.0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="built_in">min</span>(in_channels, out_channels):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f&quot;LoRA rank <span class="subst">&#123;r&#125;</span> must be less or equal than <span class="subst">&#123;<span class="built_in">min</span>(in_channels, out_channels)&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">        self.r = r</span><br><span class="line">        self.conv = nn.Conv2d(</span><br><span class="line">            in_channels=in_channels,</span><br><span class="line">            out_channels=out_channels,</span><br><span class="line">            kernel_size=kernel_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            dilation=dilation,</span><br><span class="line">            groups=groups,</span><br><span class="line">            bias=bias,</span><br><span class="line">        )</span><br><span class="line">        self.lora_down = nn.Conv2d(</span><br><span class="line">            in_channels=in_channels,</span><br><span class="line">            out_channels=r,</span><br><span class="line">            kernel_size=kernel_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            dilation=dilation,</span><br><span class="line">            groups=groups,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        self.dropout = nn.Dropout(dropout_p)</span><br><span class="line">        self.lora_up = nn.Conv2d(</span><br><span class="line">            in_channels=r,</span><br><span class="line">            out_channels=out_channels,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        self.selector = nn.Identity()</span><br><span class="line">        self.scale = scale</span><br><span class="line"></span><br><span class="line">        nn.init.normal_(self.lora_down.weight, std=<span class="number">1</span> / r)</span><br><span class="line">        nn.init.zeros_(self.lora_up.weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            self.conv(<span class="built_in">input</span>)</span><br><span class="line">            + self.dropout(self.lora_up(self.selector(self.lora_down(<span class="built_in">input</span>))))</span><br><span class="line">            * self.scale</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">realize_as_lora</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lora_up.weight.data * self.scale, self.lora_down.weight.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_selector_from_diag</span>(<span class="params">self, diag: torch.Tensor</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> diag.shape == (self.r,)</span><br><span class="line">        self.selector = nn.Conv2d(</span><br><span class="line">            in_channels=self.r,</span><br><span class="line">            out_channels=self.r,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">        self.selector.weight.data = torch.diag(diag)</span><br><span class="line">        self.selector.weight.data = self.selector.weight.data.to(</span><br><span class="line">            self.lora_up.weight.device</span><br><span class="line">        ).to(self.lora_up.weight.dtype)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/675231376">一文辨析清楚LORA、Prompt Tuning、P-Tuning、Adapter 、Prefix等大模型微调方法 - 知乎</a></li><li><a href="https://www.artvy.ai/resource/lora-vs-dreambooth-vs-textual-inversion-vs">LoRA vs Dreambooth vs Textual Inversion vs Hypernetworks: Exploring the World of Stable Diffusion Fine-Tuning Methods</a></li><li><a href="https://openreview.net/forum?id=wfzXa8e783">Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation | OpenReview</a></li><li><a href="https://github.com/KohakuBlueleaf/LyCORIS?tab=readme-ov-file">KohakuBlueleaf/LyCORIS: Lora beYond Conventional methods, Other Rank adaptation Implementations for Stable diffusion.</a></li><li><a href="https://towardsdatascience.com/an-overview-of-the-lora-family-515d81134725">An Overview of the LoRA Family. LoRA, DoRA, AdaLoRA, Delta-LoRA, and… | by Dorian Drost | Towards Data Science</a></li><li><a href="https://arxiv.org/pdf/2106.09685">2106.09685</a></li><li><a href="https://arxiv.org/abs/2309.14859">[2309.14859] Navigating Text-To-Image Customization: From LyCORIS Fine-Tuning to Model Evaluation</a></li><li><a href="https://arxiv.org/pdf/2307.04725">2307.04725</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;文生图和图生图应用已经出现一段时间了,目前常用的应用就是根据用户需求修改图片,事实上这就是一种自定义. 因为需要模型重新生成整张图或者部分图,要么通过prompt、reference image,也就是改变输入的方式;要么通过修改模型,也就是微调模型的方式. 因此诞生出了许多微调模型的方式,目前常用的微调库是&lt;a href=&quot;https://github.com/huggingface/peft&quot;&gt;huggingface/peft: 🤗 PEFT&lt;/a&gt;. 针对AI绘图应用的微调技术,倒是可以推出一道清晰的发展线. 这里简单整理一下.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>An intro to Websocket and SSE</title>
    <link href="https://www.sekyoro.top/2024/12/31/An-intro-to-Websocket-and-SSE/"/>
    <id>https://www.sekyoro.top/2024/12/31/An-intro-to-Websocket-and-SSE/</id>
    <published>2024-12-31T11:29:32.000Z</published>
    <updated>2024-12-31T15:44:07.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在看LLM的流式输出如何反映到json输出上,现有的解决方案包括 WebSocket 或 Server-Sent Events (SSE) 实时通信技术.<br><span id="more"></span></p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>WebSocket API</strong> 可在用户浏览器和服务器之间开启双向交互式通信会话。利用该 API，可以向服务器发送信息，并接收事件驱动的响应，而无需轮询服务器以获得回复。</p><p><img data-src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png" alt="img"></p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><p><strong>客户端</strong></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>, protocols);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器向所有用户发送文本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造一个 msg 对象，包含了服务器处理所需的数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value,</span><br><span class="line">    <span class="attr">id</span>: clientID,</span><br><span class="line">    <span class="attr">date</span>: <span class="built_in">Date</span>.now(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 msg 对象作为 JSON 格式字符串发送</span></span><br><span class="line">  exampleSocket.send(<span class="built_in">JSON</span>.stringify(msg));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空文本输入元素，为接收下一条消息做好准备。</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><p>可以使用<a href="https://socket.io/">Socket.IO</a>,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Server &#125; = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> Server(&#123; <span class="comment">/* options */</span> &#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFileSync &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; createServer &#125; = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Server &#125; = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpsServer = createServer(&#123;</span><br><span class="line">  <span class="attr">key</span>: readFileSync(<span class="string">&quot;/path/to/my/key.pem&quot;</span>),</span><br><span class="line">  <span class="attr">cert</span>: readFileSync(<span class="string">&quot;/path/to/my/cert.pem&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> Server(httpsServer, &#123; <span class="comment">/* options */</span> &#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">httpsServer.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><p>HTTP 协议本身不允许服务器主动给客户端发送信息，但有一种方法可以让服务器持续向客户端发送数据流。这种方法不是发送一次性数据包，而是保持连接开放，像视频播放那样连续发送数据。这种长时间的下载过程实际上是以数据流的形式进行的。</p><p>服务器发送事件（SSE）就是利用了这个特性，通过HTTP协议让服务器可以向浏览器推送实时更新的信息。传统上，网页需要先请求服务器才能获取新数据，但是使用SSE，服务器可以在任何时候主动向网页推送新的数据和消息，这些消息可以在网页内作为事件来处理。</p><p>服务端推送的数据是单向的，只从服务器到客户端流动。当不需要从客户端向服务器发送信息时，比如更新社交媒体状态、新闻推送或把数据传送到客户端存储（如IndexedDB或Web Storage），SSE就非常适合。</p><p>与SSE不同的是，WebSocket提供了一个更强大的双向通信通道，允许客户端和服务器之间互相发送信息。SSE则是单向的，主要用于服务器向浏览器发送信息。如果浏览器需要向服务器发送信息，它必须发起一个新的HTTP请求。</p><p>这里有几个关于SSE和WebSocket的区别：</p><ul><li>SSE基于HTTP，因此所有现有的服务器软件都能支持它；而WebSocket是一个独立的协议。</li><li>SSE设置起来简单得多，适合轻量级应用；WebSocket则更为复杂。</li><li>SSE自带断线重连功能，而WebSocket需要开发者自己实现这一功能。</li><li>SSE主要用于传输文本数据，若要发送二进制数据则需编码；WebSocket直接支持二进制数据传输。</li><li>SSE允许自定义消息类型，增加了灵活性。</li></ul><h3 id="事件流格式"><a href="#事件流格式" class="headerlink" title="事件流格式"></a>事件流格式</h3><p>事件流是一个简单的文本数据流，文本应该使用UTF-8格式的编码。事件流中的消息由一对换行符分开。以冒号开头的行为注释行，会被忽略。</p><p><strong>备注：</strong> 注释行可以用来防止连接超时，服务器可以定期发送一条消息注释行，以保持连接不断。</p><p>每条消息由一行或多行文字组成，列出该消息的字段。每个字段由字段名表示，后面是冒号，然后是该字段值的文本数据。</p><p>规范中规定了下面这些字段：</p><ul><li><p>event</p><p>一个用于标识事件类型的字符串。如果指定了这个字符串，浏览器会将具有指定事件名称的事件分派给相应的监听器；网站源代码应该使用 <code>addEventListener()</code> 来监听指定的事件。如果一个消息没有指定事件名称，那么 <code>onmessage</code> 处理程序就会被调用。</p></li><li><p>data</p><p>消息的数据字段。当 <code>EventSource</code> 接收到多个以 <code>data:</code> 开头的连续行时，<a href="https://html.spec.whatwg.org/multipage/#dispatchMessage">会将它们连接起来</a>，在它们之间插入一个换行符。末尾的换行符会被删除。</p></li><li><p>id</p><p>事件 ID，会成为当前 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource"><code>EventSource</code></a> 对象的内部属性“最后一个事件 ID”的属性值。</p></li><li><p>retry</p><p>重新连接的时间。如果与服务器的连接丢失，浏览器将等待指定的时间，然后尝试重新连接。这必须是一个整数，以毫秒为单位指定重新连接的时间。如果指定了一个非整数值，该字段将被忽略。</p></li></ul><p>所有其他的字段名都会被忽略</p><h3 id="事件流具体例子"><a href="#事件流具体例子" class="headerlink" title="事件流具体例子"></a>事件流具体例子</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/event-stream</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>每一次发送的信息，由若干个<code>message</code>组成，每个<code>message</code>之间用<code>\n\n</code>分隔。每个<code>message</code>内部由若干行组成，每一行都是如下格式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">field</span>]: <span class="link">value\n</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">: comment</span><br><span class="line">id: 2025\n </span><br><span class="line">event: foo\n</span><br><span class="line">retry: 100\n \\指定浏览器重新发起连接的时间间隔。</span><br><span class="line">data: This is the mesage\n</span><br><span class="line">data: test\n</span><br><span class="line">data: this is the end\n\n</span><br></pre></td></tr></table></figure><p>在浏览器上<code>lastEventId</code>属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的<code>Last-Event-ID</code>头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p><h4 id="命名事件"><a href="#命名事件" class="headerlink" title="命名事件"></a>命名事件</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">event: userconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: userdisconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:23&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;sean&quot;, &quot;time&quot;: &quot;02:34:36&quot;, &quot;text&quot;: &quot;Bye, bobby.&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个事件都有一个由 <code>event</code> 字段指定的事件名称和一个 <code>data</code> 字段，其值是一个适当的 JSON 字符串，包含客户端对该事件采取行动所需的数据。<code>data</code> 字段可以包含任何字符串数据，它不一定是 JSON。</p><h4 id="混合两种事件"><a href="#混合两种事件" class="headerlink" title="混合两种事件"></a>混合两种事件</h4><p>可以在一个事件流中同时使用命名事件和未命名事件。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">event: userconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;&#125;</span><br><span class="line"></span><br><span class="line">data: Here&#x27;s a system message of some kind that will get used</span><br><span class="line">data: to accomplish some task.</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><p>默认情况下，如果客户端和服务器之间的连接关闭，则连接将重新启动。可以使用 <code>.close()</code> 方法终止连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">&quot;xxx&quot;</span>);<span class="comment">//url可以与当前网址同域，也可以跨域。</span></span><br><span class="line">evtSource.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line">evtSource.onerror = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;EventSource failed:&quot;</span>, err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义事件</span></span><br><span class="line">source.addEventListener(<span class="string">&#x27;foo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// handle message</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">date_default_timezone_set(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">header(<span class="string">&quot;Cache-Control: no-store&quot;</span>);</span><br><span class="line">header(<span class="string">&quot;Content-Type: text/event-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$counter</span> = rand(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// Every second, send a &quot;ping&quot; event.</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;event: ping\n&quot;</span>; <span class="comment"># 声明事件</span></span><br><span class="line">  <span class="variable">$curDate</span> = date(DATE_ISO8601);</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;data: &#123;&quot;time&quot;: &quot;&#x27;</span> . <span class="variable">$curDate</span> . <span class="string">&#x27;&quot;&#125;&#x27;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;\n\n&quot;</span>;  <span class="comment"># 一个事件结束</span></span><br><span class="line">  <span class="comment">// Send a simple message at random intervals.</span></span><br><span class="line">  <span class="variable">$counter</span>--;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable">$counter</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;data: This is a message at time &#x27;</span> . <span class="variable">$curDate</span> . <span class="string">&quot;\n\n&quot;</span>; <span class="comment"># 默认onmessage事件处理</span></span><br><span class="line">    <span class="variable">$counter</span> = rand(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ob_end_flush();</span><br><span class="line">  flush();</span><br><span class="line">  <span class="comment">// Break the loop if the client aborted the connection (closed the page)</span></span><br><span class="line">  <span class="keyword">if</span> (connection_aborted()) <span class="keyword">break</span>;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Using server-sent events - Web APIs | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket - Web APIs | MDN</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程 - 阮一峰的网络日志</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">Server-Sent Events 教程 - 阮一峰的网络日志</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在看LLM的流式输出如何反映到json输出上,现有的解决方案包括 WebSocket 或 Server-Sent Events (SSE) 实时通信技术.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Learn OpenGL(二):模型加载与高级OpenGL</title>
    <link href="https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/"/>
    <id>https://www.sekyoro.top/2024/12/27/Learn-OpenGL-%E4%BA%8C/</id>
    <published>2024-12-27T14:19:31.000Z</published>
    <updated>2025-01-07T13:59:29.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>从手动设置顶点坐标到加载模型以及OpenGL高级技巧<br><span id="more"></span></p><h2 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h2><p>通过一些建模软件,比如Blender,可以方便地对一些复杂物体进行建模并导出为模型,而这些模型文件包含许多信息,比如顶点坐标,法线以及纹理坐标.</p><p>不同的模型文件格式封装的信息也不同.常见的有<code>.obj</code>，<code>.fbx</code>,<code>s.tl</code>等等</p><p>通常使用<code>Assimp</code>加载模型,Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），<strong>它会将所有的模型数据加载至Assimp的通用数据结构中</strong>。当Assimp加载完模型之后就能够从Assimp的数据结构中提取我们所需的所有数据了。</p><p>由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问需要的数据。</p><p>当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型/场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。</p><p><img data-src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt="img"></p><ul><li>和材质,网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li><li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li><li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li><li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的</li><li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）</li></ul><p>使用Assimp可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。我们从上一节中学到，网格(Mesh)代表的是单个的可绘制实体</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20241228205757945.png" alt="image-20241228205757945"></p><p>一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">  glm::vec3 position;</span><br><span class="line">   glm::vec3 norm;</span><br><span class="line">    glm::vec2 textcoord;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    std::string type;</span><br><span class="line">    aiString dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    std::vector&lt;Texture&gt; textures;</span><br><span class="line">    std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">// 处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::vector&lt;Mesh&gt; meshes;</span><br><span class="line">    std::vector&lt;Textures&gt; loadad_textures;</span><br><span class="line">   <span class="comment">// 处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><blockquote><p><strong>提前深度测试</strong></p><p>提前深度测试允许深度测试<strong>在片段着色器之前运行。只要清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</strong></p><p>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。<strong>当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。</strong>OpenGL不能提前知道深度值。</p></blockquote><p>​    <strong>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息</strong>，并且（通常）和颜色缓冲有着一样的宽度和高度。<strong>深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值</strong>。在大部分的系统中，深度缓冲的精度都是24位的。</p><p>​    当深度测试(Depth Testing)被启用的时候，<strong>OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值</strong>。如果深度测试失败了，片段将会被丢弃。</p><p>​    <strong>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后）在屏幕空间中运行的。</strong>屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以<strong>直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问</strong>。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。</p><p>深度测试默认是禁用的，所以如果要启用深度测试的话用GL_DEPTH_TEST选项来启用它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>当它启用的时候，如果一个片段通过了深度测试的话，OpenGL会在深度缓冲中储存该片段的z值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则会仍在使用上一次渲染迭代中的写入的深度值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但<strong>不</strong>希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。<strong>OpenGL允许禁用深度缓冲的写入，只需要设置它的深度掩码</strong>(Depth Mask)设置为<code>GL_FALSE</code>就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br></pre></td></tr></table></figure><p>注意这只在深度测试被启用的时候才有效果。</p><p>OpenGL允许修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDepthFunc</span>(GL_LESS);</span><br></pre></td></tr></table></figure><p>默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_ALWAYS</td><td style="text-align:left">永远通过深度测试</td></tr><tr><td style="text-align:left">GL_NEVER</td><td style="text-align:left">永远不通过深度测试</td></tr><tr><td style="text-align:left">GL_LESS</td><td style="text-align:left">在片段深度值小于缓冲的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_EQUAL</td><td style="text-align:left">在片段深度值等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_LEQUAL</td><td style="text-align:left">在片段深度值小于等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_GREATER</td><td style="text-align:left">在片段深度值大于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_NOTEQUAL</td><td style="text-align:left">在片段深度值不等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:left">GL_GEQUAL</td><td style="text-align:left">在片段深度值大于等于缓冲区的深度值时通过测试</td></tr></tbody></table></div><h4 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h4><p>深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的<strong>近平面</strong>(Near)和<strong>远平面</strong>(Far)之间的任何值。</p><p>在透视矩阵中的znear和zfar决定了哪些坐标在视锥体中,我们将处在这个范围的顶点坐标z值转换到[0,1]之间. 一种简单的方式就是使用线性变换</p><script type="math/tex; mode=display">F_{\text {depth }}=\frac{z-n e a r}{f a r-n e a r}</script><p><img data-src="https://learnopengl-cn.github.io/img/04/01/depth_linear_graph.png" alt="img"></p><p>在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度</p><script type="math/tex; mode=display">F_{\text {depth }}=\frac{1 / z-1 / \text { near }}{1 / \text { far }-1 / \text { near }}</script><p>深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。</p><p><img data-src="https://learnopengl-cn.github.io/img/04/01/depth_non_linear_graph.png" alt="img"></p><p>可以将本身的非线性深度值转为线性深度值</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> near = <span class="number">0.1</span>; </span><br><span class="line"><span class="type">float</span> far  = <span class="number">100.0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">float</span> LinearizeDepth(<span class="type">float</span> depth) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near * far) / (far + near - z * (far - near));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">float</span> depth = LinearizeDepth(<span class="built_in">gl_FragCoord</span>.z) / far; <span class="comment">// 为了演示除以 far</span></span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(depth), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h4><p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，<strong>深度缓冲没有足够的精度来决定两个形状哪个在前面</strong>。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p><p>​    箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。</p><p>​    深度冲突是深度缓冲的一个常见问题，<strong>当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突</strong></p><p><strong>防止深度冲突</strong></p><p>第一个也是最重要的技巧是<strong>永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠</strong>。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，<strong>可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生</strong>。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p><p>第二个技巧是<strong>尽可能将近平面设置远一些</strong>。精度在靠近<strong>近</strong>平面时是非常高的，<strong>所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度</strong>。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的<strong>近</strong>平面距离。</p><p>另外一个很好的技巧是牺牲一些性能，<strong>使用更高精度的深度缓冲</strong>。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p><h2 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h2><p>​    当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。<strong>模板测试是根据又一个缓冲来进行的，它叫做模板缓冲(Stencil Buffer)，可以在渲染的时候更新它来获得一些很有意思的效果。</strong></p><p>​    <strong>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值</strong>。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了</p><blockquote><p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p></blockquote><p>模板缓冲操作允许在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们<strong>写入</strong>了模板缓冲。在同一个（或者接下来的）渲染迭代中，可以<strong>读取</strong>这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：</p><ul><li>启用模板缓冲的写入。</li><li>渲染物体，更新模板缓冲的内容。</li><li>禁用模板缓冲的写入。</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); <span class="comment">// 每一位写入模板缓冲时都保持原样</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br></pre></td></tr></table></figure><p>glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为<code>0x00</code>，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的</p><h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p>一共有两个函数能够用来配置模板测试：glStencilFunc和glStencilOp</p><p>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：</p><ul><li><code>func</code>：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的<code>ref</code>值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li><li><code>ref</code>：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li><li><code>mask</code>：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1</li></ul><p>如何更新缓冲就需要glStencilOp函数</p><p>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，能够设定每个选项应该采取的行为：</p><ul><li><code>sfail</code>：模板测试失败时采取的行为。</li><li><code>dpfail</code>：模板测试通过，但深度测试失败时采取的行为。</li><li><code>dppass</code>：模板测试和深度测试都通过时采取的行为。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">行为</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_KEEP</td><td style="text-align:left">保持当前储存的模板值</td></tr><tr><td style="text-align:left">GL_ZERO</td><td style="text-align:left">将模板值设置为0</td></tr><tr><td style="text-align:left">GL_REPLACE</td><td style="text-align:left">将模板值设置为glStencilFunc函数设置的<code>ref</code>值</td></tr><tr><td style="text-align:left">GL_INCR</td><td style="text-align:left">如果模板值小于最大值则将模板值加1</td></tr><tr><td style="text-align:left">GL_INCR_WRAP</td><td style="text-align:left">与GL_INCR一样，但如果模板值超过了最大值则归零</td></tr><tr><td style="text-align:left">GL_DECR</td><td style="text-align:left">如果模板值大于最小值则将模板值减1</td></tr><tr><td style="text-align:left">GL_DECR_WRAP</td><td style="text-align:left">与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td></tr><tr><td style="text-align:left">GL_INVERT</td><td style="text-align:left">按位翻转当前的模板缓冲值</td></tr></tbody></table></div><p>默认情况下glStencilOp是设置为<code>(GL_KEEP, GL_KEEP, GL_KEEP)</code>的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</p><p>通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃</p><h3 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h3><p>模板测试的一个重要应用就是人为选择需要绘制的区域. 如果要绘制一个物体的轮廓,画这个物体时更新模板缓冲为1,然后画一个更大的物体,设置模板缓冲函数,让模板测试是不等于1的位置. 则只会显示轮廓区域.</p><p>重要的几点:</p><ol><li>先进行模板测试后进行深度测试. 在这两个测试都开启时且不使用glDepthMask则在后面的物体是无法通过模板函数显示在前面的</li><li>模板测试的glStencilFunc设置的是模板测试成功条件,也就是怎样才能显示图形以及显示哪一部分图形. 比如设置当模板缓冲的值大于1时则模板测试通过. glStencilOp设置的是如何更新模板缓冲.</li></ol><p>注意:</p><ol><li>模板掩码(Stencil Mask)对 glClear 的影响:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置模板掩码</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>);  <span class="comment">// 允许写入所有位</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class="comment">// 正常清除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>);  <span class="comment">// 禁止写入</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class="comment">// 不会清除模板缓冲</span></span><br></pre></td></tr></table></figure><ol><li>清除模板缓冲区的值设置:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置清除值</span></span><br><span class="line"><span class="built_in">glClearStencil</span>(<span class="number">1</span>);  <span class="comment">// 设置清除值为1</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_STENCIL_BUFFER_BIT);  <span class="comment">// 用1填充模板缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多缓冲区同时清除</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></td></tr></table></figure><ol><li><p>```c++<br>// 错误示范<br>glStencilMask(0x00);<br>glClear(GL_STENCIL_BUFFER_BIT);  // 无效的清除</p><p>// 正确做法<br>glStencilMask(0xFF);  // 确保清除前设置正确的掩码<br>glClear(GL_STENCIL_BUFFER_BIT);<br>glStencilMask(0x00);  // 之后再改回所需的掩码值</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">## 混合</span></span><br><span class="line"></span><br><span class="line">​OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。</span><br><span class="line"></span><br><span class="line">​**一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色**。这也是混合这一名字的出处，混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 Alpha通道表示不透明度,值越大越不透明.</span><br><span class="line"></span><br><span class="line"><span class="meta">### 丢弃片段</span></span><br><span class="line"></span><br><span class="line">如果你有一个纹理，其中某些部分是完全透明的，你可以根据纹理的颜色 alpha 分量来决定是否丢弃片段。例如，对于 alpha 值小于某个阈值的片段，你可以选择将其丢弃，从而实现不规则形状的物体渲染。</span><br><span class="line"></span><br><span class="line">此外,有时你可能想要根据一些条件裁剪掉不需要的部分。比如，在绘制树叶或草地的时候，可能会根据距离相机的距离或者其他条件来决定是否绘制特定的片段。</span><br><span class="line"></span><br><span class="line">加载纹理之后,如果纹理带有alpha通道,可以通过通道值选择是否渲染这个片段. </span><br><span class="line"></span><br><span class="line">```glsl</span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">    <span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    FragColor = texColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>设置距离丢弃条件,太远就丢弃</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 400 core</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span>  TextCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec4</span> textColor = <span class="built_in">texture</span>(texture1,TextCoord);</span><br><span class="line">    <span class="keyword">if</span> (textColor.a &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> dis = <span class="built_in">distance</span>(FragPos,viewPos);</span><br><span class="line">    <span class="keyword">if</span>(dis&gt; <span class="number">15.0</span>)&#123;</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor = textColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，当采样纹理的边缘的时候，OpenGL<strong>会对边缘的值和纹理下一个重复的值进行插值</strong>（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，可以启用GL_BLEND来启用混合</p><p>OpenGL中的混合是通过下面这个方程来实现的：</p><script type="math/tex; mode=display">\bar{C}_{\text {result }}=\bar{C}_{\text {source }} * F_{\text {source }}+\bar{C}_{\text {destination }} * F_{\text {destination }}</script><p><img data-src="https://learnopengl-cn.github.io/img/04/03/blending_equation_mixed.png" alt="img"></p><ul><li>C_source：源颜色向量。这是<strong>源自纹理的颜色向量</strong>。</li><li>C_destination：目标颜色向量。这是<strong>当前储存在颜色缓冲中的颜色向量</strong>。</li><li>F_source：源因子值。指定了alpha值对源颜色的影响。</li><li>F_destination：目标因子值。指定了alpha值对目标颜色的影响</li></ul><p>使用<code>glBlendFunc</code>设置因子值,glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项，我们将在下面列出大部分最常用的选项。注意常数颜色向量C¯constantC¯constant可以通过glBlendColor函数来另外设置。</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left"><code>GL_ZERO</code></td><td style="text-align:left">因子等于00</td></tr><tr><td style="text-align:left"><code>GL_ONE</code></td><td style="text-align:left">因子等于11</td></tr><tr><td style="text-align:left"><code>GL_SRC_COLOR</code></td><td style="text-align:left">因子等于源颜色向量C¯sourceC¯source</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_SRC_COLOR</code></td><td style="text-align:left">因子等于1−C¯source1−C¯source</td></tr><tr><td style="text-align:left"><code>GL_DST_COLOR</code></td><td style="text-align:left">因子等于目标颜色向量C¯destinationC¯destination</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_DST_COLOR</code></td><td style="text-align:left">因子等于1−C¯destination1−C¯destination</td></tr><tr><td style="text-align:left"><code>GL_SRC_ALPHA</code></td><td style="text-align:left">因子等于C¯sourceC¯source的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_SRC_ALPHA</code></td><td style="text-align:left">因子等于1−1− C¯sourceC¯source的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_DST_ALPHA</code></td><td style="text-align:left">因子等于C¯destinationC¯destination的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_DST_ALPHA</code></td><td style="text-align:left">因子等于1−1− C¯destinationC¯destination的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_CONSTANT_COLOR</code></td><td style="text-align:left">因子等于常数颜色向量C¯constantC¯constant</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_CONSTANT_COLOR</code></td><td style="text-align:left">因子等于1−C¯constant1−C¯constant</td></tr><tr><td style="text-align:left"><code>GL_CONSTANT_ALPHA</code></td><td style="text-align:left">因子等于C¯constantC¯constant的alphaalpha分量</td></tr><tr><td style="text-align:left"><code>GL_ONE_MINUS_CONSTANT_ALPHA</code></td><td style="text-align:left">因子等于1−1− C¯constantC¯constant的alphaalpha分量</td></tr></tbody></table></div><p>注意常数颜色向量C_constant可以通过glBlendColor函数来另外设置。</p><p>为了获得之前两个方形的混合结果，我们需要使用源颜色向量的alpha作为源因子，使用1−alpha作为目标因子。这将会产生以下的glBlendFunc：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure><p>也可以使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFuncSeparate</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);</span><br></pre></td></tr></table></figure><p>允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项：</p><ul><li>GL_FUNC_ADD：默认选项，将两个分量相加：</li><li>GL_FUNC_SUBTRACT：将两个分量相减： </li><li>GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：</li></ul><p>通常都可以省略调用glBlendEquation</p><h3 id="渲染半透明纹理"><a href="#渲染半透明纹理" class="headerlink" title="渲染半透明纹理"></a>渲染半透明纹理</h3><p>初始化时我们启用混合，并设定相应的混合函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure><p>由于启用了混合，我们就不需要丢弃片段了，所以我们把片段着色器还原：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可能跟绘图顺序有关.深度测试和混合一起使用的话会产生一些麻烦。当<strong>写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中</strong>。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 也就是说</p><p>要想保证窗户中能够显示它们背后的物体，我们需要首先绘制背后的这部分物体。这也就是说在绘制的时候，必须先手动将窗户按照最远到最近来排序，再按照顺序渲染.</p><blockquote><p>注意，对于草这种全透明的物体，可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）</p></blockquote><h3 id="不要打扰顺序"><a href="#不要打扰顺序" class="headerlink" title="不要打扰顺序"></a>不要打扰顺序</h3><p>​    <strong>要想让混合在多个物体上工作，需要最先绘制最远的物体，最后绘制最近的物体</strong>。</p><p>​    普通<strong>不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序</strong>。但<strong>仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了</strong>。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：</p><ol><li><p>先绘制所有不透明的物体。</p></li><li><p>对所有透明的物体排序。</p></li><li><p>按顺序绘制所有透明的物体</p></li></ol><p>​    排序透明物体的一种方法是，<strong>从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得</strong>。</p><p>​    接下来把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。</p><p>​    在渲染的时候以逆序（从远到近）从map中获取值，之后以正确的顺序绘制对应的窗户.</p><p>​    虽然按照距离排序物体这种方法对这个场景能够正常工作，<strong>但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。</strong></p><p>​    在场景中排序物体是一个很困难的技术，很大程度上由场景的类型所决定，更别说它额外需要消耗的处理能力了。<strong>完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有次序无关透明度</strong>(Order Independent Transparency, OIT)</p><h2 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h2><p>想象任何一个闭合形状，它的每一个面都有两侧，每一侧要么<strong>面向</strong>用户，要么背对用户。如果我们能够只绘制<strong>面向</strong>观察者的面呢？</p><p>这正是面剔除(Face Culling)所做的。OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，<strong>分析顶点数据的环绕顺序(Winding Order)。</strong></p><h4 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h4><p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，会从三角形中间来看，为这3个顶点设定一个环绕顺序。</p><p><strong>每组组成三角形图元的三个顶点就包含了一个环绕顺序</strong>。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。</p><p><strong>默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</strong>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从<strong>观察者视角</strong>所见的了。</p><h4 id="面剔除-1"><a href="#面剔除-1" class="headerlink" title="面剔除"></a>面剔除</h4><p>OpenGL能够丢弃那些渲染为背向三角形的三角形图元。既然已经知道如何设置顶点的环绕顺序了，我们就可以使用OpenGL的面剔除选项了，它默认是禁用状态的。</p><p>在之前教程中使用的立方体顶点数据并不是按照逆时针环绕顺序定义的，所以顶点数据反映了环绕顺序从而反应是正向面和背向面.</p><p>要想启用面剔除，我们只需要启用OpenGL的GL_CULL_FACE选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br></pre></td></tr></table></figure><p>从这一句代码之后，所有背向面都将被丢弃（尝试飞进立方体内部，看看所有的内面是不是都被丢弃了）。目前我们在渲染片段的时候能够节省50%以上的性能，但注意这只对像立方体这样的封闭形状有效。</p><p>OpenGL允许我们改变需要剔除的面的类型。我们可以调用glCullFace来定义这一行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br></pre></td></tr></table></figure><p>glCullFace函数有三个可用的选项：</p><ul><li><code>GL_BACK</code>：只剔除背向面。</li><li><code>GL_FRONT</code>：只剔除正向面。</li><li><code>GL_FRONT_AND_BACK</code>：剔除正向面和背向面。</li></ul><p>glCullFace的初始值是GL_BACK。除了需要剔除的面之外，也可以通过调用glFrontFace，告诉OpenGL我们希望将顺时针的面（而不是逆时针的面）定义为正向面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glFrontFace</span>(GL_CCW);</span><br></pre></td></tr></table></figure><p>默认值是GL_CCW，它代表的是逆时针的环绕顺序，另一个选项是GL_CW，它（显然）代表的是顺时针顺序。</p><p>我们可以来做一个实验，告诉OpenGL现在顺时针顺序代表的是正向面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK);</span><br><span class="line"><span class="built_in">glFrontFace</span>(GL_CW);</span><br></pre></td></tr></table></figure><h2 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h2><p>​    现在已经使用了很多屏幕缓冲了：用于<strong>写入颜色值的颜色缓冲</strong>、用于<strong>写入深度信息的深度缓冲</strong>和允许我们<strong>根据一些条件丢弃特定片段的模板缓冲</strong>。这些缓冲<strong>结合起来叫做帧缓冲(</strong>Framebuffer)</p><p>​    它被<strong>储存在GPU内存</strong>中的某处。<strong>OpenGL允许我们定义我们自己的帧缓冲，也就是说能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲</strong>。</p><p>​    目前所做的<strong>所有操作都是在默认帧缓冲的渲染缓冲上进行的</strong>。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。通过创建自己的帧缓冲，我们可以获得额外的渲染目标(target)。</p><p>渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果</p><h4 id="创建帧缓冲"><a href="#创建帧缓冲" class="headerlink" title="创建帧缓冲"></a>创建帧缓冲</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gluint fbo;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>,&amp;fbo);</span><br><span class="line"><span class="built_in">glBindFrameBuffer</span>(GL_FRAMEBUFFER，fbo);</span><br></pre></td></tr></table></figure><p>在绑定到GL_FRAMEBUFFER目标之后，所有的<strong>读取</strong>和<strong>写入</strong>帧缓冲的操作将会影响当前绑定的帧缓冲。<strong>也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标</strong>。绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上</p><p>一个完整的帧缓冲需要满足以下的条件：</p><ul><li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li><li>至少有一个颜色附件(Attachment)。</li><li>所有的附件都必须是完整的（保留了内存）。</li><li>每个缓冲都应该有相同的样本数(sample)</li></ul><p>​    需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以GL_FRAMEBUFFER为参数调用glCheckFramebufferStatus，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是GL_FRAMEBUFFER_COMPLETE，帧缓冲就是完整的了</p><p>​    <strong>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中</strong>。由于帧缓冲不是默认帧缓冲，<strong>渲染指令将不会对窗口的视觉输出有任何影响</strong>。出于这个原因，<strong>渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到<code>0</code>。</strong></p><p>​    在完整性检查执行之前，<strong>需要给帧缓冲附加一个附件。附件是一个内存位置，它能够作为帧缓冲的一个缓冲</strong>，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer Object)。</p><h4 id="纹理附件"><a href="#纹理附件" class="headerlink" title="纹理附件"></a>纹理附件</h4><p>想象帧缓冲(FBO)是一个画框，纹理附件就是可以放进这个画框的”画布”。这些”画布”可以用来：</p><ul><li>存储颜色(类似照片)</li><li>存储深度(物体的远近信息)</li><li>存储模板值(用于特效)</li></ul><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就像它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，<strong>所有渲染操作的结果将会被储存在一个纹理图像中，之后可以在着色器中很方便地使用它。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>,&amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D,texture);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_RGB,<span class="number">800</span>,<span class="number">600</span>,<span class="number">0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 添加颜色纹理附件</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>对于深度和模板缓冲格式不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_DEPTH_COMPONENT,<span class="number">800</span>,<span class="number">600</span>,<span class="number">0</span>,GL_DEPTH_COMPONENT,GL_UNSIGNED_BYTE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 添加深度纹理附件</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_STENCIL_INDEX,<span class="number">800</span>,<span class="number">600</span>,<span class="number">0</span>,GL_STENCIL_INDEX,GL_UNSIGNED_BYTE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 添加模板纹理附件</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h4><p>​    和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，<strong>它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</strong></p><p>​    <strong>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。</strong>然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>,&amp;rbo);</span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER,rbo);</span><br><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER,GL_DEPTH24_STENCIL8,<span class="number">800</span>,<span class="number">600</span>);</span><br><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER,GL_DEPTH_STENCIL_ATTACHMENT,GL_RENDERBUFFER,rbo);</span><br></pre></td></tr></table></figure><p>由于<strong>渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间都不需要从深度和模板缓冲中读取值</strong>，只关心深度和模板测试。我们<strong>需要</strong>深度和模板值用于测试，但不需要对它们进行<strong>采样</strong>，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p><h4 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h4><p>要想绘制场景到一个纹理上，我需要采取以下的步骤：</p><ol><li>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景</li><li>绑定默认的帧缓冲</li><li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</li></ol><p>将帧缓冲的颜色渲染到默认缓冲的纹理上</p><h4 id="反相"><a href="#反相" class="headerlink" title="反相"></a>反相</h4><p>将纹理颜色反相</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="number">1.0</span> - <span class="built_in">texture</span>(screenTexture, TexCoords)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(screenTexture, TexCoords);</span><br><span class="line">    <span class="type">float</span> average = <span class="number">0.2126</span> * FragColor.r + <span class="number">0.7152</span> * FragColor.g + <span class="number">0.0722</span> * FragColor.b;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(average, average, average, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> <span class="keyword">offset</span> = <span class="number">1.0</span> / <span class="number">300.0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> offsets[<span class="number">9</span>] = <span class="type">vec2</span>[](</span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 左上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="keyword">offset</span>), <span class="comment">// 正上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 右上</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 左</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="number">0.0</span>f),   <span class="comment">// 中</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 右</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>, -<span class="keyword">offset</span>), <span class="comment">// 左下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,   -<span class="keyword">offset</span>), <span class="comment">// 正下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>, -<span class="keyword">offset</span>)  <span class="comment">// 右下</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kernel[<span class="number">9</span>] = <span class="type">float</span>[](</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">9</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> sampleTex[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sampleTex[i] = <span class="type">vec3</span>(<span class="built_in">texture</span>(screenTexture, TexCoords.st + offsets[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> col = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        col += sampleTex[i] * kernel[i];</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有模糊、边缘检测等效果,都是利用卷积核.</p><h2 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h2><p>立方体贴图(Cube Map)是将多个纹理组合起来映射到一张纹理上的一种纹理类型.  </p><p>立方体贴图的坐标至关重要,通过一个方向向量进行索引. 方向向量原点位于立方体中心</p><p><img data-src="https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png" alt="img"></p><p>假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; textures_faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="built_in">stbi_load</span>(textures_faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(</span><br><span class="line">        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">        <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure><p>立方体纹理最常用的就是天空盒,而天空盒的核心就是将贴图用在一个立方体上并通过深度测试将贴图作为背景.  一个简单的方法就是利用<code>glDepthMask</code>,首先渲染天空盒,在绘制其他物体之前再启动Mask,更新深度缓冲.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br><span class="line">skyboxShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="comment">// ... 设置观察和投影矩阵</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(skyboxVAO);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, cubemapTexture);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_TRUE);</span><br><span class="line"><span class="comment">// ... 绘制剩下的场景</span></span><br></pre></td></tr></table></figure><p>注意到天空盒的大部分可能会被其他物体覆盖,通过提前深度测试,将已知的深度较大的物体在之后绘制,这样在片段着色器运行之前就直到被其他物体””盖住”了. 因为天空盒总是在最后,设置其z在透视变换后为1即可,在片段着色器中设置其z为w.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> pos = projection * view * <span class="type">vec4</span>(position, <span class="number">1.0</span>); <span class="comment">// view矩阵取消了移动,projection矩阵只对z进行了缩放,而之后通过透视除法将z设置为了1</span></span><br><span class="line">   <span class="built_in">gl_Position</span> = pos.xyww;</span><br></pre></td></tr></table></figure><h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>我们现在<strong>将整个环境映射到了一个纹理对象</strong>上了，能利用这个信息的不仅仅只有天空盒。通过使用环境的立方体贴图，<strong>可以给物体反射和折射的属性。这样使用环境立方体贴图的技术叫做环境映射</strong>(Environment Mapping)，其中最流行的两个是反射(Reflection)和折射(Refraction)。</p><p><img data-src="https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_theory.png" alt="img"></p><p>反射通过眼睛与物体法线向量得到的反射向量对立方体纹理采样</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="type">vec3</span> CalcEnvReflectLight(<span class="type">vec3</span> viewDir,<span class="type">vec3</span> norm) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="built_in">texture</span>(skybox,<span class="built_in">reflect</span>(-viewDir,norm)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当反射应用到一整个物体上时，这个物体看起来就像是钢或者铬这样的高反射性材质. 在现实中大部分的模型都不具有完全反射性。<strong>可以引入反射贴图(Reflection Map)，来给模型更多的细节。与漫反射和镜面光贴图一样，反射贴图也是可以采样的纹理图像，它决定这片段的反射性</strong>。通过使用反射贴图，可以知道模型的哪些部分该以什么强度显示反射。</p><p><img data-src="https://s2.loli.net/2025/01/05/kCJ4toqla1Vy8FL.png" alt="image-20250105144159047"></p><p>环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。</p><p><img data-src="https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction_theory.png" alt="img"></p><p>折射率是光在真空中的传播速度与光在该介质中的传播速度之比,光从介质1射入介质2发生折射时，入射角与折射角的正弦之比叫做介质2相对介质1的折射率. 折射率越大,光线扭曲程度越大. 有一个观察向量I¯，一个法向量N¯，而这次是折射向量R¯。</p><p>观察向量的方向轻微弯曲了。弯折后的向量R¯R¯将会用来从立方体贴图中采样。折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。</p><p>假设看向水面,折射率就是在空气中的折射率/在水中的折射率.</p><p><img data-src="https://s2.loli.net/2025/01/05/qVRmaAPHS14loCg.png" alt="image-20250105144121316"></p><h4 id="动态环境贴图"><a href="#动态环境贴图" class="headerlink" title="动态环境贴图"></a>动态环境贴图</h4><p>​    现在使用的都是静态图像的组合来作为天空盒，看起来很不错，但它<strong>没有在场景中包括可移动的物体</strong>。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</p><p>​    <strong>通过使用帧缓冲能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic Environment Mapping)，因为动态创建了物体周围的立方体贴图，并将其用作环境贴图。</strong></p><p>​    但它有一个很大的缺点：<strong>需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图</strong>，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p><h2 id="高级数据"><a href="#高级数据" class="headerlink" title="高级数据"></a>高级数据</h2><p>缓冲有不同的类型,比如GL_ARRAY_BUFFER,GL_ELEMENT_BUFFER. 不同缓冲有不同用处. 当<code>glGenBuffers()</code>创建缓冲对象后,需要绑定相应类型才有意义. </p><h3 id="填充缓冲数据"><a href="#填充缓冲数据" class="headerlink" title="填充缓冲数据"></a>填充缓冲数据</h3><p>glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的<code>data</code>参数设置为<code>NULL</code>，那么这个函数将只会分配内存，但不进行填充。这在我们需要<strong>预留</strong>(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER,,<span class="built_in"><span class="keyword">sizeof</span></span>(vertices),<span class="literal">NULL</span>,GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER,<span class="number">24</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(data),&amp;data);</span><br></pre></td></tr></table></figure><p>除了使用一次函数调用填充整个缓冲之外，也可以使用glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从<strong>何处</strong>开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</p><p>此外可以获得指向内存的指针,通过一些内存函数进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="keyword">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in"><span class="keyword">sizeof</span></span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in modern c++ </span></span><br><span class="line">  <span class="keyword">auto</span> ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_READ_WRITE);</span><br><span class="line">  std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(skyboxVertices), std::<span class="built_in">end</span>(skyboxVertices),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line">  <span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure><p>使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。<strong>在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE</strong></p><h3 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h3><p>假设数据如下,表示一个点的三种属性,通过glBufferData加载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">      <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>,</span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>,</span><br><span class="line">      <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">-0.5f</span>, <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STREAM_DRAW);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span> *)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">  <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)(<span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer设置了解析这些数据的方式,其中3表示这个属性有几个值,8*sizeof(float)表示下一个点的相同属性的距离,0是偏移量.</p><p>假设读入数据布局不同,比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">      <span class="comment">// positions                 </span></span><br><span class="line">     <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">      <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>,</span><br><span class="line">       <span class="comment">// normals </span></span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">-1.0f</span>, </span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.5f</span>, </span><br><span class="line">      <span class="number">-0.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>, </span><br><span class="line">       <span class="comment">// texture coords</span></span><br><span class="line">      <span class="number">-1.0f</span>, <span class="number">1.0f</span>,   </span><br><span class="line">      <span class="number">0.5f</span>,  <span class="number">0.5f</span>,   </span><br><span class="line">      <span class="number">0.0f</span>,  <span class="number">0.0f</span>, ,&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)(<span class="number">9</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),(<span class="keyword">void</span> *)(<span class="number">18</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br></pre></td></tr></table></figure><p>此外可以通过<code>glBufferSubData</code>将数据从分别的数据加载到缓冲中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(positions), <span class="built_in"><span class="keyword">sizeof</span></span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(positions) + <span class="built_in"><span class="keyword">sizeof</span></span>(normals), <span class="built_in"><span class="keyword">sizeof</span></span>(tex), &amp;tex);</span><br></pre></td></tr></table></figure><h4 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h4><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。 这可以通过刚才的glMapBuffer实现. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GLuint vbo1, vbo2;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo1);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo2);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="keyword">float</span> data[] =&#123;<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo2);</span><br><span class="line">ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_READ_ONLY);</span><br><span class="line"><span class="keyword">float</span> data1[<span class="number">12</span>];</span><br><span class="line">std::<span class="built_in">copy</span>(data1, data1 + <span class="number">12</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br><span class="line">ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span> *&gt;(ptr));</span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure><p>但通过<code>glCopyBufferSubData</code>更方便.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                         GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>readtarget</code>和<code>writetarget</code>参数需要填入复制源和复制目标的缓冲目标。比如可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p><p>但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。<strong>OpenGL提供另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER。</strong>接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vertexData));</span><br></pre></td></tr></table></figure><p>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vertexData));</span><br></pre></td></tr></table></figure><h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>​    <strong>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点</strong>。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，<strong>它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。</strong></p><p>首先定义在c++中绘画命令指定的图元类型,比如<code>GLDrawArrays(GL_POINTS,0,4)</code>绘画点图元,而几何着色器能够作为顶点和片段着色器之间的桥梁,能够增删/修改点的属性. out定义输出的图元以及最多的定点数.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">2</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何着色器需要声明输入和输出的图元类型，以处理从顶点着色器接收的数据并生成新的几何图形。对于输入图元类型，在<code>in</code>关键字前使用布局修饰符（Layout Qualifier），可接收如下图元：</p><ul><li><code>points</code>：用于单个点。图元所包含的最小顶点数 1</li><li><code>lines</code>：用于线段或线带。</li><li><code>lines_adjacency</code>：用于带有相邻信息的线段或线带。</li><li><code>triangles</code>：用于三角形、三角形带或三角形扇。</li><li><code>triangles_adjacency</code>：用于带有相邻信息的三角形或三角形带。</li></ul><p>括号中的数字表示构成该图元所需的最小顶点数。</p><p>对于输出图元类型，在<code>out</code>关键字前同样使用布局修饰符，可设置为：</p><ul><li><code>points</code></li><li><code>line_strip</code></li><li><code>triangle_strip</code></li></ul><p>​    这些输出图元允许几何着色器创建各种形状。例如，为了生成一个三角形，可以将输出定义为<code>triangle_strip</code>并提供3个顶点。</p><p>此外，几何着色器还要求指定其能输出的最大顶点数量，防止超出限制导致OpenGL忽略额外的顶点。此最大值也在<code>out</code>布局修饰符中设定。例如，若要输出一条线段，则应将最大顶点数设为2。</p><p>线条（Line Strip）是由一系列点组成的连续线段，至少需要两个点来形成。每增加一个点，就会与前一个点之间形成一条新的线段。例如，如果有5个顶点，它们会依次相连形成4条线段。</p><p>​    当使用几何着色器时，如果最大输出顶点数设为2，则只能输出一条线段。为了生成更复杂的形状，几何着色器可以通过GLSL提供的内置变量<code>gl_in[]</code>访问来自上一阶段（如顶点着色器）的顶点数据。<code>gl_in[]</code>是一个接口块，它包含了每个输入顶点的位置和其他信息，如<code>gl_Position</code>等。</p><p>​    几何着色器通过调用<code>EmitVertex()</code>函数来发射一个新的顶点，并最终通过<code>EndPrimitive()</code>函数来完成一个图元的定义。代码修改了原始顶点的位置，创建了两个新位置，然后发射了这两个顶点，最后通过调用<code>EndPrimitive()</code>将它们合成为一个线条图元。这样就创建了一条从原始顶点位置向左和向右各平移0.1单位的新线段。</p><p>​    <strong>线条是由连续的点组成，几何着色器可以访问先前阶段的顶点数据并通过发射顶点和结束图元的方法来创建新的几何图形</strong></p><h3 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h3><p>当我们说<strong>爆破</strong>一个物体时，我们并不是指要将宝贵的顶点集给炸掉，我们是要将每个三角形沿着法向量的方向移动一小段时间。效果就是，整个物体看起来像是沿着每个三角形的法线向量<strong>爆炸</strong>一样。</p><p>做法就是在几何着色器中计算一个三角形面的法向量(通过面上的三个点得到两个向量并计算叉乘),在几何着色器中改变顶点位置.</p><h3 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h3><p>​    可以作为一种Debug工具,当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。<strong>光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的</strong>。想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p><p>​    首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>如果我们需要渲染大量物体时，代码看起来会像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amount_of_models_to_draw; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomePreparations</span>(); <span class="comment">// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, amount_of_vertices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为<strong>OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）</strong>。所以，即便渲染顶点非常快，命令GPU去渲染却未必。</p><p>如果<strong>能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)</strong>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从手动设置顶点坐标到加载模型以及OpenGL高级技巧&lt;br&gt;</summary>
    
    
    
    
    <category term="OpenGL" scheme="https://www.sekyoro.top/tags/OpenGL/"/>
    
    <category term="computer graphics" scheme="https://www.sekyoro.top/tags/computer-graphics/"/>
    
  </entry>
  
  <entry>
    <title>Agentic RAG and LLMs-based assistant</title>
    <link href="https://www.sekyoro.top/2024/12/26/Agentic-RAG-and-LLMs-based-assistant/"/>
    <id>https://www.sekyoro.top/2024/12/26/Agentic-RAG-and-LLMs-based-assistant/</id>
    <published>2024-12-26T12:25:13.000Z</published>
    <updated>2024-12-31T10:38:35.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>既text2img和大语言模型之后的热点,AI Agent和RAG,简单来说在既有的多模态大模型基础上打造应用,比如利用多个智能体以及外部数据进行搜索. 目前来看还是有一些发展潜力,这方面的资料多见于Hugging Face,LangChain,llama index等等<br><span id="more"></span></p><p>​    过去一段时间涌现了一大堆大模型,参数量多达几十B,并且这些模型在许多benchmark上都似乎达到了很高的水平(甚至最近OpenAI的o3达到超越普通人的水平,AGI达没达到不知道,Hype是足够了). 普通人想免费下载的大模型就是贴心的llama了,可以在llama上进行微调等操作. 此外文生图等模型既Stable Diffusion v3.5之后,出走后的人员打造FLUX. </p><p>​    种种迹象表明,Foundation Model的发展已经超出普通人能玩的范围了,因为背后耗费这成千上万张显卡以及大量人员精心修剪后的数据。而如何实现长期盈利才是关键,OpenAI早已打出了名声,作为行业标杆,不少人会去订阅ChatGPT Plus,即使再贵. 但其他公式就会遭殃了,毕竟一个人使用一到两种类似的AI服务已经足够,于是形成了类似冠军争夺,专业做AI的,只有前几家才能生成. 大厂可以背靠大量数据集和人力做模型以及服务,中小公司相对更困难. 而普通人貌似要么花钱使用Open(并不Open)AI更高质量服务,要么用开源的模型,事实上,在这个开源领域正在或者应该,在开发者之间流行,作为辅助工具抑或创造性的图片生成,即使无法盈利,但也逐渐变成计算器一样的工具成为普遍现象. 其中的一些有趣技术就包括T2I文生图以及相关的LoRA,ControlNet. 而多模态大语言模型就是RAG和AI Agent了.</p><p>目前国内大中厂以及个人开发者都在这些方向不断努力</p><p><img data-src="https://s2.loli.net/2024/12/26/4HhWUIlqwgAYEKJ.png" alt="image-20241226205431156"></p><h2 id="For-any-API-provider"><a href="#For-any-API-provider" class="headerlink" title="For any API provider"></a>For any API provider</h2><p>因为目前有许多大模型供应商,比如grok,gemini,openai,它们提供不同的大模型和接口. 如果为多个不同供应商分别写然后能够统一进行调用就更好了. HuggingFace提供了相关方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">openai_role_conversions = &#123;</span><br><span class="line">    MessageRole.TOOL_RESPONSE: MessageRole.USER,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAIEngine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name=<span class="string">&quot;gpt-4o&quot;</span></span>):</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        self.client = OpenAI(</span><br><span class="line">            api_key=os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, messages, stop_sequences=[]</span>):</span></span><br><span class="line">        messages = get_clean_message_list(messages, role_conversions=openai_role_conversions)</span><br><span class="line"></span><br><span class="line">        response = self.client.chat.completions.create(</span><br><span class="line">            model=self.model_name,</span><br><span class="line">            messages=messages,</span><br><span class="line">            stop=stop_sequences,</span><br><span class="line">            temperature=<span class="number">0.5</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> response.choices[<span class="number">0</span>].message.content</span><br></pre></td></tr></table></figure><p>核心是构建一个llm_engine然后通过ReactCodeAgent或者其他Agent调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> anthropic <span class="keyword">import</span> Anthropic, AnthropicBedrock</span><br><span class="line"><span class="comment"># Cf this page for using Anthropic from Bedrock: https://docs.anthropic.com/en/api/claude-on-amazon-bedrock</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnthropicEngine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name=<span class="string">&quot;claude-3-5-sonnet-20240620&quot;</span>, use_bedrock=<span class="literal">False</span></span>):</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        <span class="keyword">if</span> use_bedrock:</span><br><span class="line">            self.model_name = <span class="string">&quot;anthropic.claude-3-5-sonnet-20240620-v1:0&quot;</span></span><br><span class="line">            self.client = AnthropicBedrock(</span><br><span class="line">                aws_access_key=os.getenv(<span class="string">&quot;AWS_BEDROCK_ID&quot;</span>),</span><br><span class="line">                aws_secret_key=os.getenv(<span class="string">&quot;AWS_BEDROCK_KEY&quot;</span>),</span><br><span class="line">                aws_region=<span class="string">&quot;us-east-1&quot;</span>,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.client = Anthropic(</span><br><span class="line">                api_key=os.getenv(<span class="string">&quot;ANTHROPIC_API_KEY&quot;</span>),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, messages, stop_sequences=[]</span>):</span></span><br><span class="line">        messages = get_clean_message_list(messages, role_conversions=openai_role_conversions)</span><br><span class="line">        index_system_message, system_prompt = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> index, message <span class="keyword">in</span> <span class="built_in">enumerate</span>(messages):</span><br><span class="line">            <span class="keyword">if</span> message[<span class="string">&quot;role&quot;</span>] == MessageRole.SYSTEM:</span><br><span class="line">                index_system_message = index</span><br><span class="line">                system_prompt = message[<span class="string">&quot;content&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> system_prompt <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;No system prompt found!&quot;</span>)</span><br><span class="line"></span><br><span class="line">        filtered_messages = [message <span class="keyword">for</span> i, message <span class="keyword">in</span> <span class="built_in">enumerate</span>(messages) <span class="keyword">if</span> i != index_system_message]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(filtered_messages) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error, no user message:&quot;</span>, messages)</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        response = self.client.messages.create(</span><br><span class="line">            model=self.model_name,</span><br><span class="line">            system=system_prompt,</span><br><span class="line">            messages=filtered_messages,</span><br><span class="line">            stop_sequences=stop_sequences,</span><br><span class="line">            temperature=<span class="number">0.5</span>,</span><br><span class="line">            max_tokens=<span class="number">2000</span>,</span><br><span class="line">        )</span><br><span class="line">        full_response_text = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> content_block <span class="keyword">in</span> response.content:</span><br><span class="line">            <span class="keyword">if</span> content_block.<span class="built_in">type</span> == <span class="string">&quot;text&quot;</span>:</span><br><span class="line">                full_response_text += content_block.text</span><br><span class="line">        <span class="keyword">return</span> full_response_text</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent = ReactCodeAgent(tools=[], llm_engine=llm_engine)</span><br></pre></td></tr></table></figure><h2 id="Intro-to-RAG"><a href="#Intro-to-RAG" class="headerlink" title="Intro to RAG"></a>Intro to RAG</h2><p>RAG是一种流行的方法，用于解决LLM由于所述内容不在其训练数据中而无法意识到特定内容的问题，或者即使以前看到过该内容也会产生幻觉。这些特定内容可能是专有的、敏感的，或者是最近的和经常更新的。</p><p>如果数据是静态的，并且不定期更改，则可以考虑对大型模型进行微调。然而，在许多情况下，微调可能是昂贵的，并且，当重复进行时（例如，为了解决数据漂移），会导致“模型转移”。这是指模型的行为以一种没有改变的方式发生变化</p><p>RAG（检索增强生成）不需要模型微调。相反，RAG通过向LLM提供从相关数据中检索的附加上下文来工作，以便它可以生成更明智的响应。</p><p><img data-src="https://huggingface.co/datasets/huggingface/cookbook-images/resolve/main/rag-diagram.png" alt="RAG diagram"></p><p>这类应用可以非常方便写文档、报告的人,因为时常会有比较新的消息而大模型训练资料中没有,这个时候可以让大模型主动调用外部工具(比如搜索引擎),或者主动给它额外的工具从而补充大模型的能力.</p><h3 id="简易的RAG工作流"><a href="#简易的RAG工作流" class="headerlink" title="简易的RAG工作流"></a>简易的RAG工作流</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> GitHubIssuesLoader</span><br><span class="line">ACCESS_TOKEN = getpass(<span class="string">&quot;YOUR_GITHUB_PERSONAL_TOKEN&quot;</span>)</span><br><span class="line">loader = GitHubIssuesLoader(repo=<span class="string">&quot;huggingface/peft&quot;</span>, access_token=ACCESS_TOKEN, include_prs=<span class="literal">False</span>, state=<span class="string">&quot;all&quot;</span>)</span><br><span class="line">docs = loader.load()</span><br></pre></td></tr></table></figure><p>使用github加载数据,将数据分块加载，最常见和直接的分块方法是定义一个固定大小的块，以及它们之间是否应该有任何重叠。在块之间保持一些重叠可以让我们在块之间保留一些语义上下文。一般文本的推荐拆分器是RecursiveCharacterTextSplitter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line">splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">512</span>, chunk_overlap=<span class="number">30</span>)</span><br><span class="line">chunked_docs = splitter.split_documents(docs)</span><br></pre></td></tr></table></figure><h4 id="创建embedding和retriever"><a href="#创建embedding和retriever" class="headerlink" title="创建embedding和retriever"></a>创建embedding和retriever</h4><p>需要将文件转为特征,为了创建文档块嵌入,这里使用HuggingFaceEmbeddings和BAAI/ big -base-en-v1.5嵌入模型。Hub上还有许多其他的嵌入模型<a href="https://huggingface.co/spaces/mteb/leaderboard">MTEB Leaderboard - a Hugging Face Space by mteb</a>，使用FAISS作为嵌入特征搜索库,相当于创建一个数据库,其中数据就是嵌入后的特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line"></span><br><span class="line">db = FAISS.from_documents(chunked_docs, HuggingFaceEmbeddings(model_name=<span class="string">&quot;BAAI/bge-base-en-v1.5&quot;</span>))</span><br></pre></td></tr></table></figure><p>设置检索方式,近邻搜索,返回最高的4个结果.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retriever = db.as_retriever(search_type=<span class="string">&quot;similarity&quot;</span>, search_kwargs=&#123;<span class="string">&quot;k&quot;</span>: <span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h4><p>刚才使用了嵌入模型,现在使用对输入prompt以及回复的llm,相关榜单<a href="https://huggingface.co/spaces/open-llm-leaderboard/open_llm_leaderboard">Open LLM Leaderboard - a Hugging Face Space by open-llm-leaderboard</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig</span><br><span class="line"></span><br><span class="line">model_name = <span class="string">&quot;HuggingFaceH4/zephyr-7b-beta&quot;</span></span><br><span class="line"></span><br><span class="line">bnb_config = BitsAndBytesConfig(</span><br><span class="line">    load_in_4bit=<span class="literal">True</span>, bnb_4bit_use_double_quant=<span class="literal">True</span>, bnb_4bit_quant_type=<span class="string">&quot;nf4&quot;</span>, bnb_4bit_compute_dtype=torch.bfloat16</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name, quantization_config=bnb_config)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br></pre></td></tr></table></figure><p>此外对模型做了量化减小体积</p><h4 id="搭建LLM链"><a href="#搭建LLM链" class="headerlink" title="搭建LLM链"></a>搭建LLM链</h4><p>设置pipeline,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> HuggingFacePipeline</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"></span><br><span class="line">text_generation_pipeline = pipeline(</span><br><span class="line">    model=model,</span><br><span class="line">    tokenizer=tokenizer,</span><br><span class="line">    task=<span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.2</span>,</span><br><span class="line">    do_sample=<span class="literal">True</span>,</span><br><span class="line">    repetition_penalty=<span class="number">1.1</span>,</span><br><span class="line">    return_full_text=<span class="literal">True</span>,</span><br><span class="line">    max_new_tokens=<span class="number">400</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">llm = HuggingFacePipeline(pipeline=text_generation_pipeline)</span><br><span class="line"></span><br><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;|system|&gt;</span></span><br><span class="line"><span class="string">Answer the question based on your knowledge. Use the following context to help:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/s&gt;</span></span><br><span class="line"><span class="string">&lt;|user|&gt;</span></span><br><span class="line"><span class="string">&#123;question&#125;</span></span><br><span class="line"><span class="string">&lt;/s&gt;</span></span><br><span class="line"><span class="string">&lt;|assistant|&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;context&quot;</span>, <span class="string">&quot;question&quot;</span>],</span><br><span class="line">    template=prompt_template,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">llm_chain = prompt | llm | StrOutputParser()</span><br></pre></td></tr></table></figure><p>结合llm_chain搭配retriver</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnablePassthrough</span><br><span class="line"></span><br><span class="line">retriever = db.as_retriever()</span><br><span class="line"></span><br><span class="line">rag_chain = &#123;<span class="string">&quot;context&quot;</span>: retriever, <span class="string">&quot;question&quot;</span>: RunnablePassthrough()&#125; | llm_chain</span><br></pre></td></tr></table></figure><h4 id="比较结果"><a href="#比较结果" class="headerlink" title="比较结果"></a>比较结果</h4><p>在没有rag下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;How do you combine multiple adapters?&quot;</span></span><br><span class="line">llm_chain.invoke(&#123;<span class="string">&quot;context&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;question&quot;</span>: question&#125;)</span><br></pre></td></tr></table></figure><p>在有rag下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rag_chain.invoke(question)</span><br></pre></td></tr></table></figure><h2 id="Agent-with-tool-calling"><a href="#Agent-with-tool-calling" class="headerlink" title="Agent with tool-calling"></a>Agent with tool-calling</h2><p>大模型搭配tool calling(比如调用计算器,编程语言解析器,浏览器搜索等)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> load_tool, ReactCodeAgent, HfApiEngine</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import tool from Hub</span></span><br><span class="line">image_generation_tool = load_tool(<span class="string">&quot;m-ric/text-to-image&quot;</span>, cache=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import tool from LangChain</span></span><br><span class="line"><span class="keyword">from</span> transformers.agents.search <span class="keyword">import</span> DuckDuckGoSearchTool</span><br><span class="line"></span><br><span class="line">search_tool = DuckDuckGoSearchTool()</span><br><span class="line"></span><br><span class="line">llm_engine = HfApiEngine(<span class="string">&quot;Qwen/Qwen2.5-72B-Instruct&quot;</span>)</span><br><span class="line"><span class="comment"># Initialize the agent with both tools</span></span><br><span class="line">agent = ReactCodeAgent(tools=[image_generation_tool, search_tool], llm_engine=llm_engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run it!</span></span><br><span class="line">result = agent.run(</span><br><span class="line">    <span class="string">&quot;Generate me a photo of the car that James bond drove in the latest movie.&quot;</span>,</span><br><span class="line">)</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p>使用Qwen-2.5大模型,搭配文生图和搜索工具,相当于结合了多个模型和外部工具,让原本单一的模型具备多种功能.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> langchain.docstore.document <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"><span class="keyword">from</span> langchain_community.embeddings <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line">knowledge_base = datasets.load_dataset(<span class="string">&quot;m-ric/huggingface_doc&quot;</span>, split=<span class="string">&quot;train&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source_docs = [</span><br><span class="line">    Document(page_content=doc[<span class="string">&quot;text&quot;</span>], metadata=&#123;<span class="string">&quot;source&quot;</span>: doc[<span class="string">&quot;source&quot;</span>].split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>]&#125;) <span class="keyword">for</span> doc <span class="keyword">in</span> knowledge_base</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">docs_processed = RecursiveCharacterTextSplitter(chunk_size=<span class="number">500</span>).split_documents(source_docs)[:<span class="number">1000</span>]</span><br><span class="line"></span><br><span class="line">embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;thenlper/gte-small&quot;</span>)</span><br><span class="line">vectordb = FAISS.from_documents(documents=docs_processed, embedding=embedding_model)</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> transformers.agents <span class="keyword">import</span> Tool</span><br><span class="line"><span class="keyword">from</span> langchain_core.vectorstores <span class="keyword">import</span> VectorStore</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieverTool</span>(<span class="params">Tool</span>):</span></span><br><span class="line">    name = <span class="string">&quot;retriever&quot;</span></span><br><span class="line">    description = (</span><br><span class="line">        <span class="string">&quot;Retrieves some documents from the knowledge base that have the closest embeddings to the input query.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    inputs = &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The query to perform. This should be semantically close to your target documents. Use the affirmative form rather than a question.&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;source&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;number_of_documents&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;the number of documents to retrieve. Stay under 10 to avoid drowning in docs&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    output_type = <span class="string">&quot;string&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vectordb: VectorStore, all_sources: <span class="built_in">str</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        self.vectordb = vectordb</span><br><span class="line">        self.inputs[<span class="string">&quot;source&quot;</span>][<span class="string">&quot;description&quot;</span>] = (</span><br><span class="line">            <span class="string">f&quot;The source of the documents to search, as a str representation of a list. Possible values in the list are: <span class="subst">&#123;all_sources&#125;</span>. If this argument is not provided, all sources will be searched.&quot;</span>.replace(</span><br><span class="line">                <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;`&quot;</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, query: <span class="built_in">str</span>, source: <span class="built_in">str</span> = <span class="literal">None</span>, number_of_documents=<span class="number">7</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(query, <span class="built_in">str</span>), <span class="string">&quot;Your search query must be a string&quot;</span></span><br><span class="line">        number_of_documents = <span class="built_in">int</span>(number_of_documents)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> source:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(source, <span class="built_in">str</span>) <span class="keyword">and</span> <span class="string">&quot;[&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(source):  <span class="comment"># if the source is not representing a list</span></span><br><span class="line">                source = [source]</span><br><span class="line">            source = json.loads(<span class="built_in">str</span>(source).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&#x27;&quot;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        docs = self.vectordb.similarity_search(</span><br><span class="line">            query,</span><br><span class="line">            <span class="built_in">filter</span>=(&#123;<span class="string">&quot;source&quot;</span>: source&#125; <span class="keyword">if</span> source <span class="keyword">else</span> <span class="literal">None</span>),</span><br><span class="line">            k=number_of_documents,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(docs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;No documents found with this filtering. Try removing the source filter.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Retrieved documents:\n\n&quot;</span> + <span class="string">&quot;\n===Document===\n&quot;</span>.join([doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> docs])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers.agents <span class="keyword">import</span> HfApiEngine, ReactJsonAgent</span><br><span class="line"></span><br><span class="line">llm_engine = HfApiEngine(<span class="string">&quot;Qwen/Qwen2.5-72B-Instruct&quot;</span>)</span><br><span class="line"></span><br><span class="line">retriever_tool = RetrieverTool(vectordb=vectordb, all_sources=all_sources)</span><br><span class="line">agent = ReactJsonAgent(tools=[retriever_tool], llm_engine=llm_engine, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">agent_output = agent.run(<span class="string">&quot;Please show me a LORA finetuning script&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Final output:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(agent_output)</span><br></pre></td></tr></table></figure><p>通过RAG以及迭代的询问提升回答质量,首先还是加载数据,分块,编码为向量加载到一个向量数据库. </p><p><img data-src="https://s2.loli.net/2024/12/26/WSB5vpIPZzTwC31.png" alt="image-20241226215424509"></p><p>huggingface的transformers库自带调用解释器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> ReactCodeAgent</span><br><span class="line"></span><br><span class="line">agent = ReactCodeAgent(tools=[], llm_engine=HfApiEngine(<span class="string">&quot;Qwen/Qwen2.5-72B-Instruct&quot;</span>))</span><br><span class="line"></span><br><span class="line">code = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">list=[0, 1, 2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    print(list(i))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">final_answer = agent.run(</span><br><span class="line">    <span class="string">&quot;I have some code that creates a bug: please debug it, then run it to make sure it works and return the final code&quot;</span>,</span><br><span class="line">    code=code,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结合OpenAI的接口制作agent.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> transformers.agents.llm_engine <span class="keyword">import</span> MessageRole, get_clean_message_list</span><br><span class="line"></span><br><span class="line">openai_role_conversions = &#123;</span><br><span class="line">    MessageRole.TOOL_RESPONSE: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAIEngine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name=<span class="string">&quot;gpt-4o-2024-05-13&quot;</span></span>):</span></span><br><span class="line">        self.model_name = model_name</span><br><span class="line">        self.client = OpenAI(</span><br><span class="line">            api_key=os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, messages, stop_sequences=[]</span>):</span></span><br><span class="line">        <span class="comment"># Get clean message list</span></span><br><span class="line">        messages = get_clean_message_list(messages, role_conversions=openai_role_conversions)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get LLM output</span></span><br><span class="line">        response = self.client.chat.completions.create(</span><br><span class="line">            model=self.model_name,</span><br><span class="line">            messages=messages,</span><br><span class="line">            stop=stop_sequences,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> response.choices[<span class="number">0</span>].message.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">openai_engine = OpenAIEngine()</span><br><span class="line">agent = ReactCodeAgent(llm_engine=openai_engine, tools=[])</span><br><span class="line"></span><br><span class="line">code = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">list=[0, 1, 2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(4):</span></span><br><span class="line"><span class="string">    print(list(i))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">final_answer = agent.run(</span><br><span class="line">    <span class="string">&quot;I have some code that creates a bug: please debug it and return the final code&quot;</span>,</span><br><span class="line">    code=code,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Agentic-RAG"><a href="#Agentic-RAG" class="headerlink" title="Agentic RAG"></a>Agentic RAG</h2><p>单纯的RAG也有局限性，最重要的是以下两点：</p><ul><li>它只执行一个检索步骤：如果结果不好，那么生成的结果也会不好。</li><li>语义相似度是以用户查询作为参考来计算的，这可能是次优的：例如，用户查询通常是一个问题，而包含真实答案的文档就是确定句式，因此与疑问形式的其他源文档相比，其相似度得分将被降低，从而导致丢失相关信息的风险。</li></ul><p>但是可以通过创建一个RAG代理来缓解这些问题：</p><ol><li>不直接使用用户的问题作为查询,agent将结合用户输入</li><li>agent可以生成片段以便重新检索</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> langchain.docstore.document <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"><span class="keyword">from</span> langchain_community.embeddings <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores.utils <span class="keyword">import</span> DistanceStrategy</span><br><span class="line"></span><br><span class="line">knowledge_base = datasets.load_dataset(<span class="string">&quot;m-ric/huggingface_doc&quot;</span>, split=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">source_docs = [</span><br><span class="line">    Document(page_content=doc[<span class="string">&quot;text&quot;</span>], metadata=&#123;<span class="string">&quot;source&quot;</span>: doc[<span class="string">&quot;source&quot;</span>].split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>]&#125;) <span class="keyword">for</span> doc <span class="keyword">in</span> knowledge_base</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter.from_huggingface_tokenizer(</span><br><span class="line">    AutoTokenizer.from_pretrained(<span class="string">&quot;thenlper/gte-small&quot;</span>),</span><br><span class="line">    chunk_size=<span class="number">200</span>,</span><br><span class="line">    chunk_overlap=<span class="number">20</span>,</span><br><span class="line">    add_start_index=<span class="literal">True</span>,</span><br><span class="line">    strip_whitespace=<span class="literal">True</span>,</span><br><span class="line">    separators=[<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Split docs and keep only unique ones</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Splitting documents...&quot;</span>)</span><br><span class="line">docs_processed = []</span><br><span class="line">unique_texts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> tqdm(source_docs):</span><br><span class="line">    new_docs = text_splitter.split_documents([doc])</span><br><span class="line">    <span class="keyword">for</span> new_doc <span class="keyword">in</span> new_docs:</span><br><span class="line">        <span class="keyword">if</span> new_doc.page_content <span class="keyword">not</span> <span class="keyword">in</span> unique_texts:</span><br><span class="line">            unique_texts[new_doc.page_content] = <span class="literal">True</span></span><br><span class="line">            docs_processed.append(new_doc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Embedding documents... This should take a few minutes (5 minutes on MacBook with M1 Pro)&quot;</span>)</span><br><span class="line">embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;thenlper/gte-small&quot;</span>)</span><br><span class="line">vectordb = FAISS.from_documents(</span><br><span class="line">    documents=docs_processed,</span><br><span class="line">    embedding=embedding_model,</span><br><span class="line">    distance_strategy=DistanceStrategy.COSINE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20241228204813028.png" alt="image-20241228204813028"></p><h2 id="Use-local-data"><a href="#Use-local-data" class="headerlink" title="Use local data"></a>Use local data</h2><p><a href="https://huggingface.co/learn/cookbook/rag_with_unstructured_data">Building RAG with Custom Unstructured Data</a></p><p>许多重要的知识都以各种格式存储，如pdf、电子邮件、Markdown文件、PowerPoint演示文稿、HTML页面、Word文档等。</p><p>如何预处理所有这些数据,因为这些文件的格式各不相同,要么搭配langchain等工具分别进行解析,要么直接使用现有工具库<a href="https://python.langchain.com/docs/introduction/">Introduction | 🦜️🔗 LangChain</a>,<a href="https://docs.unstructured.io/welcome">Unstructured - Unstructured</a></p><h3 id="本地推理应用与库"><a href="#本地推理应用与库" class="headerlink" title="本地推理应用与库"></a>本地推理应用与库</h3><p>目前有许多大模型本地推理应用,比如Ollama,LMStudio,GPT4All等等,而它们背后的推理库也有很多,比如<a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a>,<a href="https://huggingface.co/blog/introduction-to-ggml">ggml</a>. 通过利用Ollama等工具搭配LangChain可以更高效及其定制化属于自己的LLM应用.</p><p>Ollama本身提供了API服务,通过这个服务与用户本地文件和prompt,可以搭建一个小应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:11434/api/chat -d &#x27;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;llama3.2&quot;,</span><br><span class="line">  &quot;messages&quot;: [</span><br><span class="line">    &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;why is the sky blue?&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><p>注意这个返回值会是一个JSON流.具体来说, 通过<a href="https://python.langchain.com/docs/integrations/chat/ollama/">ChatOllama | 🦜️🔗 LangChain</a>获得更好的处理,再利用FastAPI或Sanic搭建web用户界面,结合上传用户文件等搭建一个应用.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_ollama <span class="keyword">import</span> OllamaLLM</span><br><span class="line"></span><br><span class="line">model = OllamaLLM(model=<span class="string">&quot;llama3&quot;</span>)</span><br><span class="line">model.invoke(<span class="string">&quot;Come up with 10 names for a song about parrots&quot;</span>)</span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20241231183826980.png" alt="image-20241231183826980"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;既text2img和大语言模型之后的热点,AI Agent和RAG,简单来说在既有的多模态大模型基础上打造应用,比如利用多个智能体以及外部数据进行搜索. 目前来看还是有一些发展潜力,这方面的资料多见于Hugging Face,LangChain,llama index等等&lt;br&gt;</summary>
    
    
    
    
    <category term="AI Agent" scheme="https://www.sekyoro.top/tags/AI-Agent/"/>
    
    <category term="RAG" scheme="https://www.sekyoro.top/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL中不可忽视的部分:glsl、glm、assimp以及更多</title>
    <link href="https://www.sekyoro.top/2024/12/25/glsl%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/12/25/glsl%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-12-25T14:15:40.000Z</published>
    <updated>2025-01-06T14:17:57.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在OpenGL中着色器的编程语言叫做GLSL,类似C语言但是内置了许多有用的函数. 这里简单学习其基础语法和包含特殊函数.<br><span id="more"></span></p><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>着色器编程语言,在GPU下编程</p><h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p>这里使用vscode进行开发,由于着色器语言不像C++,Java这种通用语言,它的语法检查和Lint没有这么丰富. 在vscode主要下载两个插件,一个是语法高亮<a href="https://marketplace.visualstudio.com/items?itemName=slevesque.shader">Shader languages support for VS Code - Visual Studio Marketplace</a>,另一个是Lint<a href="https://github.com/hsimpson/vscode-glsllint?tab=readme-ov-file">hsimpson/vscode-glsllint: VSCode extension to lint GLSL shading language files</a>.</p><p><img data-src="https://s2.loli.net/2024/12/26/RenYMiV8qSGBm4y.png" alt="image-20241226175503864"></p><p>此外Lint的插件本身不提供Linter,需要自己下载<a href="https://github.com/KhronosGroup/glslang">KhronosGroup/glslang: Khronos-reference front end for GLSL/ESSL, partial front end for HLSL, and a SPIR-V generator.</a></p><p>语法提示规则与文件名后缀相关</p><p>The applied stage-specific rules are based on the file extension:</p><ul><li><code>.vert</code> for a vertex shader</li><li><code>.tesc</code> for a tessellation control shader</li><li><code>.tese</code> for a tessellation evaluation shader</li><li><code>.geom</code> for a geometry shader</li><li><code>.frag</code> for a fragment shader</li><li><code>.comp</code> for a compute shader</li></ul><p>For ray tracing pipeline shaders:</p><ul><li><code>.rgen</code> for a ray generation shader</li><li><code>.rint</code> for a ray intersection shader</li><li><code>.rahit</code> for a ray any-hit shader</li><li><code>.rchit</code> for a ray closest-hit shader</li><li><code>.rmiss</code> for a ray miss shader</li><li><code>.rcall</code> for a callable shader</li></ul><p>此外还可以配置代码片段<a href="https://gist.github.com/lewislepton/8b17f56baa7f1790a70284e7520f9623">GLSL snippets for visual studio code/kode studio</a>,输入缩写即可提示.</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>float,int,bool,vec,mat, struct,[]</p><h3 id="重要辅助函数"><a href="#重要辅助函数" class="headerlink" title="重要辅助函数"></a>重要辅助函数</h3><h4 id="向量和矩阵运算"><a href="#向量和矩阵运算" class="headerlink" title="向量和矩阵运算"></a>向量和矩阵运算</h4><p>dot,cross,normalize,transpose,inverse</p><h4 id="纹理采样"><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h4><p>texture,mix</p><h4 id="光照计算"><a href="#光照计算" class="headerlink" title="光照计算"></a>光照计算</h4><p>clamp,mix,reflect</p><h3 id="高级GLSL"><a href="#高级GLSL" class="headerlink" title="高级GLSL"></a>高级GLSL</h3><p>glsl定义了几个以<code>gl_</code>为前缀的变量，它们能提供给我们更多的方式来读取/写入数据。比如顶点着色器的输出向量gl_Position和片段着色器的gl_FragCoord。</p><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p><strong>gl_PointSize</strong></p><p>通过gl_PointSize设置GL_POINT图元的大小,在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，需要启用OpenGL的GL_PROGRAM_POINT_SIZE：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_PROGRAM_POINT_SIZE);</span><br></pre></td></tr></table></figure><p><strong>gl_VertexID</strong></p><p>gl_Position和gl_PointSize都是<strong>输出变量</strong>，因为它们的值是作为顶点着色器的输出被读取的。可以对它们进行写入，来改变结果。</p><p>顶点着色器还提供了一个有趣的<strong>输入变量</strong>，只能对它进行读取，它叫做gl_VertexID。</p><p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。<strong>当使用glDrawElements进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引</strong>。当使用glDrawArrays不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</p><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>GLSL提供给两个输入变量：gl_FragCoord和gl_FrontFacing。</p><p><strong>gl_FragCoord</strong></p><p>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。 可以利用它的z值(也就是深度)和xy空间坐标(屏幕空间,归一到[0,1])</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FragCoord</span>.x &lt; <span class="number">400</span>)</span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gl_FrontFacing</strong></p><p>提到OpenGL根据顶点的环绕顺序来决定一个面是正向还是背向面。如果我们不（启用GL_FACE_CULL来）使用面剔除，那么<strong>gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分</strong>。</p><p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是<code>true</code>，否则就是<code>false</code></p><p>如果开启了面剔除，就看不到箱子内部的面了，再使用gl_FrontFacing就没有意义了。</p><p><strong>gl_FragDepth</strong></p><p>输入变量gl_FragCoord的深度值是一个只读(Read-only)变量,不能修改片段的窗口空间坐标，但实际上<strong>修改片段的深度值还是可能的</strong>。<strong>GLSL提供一个叫做gl_FragDepth的输出变量，可以使用它来在着色器内设置片段的深度值。</strong></p><p>要想设置深度值，直接写入一个0.0到1.0之间的float值到输出变量就可以了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_FragDepth</span> = <span class="number">0.0</span>; <span class="comment">// 这个片段现在的深度值为 0.0</span></span><br></pre></td></tr></table></figure><p>如果着色器没有写入值到gl_FragDepth，它会自动取用<code>gl_FragCoord.z</code>的值。但是只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会<strong>禁用所有的提前深度测试</strong>(Early Depth Testing)。它被禁用的原因是，OpenGL无法在片段着色器运行<strong>之前</strong>得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。</p><p>从4.2起,在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (depth_&lt;condition&gt;) <span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_FragDepth</span>;</span><br></pre></td></tr></table></figure><p><code>condition</code>可以为下面的值：</p><div class="table-container"><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>any</code></td><td style="text-align:left">默认值。提前深度测试是禁用的，你会损失很多性能</td></tr><tr><td style="text-align:left"><code>greater</code></td><td style="text-align:left">你只能让深度值比<code>gl_FragCoord.z</code>更大</td></tr><tr><td style="text-align:left"><code>less</code></td><td style="text-align:left">你只能让深度值比<code>gl_FragCoord.z</code>更小</td></tr><tr><td style="text-align:left"><code>unchanged</code></td><td style="text-align:left">如果你要写入<code>gl_FragDepth</code>，你将只能写入<code>gl_FragCoord.z</code>的值</td></tr></tbody></table></div><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 420 core</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">depth_less</span>) <span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_FragDepth</span>;</span><br><span class="line">voif main&#123;</span><br><span class="line">    <span class="built_in">gl_FragDepth</span> = <span class="built_in">gl_FragCoord</span>.z+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h4><p>为了方便在着色器之间传递数据,可以定义in out块,类似结构体</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> <span class="built_in">texture</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(<span class="built_in">texture</span>, fs_in.TexCoords);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来.它在几何着色器这样穿插特定着色器阶段的场景下会很有用。</p><h4 id="Uniform缓冲对象"><a href="#Uniform缓冲对象" class="headerlink" title="Uniform缓冲对象"></a>Uniform缓冲对象</h4><p>假设多个着色器都包含一个uniform变量,它们的值相同,为了不重复地设置,可以使用Uniform缓冲对象.<strong>允许定义一系列在多个着色器程序中相同的全局Uniform变量</strong>。当<strong>使用Uniform缓冲对象的时候，只需要设置相关的uniform一次</strong>。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices</span><br><span class="line">    <span class="comment">// 定义的Uniform块对它的内容使用一个特定的内存布局。这个语句设置了Uniform块布局(Uniform Block Layout)。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Uniform块储存了两个4x4矩阵。<strong>Uniform块中的变量可以直接访问，不需要加块名作为前缀。</strong> 每个声明了这个Uniform块的着色器都能够访问这些矩阵。</p><h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><p>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</p><p>假设着色器中有以下的这个Uniform块：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">    <span class="type">vec3</span>  vector;</span><br><span class="line">    <span class="type">mat4</span>  matrix;</span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>];</span><br><span class="line">    <span class="type">bool</span>  boolean;</span><br><span class="line">    <span class="type">int</span>   integer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。<strong>每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型</strong>，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。这个特性本身很棒，但是会造成麻烦。</p><p><strong>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的</strong>。使用共享布局时，GLSL是<strong>可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变</strong>。<strong>因为无法知道每个uniform变量的偏移量，我们也就不知道如何准确地填充Uniform缓冲</strong>了。我们能够使用像是<strong>glGetUniformIndices这样的函数来查询这个信息</strong></p><p>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这<strong>显式地</strong>声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。</p><p>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。<strong>一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</strong></p><p>GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个<code>N</code>来表示。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">布局规则</th></tr></thead><tbody><tr><td style="text-align:left">标量，比如int和bool</td><td style="text-align:left">每个标量的基准对齐量为N。</td></tr><tr><td style="text-align:left">向量</td><td style="text-align:left">2N或者4N。这意味着vec3的基准对齐量为4N。</td></tr><tr><td style="text-align:left">标量或向量的数组</td><td style="text-align:left">每个元素的基准对齐量与vec4的相同。</td></tr><tr><td style="text-align:left">矩阵</td><td style="text-align:left">储存为列向量的数组，每个向量的基准对齐量与vec4的相同。</td></tr><tr><td style="text-align:left">结构体</td><td style="text-align:left">等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。</td></tr></tbody></table></div><p>使用计算后的偏移量值，根据std140布局的规则，我们就能使用像是glBufferSubData的函数将变量数据按照偏移量填充进缓冲中了。<strong>虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。</strong></p><p><strong>通过在Uniform块定义之前添加<code>layout (std140)</code>语句，告诉OpenGL这个Uniform块使用的是std140布局。</strong>除此之外<strong>还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量</strong>。</p><p>​    我们已经见过<code>shared</code>布局了，剩下的一个布局是<code>packed</code>。<strong>当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。</strong></p><h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><p>我们已经讨论了如何在着色器中定义Uniform块，并设定它们的内存布局了，但我们还没有讨论该如何使用它们。</p><p>首先，我们需要调用glGenBuffers，创建一个Uniform缓冲对象。一旦我们有了一个缓冲对象，我们需要将它绑定到GL_UNIFORM_BUFFER目标，并调用glBufferData，分配足够的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> uboExampleBlock;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboExampleBlock); <span class="comment">//创建uniform buffer对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">152</span>, <span class="literal">NULL</span>, GL_STATIC_DRAW); <span class="comment">// 分配152字节的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>每当我们需要对缓冲更新或者插入数据，我们都会绑定到uboExampleBlock，并使用glBufferSubData来更新它的内存。我们只需要更新这个Uniform缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了</p><p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个：</p><p><img data-src="https://learnopengl-cn.github.io/img/04/08/advanced_glsl_binding_points.png" alt="img"></p><p>你可以看到，我们可以绑定多个Uniform缓冲到不同的绑定点上。因为着色器A和着色器B都有一个链接到绑定点0的Uniform块，它们的Uniform块将会共享相同的uniform数据，uboMatrices，前提条件是两个着色器都定义了相同的Matrices Uniform块。</p><p>为了将Uniform块绑定到一个特定的绑定点中，我们需要调用glUniformBlockBinding函数，它的第一个参数是一个程序对象，之后是一个Uniform块索引和链接到的绑定点。Uniform块索引(Uniform Block Index)是着色器中已定义Uniform块的位置值索引。这可以通过调用glGetUniformBlockIndex来获取，它接受一个程序对象和Uniform块的名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lights_index = <span class="built_in">glGetUniformBlockIndex</span>(shaderA.ID, <span class="string">&quot;Lights&quot;</span>);   </span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderA.ID, lights_index, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>从OpenGL 4.2版本起，也可以添加一个布局标识符，显式地将Uniform块的绑定点储存在着色器中，这样就不用再调用glGetUniformBlockIndex和glUniformBlockBinding了。下面的代码显式地设置了Lights Uniform块的绑定点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">layout</span>(std140, binding = <span class="number">2</span>) uniform Lights &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>接下来，我们还需要绑定Uniform缓冲对象到相同的绑定点上，这可以使用glBindBufferBase或glBindBufferRange来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBufferBase</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock); </span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock, <span class="number">0</span>, <span class="number">152</span>);</span><br></pre></td></tr></table></figure><p>glBindbufferBase需要一个目标，一个绑定点索引和一个Uniform缓冲对象作为它的参数。这个函数将uboExampleBlock链接到绑定点2上，自此，绑定点的两端都链接上了。你也可以使用glBindBufferRange函数，它需要一个附加的偏移量和大小参数，这样子你可以绑定Uniform缓冲的特定一部分到绑定点中。通过使用glBindBufferRange函数，你可以让多个不同的Uniform块绑定到同一个Uniform缓冲对象上。</p><p>现在，所有的东西都配置完毕了，我们可以开始向Uniform缓冲中添加数据了。只要我们需要，就可以使用glBufferSubData函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新uniform变量boolean，我们可以用以下方式更新Uniform缓冲对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="keyword">int</span> b = <span class="literal">true</span>; <span class="comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">144</span>, <span class="number">4</span>, &amp;b); </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>同样的步骤也能应用到Uniform块中其它的uniform变量上，但需要使用不同的范围参数。</p><p>Uniform缓冲对象比起独立的uniform有很多好处。第一，<strong>一次设置很多uniform会比一个一个设置多个uniform要快很多</strong>。第二，<strong>比起在多个着色器中修改同样的uniform，在Uniform缓冲中修改一次会更容易一些</strong>。最后一个好处可能不会立即显现，<strong>如果使用Uniform缓冲对象的话，你可以在着色器中使用更多的uniform</strong>。OpenGL限制了它能够处理的uniform数量，这可以通过GL_MAX_VERTEX_UNIFORM_COMPONENTS来查询。当<strong>使用Uniform缓冲对象时，最大的数量会更高。</strong>所以，当你达到了uniform的最大数量时（比如再做骨骼动画(Skeletal Animation)的时候），总是可以选择使用Uniform缓冲对象。</p><h2 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h2><p>与opengl向适应的向量计算库</p><ol><li><strong>向量类</strong>:<ul><li><code>glm::vec2</code>: 2D 向量。</li><li><code>glm::vec3</code>: 3D 向量。</li><li><code>glm::vec4</code>: 4D 向量（通常用于颜色或齐次坐标）。</li></ul></li><li><strong>矩阵类</strong>:<ul><li><code>glm::mat2</code>: 2x2 矩阵。</li><li><code>glm::mat3</code>: 3x3 矩阵。</li><li><code>glm::mat4</code>: 4x4 矩阵（常用于变换矩阵）。</li></ul></li><li><strong>四元数类</strong>:<ul><li><code>glm::quat</code>: 四元数，用于表示旋转。</li></ul></li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h4><ul><li><p><strong>创建向量</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">v</span><span class="params">(<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>向量加法</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 sum = v1 + v2;</span><br></pre></td></tr></table></figure></li><li><p><strong>向量减法</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 difference = v1 - v2;</span><br></pre></td></tr></table></figure></li><li><p><strong>标量乘法</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 scaled = v * scalar;</span><br></pre></td></tr></table></figure></li><li><p><strong>点积</strong> (<code>dot product</code>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> dotProduct = glm::<span class="built_in">dot</span>(v1, v2);</span><br></pre></td></tr></table></figure></li><li><p><strong>叉积</strong> (<code>cross product</code>) - 仅适用于3D向量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 crossProduct = glm::<span class="built_in">cross</span>(v1, v2);</span><br></pre></td></tr></table></figure></li><li><p><strong>长度/模</strong> (<code>length/magnitude</code>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> length = glm::<span class="built_in">length</span>(v);</span><br></pre></td></tr></table></figure></li><li><p><strong>标准化</strong> (<code>normalize</code>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 normalizedV = glm::<span class="built_in">normalize</span>(v);</span><br></pre></td></tr></table></figure></li></ul><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><ul><li><p><strong>创建单位矩阵</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 identity = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>平移矩阵</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 translateMatrix = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(x, y, z));</span><br></pre></td></tr></table></figure></li><li><p><strong>缩放矩阵</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 scaleMatrix = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(sx, sy, sz));</span><br></pre></td></tr></table></figure></li><li><p><strong>旋转矩阵</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 rotateMatrix = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), angle, glm::<span class="built_in">vec3</span>(axisX, axisY, axisZ));</span><br></pre></td></tr></table></figure></li><li><p><strong>组合变换</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation) *</span><br><span class="line">                  glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), rotationAngle, rotationAxis) *</span><br><span class="line">                  glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), scale);</span><br></pre></td></tr></table></figure></li><li><p><strong>视图矩阵</strong> (<code>lookAt</code>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::<span class="built_in">lookAt</span>(cameraPosition, cameraTarget, upVector);</span><br></pre></td></tr></table></figure></li><li><p><strong>投影矩阵</strong> (<code>perspective</code> 和 <code>orthographic</code>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(fov), aspectRatio, nearPlane, farPlane);</span><br><span class="line"><span class="comment">// 或者正交投影</span></span><br><span class="line">glm::mat4 orthoProjection = glm::<span class="built_in">ortho</span>(left, right, bottom, top, nearPlane, farPlane);</span><br></pre></td></tr></table></figure></li></ul><h4 id="四元数操作"><a href="#四元数操作" class="headerlink" title="四元数操作"></a>四元数操作</h4><ul><li><p><strong>创建四元数</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::quat q = glm::<span class="built_in">quat</span>(angle, glm::<span class="built_in">vec3</span>(axisX, axisY, axisZ));</span><br></pre></td></tr></table></figure></li><li><p><strong>从旋转矩阵转换到四元数</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::quat qFromMat = glm::<span class="built_in">quat_cast</span>(rotationMatrix);</span><br></pre></td></tr></table></figure></li><li><p><strong>四元数插值</strong> (<code>slerp</code>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::quat interpolatedQ = glm::<span class="built_in">slerp</span>(q1, q2, t);</span><br></pre></td></tr></table></figure></li><li><p><strong>四元数转欧拉角</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 eulerAngles = glm::<span class="built_in">eulerAngles</span>(q);</span><br></pre></td></tr></table></figure></li><li><p><strong>四元数转旋转矩阵</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 matFromQuat = glm::<span class="built_in">mat4_cast</span>(q);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h2><p>模型加载库</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assimp::Importer::<span class="built_in">ReadFile</span>()</span><br></pre></td></tr></table></figure><p>​    该类将读取文件并处理其数据，将导入的数据作为指向一个对象的指针返回。现在可以从文件中提取所需的数据。</p><p>​    导入器为自己管理所有资源。如果导入器被销毁，那么由它创建/读取的所有数据也将被销毁。因此，使用Importer最简单的方法是在本地创建一个实例，使用它的结果，然</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assimp/Importer.hpp&gt;</span>      <span class="comment">// C++ importer interface</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assimp/scene.h&gt;</span>           <span class="comment">// Output data structure</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assimp/postprocess.h&gt;</span>     <span class="comment">// Post processing flags</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoTheImportThing</span><span class="params">( <span class="keyword">const</span> std::string&amp; pFile)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create an instance of the Importer class</span></span><br><span class="line">  Assimp::Importer importer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// And have it read the given file with some example postprocessing</span></span><br><span class="line">  <span class="comment">// Usually - if speed is not the most important aspect for you - you&#x27;ll</span></span><br><span class="line">  <span class="comment">// probably to request more postprocessing than we do in this example.</span></span><br><span class="line">  <span class="keyword">const</span> aiScene* scene = importer.<span class="built_in">ReadFile</span>( pFile,</span><br><span class="line">    aiProcess_CalcTangentSpace       |</span><br><span class="line">    aiProcess_Triangulate            |</span><br><span class="line">    aiProcess_JoinIdenticalVertices  |</span><br><span class="line">    aiProcess_SortByPType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the import failed, report it</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> == scene) &#123;</span><br><span class="line">    <span class="built_in">DoTheErrorLogging</span>( importer.<span class="built_in">GetErrorString</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we can access the file&#x27;s contents.</span></span><br><span class="line">  <span class="built_in">DoTheSceneProcessing</span>( scene);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;re done. Everything will be cleaned up by the importer destructor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后简单地让它离开作用域。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>以结构集合的形式返回导入的数据。aiScene形成数据的根，从这里可以访问从导入文件中<strong>读取的所有节点，网格，材质，动画或纹理</strong>。</p><p>默认情况下，所有3D数据都以右手坐标系提供，例如OpenGL使用的坐标系。在这个坐标系中，+X指向右侧，+Y指向上方，+Z指向屏幕外的观察者</p><p>输出面顺序为逆时针方向</p><h5 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h5><p>场景包含一个rootNode用于遍历以及mesh和material,通过node中的mesh索引获得具体mesh,通过mesh中的material索引获得具体material,mesh还包括faces,一个face就是一个primitive.</p><ol><li><strong><code>mFlags</code></strong>: 这个标志表示场景的一些特性，例如是否是不完整的 (<code>AI_SCENE_FLAGS_INCOMPLETE</code>) 或者是否有无效的数据 (<code>AI_SCENE_FLAGS_INVALID_DATA</code>)。</li><li><strong><code>mRootNode</code></strong>: 指向场景根节点的指针。每个场景都有一个根节点，所有其他节点都是它的子节点。通过遍历这个节点树，你可以获取场景的所有几何信息。</li><li><strong><code>mNumMeshes</code> 和 <code>mMeshes</code></strong>: 分别表示场景中网格的数量和指向网格数组的指针。网格包含了顶点、面和其他几何数据。</li><li><strong><code>mNumMaterials</code> 和 <code>mMaterials</code></strong>: 分别表示场景中材质的数量和指向材质数组的指针。材质定义了网格的外观属性。</li><li><strong><code>mNumTextures</code> 和 <code>mTextures</code></strong>: 分别表示场景中文本贴图的数量和指向文本贴图数组的指针。请注意，不是所有的模型格式都支持直接导出纹理，所以这个成员可能为空。</li><li><strong><code>mNumCameras</code> 和 <code>mCameras</code></strong>: 分别表示场景中相机的数量和指向相机数组的指针。并不是所有模型文件都会包含相机信息。</li><li><strong><code>mNumLights</code> 和 <code>mLights</code></strong>: 分别表示场景中光源的数量和指向光源数组的指针。同样地，并非所有模型文件都包含光源信息。</li><li><strong><code>mMetaData</code></strong>: 包含有关场景的元数据。这可以包括版本号、作者等信息</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们已经有一个 aiScene* scene</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根节点</span></span><br><span class="line">aiNode* rootNode = scene-&gt;mRootNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有网格</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scene-&gt;mNumMeshes; ++i) &#123;</span><br><span class="line">    aiMesh* mesh = scene-&gt;mMeshes[i];</span><br><span class="line">    <span class="comment">// 处理网格...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有材质</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scene-&gt;mNumMaterials; ++i) &#123;</span><br><span class="line">    aiMaterial* material = scene-&gt;mMaterials[i];</span><br><span class="line">    <span class="comment">// 处理材质...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有纹理，遍历它们</span></span><br><span class="line"><span class="keyword">if</span> (scene-&gt;mNumTextures &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scene-&gt;mNumTextures; ++i) &#123;</span><br><span class="line">        aiTexture* texture = scene-&gt;mTextures[i];</span><br><span class="line">        <span class="comment">// 处理纹理...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有相机，遍历它们</span></span><br><span class="line"><span class="keyword">if</span> (scene-&gt;mNumCameras &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scene-&gt;mNumCameras; ++i) &#123;</span><br><span class="line">        aiCamera* camera = scene-&gt;mCameras[i];</span><br><span class="line">        <span class="comment">// 处理相机...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有光源，遍历它们</span></span><br><span class="line"><span class="keyword">if</span> (scene-&gt;mNumLights &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scene-&gt;mNumLights; ++i) &#123;</span><br><span class="line">        aiLight* light = scene-&gt;mLights[i];</span><br><span class="line">        <span class="comment">// 处理光源...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h5><p>节点是场景中名字不大的实体，相对于它们的父节点有一个位置和方向。从场景的根节点开始，所有节点可以有0到x个子节点，从而形成一个层次结构。</p><ol><li><strong><code>mTransformation</code></strong>:<ul><li>类型: <code>aiMatrix4x4</code></li><li>描述: 表示节点的本地变换矩阵，它定义了该节点相对于其父节点的位置、旋转和缩放。</li></ul></li><li><strong><code>mNumMeshes</code> 和 <code>mMeshes</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>unsigned int*</code></li><li>描述: <code>mNumMeshes</code> 表示此节点直接关联的网格数量；<code>mMeshes</code> 是一个索引数组，指向 <code>aiScene</code> 的 <code>mMeshes</code> 数组中的相应网格。如果 <code>mNumMeshes</code> 为 0，则该节点没有直接关联的网格。</li></ul></li><li><strong><code>mParent</code></strong>:<ul><li>类型: <code>aiNode*</code></li><li>描述: 指向该节点的父节点的指针。根节点的 <code>mParent</code> 为 <code>nullptr</code>。</li></ul></li><li><strong><code>mNumChildren</code> 和 <code>mChildren</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiNode**</code></li><li>描述: <code>mNumChildren</code> 表示该节点的子节点数量；<code>mChildren</code> 是一个指针数组，指向该节点的所有子节点。</li></ul></li><li><strong><code>mName</code></strong>:<ul><li>类型: <code>aiString</code></li><li>描述: 节点的名字。在某些情况下，这个名字可能被用来标识特定的节点或作为动画等的参考</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个 aiNode* node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点的变换矩阵</span></span><br><span class="line">aiMatrix4x4 transformation = node-&gt;mTransformation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有与该节点关联的网格</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; ++i) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> meshIndex = node-&gt;mMeshes[i];</span><br><span class="line">    aiMesh* mesh = scene-&gt;mMeshes[meshIndex];</span><br><span class="line">    <span class="comment">// 处理网格...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;mParent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    aiNode* parentNode = node-&gt;mParent;</span><br><span class="line">    <span class="comment">// 处理父节点...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有子节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; ++i) &#123;</span><br><span class="line">    aiNode* childNode = node-&gt;mChildren[i];</span><br><span class="line">    <span class="comment">// 处理子节点...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点名称</span></span><br><span class="line"><span class="function">std::string <span class="title">nodeName</span><span class="params">(node-&gt;mName.C_Str())</span></span>;</span><br></pre></td></tr></table></figure><h5 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h5><ol><li><strong><code>mPrimitiveTypes</code></strong>:<ul><li>类型: <code>unsigned int</code></li><li>描述: 表示该网格中包含的图元类型，例如点 (<code>aiPrimitiveType_POINT</code>)、线 (<code>aiPrimitiveType_LINE</code>) 或三角形 (<code>aiPrimitiveType_TRIANGLE</code>)。</li></ul></li><li><strong><code>mNumVertices</code> 和 <code>mVertices</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiVector3D*</code></li><li>描述: <code>mNumVertices</code> 表示顶点的数量；<code>mVertices</code> 是指向 <code>aiVector3D</code> 数组的指针，每个元素代表一个顶点的位置。</li></ul></li><li><strong><code>mNormals</code></strong>:<ul><li>类型: <code>aiVector3D*</code></li><li>描述: 指向法线数组的指针。如果网格包含法线数据，则每个顶点都有一个对应的法线向量。</li></ul></li><li><strong><code>mTextureCoords</code></strong>:<ul><li>类型: <code>aiVector3D**</code></li><li>描述: 指向纹理坐标数组的二维数组指针。第一维是纹理坐标集的数量（最多8个），第二维是实际的纹理坐标。如果某个顶点有纹理坐标，则可以通过这个成员访问。</li></ul></li><li><strong><code>mColors</code></strong>:<ul><li>类型: <code>aiColor4D**</code></li><li>描述: 指向颜色数组的二维数组指针。第一维是颜色集的数量（最多8个），第二维是实际的颜色值。如果顶点有色值，则可以在这里找到。</li></ul></li><li><strong><code>mNumFaces</code> 和 <code>mFaces</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiFace*</code></li><li>描述: <code>mNumFaces</code> 表示面的数量；<code>mFaces</code> 是指向 <code>aiFace</code> 数组的指针，每个 <code>aiFace</code> 定义了一个由若干顶点组成的多边形（通常是三角形）。</li></ul></li><li><strong><code>mMaterialIndex</code></strong>:<ul><li>类型: <code>unsigned int</code></li><li>描述: 网格使用的材质在场景的 <code>mMaterials</code> 数组中的索引。通过这个索引，你可以获取与该网格关联的 <code>aiMaterial</code> 对象。</li></ul></li><li><strong><code>mNumBones</code> 和 <code>mBones</code></strong>:<ul><li>类型: <code>unsigned int</code> 和 <code>aiBone**</code></li><li>描述: 如果网格支持骨骼动画，则 <code>mBones</code> 包含了指向 <code>aiBone</code> 数组的指针，每个 <code>aiBone</code> 定义了一个影响顶点位置的骨骼。<code>mNumBones</code> 是骨骼的数量。</li></ul></li><li><strong><code>mName</code></strong>:<ul><li>类型: <code>aiString</code></li><li>描述: 网格的名字。某些情况下，这个名字可能是有意义的，比如用于标识特定的网格或作为其他资源的引用。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个 aiMesh* mesh 和 aiScene* scene</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取网格的材质</span></span><br><span class="line">aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumVertices; ++i) &#123;</span><br><span class="line">    aiVector3D position = mesh-&gt;mVertices[i];</span><br><span class="line">    <span class="comment">// 处理顶点位置...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasNormals</span>()) &#123;</span><br><span class="line">        aiVector3D normal = mesh-&gt;mNormals[i];</span><br><span class="line">        <span class="comment">// 处理法线...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasTextureCoords</span>(<span class="number">0</span>)) &#123; <span class="comment">// 假设使用第0个纹理坐标集</span></span><br><span class="line">        aiVector3D texCoord = mesh-&gt;mTextureCoords[<span class="number">0</span>][i];</span><br><span class="line">        <span class="comment">// 处理纹理坐标...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumFaces; ++i) &#123;</span><br><span class="line">    aiFace face = mesh-&gt;mFaces[i];</span><br><span class="line">    <span class="comment">// 处理面...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; face.mNumIndices; ++j) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexIndex = face.mIndices[j];</span><br><span class="line">        <span class="comment">// 使用顶点索引...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有骨骼信息，遍历它们</span></span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasBones</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumBones; ++i) &#123;</span><br><span class="line">        aiBone* bone = mesh-&gt;mBones[i];</span><br><span class="line">        <span class="comment">// 处理骨骼...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aiMesh</code> 还提供了一些辅助函数来检查网格是否包含特定的数据类型：</p><ul><li><strong><code>HasPositions()</code></strong>: 返回网格是否有顶点位置。</li><li><strong><code>HasNormals()</code></strong>: 返回网格是否有法线数据。</li><li><strong><code>HasTangentsAndBitangents()</code></strong>: 返回网格是否有切线和副切线数据。</li><li><strong><code>HasTextureCoords(unsigned int)</code></strong>: 接受一个参数指定纹理坐标集的索引，返回网格是否有对应的纹理坐标。</li><li><strong><code>HasVertexColors(unsigned int)</code></strong>: 接受一个参数指定颜色集的索引，返回网格是否有对应的顶点颜色。</li><li><strong><code>HasFaces()</code></strong>: 返回网格是否有面数据。</li><li><strong><code>HasBones()</code></strong>: 返回网格是否有骨骼信息。</li></ul><h5 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h5><h6 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h6><ul><li><strong><code>AI_MATKEY_COLOR_DIFFUSE</code></strong>: 扩散（漫反射）颜色。</li><li><strong><code>AI_MATKEY_COLOR_AMBIENT</code></strong>: 环境光颜色。</li><li><strong><code>AI_MATKEY_COLOR_SPECULAR</code></strong>: 高光（镜面反射）颜色。</li><li><strong><code>AI_MATKEY_COLOR_EMISSIVE</code></strong>: 发射光颜色。</li><li><strong><code>AI_MATKEY_COLOR_TRANSPARENT</code></strong>: 透明颜色。</li><li><strong><code>AI_MATKEY_COLOR_REFLECTIVE</code></strong>: 反射颜色。</li></ul><h6 id="浮点数属性"><a href="#浮点数属性" class="headerlink" title="浮点数属性"></a>浮点数属性</h6><ul><li><strong><code>AI_MATKEY_SHININESS</code></strong>: 高光强度。</li><li><strong><code>AI_MATKEY_SHININESS_STRENGTH</code></strong>: 高光强度因子。</li><li><strong><code>AI_MATKEY_REFRACTI</code></strong>: 折射率。</li></ul><h6 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h6><ul><li><strong><code>AI_MATKEY_ENABLE_WIREFRAME</code></strong>: 是否启用线框模式。</li></ul><h6 id="纹理属性"><a href="#纹理属性" class="headerlink" title="纹理属性"></a>纹理属性</h6><ul><li><strong><code>AI_MATKEY_TEXTURE_BASE</code></strong>: 基础纹理。</li><li><strong><code>AI_MATKEY_TEXTURE_DIFFUSE</code></strong>: 扩散（漫反射）纹理。</li><li><strong><code>AI_MATKEY_TEXTURE_SPECULAR</code></strong>: 高光（镜面反射）纹理。</li><li><strong><code>AI_MATKEY_TEXTURE_AMBIENT</code></strong>: 环境光纹理。</li><li><strong><code>AI_MATKEY_TEXTURE_EMISSIVE</code></strong>: 发射光纹理。</li><li><strong><code>AI_MATKEY_TEXTURE_HEIGHT</code></strong>: 高度图。</li><li><strong><code>AI_MATKEY_TEXTURE_NORMALS</code></strong>: 法线贴图。</li><li><strong><code>AI_MATKEY_TEXTURE_SHININESS</code></strong>: 高光贴图。</li><li><strong><code>AI_MATKEY_TEXTURE_OPACITY</code></strong>: 不透明度贴图。</li><li><strong><code>AI_MATKEY_TEXTURE_DISPLACEMENT</code></strong>: 位移贴图。</li><li><strong><code>AI_MATKEY_TEXTURE_LIGHTMAP</code></strong>: 光照贴图。</li><li><strong><code>AI_MATKEY_TEXTURE_REFLECTION</code></strong>: 反射贴图。</li></ul><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><p>为了访问上述属性，<code>aiMaterial</code> 提供了一系列的 <code>Get</code> 和 <code>Set</code> 函数。最常用的 <code>Get</code> 函数包括：</p><ol><li><strong><code>Get(AI_MATKEY key, aiColor4D&amp; out)</code></strong>:<ul><li>获取指定键的颜色值。</li></ul></li><li><strong><code>Get(AI_MATKEY key, float&amp; out)</code></strong>:<ul><li>获取指定键的浮点数值。</li></ul></li><li><strong><code>Get(AI_MATKEY key, bool&amp; out)</code></strong>:<ul><li>获取指定键的布尔值。</li></ul></li><li><strong><code>GetTexture(aiTextureType type, unsigned int index, aiString\* path)</code></strong>:<ul><li>获取指定类型的纹理路径。<code>index</code> 参数允许你访问同一类型下的多个纹理（例如，多层扩散纹理）。</li></ul></li><li><strong><code>HasProperty(const char\* key)</code></strong>:<ul><li>检查材质是否具有给定键的属性。</li></ul></li><li><strong><code>Get(AI_MATKEY key, unsigned int&amp; out)</code></strong>:<ul><li>获取指定键的无符号整数值（例如，用于获取纹理的数量）</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个 aiMaterial* material</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取扩散颜色</span></span><br><span class="line">aiColor4D diffuseColor;</span><br><span class="line"><span class="keyword">if</span> (AI_SUCCESS == material-&gt;<span class="built_in">Get</span>(AI_MATKEY_COLOR_DIFFUSE, diffuseColor)) &#123;</span><br><span class="line">    <span class="comment">// 使用 diffuseColor...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高光强度</span></span><br><span class="line"><span class="keyword">float</span> shininess;</span><br><span class="line"><span class="keyword">if</span> (AI_SUCCESS == material-&gt;<span class="built_in">Get</span>(AI_MATKEY_SHININESS, shininess)) &#123;</span><br><span class="line">    <span class="comment">// 使用 shininess...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个扩散纹理路径</span></span><br><span class="line">aiString texturePath;</span><br><span class="line"><span class="keyword">if</span> (AI_SUCCESS == material-&gt;<span class="built_in">GetTexture</span>(aiTextureType_DIFFUSE, <span class="number">0</span>, &amp;texturePath)) &#123;</span><br><span class="line">    <span class="comment">// 使用 texturePath.C_Str()...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有环境光颜色</span></span><br><span class="line"><span class="keyword">if</span> (material-&gt;<span class="built_in">HasProperty</span>(AI_MATKEY_COLOR_AMBIENT)) &#123;</span><br><span class="line">    aiColor4D ambientColor;</span><br><span class="line">    <span class="keyword">if</span> (AI_SUCCESS == material-&gt;<span class="built_in">Get</span>(AI_MATKEY_COLOR_AMBIENT, ambientColor)) &#123;</span><br><span class="line">        <span class="comment">// 使用 ambientColor...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h5><p>通常，资源使用的纹理存储在单独的文件中，但是也有文件格式将纹理直接嵌入到模型文件中。这样的纹理被加载到aittexture结构中</p><ol><li><strong><code>mWidth</code> 和 <code>mHeight</code></strong>:<ul><li>类型: <code>unsigned int</code></li><li>描述: 分别表示纹理图像的宽度和高度（以像素为单位）。对于非图像格式（例如程序生成的纹理），这些值可能为0。</li></ul></li><li><strong><code>mData</code></strong>:<ul><li>类型: <code>unsigned char*</code></li><li>描述: 指向包含纹理数据的缓冲区。注意，并不是所有情况下都会提供实际的纹理数据；某些导入器可能会直接返回文件路径而不是加载图像数据到内存中。</li></ul></li><li><strong><code>mHeight</code></strong>:<ul><li>类型: <code>unsigned int</code></li><li>描述: 纹理的高度（以像素为单位）。</li></ul></li><li><strong><code>achFormatHint</code></strong>:<ul><li>类型: <code>char[AI_TEXTURE_FORMAT_MAX]</code></li><li>描述: 提供关于纹理格式的提示字符串，例如 <code>&quot;jpg&quot;</code> 或 <code>&quot;png&quot;</code>。这可以帮助你确定如何正确地解码纹理数据。</li></ul></li><li><strong><code>mFilename</code></strong>:<ul><li>类型: <code>aiString</code></li><li>描述: 包含纹理文件的相对或绝对路径名。这是最常用的方式来获取纹理资源的位置。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个 aiTexture* texture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取纹理文件名</span></span><br><span class="line"><span class="function">std::string <span class="title">filename</span><span class="params">(texture-&gt;mFilename.C_Str())</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Texture filename: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有纹理数据，可以尝试读取其大小</span></span><br><span class="line"><span class="keyword">if</span> (texture-&gt;mWidth &gt; <span class="number">0</span> &amp;&amp; texture-&gt;mHeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Texture dimensions: &quot;</span> &lt;&lt; texture-&gt;mWidth &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; texture-&gt;mHeight &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据格式提示来决定如何处理纹理数据</span></span><br><span class="line"><span class="function">std::string <span class="title">formatHint</span><span class="params">(texture-&gt;achFormatHint)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!formatHint.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Texture format hint: &quot;</span> &lt;&lt; formatHint &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有纹理数据，可以直接使用指针访问</span></span><br><span class="line"><span class="keyword">if</span> (texture-&gt;mData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意：这里只是示例，通常你需要根据具体的格式解码这些数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* data = texture-&gt;mData;</span><br><span class="line">    <span class="comment">// 使用纹理数据...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stb-image"><a href="#stb-image" class="headerlink" title="stb_image"></a>stb_image</h2><p>加载图像库,通过<code>stbi_load</code>读取图像的宽高和通道</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">LoadTexture</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">bool</span> clip)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 生成纹理</span></span><br><span class="line">  GLuint texture;</span><br><span class="line">  <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line">  <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 加载图像</span></span><br><span class="line">  <span class="keyword">int</span> img_width, img_height, nrChannels;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *data =</span><br><span class="line">      <span class="built_in">stbi_load</span>(path, &amp;img_width, &amp;img_height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    GLenum format;</span><br><span class="line">    <span class="keyword">if</span> (nrChannels == <span class="number">1</span>) &#123;</span><br><span class="line">      format = GL_RED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nrChannels == <span class="number">3</span>) &#123;</span><br><span class="line">      format = GL_RGB;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nrChannels == <span class="number">4</span>) &#123;</span><br><span class="line">      format = GL_RGBA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;No available format.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, format, img_width, img_height, <span class="number">0</span>, format,</span><br><span class="line">                 GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    <span class="keyword">if</span> (clip) &#123;</span><br><span class="line">      <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">      <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">      <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,</span><br><span class="line">                    GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Error: Failed to load the image because &quot;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">stbi_failure_reason</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">  <span class="keyword">return</span> texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在OpenGL中着色器的编程语言叫做GLSL,类似C语言但是内置了许多有用的函数. 这里简单学习其基础语法和包含特殊函数.&lt;br&gt;</summary>
    
    
    
    
    <category term="GLSL编程" scheme="https://www.sekyoro.top/tags/GLSL%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从C++模板谈起</title>
    <link href="https://www.sekyoro.top/2024/12/09/%E4%BB%8EC-%E6%A8%A1%E6%9D%BF%E8%B0%88%E8%B5%B7/"/>
    <id>https://www.sekyoro.top/2024/12/09/%E4%BB%8EC-%E6%A8%A1%E6%9D%BF%E8%B0%88%E8%B5%B7/</id>
    <published>2024-12-09T09:06:21.000Z</published>
    <updated>2024-12-13T03:10:16.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++的模板编程是学习C++不可或缺的一部分,说来讽刺,这部分在Rust中实现得很优雅.<br><span id="more"></span></p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 提供了不同的方法来处理这个问题:</span></span><br><span class="line"><span class="comment">// • 为返回类型引入第三个模板参数。</span></span><br><span class="line"><span class="comment">//• 让编译器找出返回类型。</span></span><br><span class="line"><span class="comment">//• 将返回类型声明为两个参数类型的“公共类型”。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> RT&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">lowMax</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// since c++14, 使用auto不显式声明返回类型</span></span><br><span class="line"><span class="comment">// :返回类型可能是引用类型，在某些条件下T可能是引用。因为这个原因，应该返回T衰变的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// 实现也不一定要匹配。事实上，使用true作为操作符的条件就够了</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(T1 <span class="keyword">const</span>&amp; a,T2 <span class="keyword">const</span>&amp; b)</span>-&gt;  std::<span class="keyword">decay_t</span>&lt;<span class="title">decltype</span><span class="params">(<span class="literal">true</span>? T1():T2())</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 后，标准库提供了一种方法来指定选择“公共类型”。std::common_type&lt;&gt;::type会产生</span></span><br><span class="line"><span class="comment">// 由两个(或多个)不同类型作为模板类型的“公共类型”</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">std::<span class="keyword">common_type_t</span>&lt;T1,T2&gt; <span class="title">commonMax</span><span class="params">(T1 a,T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，自动类型转换在类型推导时有一些限制:</span></span><br><span class="line"><span class="comment">// • 当通过引用声明参数时，简单的转换也不适用于类型推导。用同一个模板参数T声明的两个</span></span><br><span class="line"><span class="comment">// 实参必须完全匹配。</span></span><br><span class="line"><span class="comment">// • 当按值声明参数时，只支持简单的转换:忽略const或volatile的限定符，引用转换为引用的类</span></span><br><span class="line"><span class="comment">// 型，原始数组或函数转换为相应的指针类型。对于使用相同模板参数T声明的两个参数，转换类型必须匹配。</span></span><br><span class="line"><span class="comment">// 默认模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,</span><br><span class="line"><span class="keyword">typename</span> RT = std::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span>? <span class="built_in">T1</span>():<span class="built_in">T2</span>())&gt;&gt;</span><br><span class="line">RT <span class="built_in">defaultMax</span>(T1 a,T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他相同的情况下，重载解析将优先使用非模板方式</span></span><br><span class="line"><span class="comment">// 重载函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板参数推导"><a href="#模板参数推导" class="headerlink" title="模板参数推导"></a>模板参数推导</h4><p>自动类型转换在类型推导时有一些限制: </p><ul><li>当通过引用声明参数时，简单的转换也不适用于类型推导。用同一个模板参数T声明的两个实参必须完全匹配。 </li><li>当按值声明参数时，只支持简单的转换:忽略const或volatile的限定符，引用转换为引用的类型，原始数组或函数转换为相应的指针类型。对于使用相同模板参数T声明的两个参数，转换类型必须匹配。</li></ul><p>与普通函数一样，函数模板也可以重载。可以使用相同的函数名来声明不同的函数体，当使用 该函数名称时，编译器会决定调用哪一个候选函数。</p><p>重载函数模板时，应该确保只有一 个函数模板与调用匹配。</p><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="comment">// 使用类模板时除了可以推导参数的情况下必须使用声明</span></span><br><span class="line"><span class="comment">// 在类模板中使用不带模板参数的类名表明这个内部类的模板参数类型和模板类的参数类型相同</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::array&lt;T,Maxsize&gt; elems;</span><br><span class="line">        std::<span class="keyword">size_t</span> numElems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>();</span><br><span class="line">        <span class="built_in">Stack</span>(Stack <span class="keyword">const</span>&amp;) ;</span><br><span class="line">        Stack&amp; <span class="keyword">operator</span>=(Stack <span class="keyword">const</span>&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">(std::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> T&amp; elem: elems)&#123;</span><br><span class="line">                strm&lt;&lt;elem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="keyword">friend</span>  std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; strm,Stack&lt;U,Maxsize&gt; <span class="keyword">const</span> &amp; sk) &#123;</span><br><span class="line">            sk.<span class="built_in">printOn</span>(strm);</span><br><span class="line">            <span class="keyword">return</span> strm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要类名而不是类类型的地方，只能使用Stack。尤其是，指定构造函数的名称(而不是参数)和析构函数时。</span></span><br><span class="line"><span class="comment">// 不能在函数或块作用域内声明或定义类模板。通常，模板只能在全局/命名空间作用域或类中声明内部定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明成员函数</span></span><br><span class="line"><span class="comment">// 定义类模板的成员函数, 必须将其指定为模板. 使用类模板对类型进行限定</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,std::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T,Maxsize&gt;::<span class="built_in">Stack</span>():numElems&#123;<span class="number">0</span>&#125; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,std::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">push</span>(T <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(numElems&lt;Maxsize);</span><br><span class="line">    elems[numElems] = elem;</span><br><span class="line">    ++numElems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,std::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">empty</span>());</span><br><span class="line">    numElems--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,std::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T,Maxsize&gt;::<span class="built_in">top</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems[numElems<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span><span class="keyword">float</span>,<span class="number">12</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">        std::array&lt;<span class="keyword">float</span>,12&gt; elems;</span><br><span class="line">        std::<span class="keyword">size_t</span> numElems;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的偏特化</span></span><br><span class="line"><span class="comment">// template&lt;std::size_t Maxsize&gt;</span></span><br><span class="line"><span class="comment">// class Stack&lt;int,Maxsize&gt;&#123;</span></span><br><span class="line"><span class="comment">//     private:</span></span><br><span class="line"><span class="comment">//         std::array&lt;int,Maxsize&gt; elems;</span></span><br><span class="line"><span class="comment">//         std::size_t numElems;</span></span><br><span class="line"><span class="comment">//     public:</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span>T,<span class="number">10</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::array&lt;T,10&gt; elems;</span><br><span class="line">        std::<span class="keyword">size_t</span> numElems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="模板聚合"><a href="#模板聚合" class="headerlink" title="模板聚合"></a>模板聚合</h3><p>聚合类(不由用户提供、显式或继承的构造函数的类/结构，没有private或protected的非静态数据成员，没有虚函数，也没有virtual、private或protected基类)也可以是模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ValueWithComment</span> &#123;</span></span><br><span class="line">T Value;</span><br><span class="line">std::string comment;</span><br><span class="line">&#125;;</span><br><span class="line">ValueWithComment&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">vc.value = <span class="number">42</span>;</span><br><span class="line">vc.comment = <span class="string">&quot;initial value&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::array&lt;T,Maxsize&gt; elems;</span><br><span class="line">        std::<span class="keyword">size_t</span> numElems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>();</span><br><span class="line">        <span class="built_in">Stack</span>(Stack <span class="keyword">const</span>&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        Stack&amp; <span class="keyword">operator</span>=(Stack <span class="keyword">const</span>&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">(std::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> T&amp; elem: elems)&#123;</span><br><span class="line">                strm&lt;&lt;elem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        <span class="keyword">friend</span>  std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; strm,Stack&lt;U,Maxsize&gt; <span class="keyword">const</span> &amp; sk) &#123;</span><br><span class="line">            sk.<span class="built_in">printOn</span>(strm);</span><br><span class="line">            <span class="keyword">return</span> strm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板非类型参数"><a href="#函数模板非类型参数" class="headerlink" title="函数模板非类型参数"></a>函数模板非类型参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> Val,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addValue</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+Val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> Val,<span class="keyword">typename</span> T </span>= <span class="keyword">decltype</span>(Val)&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Val </span>= T&#123;&#125;&gt;</span><br><span class="line"><span class="function">T <span class="title">bar</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数限制"><a href="#非类型模板参数限制" class="headerlink" title="非类型模板参数限制"></a>非类型模板参数限制</h3><p>非类型模板参数有一些限制，只能是整型常量值(包括枚举)，指向对象/函数/成员的指针，指 向对象或函数的左值引用，或者std::nullptr_t(nullptr的类型)</p><ul><li>浮点数和类型对象不允许作为非类型模板参数</li><li>当向指针或引用传递模板参数时，对象不能是字符串字面值、临时对象或数据成员和其他子对象。</li></ul><p>非类型模板参数可以是编译时表达式</p><h3 id="模板参数类型auto"><a href="#模板参数类型auto" class="headerlink" title="模板参数类型auto"></a>模板参数类型auto</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">autoStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">decltype</span>(Maxsize);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T,Maxsize&gt; elems;</span><br><span class="line">    size_type numElems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">autoStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numElems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>模板的模板参数可以是值，而非类型。 </li><li>不能将浮点数或类类型对象作为非类型模板的参数。对于指向字符串字面量、临时对象和子 对象的指针/引用，有一些限制。 </li><li>使用auto可使模板具有泛型值的非类型模板参数。</li></ul><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T firstArg,Types... args)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;firstArg&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载可变和非可变模板"><a href="#重载可变和非可变模板" class="headerlink" title="重载可变和非可变模板"></a>重载可变和非可变模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;arg&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T firstArg,Types... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(firstArg);</span><br><span class="line">    <span class="built_in">print</span>(args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若两个函数模板的区别仅在于末尾参数包的不同，则首选没有末尾参数包的函数模板</p><p><code>sizeof...</code>操作符应用在可变参模板</p><h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/12/09/ZT8oyw5s3ChWH1n.png" alt="image-20241209220950737"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> i=<span class="number">0</span>):<span class="built_in">value</span>(i),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> left = &amp;Node::left;</span><br><span class="line"><span class="keyword">auto</span> right = &amp;Node::right;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... TP&gt;</span></span><br><span class="line"><span class="function">Node* <span class="title">traverse</span><span class="params">(T np,TP... paths)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (np -&gt;* ... -&gt;* paths);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printargs</span><span class="params">(Types <span class="keyword">const</span>&amp;... args)</span> </span>&#123;</span><br><span class="line">    (std::cout&lt;&lt; ... &lt;&lt; args)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddSpace</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T <span class="keyword">const</span>&amp; ref;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddSpace</span>(T <span class="keyword">const</span>&amp; r):<span class="built_in">ref</span>(r) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os,AddSpace&lt;T&gt; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> os&lt;&lt; s.ref&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Args... args)</span></span>&#123;</span><br><span class="line">    (std::cout&lt;&lt; ... &lt;&lt;<span class="built_in">AddSpace</span>(args))&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可变参数模板在实现通用库(如C++标准库)时扮演着重要的角色。 典型的应用是转发可变数量的类型参数</p><h3 id="类模板和表达式"><a href="#类模板和表达式" class="headerlink" title="类模板和表达式"></a>类模板和表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubled</span><span class="params">(Args... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(args + args ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">(T <span class="keyword">const</span>&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(args+<span class="number">1</span> ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubled</span><span class="params">(Args... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(args + args ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">(T <span class="keyword">const</span>&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(args+<span class="number">1</span> ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... TN&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">isHomogeneous</span><span class="params">(T1,TN...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::is_same&lt;T1,TN&gt;::value &amp;&amp; ...);</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span>... Idx&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElems</span><span class="params">(C <span class="keyword">const</span>&amp; coll,Idx... idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(coll[idx]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="keyword">size_t</span>... Idx, <span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIdx</span><span class="params">(C <span class="keyword">const</span>&amp; coll)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(coll[Idx]...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h4><p><strong>typename</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printcoll</span><span class="params">(T <span class="keyword">const</span>&amp; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::const_iterator pos;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> T::const_iterator <span class="title">end</span><span class="params">(coll.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(pos = coll.<span class="built_in">begin</span>();pos!=end;++pos) &#123;</span><br><span class="line">        std::cout&lt;&lt;*pos&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>说明模板内的标识符是类型.当模板参数是类型时，必须使用typename。</p><p><strong>零值初始化</strong></p><p>因此，可以显式调用内置类型的默认构造函数，该构造函数用0初始化内置类型(bool为false， 指针为nullptr)。因此，即使是内置类型，也可以通过零初始化来确保正确的初始化</p><p><strong>使用this-&gt;</strong></p><p>对于具有依赖于模板参数的基类类模板，即使成员x被继承，使用名称x本身并不总是等同于 this-&gt;x。</p><p><strong>原始数组和字符串字面量的模板</strong></p><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tempmemberStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员模板</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    tempmemberStack&amp; <span class="keyword">operator</span>=(tempmemberStack&lt;T2&gt; <span class="keyword">const</span>&amp;); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">tempmemberStack&lt;T&gt;&amp; tempmemberStack&lt;T&gt;::<span class="keyword">operator</span>=(tempmemberStack&lt;T2&gt; <span class="keyword">const</span>&amp; op2) &#123;</span><br><span class="line">    tempmemberStack&lt;T2&gt; <span class="built_in">tmp</span>(op2);</span><br><span class="line">    elems.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span>(!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        elems.<span class="built_in">push_front</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Cont=std::deque&lt;T&gt;&gt;</span><br><span class="line">class memStack &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">     Cont elems;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2,<span class="keyword">typename</span> Cont2&gt;</span><br><span class="line">     memStack&amp; <span class="keyword">operator</span>=(memStack&lt;T2,Cont2&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">memStack</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成员函数模板也可以全特化,不能偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoolString</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BoolString</span> (std::string <span class="keyword">const</span>&amp; s):<span class="built_in">value</span>(s) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T</span>= std::string&gt;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> BoolString::get&lt;<span class="keyword">bool</span>&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="string">&quot;true&quot;</span> || value ==<span class="string">&quot;1&quot;</span> || value == <span class="string">&quot;on&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要也不能对特化进行声明，只需要定义。因为它是全特化的，且位于头文件中，所以若定 义包含在不同的转译单元中，必须使用内联声明，以避免错误。</p><h4 id="特殊成员函数的模板"><a href="#特殊成员函数的模板" class="headerlink" title="特殊成员函数的模板"></a>特殊成员函数的模板</h4><p><strong>只要特殊成员函数允许复制或移动对象，就可以使用模板成员函数</strong>。与上面定义的赋值操作符 类似，也可以是构造函数。但模板构造函数或模板赋值操作符，不能取代预定义构造函数或赋值操 作符，成员模板不作为复制或移动对象的特殊成员函数。本例中，对于相同类型的堆栈赋值，仍然使用默认赋值操作符</p><h4 id="泛型Lambda和成员模板"><a href="#泛型Lambda和成员模板" class="headerlink" title="泛型Lambda和成员模板"></a>泛型Lambda和成员模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">auto</span> sum = [](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCompilerSpecificName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeCompilerSpecificName</span>();</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="comment">// 仿函数、函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T1 x,T2 y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">long</span> <span class="keyword">double</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi&#123;<span class="number">3.141</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据成员模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> max = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> myMax = MyClass&lt;T&gt;::max;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> isSigned = std::numeric_limits&lt;T&gt;::is_signed</span><br></pre></td></tr></table></figure><h2 id="std-enable-if-lt-gt-和移动语义"><a href="#std-enable-if-lt-gt-和移动语义" class="headerlink" title="std::enable_if&lt;&gt;和移动语义"></a>std::enable_if&lt;&gt;和移动语义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;g() for variable\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X <span class="keyword">const</span> &amp;)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;g() for constant\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;g() for movable object\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span>:name(std::forward&lt;STR&gt;(n))&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(Person <span class="keyword">const</span>&amp; p):name&#123;p.name&#125;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(Person &amp;&amp;p):name&#123;std::<span class="built_in">move</span>(p.name)&#125;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从C++11开始，标准库提供了辅助模板std::enable_if&lt;&gt;，以<strong>在特定的编译时条件下忽略函数模板</strong></p><p>std::enable_if&lt;&gt; 是一种类型特征，计算作为其(第一个)模板参数传递的给定编译时 表达式: </p><ul><li>若表达式结果为true，其类型成员类型将产生一个类型:</li><li>若没有传递第二个模板参数，则该类型为void。否则，该类型就是第二个模板参数类型</li></ul><p>若表达式结果为false，则没有定义成员类型。由于SFINAE的模板特性(替换失败不为 过),这将忽略使用enable_if表达式的函数模板</p><p>在声明中间使用enable_if表达式非常笨拙。由于这个原因，使用std::enable_if&lt;&gt;的常见方法是 使用带有默认值的函数模板参数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::<span class="keyword">enable_if_t</span>&lt;(<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="number">1</span>),T&gt; <span class="built_in">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> T&#123;&#125;*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> = std::<span class="keyword">enable_if_t</span>&lt;(<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="number">4</span>)&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">foo</span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::<span class="keyword">enable_if_t</span>&lt;(<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="number">1</span>),T&gt; <span class="built_in">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> T&#123;&#125;*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> = std::<span class="keyword">enable_if_t</span>&lt;(<span class="built_in"><span class="keyword">sizeof</span></span>(T)&gt;<span class="number">4</span>)&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">foo</span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>禁用模板构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR,<span class="keyword">typename</span> = std::<span class="keyword">enable_if_t</span>&lt;std::is_convertible_v&lt;STR,std::string&gt; &gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(STR&amp;&amp; n):<span class="built_in">name</span>(std::forward&lt;STR&gt;(n))&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(Person <span class="keyword">const</span>&amp; p):name&#123;p.name&#125;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(Person &amp;&amp;p):name&#123;std::<span class="built_in">move</span>(p.name)&#125;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用概念简化std-enable-if表达式"><a href="#使用概念简化std-enable-if表达式" class="headerlink" title="使用概念简化std::enable_if表达式"></a>使用概念简化std::enable_if表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> ConvertibleToString = std::is_convertible_v&lt;T,std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> ConvertibleToString&lt;STR&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp;)</span>....</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;ConvertibleToString STR&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp;)</span></span></span><br></pre></td></tr></table></figure><h3 id="按值与按引用传递"><a href="#按值与按引用传递" class="headerlink" title="按值与按引用传递"></a>按值与按引用传递</h3><h4 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h4><p><strong>按值传递参数</strong>时，原则上必须复制每个参数，每个参数都成为所传递实参的副本。对于类，作 为副本创建的对象通常由复制构造函数初始化。 调用复制构造函数的代价可能会很高。然而，即使在按值传递参数时，也有方法来避免复制: 编译器可能会优化复制对象的复制操作，并且通过移动语义，对复杂对象的操作也可以变得廉价</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span>&#125;;</span><br><span class="line">Student s;</span><br><span class="line"><span class="built_in">printV</span>(std::<span class="built_in">move</span>(s));</span><br></pre></td></tr></table></figure><p>按值传递:1. 会进行拷贝/移动构造,相当于进行了一次拷贝 2. 会decay衰变::当按值传递参数时，类型会衰变。从而数组将转换为指针，并删除 const 和 volatile 等限定符(就像使用值作为使用auto声明的对象的初始化式一样)</p><p>优点: 方便</p><p>缺点: 多一次构造并且参数会衰变，影响数组和指针</p><h4 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h4><p><strong>常量引用</strong></p><p>为了避免(不必要的)复制，传递非临时对象时，可以使用常量引用</p><p>传递引用类型不会衰变 当通过引用将参数进行传递时，就不会衰变。从而不会将数组转换为指针，并且不删除const和 volatile等限定符。因为调用参数声明为Tconst&amp;，所以模板参数T本身并没有推导为const。</p><p>优点：避免(不必要的)复制</p><p>缺点：通过引用传递参数是通过传递参数地址实现的。地址编码紧凑时，将地址从调用 方传递给被调用方的效率很高。然而，在编译代码时，传递地址会给编译器带来不确定性</p><p><strong>传递非常量引用</strong></p><p>当通过传递的参数作为返回值时(例如，使用out或inout参数时)，必须使用非常量引用(除非 通过指针传递)。在传递参数时，不会创建副本，被调用函数模板的参数只能直接访问传递的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutR</span><span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许对一个临时的(prvalue)或一个通过std::move()(xvalue)传递的现有对象调用</p><p>如果传递const就会有比较尴尬的情况.。若传递const参数，可能导致arg变成一个常量引用的声明，这意 味着允许传递右值，但这里需要左值.这种情况下，修改函数模板中传递的参数是错误的。在表达式中传递常量对象是可能的，但当 函数完全实例化时(这可能发生在编译的后期)，修改该值的尝试都将触发错误</p><p>需要使用静态断言或std::enable_if或概念禁用</p><p><strong>通过转发引用进行传递</strong></p><p>使用引用调用的原因是能够完美地转发参数。但当使用转发引用(定义为模板形参的右值引用)时，需要使用特殊的规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(T&amp;&amp; arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将参数声明为转发引用几乎完美。但是注意传左值时,T推到为左引用不能用来直接初始化值.</p><h4 id="std-ref-和std-cref"><a href="#std-ref-和std-cref" class="headerlink" title="std::ref()和std::cref()"></a>std::ref()和std::cref()</h4><p>可以<strong>让调用者决定函数模板参数是通过值传递，还是通过引用传递</strong>。当模板声明为 按值接受参数时，调用者可以使用在头文件中声明的std::cref()和std::ref()，通过引用 传递参数。 它们都是将对象包装为引用,本身不能直接与其他类型比较,往往需要一个转换.</p><h3 id="编译时编程"><a href="#编译时编程" class="headerlink" title="编译时编程"></a>编译时编程</h3><p>使用constexpr计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> p,<span class="keyword">unsigned</span> d&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoIsPrime</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">constexpr</span> value = (p%d != <span class="number">0</span>) &amp;&amp; DoIsPrime&lt;p,d<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> p&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoIsPrime</span>&lt;</span>p,<span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = (p%<span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> p&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPrime</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = DoIsPrime&lt;p,p/<span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPrime</span>&lt;</span><span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPrime</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPrime</span>&lt;</span><span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPrime</span>&lt;</span><span class="number">3</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">doIsPrime</span><span class="params">(<span class="keyword">unsigned</span> p,<span class="keyword">unsigned</span> d)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d!=<span class="number">2</span> ? (p%d!=<span class="number">0</span>) &amp;&amp; <span class="built_in">doIsPrime</span>(p,d<span class="number">-1</span>):(p%<span class="number">2</span>!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">longisPrime</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> d=<span class="number">2</span>;d&lt;=p/<span class="number">2</span>;d++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p%d==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用偏特化的执行路径选择</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> SZ,<span class="keyword">bool</span> = <span class="built_in">isPrime</span>(SZ)&gt;</span><br><span class="line">struct Helper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> SZ&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Helper</span>&lt;</span>SZ,<span class="literal">false</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> SZ&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Helper</span>&lt;</span>SZ,<span class="literal">true</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,std::<span class="keyword">size_t</span> SZ&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">foo</span><span class="params">(std::array&lt;T,SZ&gt; <span class="keyword">const</span>&amp; coll)</span> </span>&#123;</span><br><span class="line">    Helper&lt;SZ&gt; h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为函数模板不支持偏特化，所以必须使用其他机制根据某些约束来更改函数实现。可供的选择包括: </p><ul><li>带有静态函数的类</li><li>std::enable_if</li><li>SFINAE特性</li><li>编译时if特性</li></ul><h4 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h4><p>以各种参数类型重载的函数很常见。因此，当编译器看到对重载函数的调用时，必须 考虑每个候选函数，评估调用参数，并选择最匹配的候选函数。 候选集包括函数模板的情况下，编译器首先必须确定为该候选对象使用哪些模板参数，然后在 函数参数列表及其返回类型中替换这些参数，然后评估匹配程度(就像普通函数一样)。但替换过程 可能会遇到问题:可能产生毫无意义的构造。语言规则并不认为这种无意义的替换会导致错误，而 具有这种问题的候选则会直接忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foot</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(t&gt;<span class="number">0</span>)&#123; </span><br><span class="line">       <span class="built_in">foo</span> (t<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_integral_v&lt;T&gt;,<span class="string">&quot;no integral&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际使用模板"><a href="#实际使用模板" class="headerlink" title="实际使用模板"></a>实际使用模板</h3><h4 id="包含模型"><a href="#包含模型" class="headerlink" title="包含模型"></a>包含模型</h4><p>为了实例化模板，编译器必须知道应该实例化哪个定义，以及应该为哪个模板参数实例化它。常见的解决方案是使用与宏或内联函数相同的方法:在声明模板的头文件中包 含模板的定义。</p><p>这在实践中是一个问题，因为它增加了编译器编译重要程序所需的时间。因此，我们将研究一 些方法来解决这个问题，包括<strong>预编译头文件</strong>和<strong>使用显式模板实例化</strong></p><h3 id="通用库设计"><a href="#通用库设计" class="headerlink" title="通用库设计"></a>通用库设计</h3><p>C++ 中，有几种类型可以很好地用于回调，它们既可以作为函数调用参数传递，也可以以f(… ) 方式直接使用: </p><ul><li>函数指针类型 </li><li>具有重载operator()(函数操作符，有时称为函子)的类类型，包括Lambda</li><li>使用转换函数生成指向函数的指针或指向函数引用的类类型 这些类型统称为函数对象类型，这种类型的值就是函数对象</li></ul><h4 id="std-invoke"><a href="#std-invoke" class="headerlink" title="std::invoke"></a>std::invoke</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">call</span><span class="params">(Callable&amp;&amp; op,Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;std::<span class="keyword">invoke_result_t</span>&lt;Callable,Args...&gt;,<span class="keyword">void</span>&gt;)</span></span>&#123;</span><br><span class="line">        std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op),std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">decltype</span>(<span class="keyword">auto</span>) ret&#123;std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op),std::forward&lt;Args&gt;(args)...)&#125;;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型特征"><a href="#类型特征" class="headerlink" title="类型特征"></a>类型特征</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_same_v&lt;std::<span class="keyword">remove_cv_t</span>&lt;T&gt;,<span class="keyword">void</span>&gt;,<span class="string">&quot;invalid instantiation of class C for void type&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">f</span><span class="params">(V&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_reference_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_convertible_v&lt;std::<span class="keyword">decay_t</span>&lt;V&gt;,T&gt;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::has_virtual_destructor_v&lt;V&gt;)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="std-addressof"><a href="#std-addressof" class="headerlink" title="std::addressof"></a>std::addressof</h4><p> std::addressof&lt;&gt;() 函数模板生成对象或函数的实际地址。即使对象类型有重载操作符&amp;，也能 工作。尽管后者很少使用，但可能会发生。因此，如果需要任意类型对象的地址，建议使用addressof()</p><h4 id="std-declval"><a href="#std-declval" class="headerlink" title="std::declval"></a>std::declval</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT=std::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span>?std::declval&lt;T1&gt;():std::declval&lt;T2&gt;())&gt;&gt;</span><br><span class="line">RT <span class="built_in">max</span>(T1 a,T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a?a:b;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>std::declval&lt;&gt;() 函数模板可以用作特定类型的对象引用的占位符。该函数没有定义，因此不能 调用(也不创建对象)。因此，只能用于未求值的操作数(decltype和sizeof构造的操作数)。因此与其尝试创建一个对象，可以假设有一个相应类型的对象。</p><p>不过，这只可能在decltype未求值的上下文中实 现。 不要忘记使用std::decay&lt;&gt;类型来确保默认的返回类型不是一个引用，因为std::declval()本身 会产生右值引用。否则，像max(1,2)这样的调用将得到一个int&amp;&amp;的返回类型</p><h4 id="完美转发临时变量"><a href="#完美转发临时变量" class="headerlink" title="完美转发临时变量"></a>完美转发临时变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">g</span>(std::forward&lt;T&gt;(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板参数的引用"><a href="#模板参数的引用" class="headerlink" title="模板参数的引用"></a>模板参数的引用</h4><p>使用decltype(auto)可以很容易地产生引用类型，因此在上下文中最好不要使用。</p><p>开发者应该注意 decltype 产生类型的差别，这取决于传递的参数是声明还是表达式: • decltype(e) 中，若e 是实体 (如变量、函数、枚举器或数据成员) 或类成员访问的名称，则 decltype(e) 生成该实体声明的类型或指定的类成员。因此，decltype可以用来检查变量的类型。 这用在需要精确匹配现有声明的类型时。否则，若e是其他表达式，decltype(e)会产生一个类型，表示该表达式的类型和值别</p><ul><li>若e是类型T的左值，则decltype(e)生成T&amp;。</li><li>若e是类型T的xvalue，则decltype(e)生成T&amp;&amp;。</li><li>若e是类型T的prvalue，则decltype(e)生成T</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_ref</span><span class="params">(std::string&amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    std::is_lvalue_reference&lt;<span class="keyword">decltype</span>(s)&gt;::value;</span><br><span class="line">    std::is_rvalue_reference&lt;<span class="keyword">decltype</span>(s)&gt;::value;</span><br><span class="line">    std::is_same&lt;<span class="keyword">decltype</span>(s),std::string&amp;&gt;::value;</span><br><span class="line">    std::is_same&lt;<span class="keyword">decltype</span>(s),std::string&amp;&amp;&gt;::value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::is_lvalue_reference&lt;<span class="keyword">decltype</span>((s))&gt;::value;</span><br><span class="line">    std::is_rvalue_reference&lt;<span class="keyword">decltype</span>((s))&gt;::value;</span><br><span class="line">    std::is_same&lt;<span class="keyword">decltype</span>((s)),std::string&amp;&gt;::value;</span><br><span class="line">    std::is_same&lt;<span class="keyword">decltype</span>((s)),std::string&amp;&amp;&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto使用模板参数推导规则来确定感兴趣的类型，实际的类型是通过直接对表达式应用decltype来确定</p><h2 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h2><p>可以为模板特化显式地创建实例化点。实现点的构造称为显式实例化指令。语法上，由关键字 template 和要实例化的特化声明组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(F)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> f&lt;&gt;(<span class="keyword">float</span>);</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="手动实例化"><a href="#手动实例化" class="headerlink" title="手动实例化"></a>手动实例化</h3><p>自动模板实例化对构建时间有很大的负面影响。对于实现贪婪实 例化的编译器来说尤其如此，因为相同的模板特化，可能在许多不同的翻译单元中实 例化和优化</p><p>改进构建时间的技术包括，在<strong>特定位置手动实例化程序所需的那些模板特化</strong>，并<strong>在所有其他翻译单元中抑制实例化</strong>。确保这种抑制的一种可移植的方法是不提供模板定义，除非在显式实例化的 翻译单元中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻译单元1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">exf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    exf&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻译单元2</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">exf</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个翻译单元中，编译器无法看到函数模板f的定义，因此不会(不能)生成f的实例化。 第二个翻译单元通过显式实例化定义提供f的定义;没有它，程序将无法连接。 手动实例化有一个明显的缺点:必须小心地跟踪要实例化的实体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// no definition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f.tpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;f.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// definition</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// f.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;f.tpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// manual instantiation</span></span><br></pre></td></tr></table></figure><p>可以只包含f.hpp来获得f的声明，可以根据需要将显式实例化添加到f.cpp中。或者，若手动实例化过于繁重，还可以包含f.tpp来启用自动实例化。</p><h3 id="显示实例化声明"><a href="#显示实例化声明" class="headerlink" title="显示实例化声明"></a>显示实例化声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// t.cpp</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">int</span>&gt;()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> f&lt;<span class="keyword">float</span>&gt;()&#123;&#125;;</span><br></pre></td></tr></table></figure><p>消除冗余自动实例化的一种更有针对性的方法是使用显式实例化声明，它以关键字extern为前缀的显式实例化指令。<strong>显式实例化声明通常会抑制已命名模板特化的自动实例化，因为声明已命名模板特化将在程序中的某个地方定义</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++的模板编程是学习C++不可或缺的一部分,说来讽刺,这部分在Rust中实现得很优雅.&lt;br&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://www.sekyoro.top/tags/C/"/>
    
    <category term="C++ templates" scheme="https://www.sekyoro.top/tags/C-templates/"/>
    
  </entry>
  
  <entry>
    <title>vqvae及其变体代码学习</title>
    <link href="https://www.sekyoro.top/2024/11/18/vqvae%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/11/18/vqvae%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-11-18T10:13:55.000Z</published>
    <updated>2024-11-22T14:58:48.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vqvae出自<a href="https://arxiv.org/abs/1711.00937">[1711.00937] Neural Discrete Representation Learning</a>,用于无监督学习离散表征,目前在多模态生成领域还有使用. 这里学习一下代码</p><span id="more"></span><h2 id="VQVAE"><a href="#VQVAE" class="headerlink" title="VQVAE"></a>VQVAE</h2><p>vqvae道理本身很简单,它的提出与pixelcnn、自回归模型息息相关,像vae,gan这种生成式模型,它们更像是对整个数据进行估计,而自回归模型又与序列模型相关,更像是对数据生成分布的建模</p><blockquote><p>自回归模型以序列中的先前值为条件进行预测，而不是基于潜在随机变量。因此，他们试图对数据生成分布进行显式建模，而不是对其进行近似</p></blockquote><p>poixelcnn就是一个自回归模型,而其每次就是从vqvae得到的离散结果中进行采样序列性地生成结果,为了实现这种效果利用了一种masked convolution,将卷积权重后面部分置0,使得在卷积的时候不关注后面的结果<a href="https://github.com/pilipolio/learn-pytorch/blob/master/201708_ToyPixelCNN.ipynb">ToyPixelCNN.ipynb at master · pilipolio/learn-pytorch</a></p><p><img data-src="https://camo.githubusercontent.com/2b432c6d87633c75685c3703167c0a6b5a6d6592a7ca95540bf02f6de890052c/68747470733a2f2f6c696c69616e77656e672e6769746875622e696f2f6c696c2d6c6f672f6173736574732f696d616765732f706978656c2d636e6e2e706e67" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaskedConv</span>(<span class="params">nn.Conv2d</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mask_type, *args, **kwargs</span>):</span></span><br><span class="line"><span class="built_in">super</span>(MaskedConv, self).__init__(*args, **kwargs)</span><br><span class="line">self.mask_type = mask_type</span><br><span class="line">self.register_buffer(<span class="string">&#x27;mask&#x27;</span>, self.weight.data.clone())</span><br><span class="line"></span><br><span class="line">channels, depth, height, width = self.weight.size()</span><br><span class="line"></span><br><span class="line">self.mask.fill_(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> mask_type ==<span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">self.mask[:,:,height//<span class="number">2</span>,width//<span class="number">2</span>:] = <span class="number">0</span></span><br><span class="line">self.mask[:,:,height//<span class="number">2</span>+<span class="number">1</span>:,:] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">self.mask[:,:,height//<span class="number">2</span>,width//<span class="number">2</span>+<span class="number">1</span>:] = <span class="number">0</span></span><br><span class="line">self.mask[:,:,height//<span class="number">2</span>+<span class="number">1</span>:,:] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">self.weight.data *= self.mask </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>(MaskedConv, self).forward(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在许多的模型,包括transformer都是auto-regressive的,而GAN与VAE并不是,它们的缺点就是难以建模离散数据.而vqvae就弥补了这一点.</p><p>而VQVAE中重点其实是设计好一个离散字典后,使用了一种技巧将梯度传导使得能够更新这个字典.</p><p>这种设计称作直通估计器,将decoder得到的梯度直接传到了encoder.假设codebook的shape是[codebook_size,codebook_dim],输入特征shape是[size,codebook_dim],通过一个指标得到它们的距离(可以使用<code>torch.cdist</code>)得到[size,codebook_size],这相当于得到了特征上每个位置在字典上对应的位置.</p><p><img data-src="https://notesbylex.com/_media/vq.png" alt="Vector Quantisation"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line">dist_manual = torch.sqrt(</span><br><span class="line">        torch.<span class="built_in">sum</span>(x ** <span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) +</span><br><span class="line">        torch.<span class="built_in">sum</span>(y ** <span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>).t() -</span><br><span class="line">        <span class="number">2</span> * x @ y.t()</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># 写法2 better readable and efficient since no gradient computation</span></span><br><span class="line">      <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            dist = torch.cdist(x, implicit_codebook)</span><br><span class="line">            indices = dist.argmin(dim = -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>根据最近的距离得到嵌入后的特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法1  </span></span><br><span class="line">min_encoding_indices = torch.argmin(d, dim=<span class="number">1</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># (encoded_feat size,1)</span></span><br><span class="line">        min_encodings = torch.zeros(</span><br><span class="line">            min_encoding_indices.shape[<span class="number">0</span>], self.n_e, device=z.device)  <span class="comment"># (encoded_feat size,embedding_size)</span></span><br><span class="line">        min_encodings.scatter_(<span class="number">1</span>, min_encoding_indices, <span class="number">1</span>)  <span class="comment"># one-hot  like</span></span><br><span class="line"><span class="comment"># 写法2 dry and more clean</span></span><br><span class="line">min_encoding_indices = torch.argmin(d, dim=<span class="number">1</span>)</span><br><span class="line">    my_min_encodings = F.one_hot(min_encoding_indices.squeeze())</span><br></pre></td></tr></table></figure><p><code>one-hot</code>的shape是[encode_size,embed_size],下面公式中第三项是commitment loss,用于更新encoder输出,第三项用于更新字典</p><blockquote><p>为了学习嵌入空间，使用最简单的字典学习算法之一，向量量化( VQ )。VQ目标使用l2误差将嵌入向量ei移动到编码器输出ze ( x )</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z_q = torch.matmul(min_encodings, self.embedding.weight).view(z.shape)</span><br><span class="line">        loss =  self.beta * torch.mean((z_q - z.detach()) ** <span class="number">2</span>))+torch.mean(((z_q.detach() - z) ** <span class="number">2</span>)</span><br><span class="line">        z_q = z + (z_q - z).detach()</span><br><span class="line">                                                <span class="comment"># torch.mean((z_q-z.detach())**2) 可以更简单地写为</span></span><br><span class="line"> F.mse_loss(z_q,z_e.detach())</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/11/19/1EByprM63fZXdON.png" alt="image-20241119192654741"></p><p>此外可以使用EMA更新字典</p><p><img data-src="https://s2.loli.net/2024/11/19/u2JyvB6W59j3PHC.png" alt="image-20241119202801862"></p><p>这里的更新逻辑是,每次更新ema_cluster_size,针对每个嵌入的向量,得到与它最近的特征向量个数,通过ema更新,而权重就是每次嵌入的值通过ema更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Update weights with EMA</span></span><br><span class="line">       <span class="keyword">if</span> self.training:</span><br><span class="line">           self._ema_cluster_size = self._ema_cluster_size * self._decay + (</span><br><span class="line">               <span class="number">1</span> - self._decay</span><br><span class="line">           ) * torch.<span class="built_in">sum</span>(encodings, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           <span class="comment"># Laplace smoothing</span></span><br><span class="line">           n = torch.<span class="built_in">sum</span>(self._ema_cluster_size.data)</span><br><span class="line">           self._ema_cluster_size = (</span><br><span class="line">               (self._ema_cluster_size + self._epsilon)</span><br><span class="line">               / (n + self._n_embeddings * self._epsilon)</span><br><span class="line">               * n</span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line">           dw = torch.matmul(encodings.t(), flat_z_e)</span><br><span class="line">           self._ema_w = nn.Parameter(</span><br><span class="line">               self._ema_w * self._decay + (<span class="number">1</span> - self._decay) * dw</span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line">           self._embedding.weight = nn.Parameter(</span><br><span class="line">               self._ema_w / self._ema_cluster_size.unsqueeze(<span class="number">1</span>)</span><br><span class="line">           )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/11/19/LjYv1nK2odfCQe6.png" alt="image-20241119222201269"></p><h2 id="VQVAE-2"><a href="#VQVAE-2" class="headerlink" title="VQVAE-2"></a>VQVAE-2</h2><p>简单来说就是多尺度的vqvae,设计了多个encoder-codelayer-decoder.<br>首先特征通过多个encoder降维,得到不同尺度的特征,再将不同尺度特征进行quantize,quantize后得到的特征进行上采样再decoder最终得到多尺度特征. </p><p>此外也有VQGAN论文在多尺度的基础上提出将codebook的维度从256到32,重建效果保持一致,同时将解码后的特征与codebook做l2-norm,使用cos相似度判断</p><h2 id="Residual-VQ"><a href="#Residual-VQ" class="headerlink" title="Residual VQ"></a>Residual VQ</h2><p>道理非常简单——quantize(x-quantize(x-quantize(x-…)))</p><p><img data-src="https://notesbylex.com/_media/vq-for-audio.png" alt="Vector Quantisation for Audio"></p><p><img data-src="https://notesbylex.com/_media/residual-vector-quantization-fig-2%201.png" alt="SoundStream architecture"></p><h2 id="SIMVQ"><a href="#SIMVQ" class="headerlink" title="SIMVQ"></a>SIMVQ</h2><p><img data-src="https://s2.loli.net/2024/11/19/O2APLos7bE9Fdgf.png" alt="image-20241119222219261"></p><p>据论文作者所说,在codebook上进行维度转换,提高编码表的利用率,使得在许多优化器上表现更好. 在具体代码上,我参考了<a href="https://github.com/lucidrains/vector-quantize-pytorch/tree/master">lucidrains/vector-quantize-pytorch: Vector (and Scalar) Quantization, in Pytorch</a>的实现,其使用一个linear层变换codebook的维度,在进行计算距离时也使用这个转换后的codebook,量化也使用这个codebook,这样一来特征经过encoder后的维度需要与转换后的codebook的维度一致.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> inverse(rotated)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimVQ</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            dim,</span></span></span><br><span class="line"><span class="params"><span class="function">            codebook_size,</span></span></span><br><span class="line"><span class="params"><span class="function">            codebook_transform: Module | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            init_fn: <span class="type">Callable</span> = identity,</span></span></span><br><span class="line"><span class="params"><span class="function">            channel_first=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            rotation_trick=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            input_to_quantize_commit_loss_weight=<span class="number">.25</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            commitment_weight=<span class="number">1.</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            frozen_codebook_dim=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.codebook_size = codebook_size</span><br><span class="line">        self.channel_first = channel_first</span><br><span class="line"></span><br><span class="line">        frozen_codebook_dim = default(frozen_codebook_dim, dim)</span><br><span class="line">        codebook = torch.randn(codebook_size, frozen_codebook_dim) * (frozen_codebook_dim ** -<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">        codebook = init_fn(codebook)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exists(codebook_transform):</span><br><span class="line">            codebook_transform = nn.Linear(frozen_codebook_dim, dim, bias=<span class="literal">False</span>)</span><br><span class="line">        self.code_transform = codebook_transform</span><br><span class="line">        self.register_buffer(<span class="string">&quot;frozen_codebook&quot;</span>, codebook)</span><br><span class="line"></span><br><span class="line">        self.rotation_trick = rotation_trick</span><br><span class="line">        self.input_to_quantize_commit_loss_weight = input_to_quantize_commit_loss_weight</span><br><span class="line">        self.commitment_weight = commitment_weight</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">codebook</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.code_transform(self.frozen_codebook)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">indices_to_codes</span>(<span class="params">self, indices</span>):</span></span><br><span class="line">        frozen_codes = self.frozen_codebook(indices)</span><br><span class="line">        quantized = self.code_transform(frozen_codes)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.channel_first:</span><br><span class="line">            quantized = rearrange(quantized, <span class="string">&#x27;b ... d -&gt; b d ...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> quantized</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.channel_first:</span><br><span class="line">            x = rearrange(x, <span class="string">&#x27;b ... d -&gt; b d ...&#x27;</span>)</span><br><span class="line">        x, inverse_pack = pack_one(x, <span class="string">&#x27;b * d&#x27;</span>)</span><br><span class="line">        implicit_codebook = self.codebook</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            dist = torch.cdist(x, implicit_codebook)</span><br><span class="line">            indices = dist.argmin(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        quantized = implicit_codebook[indices]</span><br><span class="line">        commit_loss = F.mse_loss(x.detach(), quantized)</span><br><span class="line">        <span class="keyword">if</span> self.rotation_trick:</span><br><span class="line">            quantized = rotate_to(x, quantized)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            commit_loss = (commit_loss + F.mse_loss(x, quantized.detach()) * self.input_to_quantize_commit_loss_weight)</span><br><span class="line">            quantized = (quantized - x).detach() + x</span><br><span class="line">        quantized = inverse_pack(quantized)</span><br><span class="line">        indices = inverse_pack(indices, <span class="string">&#x27;b *&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.channel_first:</span><br><span class="line">            quantized = rearrange(quantized, <span class="string">&#x27;b ... d-&gt; b d...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> quantized, indices, commit_loss * self.commitment_weight</span><br></pre></td></tr></table></figure><p>可以看到上面代码中经常用到einops和einx以及torch的einsum操作,这些都是非常方便的库或者函数.这里介绍一下</p><h2 id="einops中常用操作"><a href="#einops中常用操作" class="headerlink" title="einops中常用操作"></a>einops中常用操作</h2><p><img data-src="https://s2.loli.net/2024/11/19/qWTtJIihjCaeVk9.png" alt="image-20241119201935141"></p><h3 id="rearrange"><a href="#rearrange" class="headerlink" title="rearrange"></a>rearrange</h3><p>最常用的就是rearrange了,可以用来转换axis的顺序,composition,decomposition等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># order</span></span><br><span class="line">y = rearrange(x,<span class="string">&#x27;b c h w -&gt; b h w c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="comment"># composition</span></span><br><span class="line">y = rearrange(x,<span class="string">&#x27;b c h w -&gt; b c (h w)&#x27;</span>)</span><br><span class="line"><span class="comment"># decomposition</span></span><br><span class="line">y = rearrange(y,<span class="string">&#x27;b c (h w) -&gt; b h w c&#x27;</span>)</span><br><span class="line">y = rearrange(y,<span class="string">&#x27;(b1 b2) h w c -&gt; b1 b2 h w c&#x27;</span>,b1=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yet another example. Can you compute result shape?</span></span><br><span class="line"><span class="attribute">reduce</span>(ims, <span class="string">&quot;(b1 b2) h w c -&gt; (b2 h) (b1 w)&quot;</span>, <span class="string">&quot;mean&quot;</span>, b<span class="number">1</span>=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>可以用于求均值,maxpooling等,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ims = torch.randn((<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>))*<span class="number">10</span>-<span class="number">2</span></span><br><span class="line">b,c,h,w = ims.shape</span><br><span class="line">m_ims = reduce(ims,<span class="string">&#x27;b c h w -&gt; b c&#x27;</span>,<span class="string">&quot;min&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m_ims.shape)</span><br><span class="line"></span><br><span class="line">m_ims = reduce(ims,<span class="string">&#x27;b c h w -&gt; b (h w) c&#x27;</span>,<span class="string">&#x27;min&#x27;</span>).transpose(<span class="number">1</span>,<span class="number">2</span>).reshape(b,c,h,w)</span><br><span class="line"><span class="built_in">print</span>(m_ims.shape)</span><br><span class="line"><span class="built_in">print</span>(ims == m_ims)</span><br><span class="line">min2_ims = reduce(ims,<span class="string">&#x27;b c (h h2) (w w2) -&gt; b c h w&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,h2=<span class="number">2</span>,w2=<span class="number">2</span>)</span><br><span class="line">reduce(ims,<span class="string">&#x27;b (h h2) (w w2) c -&gt; h (b w) c&#x27;</span>,<span class="string">&quot;max&quot;</span>,h2=<span class="number">2</span>,w2=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通过使用<code>()</code>保持dim,或者也可以使用<code>1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = torch.randn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line">mean_ = reduce(data,<span class="string">&#x27;b c h w  -&gt; b c () ()&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>) <span class="comment"># 求均值</span></span><br><span class="line">ans = data.mean(dim=[<span class="number">2</span>,<span class="number">3</span>],keepdim=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>((((ans-mean_)&lt;<span class="number">1e-6</span>).<span class="built_in">float</span>()).mean())</span><br><span class="line"></span><br><span class="line">max_pool = reduce(data,<span class="string">&#x27;b c (2 h) (2 w) -&gt; b c h w&#x27;</span>,<span class="string">&#x27;max&#x27;</span>) <span class="comment">#max pooling</span></span><br><span class="line">adaptive_max_pool = reduce(data,<span class="string">&#x27;b c h w -&gt; b c ()&#x27;</span>,<span class="string">&#x27;max&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="stack-and-concatenation"><a href="#stack-and-concatenation" class="headerlink" title="stack and concatenation"></a>stack and concatenation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rearrange can also take care of lists of arrays with the same shape</span></span><br><span class="line">x = <span class="built_in">list</span>(ims)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x), <span class="string">&quot;with&quot;</span>, <span class="built_in">len</span>(x), <span class="string">&quot;tensors of shape&quot;</span>, x[<span class="number">0</span>].shape)</span><br><span class="line"><span class="comment"># that&#x27;s how we can stack inputs</span></span><br><span class="line"><span class="comment"># &quot;list axis&quot; becomes first (&quot;b&quot; in this case), and we left it there</span></span><br><span class="line">rearrange(x, <span class="string">&quot;b h w c -&gt; b h w c&quot;</span>).shape</span><br></pre></td></tr></table></figure><p>将一个列表的tensor中的列表大小维度进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">list</span>()</span><br><span class="line">c.append(torch.randn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>))</span><br><span class="line">c.append(torch.randn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">rearrange(c,<span class="string">&#x27;l c h w -&gt; c l h w&#x27;</span>).shape</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者求一个列表中的所有tensor和、max等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">list</span>()</span><br><span class="line">c.append(torch.randn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>))</span><br><span class="line">c.append(torch.randn(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">rearrange(c,<span class="string">&#x27;l c h w -&gt; c l h w&#x27;</span>).shape</span><br><span class="line">reduce(c,<span class="string">&#x27;c l h w -&gt; l h w&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>).shape</span><br><span class="line">reduce(c,<span class="string">&#x27;c l h w -&gt; l h w&#x27;</span>,<span class="string">&#x27;sum&#x27;</span>).shape</span><br><span class="line">reduce(c,<span class="string">&#x27;c l h w -&gt; l h w&#x27;</span>,<span class="string">&#x27;max&#x27;</span>).shape</span><br></pre></td></tr></table></figure><h3 id="add-or-remove-axis"><a href="#add-or-remove-axis" class="headerlink" title="add or remove axis"></a>add or remove axis</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = rearrange(x,<span class="string">&#x27;b h w c -&gt; b 1 h w 1 c&#x27;</span>)</span><br><span class="line">y = rearrange(y,<span class="string">&#x27;b h w c - b h (w c)&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="channel-shuffle"><a href="#channel-shuffle" class="headerlink" title="channel shuffle"></a>channel shuffle</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = torch.randn(<span class="number">10</span>,<span class="number">30</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">rearrange(c,<span class="string">&#x27;b (g1 g2 c) h w -&gt; b (g2 g1 c) h w&#x27;</span>,g1=<span class="number">3</span>,g2=<span class="number">5</span>).shape</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat(x,<span class="string">&#x27;b h w c -&gt; b (h 2) (w 2) c&#x27;</span>)</span><br><span class="line">repeat(x,<span class="string">&#x27;h w c -&gt; h new_axis w c&#x27;</span>,new_axis=<span class="number">5</span>)</span><br><span class="line">repeat(x,<span class="string">&#x27;h w c -&gt; h 5 w c&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="split-dimension"><a href="#split-dimension" class="headerlink" title="split dimension"></a>split dimension</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = torch.randn(<span class="number">10</span>,<span class="number">30</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">x,y,z = rearrange(c,<span class="string">&#x27;b (head c) h w -&gt; head b c h w&#x27;</span>,head=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shape,y.shape,z.shape)</span><br></pre></td></tr></table></figure><p>split有不同方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y1, y2 = rearrange(x, <span class="string">&#x27;b (split c) h w -&gt; split b c h w&#x27;</span>, split=<span class="number">2</span>)</span><br><span class="line">result = y2 * sigmoid(y2) <span class="comment"># or tanh</span></span><br><span class="line">y1, y2 = rearrange(x, <span class="string">&#x27;b (c split) h w -&gt; split b c h w&#x27;</span>, split=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><code>y1 = x[:, :x.shape[1] // 2, :, :]</code></li><li><code>y1 = x[:, 0::2, :, :]</code></li></ul><h3 id="striding-anything"><a href="#striding-anything" class="headerlink" title="striding anything"></a>striding anything</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># each image is split into subgrids, each subgrid now is a separate &quot;image&quot;</span></span><br><span class="line">y = rearrange(x, <span class="string">&quot;b c (h hs) (w ws) -&gt; (hs ws b) c h w&quot;</span>, hs=<span class="number">2</span>, ws=<span class="number">2</span>)</span><br><span class="line">y = convolve_2d(y)</span><br><span class="line"><span class="comment"># pack subgrids back to an image</span></span><br><span class="line">y = rearrange(y, <span class="string">&quot;(hs ws b) c h w -&gt; b c (h hs) (w ws)&quot;</span>, hs=<span class="number">2</span>, ws=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> y.shape == x.shape</span><br></pre></td></tr></table></figure><p>可以看到最常用的函数就是<code>rearrange</code>,<code>reduce</code>以及<code>repeat</code>,基本替代了原本的<code>sum</code>,<code>transpose</code>,<code>expand</code>,<code>reshape</code>等torch操作</p><h3 id="parse-shape"><a href="#parse-shape" class="headerlink" title="parse_shape"></a>parse_shape</h3><p>通过<code>parse_shape</code>,相当于更方便地获得了需要的维度大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = np.zeros([<span class="number">700</span>])</span><br><span class="line">rearrange(y, <span class="string">&#x27;(b c h w) -&gt; b c h w&#x27;</span>, **parse_shape(x, <span class="string">&#x27;b _ h w&#x27;</span>)).shape</span><br></pre></td></tr></table></figure><h3 id="pack-and-unpack"><a href="#pack-and-unpack" class="headerlink" title="pack and unpack"></a>pack and unpack</h3><p>pack是将一些列数据中的的一些维度放在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h,w = <span class="number">100</span>,<span class="number">200</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_rgb = np.random.random([h,w,<span class="number">3</span>])</span><br><span class="line">img_depth = np.random.random([h,w])</span><br><span class="line">img_rgbd,ps = pack([img_rgb,img_depth],<span class="string">&#x27;h w *&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(img_rgbd.shape,ps)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unpacked_rgb,unpacked_depth = unpack(img_rgbd,ps,<span class="string">&quot;h w *&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(unpacked_rgb.shape,unpacked_depth.shape)</span><br></pre></td></tr></table></figure><h3 id="结合torch使用layers"><a href="#结合torch使用layers" class="headerlink" title="结合torch使用layers"></a>结合torch使用layers</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> einops.layers.torch <span class="keyword">import</span> Rearrange,Reduce</span><br></pre></td></tr></table></figure><h3 id="Einx"><a href="#Einx" class="headerlink" title="Einx"></a>Einx</h3><p>一种类似<code>torch.einsum</code>的计算方式,einsum<a href="https://rockt.github.io/2018/04/30/einsum">einsum tutorial</a>是一种方便计算多个tensor乘积的方式,而Einx方便了写MLP-based架构代码,通过weight_shape和bias_shape结合pattern构造mlp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> einops.layers.torch <span class="keyword">import</span> EinMix <span class="keyword">as</span> Mix</span><br><span class="line">mlp = Mix(<span class="string">&#x27;t b c-&gt; t b c_out&#x27;</span>,weight_shape=<span class="string">&#x27;c c_out&#x27;</span>,c=<span class="number">10</span>,c_out=<span class="number">20</span>)</span><br><span class="line">x = torch.randn(<span class="number">10</span>,<span class="number">30</span>,<span class="number">10</span>)</span><br><span class="line">y = mlp(x)</span><br></pre></td></tr></table></figure><p>值得一提的是,einops也有einsum</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> einops <span class="keyword">import</span> einsum, pack, unpack</span><br><span class="line"><span class="comment"># einsum is like ... einsum, generic and flexible dot-product</span></span><br><span class="line"><span class="comment"># but 1) axes can be multi-lettered  2) pattern goes last 3) works with multiple frameworks</span></span><br><span class="line">C = einsum(A, B, <span class="string">&#x27;b t1 head c, b t2 head c -&gt; b head t1 t2&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://github.com/MishaLaskin/vqvae">MishaLaskin/vqvae: A pytorch implementation of the vector quantized variational autoencoder (https://arxiv.org/abs/1711.00937)</a></li><li><a href="https://github.com/nadavbh12/VQ-VAE/blob/master/vq_vae/auto_encoder.py">VQ-VAE/vq_vae/auto_encoder.py at master · nadavbh12/VQ-VAE</a></li><li><a href="https://github.com/AndrewBoessen/VQ-VAE/blob/main/vqvae.py">VQ-VAE/vqvae.py at main · AndrewBoessen/VQ-VAE</a></li><li><a href="https://github.com/vvvm23/vqvae-2/blob/main/vqvae.py">vqvae-2/vqvae.py at main · vvvm23/vqvae-2</a></li><li><a href="https://www.georgeho.org/deep-autoregressive-models/">Autoregressive Models in Deep Learning — A Brief Survey | George Ho</a></li><li><a href="https://github.com/lucidrains/vector-quantize-pytorch/tree/master">lucidrains/vector-quantize-pytorch: Vector (and Scalar) Quantization, in Pytorch</a></li><li><a href="https://spaces.ac.cn/archives/6760">VQ-VAE的简明介绍：量子化自编码器 - 科学空间|Scientific Spaces</a></li><li><a href="https://spaces.ac.cn/archives/10489">VQ的旋转技巧：梯度直通估计的一般推广 - 科学空间|Scientific Spaces</a></li><li><a href="https://spaces.ac.cn/archives/10519">VQ的又一技巧：给编码表加一个线性变换 - 科学空间|Scientific Spaces</a></li><li><a href="https://einops.rocks/pytorch-examples.html">Writing better code with pytorch+einops</a></li><li><a href="https://notesbylex.com/residual-vector-quantisation">Residual Vector Quantisation - Notes by Lex</a></li><li><a href="https://github.com/rese1f/awesome-VQVAE?tab=readme-ov-file">rese1f/Awesome-VQVAE: A collection of resources and papers on Vector Quantized Variational Autoencoder (VQ-VAE) and its application</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;vqvae出自&lt;a href=&quot;https://arxiv.org/abs/1711.00937&quot;&gt;[1711.00937] Neural Discrete Representation Learning&lt;/a&gt;,用于无监督学习离散表征,目前在多模态生成领域还有使用. 这里学习一下代码&lt;/p&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
    <category term="vqvae" scheme="https://www.sekyoro.top/tags/vqvae/"/>
    
  </entry>
  
  <entry>
    <title>文生图相关模型最新进展小结</title>
    <link href="https://www.sekyoro.top/2024/11/03/%E6%96%87%E7%94%9F%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9E%8B%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/"/>
    <id>https://www.sekyoro.top/2024/11/03/%E6%96%87%E7%94%9F%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9E%8B%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/</id>
    <published>2024-11-03T11:47:36.000Z</published>
    <updated>2024-11-13T02:41:33.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在较早的VAE和GAN时代,通过图形生成模型,可能出现模式坍塌(个人理解就是生成图像多样性不足)并且只有图像数据参与,在之后的diffusion时代(包括现在),有了多模态的加入,通过文本、深度图以及骨骼图(e.g.ControlNet)控制图像生成有了更高的自由度和创造性.此外有了类似LoRA,IP-Adapter等等技术提供了更好的微调方式用于在更新模型权重保持良好的风格迁移(比如原本模型训练集中没有的人物,在微调时增加新人物训练能有良好表现)或人物一致性(不同的角色不至于长得一样)</p><p>而在最近有了更多在一些较大模型(stable diffusionv3,novelai,sdxl等)上微调的模型,它们更加专注于某种画风。此外本文尝试总结目前文生图、艺术图片等生成式AI应用,最后从图片展望生成式视频创作。相对于论文、原理，这里更注重模型与应用。</p><span id="more"></span><p>之前我介绍过生成式模型与相关技术,这里不作过多介绍。</p><h2 id="模型与技术的进展"><a href="#模型与技术的进展" class="headerlink" title="模型与技术的进展"></a>模型与技术的进展</h2><p>首先,我们需要一个较大的模型,这个模型在较大的数据集上经过充分训练,已经有了相应的”知识”.作为普通用户一般不去训练这样的模型,直接下载即可<a href="https://huggingface.co/models?pipeline_tag=text-to-image&amp;sort=downloads">Models - Hugging Face</a>. 这类模型的技术从较早的VAE,flow-based,GAN到目前处于统治地位的diffusion. 可以说目前依然是diffusion的天下,基于diffusion的常用模型包括stability(或者说compvis,stability公司争议很大)下的stable diffusion,目前到了SDXL和v3.5,<a href="https://novelai.net/">NovelAI - The AI Storyteller</a>下的<a href="https://docs.novelai.net/image/models.html#novelai-diffusion-anime-v3">NovelAI Diffusion Anime V3</a>(之前<a href="https://rentry.org/sdg_FAQ">泄露过novelai早期模型</a>),但novelai本身并没有开源模型,此外还有midjourney等,但这些大都需要付费而且定制化不高大概率也不能<a href="https://zh.wikipedia.org/zh-hans/NSFW">NSFW</a>.</p><p>所以,从目前看来开源的底模(也就是上面所说的diffusion较大的模型)看起来只有stability下的对用户友好了,因为开源,社区也很给力,有了很多相关工具.</p><p>目前来看<a href="https://huggingface.co/models?pipeline_tag=text-to-image&amp;sort=downloads">Models - Hugging Face</a>,<a href="https://civitai.com/">Civitai: The Home of Open-Source Generative AI</a>以及<a href="https://rentry.co/stablediffusion">Stable Diffusion Rentries + Simple Installation Tutorial!</a>是较好的模型下载和学习资源. </p><p>此外也有<a href="https://www.reddit.com/r/StableDiffusion/wiki/index/">Reddit</a>社区,x上的相关社区以及一些相关discord作为被动看看新闻和高手们在干什么.</p><p>在两三年前,用的比较多的是stable diffusionv1.5(目前被runway删了,但网上还是有很多备份),后来有了sdxl,sdv3以及现在的sdv3.5</p><p><img data-src="https://s2.loli.net/2024/11/04/5WEsn1PwASLDbce.png" alt="image-20241104213845495"></p><p>而目前最新的就是3.5版本和sdxl,往往我们都需要这些底模. 至于这些底模有什么大差别,我认为主要还是在数据集和模型参数量上,当然如果模型太大,本地可能也不好运行.所以还是量力而行.</p><p>在这些底模基础上,通过微调技术,衍生出了一大堆社区的模型.最早的微调模型基本都是基于sd1.5或早期泄露的nai</p><ul><li><a href="https://civitai.com/models/66/anything-v3">Anything V3 - fp16 | Stable Diffusion Checkpoint | Civitai</a></li><li><a href="https://huggingface.co/gsdf/Counterfeit-V2.0">gsdf/Counterfeit-V2.0 · Hugging Face</a></li><li><a href="https://huggingface.co/hakurei/waifu-diffusion-v1-4">hakurei/waifu-diffusion-v1-4 · Hugging Face</a></li><li><a href="https://civitai.com/models/4201/realistic-vision-v13">Realistic Vision V6.0 B1 - V5.1 Hyper (VAE) | Stable Diffusion Checkpoint | Civitai</a></li></ul><p>可以看到还是专注生成人物的居多</p><p>这里挑选几个目前最火的,大多基于SDXL,除了Flux之外都是社区基于Stable diffusion的开源模型.</p><h3 id="Animagine3"><a href="#Animagine3" class="headerlink" title="Animagine3"></a>Animagine3</h3><p><a href="https://huggingface.co/cagliostrolab/animagine-xl-3.0">cagliostrolab/animagine-xl-3.0 · Hugging Face</a></p><p>基于SDXL</p><h3 id="Pony"><a href="#Pony" class="headerlink" title="Pony"></a>Pony</h3><p><a href="https://civitai.com/models/257749?modelVersionId=290640">Pony Diffusion V6 XL - V6 (start with this one) | Stable Diffusion Checkpoint | Civitai</a></p><p><a href="https://civitai.com/models/288584?modelVersionId=324619">AutismMix SDXL - AutismMix_pony | Stable Diffusion Checkpoint | Civitai</a></p><h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p><a href="https://github.com/black-forest-labs/flux">black-forest-labs/flux: Official inference repo for FLUX.1 models</a></p><p>Stability出走人员新开的公司Black Forest Lab下的开源模型<a href="https://blackforestlabs.io/flux-1/">FLUX.1 - BlackForestLabs</a></p><h3 id="illustrious"><a href="#illustrious" class="headerlink" title="illustrious"></a>illustrious</h3><p><a href="https://civitai.com/models/795765/illustrious-xl">Illustrious-XL - v0.1 | Illustrious Checkpoint | Civitai</a></p><h4 id="Noob"><a href="#Noob" class="headerlink" title="Noob"></a>Noob</h4><p><a href="https://civitai.com/models/833294/noobai-xl-nai-xl">NoobAI-XL (NAI-XL) - Epsilon-pred 1.0-Version | Stable Diffusion XL Checkpoint | Civitai</a></p><p>一些评价<a href="https://tieba.baidu.com/p/9224285639#151086745100l">了解下大家都在用什么版本-百度贴吧</a></p><blockquote><p>对于普通爱好者<br>sd1.5仅有的用处是controlnet的inpaint扩图换衣，缺点是手脚画不好<br>pony是sdxl早期的威力加强版，主打涩图，社区分享r18/r18g最广泛，最优模型是tponynai3/wai等<br>sdxl近一个月推出illustrious力争无限接近nai3，比pony省略角色lora姿势lora画风lora可以单tag直接呼出省略调权步骤色彩污染等，最优模型是tillu3/wai/noobai等<br>flux是画三次元专精，因为模型是拿三维深度图训练的，缺点是显存占用极高</p></blockquote><p>可以常逛civita看看那些些不错的图片使用的什么模型.</p><h2 id="本地使用工具的进展"><a href="#本地使用工具的进展" class="headerlink" title="本地使用工具的进展"></a>本地使用工具的进展</h2><p>目前经常看见的几个本地使用UI工具.</p><ul><li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">Automatic1111 WebUI</a>: (<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui#installation-and-running">Install Guide</a>|<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Features">Features Guide</a>) - Most feature-packed browser interface.✨✨✨✨✨</li><li><a href="https://github.com/lllyasviel/Fooocus">lllyasviel/Fooocus: Focus on prompting and generating</a></li><li><a href="https://github.com/lllyasviel/stable-diffusion-webui-forge">lllyasviel/stable-diffusion-webui-forge</a>✨✨✨✨</li><li><a href="https://github.com/comfyanonymous/ComfyUI">ComfyUI</a>: (<a href="https://github.com/comfyanonymous/ComfyUI?tab=readme-ov-file#installing">Installation</a>) - API and back-end with a graph/nodes interface.✨✨✨✨</li><li><a href="https://github.com/mcmonkeyprojects/SwarmUI">SwarmUI</a>: (<a href="https://github.com/mcmonkeyprojects/SwarmUI?tab=readme-ov-file#installing-on-windows">Installation</a>) - Super easy to install but still powerful UI, wraps and extends <a href="https://github.com/comfyanonymous/ComfyUI">ComfyUI</a>.</li></ul><p>此外还有<a href="https://github.com/invoke-ai/InvokeAI">invoke-ai/InvokeAI</a></p><h3 id="LoRA训练"><a href="#LoRA训练" class="headerlink" title="LoRA训练"></a>LoRA训练</h3><p>LoRA本身是一种微调方式,技术上修改了模型权重更新的方式,使得迁移更好. 可以下载一些脚本方便训练</p><ul><li><a href="https://github.com/Nerogar/OneTrainer">Nerogar/OneTrainer: OneTrainer is a one-stop solution for all your stable diffusion training needs.</a></li><li><a href="https://github.com/derrian-distro/LoRA_Easy_Training_Scripts">derrian-distro/LoRA_Easy_Training_Scripts: A UI made in Pyside6 to make training LoRA/LoCon and other LoRA type models in sd-scripts easy</a></li><li><a href="https://github.com/kohya-ss/sd-scripts">kohya-ss/sd-scripts</a></li><li><a href="https://github.com/bmaltais/kohya_ss">bmaltais/kohya_ss</a></li></ul><h2 id="现有应用"><a href="#现有应用" class="headerlink" title="现有应用"></a>现有应用</h2><p>目前文生图的应用虽然多,但是在商业上其实挺失败的(这也许收到了开源的影响),况且如果只是图片,也许还不够,如果结合视频、音频,那么对于辅助内容创作,面向目前广大视频博主还是很不错的.</p><p>如果只谈文生图或者图生图应用,目前大致有三种方向,第一种通过AI生成图片节省成本甚至通过AI噱头赚取更多关注度.具体来说,类似上面视频博主方案,只不过是图文博主,发短文搭配图片,发文章搭配图片,我也看见了有些学术会议的介绍图也使用了AI生成图. 这种方法商业上也是通过快速拿到还不错的搭配的图片吸引用户引流. 还有一些卖家,比如卖衣服的,不花请模特的钱,直接通过AI生成而且目前也能做到一个人物只换衣服面貌身材类似,相当于有了一个看起来很真实的人物的多种换衣图. 此外一些游戏开发者生成AI像素图,三视图等快速获得了游戏素材,比如之前的幻兽帕鲁. 上面这些方式都是通过AI辅助原本就有相关技能并以此赚钱的. 第二种更偏向兴趣,比如<a href="https://anifusion.ai/">Anifusion - AI Manga Generator</a>使用了画风更偏向漫画的模型搭配画图工作流,让画漫画更方便,但是专业的漫画家可能就不会去用了.</p><p>关于目前一些有趣的开源应用<a href="https://github.com/guoyww/animatediff/">AnimateDiff.</a>将文生图模型直接转为生成动画的模型而不需要额外训练,<a href="https://github.com/Doubiiu/ToonCrafter">ToonCrafter</a>通过两张图插值生成动画等等都是目前非常有趣的产品.</p><p>总的来说,目前商业应用前景依然不明朗,但是在一些小赛道还是不错的,其实不止AI图片,乃至AI相关的比如LLM也仍然面临这类问题.</p><h2 id="从图片到视频的展望"><a href="#从图片到视频的展望" class="headerlink" title="从图片到视频的展望"></a>从图片到视频的展望</h2><p>有了图片还是不够,如果有连续的、能体现更多故事的图片更好,那就是视频了. stability公司早已发布了<a href="https://stability.ai/stable-video">Stable Video</a>模型,runway也有了<a href="https://runwayml.com/research/gen-2">Runway Research | Gen-2: Generate novel videos with text, images or video clips</a>,OpenAI的Sora也是上了国内的大众热搜,鬼畜视频常客<a href="https://www.heygen.com/">HeyGen - AI Video Generator</a>和<a href="https://www.genmo.ai/">Genmo | Open Video Generation</a>.  但是目前仍然存在一些问题,一个是许多只允许用于调用而且还收费,通常免费生成的视频也就按秒算,由于视频生成难度更高,训练要求更高,相关开源社区发展不够. 另外目前技术也有进步空间,连贯性和人物一致性还需要进步,往往也缺少一些基本逻辑. 比如人物多手多腿,突然窜出一个莫名其妙的生物,脸部变形等等.</p><p>当然,到最后依然可能面临着商业化的问题. 但是考虑到目前互联网上有许多视频博主,他们应该是一个好的目标对象,结合AI生成的文字、音频、图片以及视频开发一个内容创作平台看起来还是有前景的.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://arxiv.org/abs/1906.00446">1906.00446] Generating Diverse High-Fidelity Images with VQ-VAE-2</a></li><li><a href="https://rentry.org/lora_train">LoRA Training Guide</a></li><li><a href="https://www.reddit.com/r/StableDiffusion/wiki/index/">r/StableDiffusion</a></li><li><a href="https://www.reddit.com/r/StableDiffusion/wiki/index/"><a href="https://huggingface.co/models?pipeline_tag=text-to-image&amp;sort=downloads">Models - Hugging Face</a></a></li><li><a href="https://stable-diffusion-book.vercel.app/">StableDiffusionBook - StableDiffusionBook</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在较早的VAE和GAN时代,通过图形生成模型,可能出现模式坍塌(个人理解就是生成图像多样性不足)并且只有图像数据参与,在之后的diffusion时代(包括现在),有了多模态的加入,通过文本、深度图以及骨骼图(e.g.ControlNet)控制图像生成有了更高的自由度和创造性.此外有了类似LoRA,IP-Adapter等等技术提供了更好的微调方式用于在更新模型权重保持良好的风格迁移(比如原本模型训练集中没有的人物,在微调时增加新人物训练能有良好表现)或人物一致性(不同的角色不至于长得一样)&lt;/p&gt;
&lt;p&gt;而在最近有了更多在一些较大模型(stable diffusionv3,novelai,sdxl等)上微调的模型,它们更加专注于某种画风。此外本文尝试总结目前文生图、艺术图片等生成式AI应用,最后从图片展望生成式视频创作。相对于论文、原理，这里更注重模型与应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
    <category term="generative AI" scheme="https://www.sekyoro.top/tags/generative-AI/"/>
    
  </entry>
  
  <entry>
    <title>c++17中的新东西</title>
    <link href="https://www.sekyoro.top/2024/10/21/c-17%E4%B8%AD%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/"/>
    <id>https://www.sekyoro.top/2024/10/21/c-17%E4%B8%AD%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/</id>
    <published>2024-10-21T14:14:30.000Z</published>
    <updated>2024-11-02T13:30:38.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c++的几个重点版本,c++11,c++17,c++20都是有必要去了解的. c++11是现代c++的基石,c++20有了更现代的东西,而c++17承前启后,多了许多现代c++常用但又常忽略的东西,这里简单介绍一些.<br><span id="more"></span></p><h2 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h2><p>std::string_view让我们像处理字符串一样处理字符序列，而不需要为它们分配内存空间。也就是说，std::string_view类型的对象只是引用一个外部的字符序列，而不需要持有它们。因此，一个字符串视图对象可以被看作字符串序列的引用</p><p>使用字符串视图的开销很小，速度却很快（以值传递一个string_view的开销总是很小）。然而，它也有一些潜在的危险，就和原生指针一样，<strong>在使用string_view时也必须由程序员自己来保证引用的字符串序列是有效的</strong></p><p>和 std::string相比，std::string_view对象有以下特点：</p><ul><li>底层的字符序列是只读的。没有操作可以修改底层的字符。你只能赋予一个新值、交换值、把视图缩小为字符序列的子序列。</li><li>字符序列不保证有空字符(‘\0’)终止。因此，字符串视图并不是一个空字符终止的字节流 </li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;c++的几个重点版本,c++11,c++17,c++20都是有必要去了解的. c++11是现代c++的基石,c++20有了更现代的东西,而c++17承前启后,多了许多现代c++常用但又常忽略的东西,这里简单介绍一些.&lt;br&gt;</summary>
    
    
    
    
    <category term="c++17" scheme="https://www.sekyoro.top/tags/c-17/"/>
    
  </entry>
  
</feed>

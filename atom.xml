<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sekyoro的博客小屋</title>
  
  
  <link href="https://www.sekyoro.top/atom.xml" rel="self"/>
  
  <link href="https://www.sekyoro.top/"/>
  <updated>2024-09-30T02:51:48.270Z</updated>
  <id>https://www.sekyoro.top/</id>
  
  <author>
    <name>Sekyoro</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>脑子没有坏掉系列:使用Rust写Web</title>
    <link href="https://www.sekyoro.top/2024/09/29/%E8%84%91%E5%AD%90%E6%B2%A1%E6%9C%89%E5%9D%8F%E6%8E%89%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Rust%E5%86%99Web/"/>
    <id>https://www.sekyoro.top/2024/09/29/%E8%84%91%E5%AD%90%E6%B2%A1%E6%9C%89%E5%9D%8F%E6%8E%89%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Rust%E5%86%99Web/</id>
    <published>2024-09-29T12:46:44.000Z</published>
    <updated>2024-09-30T02:51:48.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用rust写web框架的目的: </p><p>1)学习rust语法等知识. 找个感兴趣的项目写写</p><p>2)写写web程序练练手感.<br><!---more--><br>我这里使用的是<a href="https://rocket.rs/">Rocket - Simple, Fast, Type-Safe Web Framework for Rust</a></p><p><img data-src="https://s2.loli.net/2024/09/29/YBv5JnyopKIZDzC.png" alt="image-20240929205536867"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>路由</li></ol><p>Rocket 会将传入的 HTTP 请求解析为本地结构，供你的代码间接操作。Rocket 通过与应用程序中声明的路由属性进行匹配，确定要调用的请求处理程序</p><ol><li>验证</li></ol><p>Rocket根据匹配路由中存在的类型和守卫验证传入请求。如果验证失败，Rocket将请求转发到下一个匹配路由或调用错误处理程序。</p><ol><li>处理</li></ol><p>使用经过验证的参数调用与路由关联的请求处理程序。这是应用程序的主要业务逻辑。处理通过返回一个响应完成。</p><ol><li>相应</li></ol><p>处理返回的响应。Rocket生成适当的HTTP响应并将其发送到客户机。这就完成了生命周期。Rocket继续侦听请求，重新启动每个传入请求的生命周期。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/flosse/rust-web-framework-comparison?tab=readme-ov-file">flosse/rust-web-framework-comparison: A comparison of some web frameworks and libs written in Rust (github.com)</a></li><li><a href="https://course.rs/practice/third-party-libs.html">日常开发三方库精选 - Rust语言圣经(Rust Course)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
    <category term="rust" scheme="https://www.sekyoro.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>现代cpp多线程与并发初探</title>
    <link href="https://www.sekyoro.top/2024/09/26/%E7%8E%B0%E4%BB%A3cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.sekyoro.top/2024/09/26/%E7%8E%B0%E4%BB%A3cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2/</id>
    <published>2024-09-26T15:28:12.000Z</published>
    <updated>2024-09-28T11:32:01.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在现代c++(c++20)中,有了jthread和协程的概念,使得我们编写并发程序更加方便. 这里作简单学习.<br><span id="more"></span></p><h2 id="前言知识"><a href="#前言知识" class="headerlink" title="前言知识"></a>前言知识</h2><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p><code>std::thread</code> 用于创建一个执行的线程实例,所以它是一切并发编程的基础,使用时需要包含 <code>&lt;thread&gt;</code> 头文件, 它提供了很多基本的线程操作,例如 <code>get_id()</code> 来获取所创建线程的线程 ID,使用 <code>join()</code> 来等待这个线程结束（与该线程汇合）等等</p><p><code>std::mutex</code> 是 C++11 中最基本的互斥量类,可以通过构造 <code>std::mutex</code> 对象创建互斥量, 而通过其成员函数 <code>lock()</code> 可以进行上锁,<code>unlock()</code> 可以进行解锁. 但是在实际编写代码的过程中,最好不去直接调用成员函数, 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code></p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的,<code>std::unique_lock</code> 更加灵活, <strong><code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权）</strong> 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作.所以在并发编程中,推荐使用 <code>std::unique_lock</code>.</p><p>如果用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数.</p><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生,当互斥操作不够用而引入的. 比如,线程可能需要等待某个条件为真才能继续执行, 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时,就会发生死锁. 所以,<code>condition_variable</code> 对象被创建出现主要就是用于唤醒等待线程从而避免死锁. <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程</p><p><code>std::future</code>,它提供了一个访问异步操作结果的途径</p><p>试想,如果主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务,并返回一个结果. 而这时候,线程 A 可能正在忙其他的事情,无暇顾及 B 的结果, 所以我们会很自然的<strong>希望能够在某个特定的时间获得线程 B 的结果</strong>.</p><p>在 C++11 的 <code>std::future</code> 被引入之前,通常的做法是： 创建一个线程 A,在线程 A 里启动任务 B,当准备完毕后发送一个事件,并将结果保存在全局变量中. 而主函数线程 A 里正在做其他的事情,当需要结果的时候,调用一个线程等待函数来获得执行的结果</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程,可以用来获取异步任务的结果. 自然地,我们很容易能够想象到把它作为一种简单的线程同步手段,即屏障（barrier）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个返回值为7的 lambda 表达式封装到 task 中</span></span><br><span class="line">    <span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 获得 task 的期物</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">    result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障,阻塞到期物的完成</span></span><br><span class="line">    <span class="comment">// 输出执行结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span></span><br><span class="line">              &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-packaged-task-async-解决异步"><a href="#promise-packaged-task-async-解决异步" class="headerlink" title="promise packaged_task async 解决异步"></a>promise packaged_task async 解决异步</h3><p>也许你在Python,Js中已经享受到了异步的好处,在c++中也可以,不过可能会稍微麻烦一些.</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><code>std::async</code>函数可以接受几个不同的启动策略,这些策略在<code>std::launch</code>枚举中定义</p><p>使用 <code>std::launch::async</code> 时,<code>std::async</code> 会立即在一个新线程中启动任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步任务,比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::async 异步调用 fetchDataFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB =      std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h4><p><code>std::packaged_task</code>是一个可调用目标,它包装了一个任务,该任务可以在另一个线程上运行.它可以捕获任务的返回值或异常,并将其存储在<code>std::future</code>对象中,以便以后使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象  </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象  </span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离,以便主线程可以等待任务完成  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果  </span></span><br><span class="line">    <span class="keyword">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p><code>std::promise</code>用于在某一线程中设置某个值或异常,而<code>std::future</code>则用于在另一线程中获取这个值或异常</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt; prom)</span> </span>&#123; prom.<span class="built_in">set_value</span>(<span class="number">10</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> std::promise&lt;<span class="keyword">int</span>&gt; prom;</span><br><span class="line">  std::future&lt;<span class="keyword">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::move(prom))</span></span>;</span><br><span class="line">  <span class="keyword">int</span> value2 = fut.<span class="built_in">get</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="面向c-20"><a href="#面向c-20" class="headerlink" title="面向c++20"></a>面向c++20</h2><p>C++11 引入了 std::thread 类型,其与操作系统提供的线程对应,但该类型有一个严重的设计缺陷: 不是 RAII 类型. std::thread 要求在其生命周期结束时,若表示正在运行的线程,则调用 join()(等待线程结束) 或 detach()(让线程在后台运行)</p><p>若两者都没有调用,析构函数会立即导致异常的程序终止 (在某些系统上导致段错误).</p><p>不能“杀死”已 经启动的线程.线程不是进程,线程只能通过结束自身或结束整个程序来结束. 因此,在调用 join() 之前,应该确保等待的线程将取消其执行.不过,对于 std::thread,没有这 样的机制,必须自己实现取消请求和对它的响应</p><h3 id="std-jthread"><a href="#std-jthread" class="headerlink" title="std::jthread"></a>std::jthread</h3><p>std::jthread 解决了这些问题,它是 RAII 类型.若线程是可汇入的 (“j”代表“汇入”),析构函数会自动调用 join()</p><ol><li><strong>自动加入</strong>：<code>std::jthread</code> 在析构时会自动调用 <code>join</code>,确保线程在销毁前完成执行.这避免了 <code>std::thread</code> 在析构时未调用 <code>join</code> 或 <code>detach</code> 导致的未定义行为.</li><li><strong>停止标记</strong>：<code>std::jthread</code> 支持停止标记（stop token）,允许线程协作地停止执行.这使得线程可以优雅地处理停止请求.</li><li><strong>异常安全</strong>：<code>std::jthread</code> 在异常处理方面更加安全,确保在异常抛出时线程能够正确地清理资源.</li></ol><p>使用 std::jthread 就不再存在导致异常程序终止的危险,也不需要异常处理.为了支持尽可能容易地切换到 std::jthread 类,该类提供了与 std::thread 相同的 API,包括: </p><ul><li><strong><code>jthread()</code></strong>：默认构造函数,创建一个未关联任何线程的 <code>jthread</code>.</li><li><strong><code>jthread(Function&amp;&amp; f, Args&amp;&amp;... args)</code></strong>：构造函数,启动一个新的线程来执行给定的函数.</li><li><strong><code>join()</code></strong>：等待线程完成执行.</li><li><strong><code>detach()</code></strong>：分离线程,使其独立运行.</li><li><strong><code>get_id()</code></strong>：获取线程的标识符.</li><li><strong><code>joinable()</code></strong>：检查线程是否可以加入.</li><li><strong><code>swap(jthread&amp; other)</code></strong>：交换两个 <code>jthread</code> 对象.</li><li><strong><code>request_stop()</code></strong>：请求线程停止执行.</li><li><strong><code>stop_requested()</code></strong>：检查是否请求了停止.</li><li><strong><code>get_stop_token()</code></strong>：获取线程的停止标记</li><li><strong>get_stop_source</strong>:获取线程停止源</li></ul><h4 id="引入停止请求与停止回调"><a href="#引入停止请求与停止回调" class="headerlink" title="引入停止请求与停止回调"></a>引入停止请求与停止回调</h4><p>std::jthread 提供了一种协作机制来表示线程不应该再运行.它是“协作的”,因为该机制 不会杀死正在运行的线程 (因为 C++ 线程根本不支持杀死线程,杀死线程的操作可能很容易使程序处于损坏状态).</p><p>为了响应停止请求,已启动的线程必须声明<code>std::stop_token</code>作为附加的第一个参数, 并使用它不时的检查是否应该继续运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(std::stop_token st, std::string s, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!st.<span class="built_in">stop_requested</span>())&#123; # 检查是否停止了请求</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// t.request_sop() 显式请求task()停止执行</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is stopping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">jt</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求工作线程停止</span></span><br><span class="line">    jt.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    jt.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另一种对停止请求作出反应的方法: 可以为<code>std::stop_token</code>注册回调,该回调将在请求停止时自动调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::stop_callback cb&#123;st,[]()&#123;&#125;&#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stop_token&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::stop_callback <span class="title">sc</span><span class="params">(st, []&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Stop request received, cleaning up...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is stopping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">jt</span><span class="params">(worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is doing other work...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求工作线程停止</span></span><br><span class="line">    jt.<span class="built_in">request_stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    jt.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::jthread 的主要优点是会自动建立停止信号的机制.<strong>启动线程的构造函数将创建一个停止源</strong>,将其存储为线程对象的成员,并将相应的停止令牌传递给被调用的函数,以避免该函数将额外的 stop_token 作为第一个参数</p><h4 id="停止来源"><a href="#停止来源" class="headerlink" title="停止来源"></a>停止来源</h4><p><code>std::stop_source</code> 是 C++20 引入的一个类,用于管理停止请求.它与 <code>std::stop_token</code> 和 <code>std::jthread</code> 一起使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::stop_source ssrc;</span><br><span class="line">  std::stop_token stok&#123;ssrc.<span class="built_in">get_token</span>()&#125;;</span><br><span class="line">  std::stop_callback cb&#123;stok, []() &#123; <span class="built_in">syncOut</span>() &lt;&lt; <span class="string">&quot;stop requested\n&quot;</span>; &#125;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(std::launch::async, [stok] &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">stop_callback_task</span>(stok, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ssrc.<span class="built_in">request_stop</span>();</span><br></pre></td></tr></table></figure><p>停止来源可以request_stop,jthread对象也可以request_stop. jthread对象可以可以获得停止源和stop_token</p><p>若启动多个 jthread,每个线程都有自己的停止令牌,这可能会导致停止所有线程的时间可能比预期的要长</p><p>可能还需要使用相同的停止令牌为多个线程请求停止,只需自己创建停止令牌,或者从已经启 动的第一个线程中获取停止令牌,并将此停止令牌作为第一个参数启动线程</p><h3 id="std-latch锁存器与std-barrier"><a href="#std-latch锁存器与std-barrier" class="headerlink" title="std::latch锁存器与std::barrier"></a>std::latch锁存器与std::barrier</h3><p><code>std::latch</code> 是一个一次性的同步点,类似于倒计时事件.它允许多个线程等待某个计数器达到零,然后所有等待的线程同时继续执行.一旦计数器达到零,<code>std::latch</code> 就不能再被重置.</p><p><strong>主要特点</strong></p><ul><li><strong>一次性</strong>：一旦计数器达到零,<code>std::latch</code> 就不能再被重置.</li><li><strong>倒计时</strong>：多个线程可以通过调用 <code>count_down</code> 方法减少计数器的值.</li><li><strong>等待</strong>：线程可以调用 <code>wait</code> 方法等待计数器达到零.</li></ul><p><strong>成员方法</strong></p><ul><li><strong><code>latch(count_t count)</code></strong>：构造函数,初始化计数器.</li><li><strong><code>count_down(count_t n = 1)</code></strong>：减少计数器的值.</li><li><strong><code>count_down_and_wait(count_t n = 1)</code></strong>：减少计数器的值并等待计数器达到零.</li><li><strong><code>wait()</code></strong>：等待计数器达到零.</li><li><strong><code>try_wait()</code></strong>：尝试等待计数器达到零,如果计数器尚未达到零则立即返回 <code>false</code>.</li><li><strong><code>arrive_and_wait(count_t n = 1)</code></strong>：等同于 <code>count_down_and_wait(n)</code></li></ul><p>锁存器是用于并发执行的一种新的同步机制,支持单次使用异步倒计时.从初始整数值开始, 各种线程可以自动将该值计数到零.当计数器达到零时,等待此倒计时的所有线程继续运行</p><p><img data-src="https://s2.loli.net/2024/09/28/eyjWsP9bpHdwacD.png" alt="image-20240928144118863"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(std::latch &amp;l)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  l.<span class="built_in">count_down</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Worker thread finished and counted down\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_threads&#123;<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="function">std::latch <span class="title">l</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">  std::vector&lt;std::jthread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(worker, std::<span class="built_in">ref</span>(l));</span><br><span class="line">  &#125;</span><br><span class="line">  l.<span class="built_in">wait</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::latch allReady&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  std::vector&lt;std::jthread&gt; threads2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    std::jthread t&#123;[i, &amp;allReady] &#123;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">      allReady.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">5</span>; ++j) &#123;</span><br><span class="line">        std::cout.<span class="built_in">put</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;A&#x27;</span> + j));</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    threads2.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>barrier</code>是用于并发执行的新的同步机制,允许多次同步多个异步任务.设置初始计数后,多个线程可以对其进行计数,并等待计数器达到零.与锁存器相比,当达到零时,将调用一个 (可选的) 回调,计数器将重新初始化为初始计数</p><p><img data-src="https://s2.loli.net/2024/09/28/SKiqeEcvdDM9N2C.png" alt="image-20240928145528067"></p><p>arrive() 函数会返回一个类型为 std::barrier::arrival_token 的到达令牌,以确保 barrier 知道要等待哪个线程.</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>C++20 引入了处理信号量的新类型.信号量是轻量级同步原语,允许同步或限制对一个或一组资源的访问</p><p>C++ 标准库提供了两种信号量类型:</p><ul><li>std::counting_semaphore&lt;&gt; 将多个资源的使用限制在最大值</li><li>std::binary_semaphore&lt;&gt; 限制对单一资源的使用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::queue&lt;<span class="keyword">char</span>&gt; values;</span><br><span class="line">  std::mutex valuesMx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    values.<span class="built_in">push</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;a&#x27;</span> + (i % (<span class="string">&#x27;z&#x27;</span> - <span class="string">&#x27;a&#x27;</span>))));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> numThreads = <span class="number">10</span>;</span><br><span class="line">  std::counting_semaphore&lt;numThreads&gt; enabled&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  std::vector&lt;std::jthread&gt; pool;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; numThreads; ++idx) &#123;</span><br><span class="line">    std::jthread t&#123;[idx, &amp;enabled, &amp;values, &amp;valuesMx](std::stop_token st) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        enabled.<span class="built_in">acquire</span>();</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        &#123;</span><br><span class="line">          std::lock_guard lg&#123;valuesMx&#125;;</span><br><span class="line">          val = values.<span class="built_in">front</span>();</span><br><span class="line">          values.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          std::cout.<span class="built_in">put</span>(val);</span><br><span class="line">          <span class="keyword">auto</span> dur = <span class="number">130</span>ms * ((idx % <span class="number">3</span>) + <span class="number">1</span>);</span><br><span class="line">          std::this_thread::<span class="built_in">sleep_for</span>(dur);</span><br><span class="line">        &#125;</span><br><span class="line">        enabled.<span class="built_in">release</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    pool.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  enabled.<span class="built_in">release</span>(<span class="number">3</span>);</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t:pool)&#123;</span><br><span class="line">    t.<span class="built_in">request_stop</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动了 10 个线程,但限制了允许其中多少线程主动运行和处理数据,因此将信号量 初始化为最大数量 (10) 和初始资源数量 (0)</p><p>因为信号量初始化为零,所以最初的情况是阻塞,因此没有可用的资源.使用release控制最大资源,acquire获得资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line">std::binary_semaphore dataReady&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::binary_semaphore dataDone&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::jthread process&#123;[&amp;](std::stop_token st) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dataReady.<span class="built_in">try_acquire_for</span>(<span class="number">1</span>s)) &#123;</span><br><span class="line">      <span class="keyword">int</span> data = sharedData;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[process] read &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">      std::this_thread::<span class="built_in">sleep_for</span>(data * <span class="number">.5</span>s);</span><br><span class="line"></span><br><span class="line">      dataDone.<span class="built_in">release</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;[process] no data to process\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[main] write &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">  sharedData = i;</span><br><span class="line">  dataReady.<span class="built_in">release</span>();</span><br><span class="line">  dataDone.<span class="built_in">acquire</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[main] data processed\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><ul><li><strong><code>std::atomic_ref</code></strong>：用于在现有对象上提供原子操作,适用于非侵入性地将非原子类型包装成原子类型.</li><li><strong><code>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</code></strong>：用于在多线程环境中安全地管理共享指针,确保指针的引用计数和其他操作是线程安全的.</li></ul><p>流的并发输出会导致未定义行为 (这是数据竞争,指具有未定义行为的竞争条件).</p><p>同步并发输出流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syncstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">syncOut</span><span class="params">(std::ostream&amp; strm=std::cout)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::osyncstream&#123;strm&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-中的协程"><a href="#c-中的协程" class="headerlink" title="c++中的协程"></a>c++中的协程</h2><p>C++20 引入了对协程的支持,<strong>协程 是可以挂起的函数</strong>(类似于python中yield的生成器?)</p><p>调用普通函数 (或过程) 时,然后运行到它们的结束 (或直到到达返回语句或抛出异常),而协程 是可以分多个步骤运行的函数 </p><p>某些时刻,可以挂起一个协程,所以该函数暂停其计算,直到恢复.挂起可能是因为函数必须 等待某些东西,有其他 (更重要的) 事情要做,或者有一个中间结果要给调用者. 因此,启动协程意味着启动另一个函数,直到它的一部分完成.调用函数和协程都在它们的两 条执行路径之间来回切换.</p><p>注意,这两个函数不是并行运行的,我们用控制流来打乒乓球:</p><ul><li>函数可以通过开始或继续协程的语句来决定启动或恢复其当前控制流. </li><li>当协程运行时,协程可以决定挂起或结束其执行,启动或恢复协程的函数将继续执行其控制流.</li></ul><p><img data-src="https://s2.loli.net/2024/09/28/6q3sc8P4LS7wt5x.png" alt="image-20240928155220941"></p><p>协程的最简单形式中,主控制流和协程的控制流都在同一个线程中运行.不需要使用多线程, 也不需要处理并发访问,但可以在不同的线程中运行协程.甚至可以在不同的线程上将协程恢复到 先前挂起的位置.协程有一种正交特性,但其可以与多个线程一起使用.甚至可以在不同的线程上 将协程恢复到先前挂起的位置</p><p>使用协程就像在后台有一个函数,可以不时地启动和继续.然而,由于协程的生命周期超出了嵌套作用域,因此协程也是一个将其状态存储在某些内存中并提供处理状态的 API.</p><ul><li>协程通常返回一个对象,作为调用者的协程接口.根据协程的目的和用途,该对象可以表示 一个不时挂起或切换上下文的正在运行的任务,不时产生值的生成器,或者一个按需惰性地 返回一个或多个值的工厂</li><li>协程无堆栈.不挂起外部协程的情况下,无法挂起在外部协程中调用的内部协程,只能将外 部协程作为一个整体挂起. 当协程挂起时,协程的状态作为一个整体被存储在与堆栈分开的对象中,以便它可以在完全 不同的上下文中 (在不同的调用堆栈中,在另一个线程中等) 恢复.</li></ul><p>只需在函数中使用以下关键字即可隐式定义协程: </p><ul><li>co_await </li><li>co_yield</li><li>co_return </li></ul><p>若这些关键字在协程中都不没有,则必须显式地使用 co_return; 语句.</p><p>协程具有以下属性和限制: </p><ul><li>协程不允许有返回语句. </li><li>协程不能是 constexpr 或 consteval</li><li>协程不能有返回类型 auto 或其他占位符类型. </li><li>main() 不能是协程. </li><li>构造函数或析构函数不可为协程</li><li>协程可以是静态</li><li>协程若不是构造函数或析构函数,可以是成员函数</li><li>协程甚至可以是 Lambda,但在这种情况下,必须谨慎使用</li></ul><h3 id="实现协程接口与句柄"><a href="#实现协程接口与句柄" class="headerlink" title="实现协程接口与句柄"></a>实现协程接口与句柄</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroTask</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span>;</span></span><br><span class="line">  <span class="keyword">using</span> CoroHdl = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CoroHdl hdl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">auto</span> h) : hdl&#123;h&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CoroTask</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hdl)</span><br><span class="line">      hdl.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoroTask &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hdl || hdl.<span class="built_in">done</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    hdl.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !hdl.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoroTask</span>:</span>:promise_type &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CoroTask&#123;CoroHdl::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>处理 C++ 中的协程,需要做两件事: </p><ul><li>promise 类型 此类型用于定义处理协同例程的某些自定义点,特定的成员函数定义了在特定情况下调用的 回调函数. </li><li>std::coroutine_handle&lt;&gt; 类型的内部协程句柄 此对象在调用协程时创建 (使用上述 promise 类型的标准回调之一),可以通过提供一个底层接 口来恢复协程以及处理协程的结束,从而用于管理协程的状态</li></ul><p>引入 promise_type(每个协程类型都必须拥有),并声明本地协程句柄 hdl,它管理协程的状态. 原生协程句柄 std::coroutine_handle&lt;&gt; 的类型是用 promise 类型参数化的,存储在 promise 中的任何 数据都是句柄的一部分,promise 中的函数可以通过句柄访问</p><p>resume方法在协程挂起时恢复协程,其或多或少地将恢复请求传播到原生协程句 柄,其<strong>返回表示是否有必要再次恢复协程</strong>. </p><p>函数检查是否有句柄,或者协程是否已经结束. 尽管在这个实现中协程接口总是有一个句柄,但这是一个必要的检查,例如,若接口支持移动 语义. 只有当协程挂起且尚未结束时才允许调用 resume(),所以检查是否 done() 是必要的.调用本身恢复挂起的协程并阻塞,直到下一个挂起点或结束</p><p><strong>针对co_await等待</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoroTask.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Coro <span class="title">coro</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; start\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= max; ++val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> coroTask = <span class="built_in">coro</span>(<span class="number">3</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;coro() started\n&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (coroTask.<span class="built_in">resume</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;coro() suspended&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;coro() done\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 定义promise 类型目的是: </p><ul><li>定义如何创建或获取协程的返回值 (通常包括创建协程句柄)</li><li>决定协同程序是应该在开始还是结束时挂起</li><li>处理协程调用者与协程之间交换的值</li><li>处理未处理的异常</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoroTask</span>:</span>:promise_type &#123;</span><br><span class="line">  <span class="comment">// init and return coroutine interface</span></span><br><span class="line">  <span class="comment">// 创建协程接口 创建对象</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CoroTask&#123;CoroHdl::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; &#125;</span><br><span class="line">  <span class="comment">// 主动启动还是需要resume</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">  <span class="comment">// 到达结束时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 异常处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 最终是否挂起</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>针对co_yield返回值</strong></p><p>在promise_type中定义值,并定义<code>yield_value</code>用于保存值,在协程返回对象中定义<code>getValue</code>方便访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroTask</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coroValue = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">      coroValue = val;</span><br><span class="line">      <span class="keyword">return</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> CoroHdl = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CoroHdl hdl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">auto</span> h) : hdl&#123;h&#125; &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CoroTask</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hdl)</span><br><span class="line">      hdl.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CoroTask</span>(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoroTask &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CoroTask &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hdl || hdl.<span class="built_in">done</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    hdl.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !hdl.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hdl.<span class="built_in">promise</span>().coroValue; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>针对co_return结束并返回值</strong></p><p>通过使用 co_return,协程可以在其结束时向调用者返回结果. 实现方式是在promise_type中增加return_value,然后依旧在协程接口对象中声明一个方法访问coroutine_handle.</p><p>若协程以有时可能返回值,有时可能不返回值的方式实现,则这是未定义行为.则这个协程无效. 也就是return_value和return_void也不能同时声明</p><h3 id="实现Awaitable对象"><a href="#实现Awaitable对象" class="headerlink" title="实现Awaitable对象"></a>实现Awaitable对象</h3><p>协程必须)提供Awaitables(实现方式是使用 Awaiter)</p><p> Awaitables 是 co_await 需要作为其操作数的术语,所以 awaitables 是 co_await 可以处理的所有对象. </p><p>Awaiter 是实现 Awaitables 的一种特定 (和典型) 方式的术语.</p><p>其必须提供三个特定的成员函数来处理协程的暂停和恢复</p><p><img data-src="https://s2.loli.net/2024/09/28/giQEJnrPypb7Ko8.png" alt="image-20240928181236087"></p><p><strong>await_ready()</strong> 在协程被挂起之前调用,提供挂起.若它返回 true,则协程根本不会挂起. 这个函数通常只返回 false</p><p><strong>auto await_suspend(awaitHdl)</strong> </p><p>在<strong>协程挂起后立即为协程调用此函数</strong>.参数 awaitHdl 是被挂起的协程的句柄,其类型是 std::coroutine_handle. 这个函数中,可以指定下一步要做什么,包括立即恢复挂起的或等待的协程.</p><p> <strong>auto await_resume()</strong> 当<strong>成功挂起后恢复协程时,将为协程调用此函数</strong>.可以返回一个值,这个值就是 co_await 表达式产生的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; await_ready\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="keyword">auto</span> hdl)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; await_suspend\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot; await_resume\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>Awaiter</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CoroTask <span class="title">coro</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; start\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= max; ++val) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CORO&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    <span class="keyword">co_await</span> Awaiter&#123;&#125;;</span><br><span class="line">    <span class="comment">// co_yield val;</span></span><br><span class="line">    <span class="comment">// co_return 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个标准<code>Awaiters</code>,<code>`std::suspend_always</code>和<code>std::suspend_never</code>. 差别就是<code>await_ready</code>的返回值</p><p>若在 await_ready() 中返回 false(而在 await_suspend() 中没有返回任何值),则 suspend_always 接受每个挂起,并将协程返回给其调用者. </p><p>若在 await_ready() 中返回 true,则 suspend_never 永远不会接受任何挂起,则协程继续 (永远不会调用 await_suspend()).</p><p><code>std::suspend_always</code>通常用作 co_await 的基本 awaiter.</p><p><strong>挂起后将值传递回协程</strong></p><p>协程接口的 promise 类型是协程与调用者共享和交换数据的最佳位置,在promse_type的<code>yield_value</code>中返回一个<code>awaiter</code>,这个<code>awaiter</code>能够修改协程接口中的promise并在挂起恢复时设置值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val)</span> </span>&#123; hdl.<span class="built_in">promise</span>().backValue = val; &#125; <span class="comment">// 在协程接口中写一个方法能够修改返回值</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  coroValue = val;</span><br><span class="line">  backValue.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// return std::suspend_always&#123;&#125;;</span></span><br><span class="line">  <span class="keyword">return</span> BackAwaiter&lt;CoroHdl&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Hdl&gt; <span class="class"><span class="keyword">class</span> <span class="title">BackAwaiter</span> &#123;</span></span><br><span class="line">  Hdl hdl = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BackAwaiter</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BackAwaiter await_ready\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(Hdl h)</span> <span class="keyword">noexcept</span> </span>&#123; hdl = h; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hdl.<span class="built_in">promise</span>().backValue; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://changkun.de/modern-cpp/zh-cn/07-thread/">第 7 章 并行与并发 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)</a></li><li><a href="https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp07.html">C++ 并发三剑客future, promise和async · 恋恋风辰的编程笔记 (llfc.club)</a></li><li>C++ Concurrency In Action</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在现代c++(c++20)中,有了jthread和协程的概念,使得我们编写并发程序更加方便. 这里作简单学习.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="thread" scheme="https://www.sekyoro.top/tags/thread/"/>
    
    <category term="concurrency" scheme="https://www.sekyoro.top/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>回看深度学习:经典网络学习</title>
    <link href="https://www.sekyoro.top/2024/09/24/%E5%9B%9E%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.sekyoro.top/2024/09/24/%E5%9B%9E%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-24T07:38:15.000Z</published>
    <updated>2024-09-26T09:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>传统深度学习,或者说在llm之前的深度学习,现在看来,还是有很多trick以及各种模块”缝合”的内容,这部分有很多提出来的方法其实都有一些共通点的,这里简单回顾总结一下.<br><span id="more"></span></p><h2 id="Vision-Transformer-and-its-variants"><a href="#Vision-Transformer-and-its-variants" class="headerlink" title="Vision Transformer and its variants"></a>Vision Transformer and its variants</h2><h3 id="AN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE"><a href="#AN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE" class="headerlink" title="AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE"></a>AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE</h3><p><img data-src="https://s2.loli.net/2024/09/26/GI83VzYUF4PaKg6.png" alt="image-20240926173222690"></p><h3 id="Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows"><a href="#Swin-Transformer-Hierarchical-Vision-Transformer-using-Shifted-Windows" class="headerlink" title="Swin Transformer: Hierarchical Vision Transformer using Shifted Windows"></a>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows</h3><p><img data-src="https://s2.loli.net/2024/09/26/BEDZibGuALMsfUx.png" alt="image-20240926173305765"></p><h2 id="Modernify-Conv"><a href="#Modernify-Conv" class="headerlink" title="Modernify Conv"></a>Modernify Conv</h2><h3 id="A-ConvNet-for-the-2020s"><a href="#A-ConvNet-for-the-2020s" class="headerlink" title="A ConvNet for the 2020s"></a>A ConvNet for the 2020s</h3><p>出发点是一个ResNet-50模型.首先使用类似的训练技术来训练vision transformer,并获得了比原始ResNet-50更好的结果</p><p>然后我们研究了一系列的设计决策,总结为</p><p>1 )marco design,2 ) ResNeXt,3 )inverted- bottleneck,4 )大核尺寸,5 )各种layer-wise的mirco design.</p><p><img data-src="https://s2.loli.net/2024/09/26/LoV7htDUYzE3TuI.png" alt="image-20240926153040226"></p><h4 id="训练技术"><a href="#训练技术" class="headerlink" title="训练技术"></a>训练技术</h4><p>最近的研究表明,一套现代的训练技术可以显著提高一个简单的ResNet-50模型的性能.在本研究中,使用了与Dei-T和Swin Transformer相近的训练方法.</p><p>对于深度残差网络,训练从原来的90次扩展到300次.</p><p>使用Adam W优化器,数据增强技术如Mixup、Cutmix、Rand Augment、Random Erasing,以及正则化方案包括Stochastic Depth和Label Smoothing</p><h4 id="Marco-Design"><a href="#Marco-Design" class="headerlink" title="Marco Design"></a>Marco Design</h4><h5 id="修改阶段计算比例"><a href="#修改阶段计算比例" class="headerlink" title="修改阶段计算比例"></a>修改阶段计算比例</h5><p>Swin-T阶段计算比例略有不同,为1：1：3：1.对于较大的Swin Transformer,比例为1：1：9：1.</p><p>根据设计将每个阶段的块数从ResNet-50中的( 3、4、6、3)调整为( 3、3、9、3),这也将FLOPs与Swin-T对齐</p><h4 id="修改stem为patchify"><a href="#修改stem为patchify" class="headerlink" title="修改stem为patchify"></a>修改stem为patchify</h4><p>标准ResNet中的stem包含一个7 × 7的步幅为2的卷积层,然后是一个max pooling,这导致对输入图像进行4 ×的下采样.</p><p>在Vision Transformers中,使用了patchify策略作为stem,对应于较大的核尺寸(如kernel大小= 14或16)和非重叠卷积.</p><p>Swin Transformer使用了类似的” Patchify “层,但是具有更小的Patch size 4以适应架构的多级设计</p><p>将ResNet风格的stem替换为使用4 × 4,stride为4的卷积层实现的patchify层.准确率从79.4 %变为79.5 %.这表明ResNet中的stem可能被更简单的” patchify “层ViT替代,这将导致类似的性能</p><h4 id="ResNext-ify"><a href="#ResNext-ify" class="headerlink" title="ResNext-ify"></a>ResNext-ify</h4><p>核心部件是group normalization,其中卷积滤波器被分成不同的组.在更高的层面上,ResNeXt的指导原则是”利用更多群体,拓展宽度”.更确切地说,ResNeXt对瓶颈块中的3 × 3 conv层使用分组卷积.由于这显著降低了FLOPs,因此扩大了网络宽度以补偿容量损失,</p><p>depth-wise卷积类似于自注意力中的加权和操作,它在每个通道的基础上操作,即只在空间维度上混合信息</p><p>深度卷积和1 × 1卷积的结合导致了空间和通道混合的分离,这是视觉转换器共有的特性,其中每个操作要么混合了空间或通道维度的信息,但不是两者都混合.</p><p>depth-wise卷积的使用有效地降低了网络的FLOPs,但会降低精度</p><p>根据ResNeXt提出的策略,将网络宽度增加到与Swin-T的( 64 ~ 96)相同的通道数.随着FLOPs ( 5.3G )的增加,网络性能达到80.5 %.</p><h4 id="Inverted-Bottleneck"><a href="#Inverted-Bottleneck" class="headerlink" title="Inverted Bottleneck"></a>Inverted Bottleneck</h4><p>在每个Transformer模块中,一个重要的设计是它创建了一个反向瓶颈,即<strong>MLP模块的隐藏维度比输入维度宽4倍</strong></p><p><img data-src="https://s2.loli.net/2024/09/26/qsz5JcBe1dC9Dak.png" alt="image-20240926163046594"></p><p>尽管depth-wise卷积层的FLOP值有所增加,但由于下采样残差块的捷径1 × 1 conv层的FLOP值显著降低,该变化使得整个网络的FLOP值降低到4.6 G</p><h4 id="更大的尺寸大小"><a href="#更大的尺寸大小" class="headerlink" title="更大的尺寸大小"></a>更大的尺寸大小</h4><p>Vision Transformer最具有特色的一个方面是其非局部自注意力,这使得每一层都具有全局的感受野.过去,卷积神经网络使用大的内核尺寸,而(由VGGNet 推广)的金标准是堆叠小的内核尺寸( 3 × 3 )的conv层,它们在现代GPU上具有高效的硬件实现</p><p>虽然Swin Transformers将局部窗口重新引入到自注意力块中,但窗口大小至少为7 × 7,明显大于ResNe ( X ) t核大小3 × 3.在这里重新考虑了卷积神经网络中大核卷积的使用.</p><p>为了探索大核,<strong>一个先决条件是将depth-wise卷积放在前面</strong>.这在Transformers中也是显而易见的设计决策:MSA块( 大内核conv)放置在复杂/低效的模块的MLP层之前会有更少的通道,而高效、密集的1 × 1层会做繁重的提升.这一中间步骤将FLOPs降低到4.1 G,导致性能暂时下降到79.9 %.</p><p><img data-src="https://s2.loli.net/2024/09/26/j1EB3GYx5Kz9wJa.png" alt="image-20240926164338145"></p><p>在所有这些准备工作中,采用更大的核卷积的好处是显著的.实验了几种不同的核尺寸,包括3、5、7、9和11.网络的性能从79.9 % ( 3 × 3 )提高到80.6 % ( 7 × 7 ),而网络的FLOPs基本保持不变.此外观察到<strong>较大的核尺寸带来的收益在7 × 7处达到饱和点</strong>.在大容量模型中也验证了这一行为:将内核大小增加到7 × 7以上时,ResNet - 200机制模型没有表现出进一步的增益</p><h4 id="Micro-Design"><a href="#Micro-Design" class="headerlink" title="Micro Design"></a>Micro Design</h4><p><strong>使用GELU替换RELU</strong></p><p>NLP和视觉架构的一个不同之处在于使用的激活函数的具体形式.随着时间的推移,许多激活函数已经被开发出来,但ReLU 由于其简单和高效,仍然被广泛用于卷积神经网络中.</p><p>在ConvNet中,ReLU也可以用GELU代替,尽管精度保持不变</p><p><strong>更少的激活函数</strong></p><p>transfomer的激活函数较少.考虑一个具有key / query / value线性嵌入层的Transformer块,一个MLP块中的投影层和两个线性层.MLP块中只有一个激活函数.相比较而言,通常的做法是在每个卷积层中添加一个激活函数,包括1 × 1卷积层.</p><p>除了两个1 × 1层之间的GELU层外,从残差块中消除了所有GELU层,复制了Transformer块的风格.该过程使结果提高了0.7 % ~ 81.3 %,与Swin - T的性能基本匹配</p><p><strong>更少的normalization层</strong></p><p>transformer块通常也具有较少的归一化层数.这里去掉两个Batch Norm ( BN )层,在conv 1 × 1层之前只留下一个BN层.</p><p>每个块的归一化层数甚至比Transformers还要少,因为从经验上发现在块的开头增加一个BN层并不能提高性能</p><p><strong>替换BN为LN</strong></p><p>BatchNorm是卷积神经网络中的一个重要组成部分,它提高了收敛性并减少了过拟合</p><p>更简单的层归一化 在Transformer中得到了应用,在不同的应用场景中表现出良好的性能</p><p>直接将原始ResNet中的LN替换为BN会导致次优的性能.随着网络结构和训练技术的改变,这里重新使用LN代替BN的影响,观察到ConvNet模型在使用LN进行训练时没有任何困难；事实上,性能略好,获得了81.5 %的准确率</p><p><strong>单独的下采样层</strong></p><p>在ResNet中,空间下采样是通过每个阶段开始时的残差块来实现的,采用3×3的conv,stride为2 (short connection时使用stride为2的1 × 1 conv).</p><p>在Swin Transformers中,不同尺度之间增加了单独的下采样层.这里使用2×2的conv层和stride为2进行空间下采样.</p><p>进一步的研究表明,<strong>在空间分辨率变化的地方增加归一化层有助于稳定训练</strong>.其中包括Swin Transformers中也使用的几个LN层：每个下采样层之前的一个,stem之后的一个,最后全局平均池化之后的一个.可以将准确率提高到82.0%,明显超过Swin-T的81.3%</p><h3 id="Early-Convolutions-Help-Transformers-See-Better"><a href="#Early-Convolutions-Help-Transformers-See-Better" class="headerlink" title="Early Convolutions Help Transformers See Better"></a>Early Convolutions Help Transformers See Better</h3><p><img data-src="https://s2.loli.net/2024/09/26/Q5ajrv8dZT6MoKS.png" alt="image-20240926160213575"></p><h2 id="Vector-quantization-and-Codebook"><a href="#Vector-quantization-and-Codebook" class="headerlink" title="Vector quantization and Codebook"></a>Vector quantization and Codebook</h2><h3 id="Neural-Discrete-Representation-Learning"><a href="#Neural-Discrete-Representation-Learning" class="headerlink" title="Neural Discrete Representation Learning"></a>Neural Discrete Representation Learning</h3><p><a href="https://arxiv.org/abs/1711.00937">1711.00937] Neural Discrete Representation Learning (arxiv.org)</a></p><p><strong>在没有监督的情况下学习有用的表示</strong>(个人认为算是自监督-&gt;生成式学习)仍然是机器学习中的一个关键挑战.</p><p>VQ-VAE 两个关键方面与VAEs不同：</p><ul><li>encoder输出离散的编码,也就是中间嵌入是离散的</li><li>先验知识是学到的.</li></ul><p>为了学习一个离散的潜在表示,结合了向量量化( VQ )的思想.使用VQ方法可以使模型避免”后验崩溃”问题- -当潜在变量(中间嵌入)与decoder配对时被忽略</p><h4 id="离散潜变量-中间嵌入"><a href="#离散潜变量-中间嵌入" class="headerlink" title="离散潜变量(中间嵌入)"></a>离散潜变量(中间嵌入)</h4><p>定义一个潜在嵌入空间e∈R^K×D^,其中K为离散潜在空间(即K - way范畴)的大小,D为每个潜在嵌入向量e^i^的维数.注意到存在K个嵌入向量e~i~∈R^D^,i∈1,2,..,K.该模型取一个输入x,通过编码器产生输出z~e~(x)</p><p>然后利用共享嵌入空间e通过最近邻查找计算离散潜变量z</p><p><img data-src="https://s2.loli.net/2024/09/24/B5C7huNZsTWfdGP.png" alt="image-20240924160115359"></p><p>Z~e~(x)是编码器网络的输出,根据这个输出通过找到最近邻映射到给定的潜在空间中,得到z~q~(x)作为decoder的输入.</p><script type="math/tex; mode=display">z_q(x)=e_k,\quad\text{where}\quad k=\text{argmin}_j\|z_e(x)-e_j\|_2</script><p>对于梯度,直接将z~q~(x)的梯度copy到z~e~(x)</p><p>由于encoder的输出表示和decoder的输入共享相同的D维空间<strong>,梯度包含了encoder如何改变其输出以降低重构损失的有用信息</strong></p><p>总损失如下,有三个组成部分,分别用于训练VQ-VAE的不同部分.</p><p>第一项是重构损失(或数据项),它优化了解码器和编码器</p><p>由于z~e~ (x)到z~q~( x)映射的直通梯度估计(梯度直接copy),嵌入e~i~没有从重构损失log~p~ ( z | z~q~ ( x ) )中获得梯度.因此,为了学习嵌入空间,使用最简单的字典学习算法之一,向量量化( VQ ).VQ目标使用l2误差将嵌入向量e~i~移动到编码器输出z~e~ (x).</p><p>最后,由于嵌入空间的体积是无量纲的,如果嵌入e~i~的训练速度没有编码器参数那么快,嵌入空间的体积可以任意增长.</p><script type="math/tex; mode=display">L=\log p(x|z_q(x))+\|\mathrm{sg}[z_e(x)]-e\|_2^2+\beta\|z_e(x)-\mathrm{sg}[e]\|_2^2</script><p>Sg表示在前向计算时定义为恒等式且具有零偏导数的停止梯度算子,从而有效地约束其操作数为非更新常数</p><script type="math/tex; mode=display">sg(x)=\left\{\begin{array}{l}x (in forward propagation)\\0 (in backward propagation)\end{array}\right.</script><p>decoder只优化第一个损失项,encoder优化第一个和最后一个损失项,嵌入由中间损失项优化.</p><p><img data-src="https://raw.githubusercontent.com/zalandoresearch/pytorch-vq-vae/b98fde9a8f8f65486dbfaf12958049e8d33184a1//images/vq-vae.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorQuantizer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_embeddings, embedding_dim, commitment_cost</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VectorQuantizer, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self._embedding_dim = embedding_dim</span><br><span class="line">        self._num_embeddings = num_embeddings</span><br><span class="line">        </span><br><span class="line">        self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim)</span><br><span class="line">        self._embedding.weight.data.uniform_(-<span class="number">1</span>/self._num_embeddings, <span class="number">1</span>/self._num_embeddings)</span><br><span class="line">        self._commitment_cost = commitment_cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">        <span class="comment"># convert inputs from BCHW -&gt; BHWC</span></span><br><span class="line">        inputs = inputs.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).contiguous()</span><br><span class="line">        input_shape = inputs.shape</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Flatten input</span></span><br><span class="line">        flat_input = inputs.view(-<span class="number">1</span>, self._embedding_dim)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate distances</span></span><br><span class="line">        distances = (torch.<span class="built_in">sum</span>(flat_input**<span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) </span><br><span class="line">                    + torch.<span class="built_in">sum</span>(self._embedding.weight**<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">                    - <span class="number">2</span> * torch.matmul(flat_input, self._embedding.weight.t()))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Encoding</span></span><br><span class="line">        encoding_indices = torch.argmin(distances, dim=<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        encodings = torch.zeros(encoding_indices.shape[<span class="number">0</span>], self._num_embeddings, device=inputs.device)</span><br><span class="line">        encodings.scatter_(<span class="number">1</span>, encoding_indices, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Quantize and unflatten</span></span><br><span class="line">        quantized = torch.matmul(encodings, self._embedding.weight).view(input_shape)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Loss</span></span><br><span class="line">        e_latent_loss = F.mse_loss(quantized.detach(), inputs)</span><br><span class="line">        q_latent_loss = F.mse_loss(quantized, inputs.detach())</span><br><span class="line">        loss = q_latent_loss + self._commitment_cost * e_latent_loss</span><br><span class="line">        </span><br><span class="line">        quantized = inputs + (quantized - inputs).detach()</span><br><span class="line">        avg_probs = torch.mean(encodings, dim=<span class="number">0</span>)</span><br><span class="line">        perplexity = torch.exp(-torch.<span class="built_in">sum</span>(avg_probs * torch.log(avg_probs + <span class="number">1e-10</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># convert quantized from BHWC -&gt; BCHW</span></span><br><span class="line">        <span class="keyword">return</span> loss, quantized.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>).contiguous(), perplexity, encodings</span><br></pre></td></tr></table></figure><ul><li><a href="https://zhuanlan.zhihu.com/p/640000410">VQVAE PyTorch 实现教程 - 知乎 (zhihu.com)</a></li><li><a href="https://github.com/Jackson-Kang/Pytorch-VAE-tutorial/blob/master/02_Vector_Quantized_Variational_AutoEncoder.ipynb">Pytorch-VAE-tutorial/02_Vector_Quantized_Variational_AutoEncoder.ipynb at master · Jackson-Kang/Pytorch-VAE-tutorial (github.com)</a></li><li><a href="https://github.com/zalandoresearch/pytorch-vq-vae/blob/master/vq-vae.ipynb">pytorch-vq-vae/vq-vae.ipynb at master · zalandoresearch/pytorch-vq-vae (github.com)</a></li></ul><h3 id="Taming-Transformers-for-High-Resolution-Image-Synthesis"><a href="#Taming-Transformers-for-High-Resolution-Image-Synthesis" class="headerlink" title="Taming Transformers for High-Resolution Image Synthesis"></a>Taming Transformers for High-Resolution Image Synthesis</h3><p><a href="https://arxiv.org/pdf/2012.09841">2012.09841 (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/24/eyoQUhlq24Ynxru.png" alt="image-20240924210104616"></p><p>为了学习序列数据上的长程交互,Transformer在各种各样的任务上不断地展示出最先进的结果.与卷积神经网络不同的是,它们不包含优先考虑局部交互的归纳偏差.这使得它们具有表达能力,<strong>但对于长序列,如高分辨率图像,在计算上也是不可行的.我们展示了如何将CNN的感应偏置的有效性与变压器的表达能力相结合,使其能够建模,从而合成高分辨率图像</strong></p><p>复杂度不是建立在单个像素上,而是需要一种方法,使用学习表示的离散码本,使得任何图像x∈R^H×W×3^都可以由码本项的空间集合z~q~∈R^h×w×nz^表示,其中nz是中间变量的维数</p><h4 id="学习高效codebook"><a href="#学习高效codebook" class="headerlink" title="学习高效codebook"></a>学习高效codebook</h4><p>首先学习一个由编码器E和解码器G组成的卷积模型,使得它们一起从一个学习的离散codebook $\mathcal{Z}={z<em>k}</em>{k=1}^K\subset\mathbb{R}^{n_z}$中学习用码表示图像,获得</p><script type="math/tex; mode=display">z_{\mathbf{q}}=\mathbf{q}(\hat{z}):=\left(\underset{z_k\in\mathcal{Z}}{\operatorname*{\arg\min}}\|\hat{z}_{ij}-z_k\|\right)\in\mathbb{R}^{h\times w\times n_z}</script><script type="math/tex; mode=display">\hat{x}=G(z_\mathbf{q})=G\left(\mathbf{q}(E(x))\right)</script><p>利用编码( z = E(x)∈R^h×w×nz^ )和每个空间码( z~ij~^^^∈R^nz^ )在其最近的codebook项z~k~上的后续逐元素量化q ( · )得到zq</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}_{\mathrm{VQ}}(E,G,\mathcal{Z})&=\|x-\hat{x}\|^{2}+\|\mathrm{sg}[E(x)]-z_{\mathbf{q}}\|_{2}^{2}\\&+\|\mathrm{sg}[z_{\mathbf{q}}]-E(x)\|_{2}^{2}.\end{aligned}</script><p>使用Transformer将图像表示为潜在图像成分上的分布</p><h4 id="生成视觉丰富的codebook"><a href="#生成视觉丰富的codebook" class="headerlink" title="生成视觉丰富的codebook"></a>生成视觉丰富的codebook</h4><script type="math/tex; mode=display">\mathcal{L}_\mathrm{GAN}(\{E,G,\mathcal{Z}\},D)=[\log D(x)+\log(1-D(\hat{x}))]</script><script type="math/tex; mode=display">\begin{aligned}\mathcal{Q}^{*}=\arg\min_{E,G,\mathcal{Z}}\max_{D}\mathbb{E}_{x\sim p(x)}\Big[\mathcal{L}_{\mathrm{VQ}}(E,G,\mathcal{Z})\\+\lambda\mathcal{L}_{\mathrm{GAN}}(\{E,G,\mathcal{Z}\},D)\Big]\end{aligned}</script><p>$\lambda$设置取</p><script type="math/tex; mode=display">\lambda=\frac{\nabla_{G_L}[\mathcal{L}_{\mathrm{rec}}]}{\nabla_{G_L}[\mathcal{L}_{\mathrm{GAN}}]+\delta}</script><p>∂~GL~ [ · ]表示其梯度也就是在decoder最后一层L的梯度</p><h4 id="使用transformers学习图像生成"><a href="#使用transformers学习图像生成" class="headerlink" title="使用transformers学习图像生成"></a>使用transformers学习图像生成</h4><p>在E和G可用的情况下可以根据它们编码的codebook索引来表示图像.图像x的量化编码是由z~q~ = q ( E ( x ) )∈R^h×w×nz^给出的,并且等价于一个序列从码本中得到的索引$s\in{0,\ldots,|\mathcal{Z}|-1}^{n\times w}$,它是由码本Z中的索引替换每个码得到的</p><p>通过将序列s的索引映射回其对应的码本项,z~q~ = ( z~sij~ )很容易恢复并解码成图像(x = G(z~q~ ) ).</p><p>在s中选择一些指标的排序后图像生成可以表示为自回归下一指标预测：给定指标s &lt; i,转换器学习预测可能的下一指标的分布,即p(s~i~ | s &lt; i)</p><script type="math/tex; mode=display">\mathcal{L}_{\text{Transformer}}=\mathbb{E}_{x\sim p(x)}\left[-\log p(s)\right]</script><h4 id="约束的图像生成"><a href="#约束的图像生成" class="headerlink" title="约束的图像生成"></a>约束的图像生成</h4><p>在许多图像合成任务中,用户需要通过提供额外的信息来控制生成过程,从而合成一个示例.这种信息,我们称之为c,可以是描述整体图像类别的单个标签,也可以是另一幅图像本身.然后任务是学习给定这个信息c的序列的似然</p><script type="math/tex; mode=display">p(s|c)=\prod_ip(s_i|s_{<i},c)</script><h4 id="生成高分辨率图片"><a href="#生成高分辨率图片" class="headerlink" title="生成高分辨率图片"></a>生成高分辨率图片</h4><p>为了生成百万像素级别的图像,我们必须在训练过程中对图像块和裁剪图像进行处理,将s的长度限制在最大可行尺寸.</p><p>为了对图像进行采样使用滑动窗口方式的transformers</p><p><img data-src="https://s2.loli.net/2024/09/24/fPyLMHekCdGRWrT.png" alt="image-20240924225113569"></p><p><a href="https://github.com/Shubhamai/pytorch-vqgan">Shubhamai/pytorch-vqgan: This repo contains the implementation of VQGAN, Taming Transformers for High-Resolution Image Synthesis in PyTorch from scratch. I have added support for custom datasets, testings, experiment tracking etc. (github.com)</a></p><h2 id="UDA"><a href="#UDA" class="headerlink" title="UDA"></a>UDA</h2><h3 id="Unsupervised-Domain-Adaptation-by-Backpropagation"><a href="#Unsupervised-Domain-Adaptation-by-Backpropagation" class="headerlink" title="Unsupervised Domain Adaptation by Backpropagation"></a>Unsupervised Domain Adaptation by Backpropagation</h3><p><a href="https://arxiv.org/abs/1409.7495">1409.7495] Unsupervised Domain Adaptation by Backpropagation (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/24/l5AuBIpzqbGL2WO.png" alt="image-20240924230029897"></p><h3 id="CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation"></a>CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation</h3><p><a href="https://arxiv.org/abs/2109.06165">2109.06165] CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation (arxiv.org)</a></p><p><img data-src="https://s2.loli.net/2024/09/25/dPITi2QMRE8u4Z3.png" alt="image-20240925162052101"></p><p>它由3个权重共享的transformer组成,通过使用two-way center-aware labeling method方法选择成对输入.</p><p>源分支( HS )和目标分支( HT )采用交叉熵,源-目标分支( HS + T )和HT之间采用蒸馏损失</p><h3 id="TVT-Transferable-Vision-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#TVT-Transferable-Vision-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation"></a>TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation</h3><p><a href="https://openaccess.thecvf.com/content/WACV2023/papers/Yang_TVT_Transferable_Vision_Transformer_for_Unsupervised_Domain_Adaptation_WACV_2023_paper.pdf">TVT: Transferable Vision Transformer for Unsupervised Domain Adaptation (thecvf.com)</a></p><p>随着近年来Vision Transformer在视觉任务中的应用呈指数增长,然而,ViT在适应跨领域知识方面的能力在文献中仍未被探索.为了填补这一空白,本文首先全面考察了ViT在多种域适应任务上的表现.令人惊讶的是,ViT表现出优越的泛化能力,而通过结合对抗自适应可以进一步提高性能</p><p>尽管如此,直接使用基于CNNs的适应策略并没有利用ViT在知识转移中发挥重要作用的内在优势(例如,注意力机制和序列图像表示).为了弥补这一缺陷,我们提出了一个统一的框架,即可迁移视觉转换器( Transferable Vision Transformer,TVT ),以充分利用视觉里程计的可迁移性进行领域自适应.</p><p><img data-src="https://s2.loli.net/2024/09/25/bVSItlqa89kWpmj.png" alt="image-20240925162302199"></p><p>与ViT一样,源图像和目标图像都被分割成固定大小的图像块,然后线性映射并嵌入位置信息.生成的补丁送入变压器编码器,最后一层由可转让性适配模块( TAM )替换.特征学习、对抗域适应和分类由ViT-akin骨干、两个域判别器(在path-level和global-level上)、判别聚类模块( Discriminative Clustering Module,DCM )和基于MLP的分类器完成</p><h2 id="Variant-Transformer"><a href="#Variant-Transformer" class="headerlink" title="Variant Transformer"></a>Variant Transformer</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;传统深度学习,或者说在llm之前的深度学习,现在看来,还是有很多trick以及各种模块”缝合”的内容,这部分有很多提出来的方法其实都有一些共通点的,这里简单回顾总结一下.&lt;br&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>完整的C++项目构建注意事项</title>
    <link href="https://www.sekyoro.top/2024/09/16/%E5%AE%8C%E6%95%B4%E7%9A%84C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://www.sekyoro.top/2024/09/16/%E5%AE%8C%E6%95%B4%E7%9A%84C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2024-09-16T09:27:04.000Z</published>
    <updated>2024-09-18T15:31:47.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近常常使用cmake构建c++项目有感,从创建项目到打包发布总结一下需要注意的事情.<br><span id="more"></span></p><h2 id="项目组织方式"><a href="#项目组织方式" class="headerlink" title="项目组织方式"></a>项目组织方式</h2><p>具体的项目组织方式因人而异,这里推荐一种,在src目录中创建模块目录,再在include目录中常见对应的同名目录包含头文件,可执行程序的源代码或者最终生成库的源代码可以放在app目录中.</p><p>比如我看的一个项目组织如图</p><ol><li>在src目录中包括demo,view,assignment三个项目,对应include目录相同,或者在生成程序的目录中包含头文件而不另外放include中.</li></ol><p><img data-src="https://s2.loli.net/2024/09/16/ctGKixOyJs19qo6.png" alt="image-20240916205927734"></p><ol><li>此外也有src目录中放所有的源代码文件,include目录分别放每个模块对应的头文件,相对来说更方便.</li></ol><p>针对第一种组织方式,cmake会在src目录添加模块</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(view)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(demo)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(assignments)</span><br></pre></td></tr></table></figure><p>每个模块再单独写cmake,甚至可以单独写project,这样方便模块化,可以看到下面利用不同的<code>$&#123;PROJECT_NAME&#125;</code>设置库生成位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(demo_hello_world)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/demo_hello_world.cpp&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES </span><br><span class="line">  DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;BINARY_DIR&#125;&quot;</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC view) </span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/demo.cpp&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/window_demo.cpp&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/window_demo.h&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES </span><br><span class="line">  DEBUG_POSTFIX <span class="string">&quot;_d&quot;</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;BINARY_DIR&#125;&quot;</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;LIBRARY_DIR&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC view) </span><br></pre></td></tr></table></figure><p>比较来看,如果给src目录中放所有的cpp源文件,那不好给模块分离,因为一个项目中一般包括一个生成可执行程序或最终库的源代码,一起一堆供这个目标依赖的模块,这些模块如果能单独提出来更好,也就是说这些模板的cpp代码如果放在分别的模块目录下虽然更麻烦但更好. 此外将main程序放在app目录中也更加清晰.</p><h2 id="依赖图与文档生成"><a href="#依赖图与文档生成" class="headerlink" title="依赖图与文档生成"></a>依赖图与文档生成</h2><h3 id="查看目标的依赖"><a href="#查看目标的依赖" class="headerlink" title="查看目标的依赖"></a>查看目标的依赖</h3><p>下载graphviz</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; cmake .. --graphviz=graph.dot &amp;&amp; dot -Tpng graph.dot -o graphImage.png</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/17/z7DmyW4sqKfaMFg.png" alt="graphImage"></p><h3 id="使用Doxygen生成文档"><a href="#使用Doxygen生成文档" class="headerlink" title="使用Doxygen生成文档"></a>使用Doxygen生成文档</h3><p>需要按照规定格式撰写注释,根据注释生成文档<a href="https://www.doxygen.nl/manual/docblocks.html">Doxygen: Documenting the code</a>. </p><p>doxygen支持许多格式注释,下面列举三种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Brief description which ends at this dot. Details follow</span></span><br><span class="line"><span class="comment"> *  here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * ... text ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*! \brief Brief description.</span></span><br><span class="line"><span class="comment"> *         Brief description continued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Detailed description starts here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> ... text ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>注释</th><th>介绍</th></tr></thead><tbody><tr><td>@file</td><td>文件说明</td></tr><tr><td>@author</td><td>作者的信息</td></tr><tr><td>@brief</td><td>用于class 或function的批注中，后面为class 或function的简易说明</td></tr><tr><td>@param</td><td>参数介绍</td></tr><tr><td>@return</td><td>函数传回值的说明</td></tr></tbody></table></div><blockquote><p>Doxygen 还需要一个 Doxyfile，其包含文档生成的所有参数，比如输出格式、排除的文件模式、 项目名称等。因为配置参数太多，开始配置 Doxygen 可能会让人望而生畏，但 CMake 可以自动生 成 Doxyfile。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doxygen -g <span class="comment"># 生成doxyfile</span></span><br></pre></td></tr></table></figure><p>配置doxygenfile然后运行<code>doxygen</code>生成.</p><p>当然更好的方式是结合cmake,首先找到doxygen程序,然后设置需要的选项<a href="https://www.doxygen.nl/manual/config.html#cfg_recursive">Doxygen: Configuration</a>,最后生成文旦. 可以使用<code>add_custom_target</code>或者<code>doxygen_add_docs(推荐)</code><a href="https://cmake.org/cmake/help/latest/module/FindDoxygen.html">FindDoxygen — CMake 3.30.3 Documentation</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Doxygen)</span></span></span><br><span class="line"><span class="keyword">if</span> (DOXYGEN_FOUND)</span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_OUTPUT_DIRECTORY<span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/docs&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_GENERATE_HTML YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_GENERATE_MAN YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_MARKDOWN_SUPPORT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_AUTOLINK_SUPPORT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_HAVE_DOT YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_COLLABORATION_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_CLASS_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_UML_LOOK YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_DOT_UML_DETAILS YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_DOT_WRAP_THRESHOLD <span class="number">100</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_CALL_GRAPH YES)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(DOXYGEN_QUIET YES)</span></span></span><br><span class="line"><span class="number">#add</span>_custom_target(docs  $&#123;DOXYGEN_EXECUTABLE&#125; WORKING_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/docs))</span><br><span class="line">doxygen_add_docs(</span><br><span class="line">docs</span><br><span class="line"><span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;</span></span><br><span class="line">ALL</span><br><span class="line">COMMENT <span class="string">&quot;Generating documentation for myproject&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doxygen_add_docs(targetName</span><br><span class="line"><span class="string">    [filesOrDirs...]</span></span><br><span class="line"><span class="string">    [ALL]</span></span><br><span class="line"><span class="string">    [USE_STAMP_FILE]</span></span><br><span class="line"><span class="string">    [WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="string">    [COMMENT comment]</span></span><br><span class="line"><span class="string">    [CONFIG_FILE filename]</span>)</span><br></pre></td></tr></table></figure><p>第一个参数 targetName 是文档目标的名称,该函数将生成一个名为 targetName 的自定义目 标。这个目标将触发 Doxygen,并在构建时使用代码创建文档。</p><p>filesOrDirs包含想要从文档生成的代码的文件或目录的列表。</p><p>ALL 参数用于使 CMake 的 ALL 元目标依赖于 doxygen_add_docs(…) 创建的文档目标，因此在构建 ALL 元目标时自动生成文档。</p><p>WORKING_DIRECTORY默认是 <code>CMAKE_CURRENT_SOURCE_DIR</code></p><h2 id="代码检查和格式化工具"><a href="#代码检查和格式化工具" class="headerlink" title="代码检查和格式化工具"></a>代码检查和格式化工具</h2><p>这部分工作其实完全可以交由IDE提供,不需要在cmake build时使用的,但为了保持兼容,这里简略写一点</p><p>可以考虑使用<code>clang-tidy</code>和<code>clang-format</code>工具,在cmake文件中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE ALL_SOURCE_FILES</span><br><span class="line">    *.c *.h *.cpp *.hpp *.cxx *.hxx *.cc *.hh *.cppm *.ipp *.ixx)</span><br><span class="line"><span class="keyword">add_custom_target</span>(format</span><br><span class="line">    <span class="keyword">COMMAND</span> clang-format</span><br><span class="line">    -i</span><br><span class="line">    <span class="variable">$&#123;ALL_SOURCE_FILES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于<code>clang-tidy</code>完全可以在<code>.clang-tidy</code>文件中设置并通过clangd进行检查<a href="https://discourse.llvm.org/t/enabling-clang-tidy-checks-in-clangd/4906/2">Enabling clang-tidy checks in clangd - Clang Frontend / clangd - LLVM Discussion Forums</a></p><p><a href="https://clangd.llvm.org/config.html#clangtidy">Configuration (llvm.org)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .clangd</span><br><span class="line">Diagnostics:</span><br><span class="line">  ClangTidy:</span><br><span class="line">    CheckOptions:</span><br><span class="line">      readability-identifier-naming.VariableCase: CamelCase</span><br></pre></td></tr></table></figure><p>此外还可以设置编译器编译链接选项检查内存和初始化等错误</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (add_sanitier <span class="keyword">target</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Adding sanitizer to target $&#123;target&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;CLANG&quot;</span> <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(<span class="string">&quot;-fno-omit-frame-pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">add_link_options</span>(<span class="string">&quot;-fno-omit-frame-pointer&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=address)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=address)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=undefined)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE -fsanitize=undefined)</span><br><span class="line">  <span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;target&#125;</span> PRIVATE /fsanitize=address)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;Sanitier is not supported for $&#123;CMAKE_CXX_COMPILER_ID&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>除此之外,可以使用<code>valgrind</code>等工具动态debug查找内存问题.</p><h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><h3 id="CTest"><a href="#CTest" class="headerlink" title="CTest"></a>CTest</h3><p><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Testing With CMake and CTest.html">Testing With CMake and CTest — Mastering CMake</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">add_executable</span>(TestInstantiator TestInstantiator.cxx)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestInstantiator vtkCommon)</span><br><span class="line"><span class="keyword">add_test</span>(NAME TestInstantiator</span><br><span class="line">         <span class="keyword">COMMAND</span> TestInstantiator)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>CTest 模块通常应该只包含在项目的顶层 CMakeLists.txt 中。自从 CMake 版本 3.21 以 来，PROJECT_IS_TOP_LEVEL 可以用来测试当前的 CMakeLists.txt 是否为顶层文件。</p><p>对于项目的顶层目录和使用 ExternalProject 添加的项目顶层目录，此变量为 True。对于使用 add_subdirectory 或 FetchContent 添加的目录，该值为 False</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(CMakeBestPractice)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_test(NAME &lt;name&gt; COMMAND &lt;command&gt; <span class="meta">[&lt;arg&gt;...]</span></span><br><span class="line"><span class="meta">[CONFIGURATIONS &lt;config&gt;...]</span></span><br><span class="line"><span class="meta">[WORKING_DIRECTORY &lt;dir&gt;]</span></span><br><span class="line">[COMMAND_EXPAND_LISTS])</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctest --test-dir &lt;build_dir&gt;</span><br><span class="line">cmake --build &lt;build_dir&gt; --target <span class="built_in">test</span> <span class="comment"># 注意这里目标就是test,而不是add_test中添加的NAME</span></span><br><span class="line">ctest --build-and-test &lt;source_dir&gt; &lt;build_dir&gt;</span><br></pre></td></tr></table></figure><p>可以设置ctest多个lable,然后通过过滤查看对应结果</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_1 <span class="keyword">COMMAND</span> someTest)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test PROPERTIES LABELS <span class="string">&quot;example&quot;</span>)</span><br><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_2 <span class="keyword">COMMAND</span> anotherTest)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test_2 PROPERTIES LABELS <span class="string">&quot;will_fail&quot;</span> )</span><br><span class="line"><span class="keyword">add_test</span>(NAME labeled_test_3 <span class="keyword">COMMAND</span> YetAnotherText)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(labeled_test_3 PROPERTIES LABELS <span class="string">&quot;example;will_fail&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest -L <span class="string">&quot;example|will_fail&quot;</span></span><br></pre></td></tr></table></figure><p><code>-L</code>进行过滤</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest -I [Start,End,Stride,<span class="built_in">test</span><span class="comment">#,test#,...|Test file] </span></span><br></pre></td></tr></table></figure><p>通过 Start、End 和 Stride，可以指定要执行的测试的范围。这三个数字是与显式测试数字 test# 相结合的范围，或传递包含参数的文件</p><h4 id="处理大量测试"><a href="#处理大量测试" class="headerlink" title="处理大量测试"></a>处理大量测试</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create_test_sourcelist</span> (SourceListName</span><br><span class="line">                        DriverName</span><br><span class="line">                        test1 test2 test3</span><br><span class="line">                        EXTRA_INCLUDE <span class="keyword">include</span>.h</span><br><span class="line">                        <span class="keyword">FUNCTION</span> <span class="keyword">function</span></span><br><span class="line">                        )</span><br></pre></td></tr></table></figure><blockquote><p>注意ctest并不提供方便测试的方法,可以使用第三方库提供的REQUIRE等方法</p></blockquote><p>使用<code>include(Ctest)</code>和<code>add_test</code>可使得可以方便使用<code>ctest</code>命令进行测试</p><p>比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"><span class="built_in">cd</span> build &amp;&amp; ctest</span><br></pre></td></tr></table></figure><h3 id="使用Catch2"><a href="#使用Catch2" class="headerlink" title="使用Catch2"></a>使用Catch2</h3><p><a href="https://github.com/catchorg/Catch2">catchorg/Catch2: A modern, C++-native, test framework for unit-tests, TDD and BDD - using C++14, C++17 and later (C++11 support is in v2.x branch, and C++03 on the Catch1.x branch) (github.com)</a></p><p>创建tests目录,编写cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">ENABLE_TESTING</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(TEST_MAIN <span class="string">&quot;unit_tests&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(TEST_SOURCES main.cpp)</span><br><span class="line">    <span class="keyword">set</span>(TEST_INCLUDES <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> <span class="variable">$&#123;TEST_SOURCES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> PUBLIC <span class="variable">$&#123;TEST_INCLUDES&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;TEST_MAIN&#125;</span> PUBLIC <span class="variable">$&#123;LIBRARY_NAME&#125;</span> Catch2::Catch2WithMain)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>自动发现测试</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(baz LANGUAGES CXX VERSION <span class="number">0.0</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Catch2 REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(tests <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(tests PRIVATE Catch2::Catch2)</span><br><span class="line"><span class="comment"># list(APPEND CMAKE_MODULE_PATH $&#123;catch2_SOURCE_DIR&#125;/extras) # use FetchContent</span></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"><span class="keyword">include</span>(Catch)</span><br><span class="line">catch_discover_tests(tests)</span><br></pre></td></tr></table></figure><h3 id="使用GoogleTest"><a href="#使用GoogleTest" class="headerlink" title="使用GoogleTest"></a>使用GoogleTest</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GoogleTest requires at least C++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_test hello_test.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_test GTest::gtest_main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(hello_test) <span class="comment"># 自动发现测试</span></span><br></pre></td></tr></table></figure><h3 id="代码覆盖检查"><a href="#代码覆盖检查" class="headerlink" title="代码覆盖检查"></a>代码覆盖检查</h3><p>检查测试了哪些代码并生成覆盖率报告,使用Gcov生成覆盖率信息,使用覆盖分析程序,如 Gcovr 或 LCOVn分析覆盖文件并生成报告</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CTest+Catch2即可</p><h2 id="第三方库管理"><a href="#第三方库管理" class="headerlink" title="第三方库管理"></a>第三方库管理</h2><h3 id="使用FetchContent下载库"><a href="#使用FetchContent下载库" class="headerlink" title="使用FetchContent下载库"></a>使用FetchContent下载库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(nlohmann_json </span><br><span class="line">GIT_REPOSITORY https://github.com/nlohmann/json</span><br><span class="line">GIT_TAG v3.<span class="number">11.2</span></span><br><span class="line">GIT_SHALLOW <span class="keyword">TRUE</span>)</span><br><span class="line">FetchContent_Makeavailable(nlohmann_json)</span><br></pre></td></tr></table></figure><p>需要项目是cmake项目</p><h3 id="使用vcpkg等包管理工具下载库"><a href="#使用vcpkg等包管理工具下载库" class="headerlink" title="使用vcpkg等包管理工具下载库"></a>使用vcpkg等包管理工具下载库</h3><p><a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">包管理器与xmake介绍</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-preset&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;toolchainFile&quot;</span>: <span class="string">&quot;$env&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">find_package</span>(ftxui REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE ftxui::dom ftxui::screen ftxui::component)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br><span class="line">cmake --preset my-preset</span><br><span class="line">cmake --build build</span><br><span class="line">./build/my-app</span><br></pre></td></tr></table></figure><h3 id="使用Conan"><a href="#使用Conan" class="headerlink" title="使用Conan"></a>使用Conan</h3><p>简单介绍一下使用流程</p><p>首先定义conanfile.txt和conan profile</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[requires]</span></span><br><span class="line">zlib/<span class="number">1.2</span><span class="number">.11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[generators]</span></span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p>然后执行<code>conan insatll</code>会生成<code>conan_toolchain.cmake</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>再在cmake中使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br></pre></td></tr></table></figure><h3 id="借助git-submodule下载库"><a href="#借助git-submodule下载库" class="headerlink" title="借助git submodule下载库"></a>借助git submodule下载库</h3><p><a href="https://git.github.io/git-scm.com/docs/git-submodule/zh_HANS-CN">Git - git-submodule Documentation</a></p><p><a href="https://www.atlassian.com/git/tutorials/git-submodule">Git submodule | Atlassian</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://bitbucket.org/jaredw/awesomelibrary <span class="comment"># 添加子模块(当前新版本git也会下载对应模块)</span></span><br><span class="line">git submodule init //初始化子模块 (根据.gitmodules更新信息)</span><br><span class="line">git submodule update //更新子模块</span><br><span class="line">git submodule update --init --recursive <span class="comment"># 更新映射关系并递归下载模块</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/17/yJh84dN6IPrOjAz.png" alt="image-20240917150517478"></p><p>使用<code>git submodule add</code>之后会创建<strong>.gitmodules</strong>文件并写入相关信息,包括子模块path和url,其中path是安装路径,因此我们可以借助修改path,使得<code>git update --init</code>安装子模块时安装到3rd_party或vendor目录便于管理,比如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">&quot;glfw&quot;</span>]</span><br><span class="line">path = third_party/glfw</span><br><span class="line">url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/glfw/g</span>lfw.git</span><br></pre></td></tr></table></figure><p>修改.gitmodules 文件中对应模块的名字或者path,然后使用<code>git submodule sync</code>进行更新.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule sync --recursive</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>此外还会在<code>.git/config</code>和<code>.git/modules</code>中添加子模块信息</p><p><code>update</code>的作用是根据项目的配置信息,拉取更新子模块中的代码,也可以使用<code>git clone --recurse-submodules</code>直接下载子模块</p><p><strong>卸载子模块</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule deinit project-sub <span class="comment"># 在.gitmodules中对应的模块名 </span></span><br><span class="line">git rm project-sub <span class="comment"># 删除模块目录与.git/config,.git/modules信息</span></span><br></pre></td></tr></table></figure><p>总结来说,可以使用第三方管理工具,下载链接非常方便. 对于自己写的一些库或者没有cmake的项目可以使用vendor/3rd_party方式,放在一个单独目录,如果是源代码,添加源文件和头文件,生成库,cmake如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># glad</span></span><br><span class="line"><span class="keyword">set</span>(glad_SOURCE_DIR <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/glad&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB source</span><br><span class="line">  <span class="string">&quot;$&#123;glad_SOURCE_DIR&#125;/src/*.c&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_library</span>(glad <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(glad</span><br><span class="line">  PUBLIC <span class="string">&quot;$&#123;glad_SOURCE_DIR&#125;/include&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES FOLDER <span class="string">&quot;third_party&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果是已经编译好的库,使用<code>add_library(xxx SHARED IMPORTED)</code>并设置库文件位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(glad SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES IMPORTED_LOCATION <span class="string">&quot;/path/to/glad/library&quot;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES IMPORTED_IMPLIB <span class="string">&quot;/path/to/glad/library&quot;</span>) <span class="comment"># 针对windows</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(glad PROPERTIES FOLDER <span class="string">&quot;third_party&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>IMPORTED_IMPLIB:用于指定导入库的导入库文件（import library file）。在 Windows 上，通常用于 .lib 文件。这个属性通常用于静态链接的导入库</p></blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>vcpkg,conan的逻辑是使用一个文件声明项目信息和依赖,然后在cmake中添加toolchainfile用于下载对应的包,而CPM和FetchContent直接在cmake中声明需要添加的包.</p><p>优先使用第三方包管理工具,因为相比<code>FetchContent</code>提供更多功能,如果第三方库不是cmake项目,使用<code>git submodule</code>方式,下载到某个文件夹编译源代码、链接库</p><h2 id="项目打包、安装与分发"><a href="#项目打包、安装与分发" class="headerlink" title="项目打包、安装与分发"></a>项目打包、安装与分发</h2><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><h4 id="安装target"><a href="#安装target" class="headerlink" title="安装target"></a>安装target</h4><p>具体来说install(TARGETS …)会安装生成的的东西,不会安装头文件或者项目中的json、txt等读取文件.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS &lt;target&gt;... [...])</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/mkgtxHpDOQMJfuh.png" alt="image-20240918153002484"></p><p>这里最需要注意的就是动态库不包括windows上的dll.</p><p>默认安装路径如下,安装目录在Unix上usr/local,Windows是C:/program files,前缀通过<code>cmake  --prefix</code>或<code>CMAKE_INSTALL_PREFIX</code>指定</p><p><img data-src="https://s2.loli.net/2024/09/18/15lWXcPTQeqg37F.png" alt="image-20240918160115134"></p><p>install(TARGETS…) 如果 包 含 EXPORT 参 数, 用 于 从 给 定 的 install(…) 目 标 创 建 一 个 导 出 名 称,可以使用此导出名称导出这些目标</p><h4 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h4><blockquote><p>安装的东西并不总是目标输出构件的一部分。它们可能是目标的运行时依赖项，例如图片、源文件、脚本和配置文件</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span> (</span><br><span class="line">DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>install(FILES…) 指令接受一个或多个文件作为参数，TYPE 和DESTINATION 用于确定指定文件的目标目录。TYPE 用于指示哪些文件将使用该文件类型的默认 路径作为安装目录</p><p><img data-src="https://s2.loli.net/2024/09/18/WBoifXtdSRDcejq.png" alt="image-20240918155717561"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/greeter_content&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">install</span>(PROGRAMS <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/greeter.py&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;$&#123;CMAKE_INSTALL_BINDIR&#125;&quot;</span> RENAME chapter4_greeter)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dir1 dir2 dir3 TYPE LOCALSTATE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY dir2 DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_</span></span><br><span class="line"><span class="variable">LOCALSTATEDIR&#125;</span> FILES_MATCHING PATTERN <span class="string">&quot;*.hpp&quot;</span></span><br><span class="line">EXCLUDE PATTERN <span class="string">&quot;*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以指定匹配文件和排除文件模式.</p><h4 id="config-file"><a href="#config-file" class="headerlink" title="config-file"></a>config-file</h4><p>当别人安装了你的库,也要方便使用.为了让其他用户使用<code>find_package</code>找到我们的包,需要config-file.</p><p>包配置文件<code>Config.cmake</code>设置如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs) <span class="comment"># 便于获取安装路径变量</span></span><br><span class="line"><span class="keyword">set</span>(FOO_INCLUDE_DIRS <span class="variable">$&#123;PREFIX&#125;</span>/<span class="keyword">include</span>/foo-<span class="number">1.2</span>)</span><br><span class="line"><span class="keyword">set</span>(FOO_LIBRARIES <span class="variable">$&#123;PREFIX&#125;</span>/lib/foo-<span class="number">1.2</span>/libfoo.a)</span><br></pre></td></tr></table></figure><p>搜索包时,find_package(…) 会查找 /cmake 目录,所以包配置文件放在/cmake中.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top level cmake</span></span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"><span class="keyword">set</span>(project_INSTALL_CMAKEDIR cmake CACHE PATH</span><br><span class="line"><span class="string">&quot;Installation directory for config-file package cmake files&quot;</span>) <span class="comment"># 于设置 config-file 打包配置文件的安装目录</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(ch4_ex05_lib PUBLIC</span><br><span class="line">$&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_features</span>(ch4_ex05_lib PUBLIC cxx_std_11)</span><br></pre></td></tr></table></figure><p>使用$<BUILD_INTERFACE>设置头文件目录,因为在安装时</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS ex05_lib</span><br><span class="line"><span class="keyword">EXPORT</span> cex05_lib_export</span><br><span class="line">INCLUDES DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span> (</span><br><span class="line">DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/</span><br><span class="line">DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用<code>install(EXPORT)</code>得到xxConfig.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> ex05_lib_export</span><br><span class="line"><span class="keyword">FILE</span> ex05_lib-config.cmake</span><br><span class="line">NAMESPACE ex05_lib::</span><br><span class="line">DESTINATION <span class="variable">$&#123;project_INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要实现对 find_package(…) 的完全支持，还需要获取xxxConfig-version.cmake 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include(CMakePackageConfigHelpers)</span><br><span class="line">write_basic_package_version_file(</span><br><span class="line"><span class="string">&quot;ex05_lib-config-version.cmake&quot;</span></span><br><span class="line"><span class="comment"># Package compatibility strategy. SameMajorVersion is</span></span><br><span class="line">essentially <span class="string">&#x27;semantic versioning&#x27;</span>.</span><br><span class="line">COMPATIBILITY SameMajorVersion <span class="comment"># 与主版本号相同即可</span></span><br><span class="line">)</span><br><span class="line">install(FILES</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/ex05_lib-config-version.</span></span><br><span class="line"><span class="string">cmake&quot;</span></span><br><span class="line">DESTINATION <span class="string">&quot;<span class="variable">$&#123;project_INSTALL_CMAKEDIR&#125;</span>&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake –S . -B ./build</span><br><span class="line">cmake --build ./build</span><br><span class="line">cmake --install ./build --prefix /3rdparty</span><br></pre></td></tr></table></figure><p>安装包并使用<code>find_package</code>使用包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The chapter-4, ex05_consumer project is</span></span><br><span class="line"><span class="string">intended to be a standalone, top-level project. Do not</span></span><br><span class="line"><span class="string">include this directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">find_package</span>(ex05_lib <span class="number">1</span> CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(ex05_consumer src/main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(ex05_consumer PRIVATE cxx_std_11)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ex05_consumer ex05_lib::ch4_ex05_</span><br><span class="line">lib)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/Fg985AeDWyStn47.png" alt="image-20240918175420391"></p><h3 id="CPack"><a href="#CPack" class="headerlink" title="CPack"></a>CPack</h3><p><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Packaging With CPack.html">Packaging With CPack — Mastering CMake</a></p><p>cpack包含多种生成器生成包</p><p><img data-src="https://s2.loli.net/2024/09/18/xgPj8oBc7YtLTXC.png" alt="image-20240918161939375"></p><p>常用cpack变量,用于设置项目打包时的信息</p><p><img data-src="https://s2.loli.net/2024/09/18/vTwgth6iM8qGKWV.png" alt="image-20240918162023449"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(</span><br><span class="line">ch4_ex06_pack</span><br><span class="line">VERSION <span class="number">1.0</span></span><br><span class="line">DESCRIPTION <span class="string">&quot;Chapter 4 Example 06, Packaging with CPack&quot;</span></span><br><span class="line">LANGUAGES CXX)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> PROJECT_IS_TOP_LEVEL)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The chapter-4, ex06_pack project is</span></span><br><span class="line"><span class="string">intended to be a standalone, top-level project.</span></span><br><span class="line"><span class="string">Do not include this directory.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(executable)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(library)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="string">&quot;CTT Authors&quot;</span>) <span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_GENERATOR <span class="string">&quot;DEB;RPM;TBZ2&quot;</span>) <span class="comment"># 包管理器</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_THREADS <span class="number">0</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_DEBIAN_PACKAGE_MAINTAINER <span class="string">&quot;CTT Authors&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure><p>CPACK<em>PACKAGE_NAME 和 CPACK_PACKAGE_VERSION</em>* 默认从顶层项目名称和版本中获取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake –S . -B build/</span><br></pre></td></tr></table></figure><p>项目配置后,生成CpackConfig.cmake 和 CpackConfigSource.cmake文件到build/CPack*中,使用<code>cpack</code>得到最终包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build/</span><br><span class="line">cpack --config build/CPackConfig.cmake -B build/</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/18/5VcBEb1fQwq7eDA.png" alt="image-20240918164647416"></p><blockquote><p>注意设置generator时,其中每个都需要符合条件. 比如nsis需要安装对应的软件,否则设置generator包括它时会直接报错</p></blockquote><h2 id="经常遗忘的指令"><a href="#经常遗忘的指令" class="headerlink" title="经常遗忘的指令"></a>经常遗忘的指令</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name <span class="comment">[ALL]</span> <span class="comment">[command1 <span class="comment">[args1...]</span>]</span></span><br><span class="line"><span class="comment">[COMMAND command2 <span class="comment">[args2...]</span> ...]</span></span><br><span class="line"><span class="comment">[DEPENDS depend depend depend ... ]</span></span><br><span class="line"><span class="comment">[BYPRODUCTS <span class="comment">[files...]</span>]</span></span><br><span class="line"><span class="comment">[WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="comment">[COMMENT comment]</span></span><br><span class="line"><span class="comment">[JOB_POOL job_pool]</span></span><br><span class="line"><span class="comment">[VERBATIM]</span> <span class="comment">[USES_TERMINAL]</span></span><br><span class="line"><span class="comment">[COMMAND_EXPAND_LISTS]</span></span><br><span class="line"><span class="comment">[SOURCES src1 <span class="comment">[src2...]</span>]</span>)</span><br></pre></td></tr></table></figure><p>add_custom_target 的核心是通过 COMMAND 选项传递的命令列表。虽然第一个命令可 以不带这个选项,但最好在 add_custom_target 中添加 COMMAND 选项。</p><p><strong>默认情况下,定制目标只在显式请求时执行,除非指定了 ALL 选项</strong>。</p><p>自定义目标总认为是过时的，因此总是运行指 定的命令，而不管是否会反复产生相同的结果。</p><p>使用 DEPENDS 关键字，可以使定制目标依赖于使用 add_custom_command 或其他目标定义的定制命令的文件和输出。</p><p>要使自定义目标依赖于另 一个目标，可以使用 add_dependencies。若使用自定义目标创建文件，可以在 BYPRODUCTS 选项下列出这些文件。</p><p>列出的文件都将使用 GENERATED 属性标记，CMake 使用该属性来确定构建是否过期，并找出需要清理的文件，但使用 add_custom_command 创建文件的任务可能更适 合。</p><p> 通常，命令在当前二进制目录中执行，该目录在 CMAKE_CURRENT_BINARY_DIRECTORY 缓存变量中。若需要修改，这可以<strong>通过 WORKING_DIRECTORY 选项来更改</strong>。该选项可以是绝对 路径，也可以是相对路径 (当前二进制目录的相对路径)。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET &lt;target&gt;</span><br><span class="line">PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">COMMAND command1 <span class="comment">[ARGS]</span> <span class="comment">[args1...]</span></span><br><span class="line"><span class="comment">[COMMAND command2 <span class="comment">[ARGS]</span> <span class="comment">[args2...]</span> ...]</span></span><br><span class="line"><span class="comment">[BYPRODUCTS <span class="comment">[files...]</span>]</span></span><br><span class="line"><span class="comment">[WORKING_DIRECTORY dir]</span></span><br><span class="line"><span class="comment">[COMMENT comment]</span></span><br><span class="line"><span class="comment">[VERBATIM]</span> <span class="comment">[USES_TERMINAL]</span></span><br><span class="line"><span class="comment">[COMMAND_EXPAND_LISTS]</span>)</span><br></pre></td></tr></table></figure><p>可以在以下时段将命令连接到构建中: </p><p>• PRE_BUILD: 在 Visual Studio 中，此命令在执行其他构建步骤之前执行。当使用其他生成器 时，会在 PRE_LINK 命令之前运行。</p><p> • PRE_LINK: 此命令将在编译源代码之后运行，在可执行文件或存档工具链接到静态库之前运行。</p><p> • <strong>POS_BUILD: 这将在执行所有其他构建规则后运行该命令</strong>。 执行自定义步骤最常见的方法是使用 POST_BUILD; 其他两个选项很少使用，要么是因为支持 有限，要么是因为它们既不能影响链接，也不能影响构建。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_parse_arguments</span>(&lt;prefix&gt; &lt;options&gt; &lt;one_value_keywords&gt;</span><br><span class="line">                      &lt;multi_value_keywords&gt; &lt;args&gt;...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_parse_arguments</span>(PARSE_ARGV &lt;N&gt; &lt;prefix&gt; &lt;options&gt;</span><br><span class="line">                      &lt;one_value_keywords&gt; &lt;multi_value_keywords&gt;)</span><br></pre></td></tr></table></figure><p><a href="https://cmake.org/cmake/help/latest/command/cmake_parse_arguments.html">cmake_parse_arguments — CMake 3.30.3 Documentation</a></p><h3 id="Great-resoureces-for-learning"><a href="#Great-resoureces-for-learning" class="headerlink" title="Great resoureces for learning"></a>Great resoureces for learning</h3><ol><li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake (github.com)</a></li><li><a href="https://github.com/franneck94/CppProjectTemplate">franneck94/CppProjectTemplate: C++ project template with unit-tests, documentation, ci-testing and workflows. (github.com)</a></li></ol><p>书籍推荐<a href="https://book.douban.com/subject/35793146/">CMake Best Practices (豆瓣) (douban.com)</a>和<a href="https://book.douban.com/subject/34936765/">Professional CMake (豆瓣) (douban.com)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近常常使用cmake构建c++项目有感,从创建项目到打包发布总结一下需要注意的事情.&lt;br&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
    <category term="cmake" scheme="https://www.sekyoro.top/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>build a mini project starter in Rust</title>
    <link href="https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/"/>
    <id>https://www.sekyoro.top/2024/09/15/build-a-mini-project-starter-in-Rust/</id>
    <published>2024-09-15T01:45:08.000Z</published>
    <updated>2024-09-15T15:52:27.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator<br><span id="more"></span></p><p>项目源码:<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/mini-project-starter">build-my-own-x/mini-project-starter at main · drowning-in-codes/build-my-own-x (github.com)</a></p><p>crates.io:<a href="https://crates.io/crates/mini-project-starter">mini-project-starter - crates.io: Rust Package Registry</a></p><p><img data-src="https://s2.loli.net/2024/09/15/39hKmTFezL5vJM1.png" alt="image-20240915235220102"></p><h2 id="常见的c-项目组织方式"><a href="#常见的c-项目组织方式" class="headerlink" title="常见的c++项目组织方式"></a>常见的c++项目组织方式</h2><p>项目组织方式因人而异,但一些基本点还是相同的,比如参考Rust一些模块组织方式,由于c++代码需要有头文件(不知道c++26之后的未来会不会尽可能地使用模块替代头文件这种组织方式)</p><p>由于在其他语言中,一个模块基本上就是单独一个文件,而c++中是cpp源文件和对应的头文件,这个模块最好(或者说必须)放在对应名字的目录下,比如我的项目下写了一个logger模块,它一种组织方式如下,src目录下放置需要的库,app目录下放可执行程序或者最后生成的库.相当于在src目录下放置多个模块目录,每个目录中放源文件和头文件</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>         -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\  (optional)</span></span><br><span class="line"><span class="ruby"></span>       -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>          -<span class="ruby"> main.hpp (optional)</span></span><br></pre></td></tr></table></figure><p>或者稍微改改,将模块的头文件放在include中,也就是头文件和源文件不放在同一个目录</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> app\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br></pre></td></tr></table></figure><p>此外还有一种,将所有cpp文件都放在src中,头文件放在include中,差异就是它的源文件是放在一起的,没有放在一个所谓模块目录下.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> root_dir\</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> src\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.cpp</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.cpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> <span class="keyword">include</span>\</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> project\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> main.hpp</span></span><br><span class="line"><span class="ruby"></span>      -<span class="ruby"> logger\</span></span><br><span class="line"><span class="ruby"></span>        -<span class="ruby"> logger.hpp</span></span><br></pre></td></tr></table></figure><p>上面几种方式其实都行,我们看看rust是怎么组织的,由于没有头文件,在src目录下有main.rs,而garden.rs是模块,garden目录下的vegetables.rs是模块的子模块.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backyard</span><br><span class="line">├── Cargo<span class="selector-class">.lock</span></span><br><span class="line">├── Cargo<span class="selector-class">.toml</span></span><br><span class="line">└── <span class="attribute">src</span></span><br><span class="line">    ├── garden</span><br><span class="line">    │   └── vegetables<span class="selector-class">.rs</span></span><br><span class="line">    ├── garden<span class="selector-class">.rs</span></span><br><span class="line">    └── <span class="selector-tag">main</span>.rs</span><br></pre></td></tr></table></figure><p>上面组织方式的核心差别,是针对头文件,要么在include目录下按照模块名分几个目录,而不是将头文件放在一起,要么在src目录下分多个需要的库目录,每个目录包括源文件和头文件.</p><h2 id="mini-project-starter"><a href="#mini-project-starter" class="headerlink" title="mini-project-starter"></a>mini-project-starter</h2><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><p>使用<code>Clap</code>库解析参数，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mini-project-starter new -p &lt;DIR&gt; <span class="comment"># 在一个目录下创建项目</span></span><br><span class="line">mini-project-starter init <span class="comment"># 在当前目录下初始化项目</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils;</span><br><span class="line"><span class="keyword">use</span> clap::&#123;command, Arg, Command&#125;;</span><br><span class="line"><span class="keyword">use</span> utils::&#123;init_project, new_project&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> starter_config = command!()</span><br><span class="line">        .propagate_version(<span class="literal">true</span>)</span><br><span class="line">        .subcommand_required(<span class="literal">true</span>)</span><br><span class="line">        .arg_required_else_help(<span class="literal">true</span>)</span><br><span class="line">        .subcommand(</span><br><span class="line">            Command::new(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">                .about(<span class="string">&quot;Create a new project in the specified directory&quot;</span>)</span><br><span class="line">                .arg(</span><br><span class="line">                    Arg::new(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .short(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">                        .long(<span class="string">&quot;project_root_dir&quot;</span>)</span><br><span class="line">                        .value_name(<span class="string">&quot;DIR&quot;</span>)</span><br><span class="line">                        .value_parser(clap::builder::NonEmptyStringValueParser::new())</span><br><span class="line">                        .help(<span class="string">&quot;The root dir of the project&quot;</span>)</span><br><span class="line">                        .required(<span class="literal">true</span>),</span><br><span class="line">                ),</span><br><span class="line">        )</span><br><span class="line">        .subcommand(Command::new(<span class="string">&quot;init&quot;</span>).about(<span class="string">&quot;Init the project in the current directory&quot;</span>))</span><br><span class="line">        .get_matches();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> starter_config.subcommand() &#123;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;new&quot;</span>, sub_matches)) =&gt; &#123;</span><br><span class="line">            new_project(sub_matches.get_one::&lt;<span class="built_in">String</span>&gt;(<span class="string">&quot;project_root_dir&quot;</span>).unwrap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>((<span class="string">&quot;init&quot;</span>, _)) =&gt; init_project(),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Please specify a subcommand&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让用户输入项目的一些信息,这些信息可以替换后面<code>CMakeLists.txt</code>中的项目信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root_dir_name = default_root_dir_name</span><br><span class="line">                .file_name()</span><br><span class="line">                .unwrap()</span><br><span class="line">                .to_str()</span><br><span class="line">                .unwrap();</span><br><span class="line">    <span class="keyword">let</span> project_name = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">r&quot;Enter your project name.(project root folder name if leave blank)&quot;</span>)</span><br><span class="line">        .with_initial_text(root_dir_name.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(root_dir_name.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目版本</span></span><br><span class="line">    <span class="keyword">let</span> project_version = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project version.(default: 0.1.0)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;0.1.0&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;0.1.0&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目描述</span></span><br><span class="line">    <span class="keyword">let</span> project_desc = Input::&lt;<span class="built_in">String</span>&gt;::new()</span><br><span class="line">        .with_prompt(<span class="string">&quot;Enter your project description.(default: A new project)&quot;</span>)</span><br><span class="line">        .with_initial_text(<span class="string">&quot;A new project&quot;</span>.to_string())</span><br><span class="line">        .interact_text()</span><br><span class="line">        .unwrap_or(<span class="string">&quot;A new project&quot;</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择项目类型</span></span><br><span class="line">    <span class="keyword">let</span> project_types = <span class="built_in">vec!</span>[ ProjectType::Cpp];</span><br><span class="line">    <span class="keyword">let</span> project_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the peoject type&quot;</span>)</span><br><span class="line">        .items(&amp;project_types)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择生成目标类型</span></span><br><span class="line">    <span class="keyword">let</span> target_type = <span class="built_in">vec!</span>[</span><br><span class="line">        TargetType::Executable,</span><br><span class="line">        TargetType::StaticLibrary,</span><br><span class="line">        TargetType::DynamicLibrary,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> target_type_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the target type&quot;</span>)</span><br><span class="line">        .items(&amp;target_type)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择包管理器</span></span><br><span class="line">    <span class="keyword">let</span> package_manager_list = <span class="built_in">vec!</span>[PackageManager::VCPKG, PackageManager::CPM,PackageManager::<span class="literal">None</span>];</span><br><span class="line">    <span class="keyword">let</span> package_manager_selection = Select::with_theme(&amp;theme)</span><br><span class="line">        .with_prompt(<span class="string">&quot;choose the package manager &quot;</span>)</span><br><span class="line">        .items(&amp;package_manager_list)</span><br><span class="line">        .interact()</span><br><span class="line">        .unwrap();</span><br><span class="line">    <span class="keyword">let</span> package_manager = package_manager_list[package_manager_selection].clone();</span><br></pre></td></tr></table></figure><p>创建一个项目需要拷贝一些目录和文件,如果是目录注意不要重复创建,而文件可以直接truncate</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建src目录与main.cpp</span></span><br><span class="line"> <span class="keyword">match</span> fs::create_dir_all(root_dir.join(project_name).join(<span class="string">&quot;src&quot;</span>)) &#123;</span><br><span class="line">         <span class="literal">Ok</span>(_)=&gt;&#123;&#125;,</span><br><span class="line">         <span class="literal">Err</span>(e)=&gt;&#123;</span><br><span class="line">             eprintln!(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,e.kind(),e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">let</span> src_file = File::create(root_dir.join(project_name).join(<span class="string">&quot;src/main.cpp&quot;</span>)).unwrap();</span><br><span class="line">         <span class="keyword">match</span> fs::read_to_string(env::current_dir().unwrap().join(<span class="string">&quot;templates/main.cpp&quot;</span>)) &#123;</span><br><span class="line">             <span class="literal">Ok</span>(contents) =&gt; <span class="built_in">write!</span>(&amp;src_file, <span class="string">&quot;&#123;&#125;&quot;</span>, contents).unwrap(),</span><br><span class="line">             <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;Error reading file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>在<code>CMakeLists.txt</code>中,添加如下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.29</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;C:/Program Files/LLVM/bin/clang++.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment"># include($&#123;CMAKE_SOURCE_DIR&#125;/cmake/sanitier.cmake)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(sanitizer)</span><br><span class="line"><span class="keyword">include</span>(copy_target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(@PROJECT_NAME@ LANGUAGES C CXX VERSION @PROJECT_VERSION@ PROJECT_DESCRIPTION <span class="string">&quot;@PROJECT_DESCRIPTION@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE LIB_SOURCE  src/*.cpp src/*.c)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE HEADER  <span class="keyword">include</span>/*.h <span class="keyword">include</span>/*.hpp)</span><br><span class="line"><span class="keyword">source_group</span>(headers FILES <span class="variable">$&#123;HEADER&#125;</span>) </span><br><span class="line"><span class="keyword">add_library</span>(@PROJECT_NAME@ STATIC <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(@PROJECT_NAME@ PRIVATE <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_SANITIZER <span class="string">&quot;Enable sanitizer&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_SANITIZER)</span><br><span class="line">  add_sanitier(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_COPY_TARGET <span class="string">&quot;Enable copy target&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_COPY_TARGET)</span><br><span class="line">  copy_target(@PROJECT_NAME@)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>针对包管理器,我设置了可以使用vcpkg或者cpm,如果是cpm可以在网上下载对应cmake脚本,如果是vcpkg,在<code>CMakePresets.json</code>中添加对应toolchainfile.</p><p>最后还有测试目录,cmake脚本,scripts辅助脚本,docs文档等等,如下</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> .gitignore</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> FindSomeLib.cmake</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> something_else.cmake</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> README.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> LICENCE.md</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> tests</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> testlib.cpp</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> docs</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> CMakeLists.txt</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> extern</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> googletest</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> scripts</span></span><br><span class="line"><span class="ruby"></span>  -<span class="ruby"> helper.py</span></span><br></pre></td></tr></table></figure><h3 id="还不错的视频参考"><a href="#还不错的视频参考" class="headerlink" title="还不错的视频参考"></a>还不错的视频参考</h3><ol><li><a href="https://www.bilibili.com/video/BV1Z44y1c7UX">CMake, Tests and Tooling for C/C++ Projects</a></li><li><a href="https://www.bilibili.com/video/BV1Tr4y1Z762">Update to Modern C++</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近沉迷写c++以及cmake构建项目(不是吧,这也能沉迷?),主要关注的是一个项目的架构,以及一些辅助工具,比如生成文档,代码检查(sanitize)等,打算使用Rust写一个非常简单的c++项目的generator&lt;br&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://www.sekyoro.top/tags/Rust/"/>
    
    <category term="Cpp" scheme="https://www.sekyoro.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>xmake:另一个C++现代构建系统</title>
    <link href="https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.sekyoro.top/2024/09/11/C-%E7%8E%B0%E4%BB%A3%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-09-11T09:22:10.000Z</published>
    <updated>2024-09-14T10:42:43.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,</p><p>所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了<a href="https://xmake.io/#/getting_started">xmake</a>之外,还有<a href="https://mesonbuild.com/">The Meson Build system</a>，<a href="https://spack.io/about/">About Spack - Spack</a>，<a href="https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn">Bazel 简介 (google.cn)</a>等等.我选择xmake主要原因是其自带的包管理和方便的写法<br><span id="more"></span></p><p>在进一步介绍xmake之前,有必要区分构建工具和包管理工具.c++目前常用的包管理工具有vcpkg,cpm以及conan,它们都有自己的registries,类似于node的npm,cargo的crates,python的pip registries,java的maven仓库. 都是社区或官方维护的库下载点,一般来允许用户注册后上传自己的包(不过考虑到c++生态是一堆轮子哥,用第三方库的人可能没有python,js一半多).</p><h2 id="纯纯FetchContent"><a href="#纯纯FetchContent" class="headerlink" title="纯纯FetchContent"></a>纯纯FetchContent</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## from https://cmakebyexample.dev/use-library-fetchcontent/</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  cpr</span><br><span class="line">  GIT_REPOSITORY https://github.com/libcpr/cpr.git</span><br><span class="line">  <span class="comment"># https://github.com/libcpr/cpr/releases</span></span><br><span class="line">  GIT_TAG <span class="number">1.10</span>.<span class="number">4</span>)</span><br><span class="line">FetchContent_MakeAvailable(cpr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PUBLIC cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app PRIVATE cpr::cpr)</span><br></pre></td></tr></table></figure><p>利用cmake内置功能,下载相应库.它需要从源代码构建curl.</p><blockquote><p>FetchContent 可让您直接在 CMake 项目中包含外部项目，从而更轻松地处理依赖关系，而无需用户单独下载和构建，或依赖系统级软件包管理器。它通过自动处理下载、构建和配置这些依赖项等任务，简化了将外部代码引入项目的过程。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    my_dependency</span><br><span class="line">    GIT_REPOSITORY https://github.com/example/my_dependency.git</span><br><span class="line">    GIT_TAG v1.<span class="number">0.0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FetchContent_MakeAvailable(my_dependency)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now you can use the components of &#x27;my_dependency&#x27; in your project</span></span><br></pre></td></tr></table></figure><h2 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h2><p>包仓库<a href="https://vcpkg.io/en/packages">Browse public vcpkg packages</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myModule &amp;&amp; <span class="built_in">cd</span> myModule</span><br><span class="line">vcpkg --new application <span class="comment"># 创建应用</span></span><br></pre></td></tr></table></figure><p>在目录下生成了两个文件,<code>vcpkg.json</code>和<code>vcpkg-confuguration.json</code>分别用于存依赖信息和仓库信息.初始前者为空,后者</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;default-registry&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;baseline&quot;</span>: <span class="string">&quot;9760ce6194ef51aa4faf77b6321e1280daa4545c&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;repository&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;registries&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;artifact&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;microsoft&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认的 <code>vcpkg-configuration.json</code> 文件引入了基线约束，指定了项目应使用的依赖项的最小版本,将 <code>vcpkg-configuration.json</code> 添加到代码控制中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg add port fmt</span><br></pre></td></tr></table></figure><p>添加依赖信息,这里并没有下载包,所以直接引入头文件会报错的</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911180835085.png" alt="image-20240911180835085"></p><p>使用下面指令下载<code>vcpkg.json</code>中的包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install</span><br></pre></td></tr></table></figure><p>还会贴心提示在cmake中如何使用</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181040866.png" alt="image-20240911181040866"></p><p>vcpkg官方推荐使用<code>CMakePresets.json</code>配置进行构建</p><blockquote><p>使用预设，项目的顶层目录必须包含名为 CMakePresets.json 或 CMakeUserPresets.json 的文 件。若两个文件都存在，将先解析 CMakePresets.json，再解析 CMakeUserPresets.json。这两个文件 有相同的格式，但使用方式略有不同</p></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181547753.png" alt="image-20240911181547753"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911181640286.png" alt="image-20240911181640286"></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cmake</span> <span class="built_in">--listpresets</span> <span class="comment"># 列出写的预设</span></span><br><span class="line"><span class="string">cmake</span> <span class="built_in">--preset=name</span> <span class="comment">#选择某个预设</span></span><br></pre></td></tr></table></figure><p>其要求写入缓存变量<code>CMAKE_TOOLCHAIN_FILE</code>就是本机安装的<code>vcpkg.cmake</code>,</p><p>如果你设置了<code>VCPKG_ROOT</code>环境变量,可以使用”$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake”</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;displayname&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generator&quot;</span>: <span class="string">&quot;Ninja&quot;</span>, # 构建工具</span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span>: <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span>, # 构建输出目录</span><br><span class="line">      <span class="attr">&quot;cacheVariables&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;CMAKE_TOOLCHAIN_FILE&quot;</span>: <span class="string">&quot;&lt;VCPKG_ROOT&gt;/scripts/buildsystems/vcpkg.cmake&quot;</span> #设置vcpkg工具链</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>version 字段指定要使用的 JSON 模式。版本 1 是 CMake 3.19 的第一个版本，只支持 configurePresets。版本 2 增加了 buildPresets 和 testPresets，CMake 3.20 开始支持; 版本 3 增加了 更多选项，CMake 3.21 开始支持。 可选的 cmakeMinimumRequired 字段可以用来定义构建此项目所需的 CMake 的最小版本。由于 最低要求通常也在 CMakeLists.txt 文件中说明，这通常会省略。 这三个列表:configurePresets、buildPresets 和 testPresets，每个列表都包含了用于配置、构建和 测试项目的配置。构建和测试的预置要求至少有一个配置预置，将在本节后面看到。 vendor 字段包含特定于供应商或 IDE 信息的可选映射。CMake 不解释该字段的内容</p><p>然后写上cmake文件,因为先使用preset会执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED) <span class="comment">#重点 find_package找包</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld PRIVATE fmt::fmt) <span class="comment">#进行链接</span></span><br></pre></td></tr></table></figure><p>执行<code>cmake --preset=name</code>会进行构建,如果没有安装相应库,也会安装.所以上面的<code>vcpkg install</code>就没必要执行了.</p><p>我在使用时遇到了找不到实现的问题,这貌似需要设置vcpkg triplet,网上有一些triplets模板,简单来说需要设置一系列vcpkg变量</p><ul><li><a href="https://stackoverflow.com/questions/74422058/how-to-use-vcpkg-with-clang-on-linux">How to use vcpkg with clang on linux? - Stack Overflow</a> 创建的自己的triplets<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/vcpkg/concepts/triplets">三元组 | Microsoft Learn</a>在windows默认的就是msvc的,难怪编译不过,我使用的时mingw…</li><li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md">vcpkg/docs/users/triplets.md at master · microsoft/vcpkg (github.com)</a></li><li><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a> 在windows上编译后将动态库拷贝一份到可执行程序同一个目录.<code>exe文件运行必须依赖同一目录(或者环境变量)下的dll</code></li></ul><p>一个简单的方法时设置<code>VCPKG_TARGET_TRIPLET</code>变量为”x64-mingw-dynamic”,表示使用mingw的动态库.或者使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install fmt:x64-mingw-dynamic</span><br></pre></td></tr></table></figure><p>可以设置 <code>VCPKG_TARGET_TRIPLET</code>(需要下载和使用的库的架构)和<code>VCPKG_HOST_TRIPLET</code>(生成自己的库需要的构建架构)来设置target和host的架构,使用<code>VCPKG_OVERLAY_TRIPLETS</code>使用社区的.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg <span class="built_in">help</span> triplets </span><br></pre></td></tr></table></figure><p>查看官方和社区提供的triplets.</p><h3 id="Triplets"><a href="#Triplets" class="headerlink" title="Triplets"></a>Triplets</h3><p>triplets指定平台架构,并按照对应的架构去设置toolchain,默认是在vcpkg/triplets下找一个符合平台的,比如<code>vcpkg install xxx:abcd</code>,其中abcd就是一个triplets,设置好triplet后清单模式下就去下载相应的包</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912123855699.png" alt="image-20240912123855699" style="zoom:50%;" /></p><blockquote><p>更新:如果你只是想用clang++编译器,在<code>CMakeLists.txt</code>project指令之前指定即可</p></blockquote><p>用于交叉编译的,也就是在宿主机上编译不同平台架构的程序/库.</p><p>默认triplets</p><ul><li>Windows: <code>x64-windows</code></li><li>Linux: <code>x64-linux</code></li><li>OSX: <code>x64-osx</code></li></ul><p>可以分别指定target-triplet和host-triplet设置对应需要的工具链名称,会根据对应的名字去vcpkg/triplets找,或者使用overlay-triplets覆盖目录</p><p>以上的问题可以总结为</p><ol><li><p>使用clang需要配置triplets,可以使用社区的</p><p><a href="https://github.com/microsoft/vcpkg/issues/38042">How to compile vcpkg libraries using Clang? · Issue #38042 · microsoft/vcpkg (github.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><a href="https://github.com/Neumann-A/my-vcpkg-triplets/tree/master">Neumann-A/my-vcpkg-triplets: my collection of vcpkg triplets (github.com)</a></p></li></ol><p>我注意到社区中的triplets中很多使用了<code>VCPKG_CHAINLOAD_TOOLCHAIN_FILE</code>指定要使用的备用 CMake 工具链文件,如果设置将替代所有其他编译器检测逻辑.默认情况下工具链文件是从 <code>scripts/toolchains/</code> 适合平台选择的,使用<code>--overlay-triplets</code>选择一个目录进行覆盖<a href="https://learn.microsoft.com/zh-cn/vcpkg/users/examples/overlay-triplets-linux-dynamic">使用覆盖三联密码 | Microsoft Learn</a></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232109031.png" alt="image-20240911232109031"></p><blockquote><p>CMake 使用工具链实用程序来编译、link libraries和创建archives，并执行其他任务来进行构建。</p><p>可用的工具链由启用的语言决定。在正常编译中，<strong>CMake 会根据系统自省和默认值自动为主机编译确定工具链</strong>。在交叉编译情况下，可指定一个包含编译器和工具路径信息的工具链文件</p></blockquote><p>下面信息很重要,cmake在project()指令处查找可用的工具链,在<code>CMAKE_TOOLCHAIN_FILE</code>中处理vcpkg逻辑,其中将默认调用合适的vckpg/scripts/toolchains/中的toolchain</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911232412863.png" alt="image-20240911232412863"></p><ol><li>在windows上使用vcpkg安装得到的动态库如果想要自己放在一个统一的3rdparty目录,include目录和bin目录中再自己设置link</li></ol><p>需要放在可执行程序目录下,可以通过设置路径解决</p><p><a href="https://blog.csdn.net/Tracker647/article/details/142070768">CMake+MinGW+vcpkg项目引入三方库的两种方式（手动路径，vcpkg）-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/78962135/cmake-add-library-with-set-property-can-not-found-fmt-dll-on-windows/78962177?noredirect=1#comment139223613_78962177">c++ - cmake add_library with set_property can not found fmt dll on windows - Stack Overflow</a>注意需要设置链接的.lib和.dll库,通过<code>IMPORTED_IMPLIB</code>设置输出的.lib库</p><blockquote><ul><li><strong>IMPORTED_LOCATION</strong>：用于存储导入库的实际文件路径，通常是共享库或可执行文件的位置。</li><li><strong>IMPORTED_IMPLIB</strong>：用于存储导入库（导入库 .lib 文件）的路径，通常在 Windows 平台上使用。</li></ul></blockquote><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911230257291.png" alt="image-20240911230257291"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll)</span><br><span class="line"><span class="comment"># 改变导入库的.dll的位置</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(fmt INTERFACE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld fmt)</span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> HelloWorld POST_BUILD     <span class="comment">#-for copy libs in windows</span></span><br><span class="line">            <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll </span><br><span class="line">            <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/build)</span><br><span class="line">            <span class="comment"># 将输出动态库放在build目录下</span></span><br></pre></td></tr></table></figure><p>需要添加设置<code>IMORTED_IMPLIB</code>路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(fmt SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> fmt PROPERTY</span><br><span class="line">  IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/bin/libfmt.dll</span><br><span class="line">  IMORTED_IMPLIB <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="number">3</span>rdparty/fmt_x64-mingw-dynamic/lib/libfmt.lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意,使用vcpkg自动引入需要设置build_type,这样第三方库的动态库.dll就放在对应位置不用改了.</p></blockquote><p>使用vcpkg时注意,</p><ol><li>设置<code>CMAKE_TOOLCHAIN_FILE</code>要在project指令之前</li></ol><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240911224541731.png" alt="image-20240911224541731"></p><ol><li>使用find_package(xxx <strong>CONFIG</strong> REQUIRED)</li><li>推荐使用preset</li><li>设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>为ON让clangd检测头文件目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -S /my/project --preset debug</span><br></pre></td></tr></table></figure><p>除了下载包之外,也有打包、发布等常用功能,已经满足常用需求了,cmake本身有cpack,但没有vcpkg提供的一些发布功能</p><p>要创建vcpkg包,首先创建manifest清单文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;libogg&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version-string&quot;</span>: <span class="string">&quot;1.3.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目<code>vcpkg.json</code>中写上包内容,然后创建<code>portfile.cmake</code>,修改下面的配置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_from_github(</span><br><span class="line">    OUT_SOURCE_PATH SOURCE_PATH</span><br><span class="line">    REPO xiph/ogg</span><br><span class="line">    <span class="keyword">REF</span> v1.<span class="number">3.3</span></span><br><span class="line">    SHA512 <span class="number">0</span>bd6095d647530d4cb1f509eb5e99965a25cc3dd9b8125b93abd6b248255c890cf20710154bdec40568478eb5c4cde724abfb2eff1f3a04e63acef0fbbc9799b</span><br><span class="line">    HEAD_REF <span class="keyword">master</span></span><br><span class="line"><span class="title">)</span></span><br></pre></td></tr></table></figure><p>用于GitHub存储库路径的REPO,用于使用稳定标签/提交的REF，以及带有下载文件校验和的SHA512,别人使用时也使用vcpkg下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vcpkg_cmake_configure(SOURCE_PATH <span class="variable">$&#123;SOURCE_PATH&#125;</span>)</span><br><span class="line">vcpkg_cmake_install()</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">INSTALL</span> <span class="string">&quot;$&#123;SOURCE_PATH&#125;/COPYING&quot;</span> DESTINATION <span class="string">&quot;$&#123;CURRENT_PACKAGES_DIR&#125;/share/libogg&quot;</span> RENAME copyright)</span><br></pre></td></tr></table></figure><p>缺点就是微软文档实在烂,不是翻译的问题,英文原文的用词像是东拼西凑,感觉像是不停换人写出来的.</p><h2 id="CPM-cmake"><a href="#CPM-cmake" class="headerlink" title="CPM.cmake"></a>CPM.cmake</h2><p>轻量的包管理工具<a href="https://github.com/cpm-cmake/CPM.cmake">cpm-cmake/CPM.cmake: 📦 CMake’s missing package manager. A small CMake script for setup-free, cross-platform, reproducible dependency management. (github.com)</a>,基于cmake的FetchContent.</p><p>你只需要<code>include</code>提供的<code>cpm.cmake</code>文件即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p cmake</span><br><span class="line">wget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake</span><br></pre></td></tr></table></figure><p>此外也可以在cmake文件中下载</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># download CPM.cmake</span></span><br><span class="line"><span class="keyword">file</span>(</span><br><span class="line">  DOWNLOAD</span><br><span class="line">  https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.<span class="number">38.3</span>/CPM.cmake</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake</span><br><span class="line">  EXPECTED_HASH SHA256=cc155ce02e7945e7b8967ddfaff0b050e958a723ef7aad3766d368940cb15494</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/cmake/CPM.cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add dependencies here</span></span><br><span class="line">CPMAddPackage(...)</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>然后就能直接使用了,</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPMAddPackage(</span><br><span class="line">  NAME          <span class="comment"># The unique name of the dependency (should be the exported target&#x27;s name)</span></span><br><span class="line">  VERSION       <span class="comment"># The minimum version of the dependency (optional, defaults to 0)</span></span><br><span class="line">  PATCHES       <span class="comment"># Patch files to be applied sequentially using patch and PATCH_OPTIONS (optional)</span></span><br><span class="line">  OPTIONS       <span class="comment"># Configuration options passed to the dependency (optional)</span></span><br><span class="line">  DOWNLOAD_ONLY <span class="comment"># If set, the project is downloaded, but not configured (optional)</span></span><br><span class="line">  [...]         <span class="comment"># Origin parameters forwarded to FetchContent_Declare, see below</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>来源可以由 GIT_REPOSITORY 指定，但也支持其他来源，如一般的URL。如果没有明确指定 GIT_TAG，则默认为 v(VERSION)，这是 git 项目的通用约定。另一方面，如果没有明确指定 VERSION，在某些常见情况下，CPM 可以根据 git 标签自动识别版本。GIT_TAG 也可以设置为特定的提交或分支名称（如 master），但不建议这样做，因为这样的软件包只有在缓存被清除时才会被更新</p><p>如果将附加的可选参数 EXCLUDE_FROM_ALL 设为真,则默认情况下不会编译依赖关系中定义的任何目标.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A git package from a given uri with a version</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version&quot;</span>)</span><br><span class="line"><span class="comment"># A git package from a given uri with a git tag or commit hash</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri#tag&quot;</span>)</span><br><span class="line"><span class="comment"># A git package with both version and tag provided</span></span><br><span class="line">CPMAddPackage(<span class="string">&quot;uri@version#tag&quot;</span>)</span><br></pre></td></tr></table></figure><p>与findpackage差别,在 CMake 项目中添加库的通常方法是调用 find_package(\<PackageName>)，并与 \<PackageName>_LIBRARIES 变量中定义的库进行链接。这种方法虽然简单，<strong>但可能会导致无法预测的编译，因为它需要在系统中安装库，而且不清楚添加的是哪个版本的库</strong>。此外，<strong>交叉编译项目（如mobile项目）也很困难</strong>，因为需要针对每个目标架构手动重建依赖关系。</p><p>CPM.cmake 允许明确定义依赖关系，并从源代码构建依赖关系。请注意，该行为不同于 find_package，因为使用 CPM.cmake 添加软件包后，导出到父作用域的变量（如 \<PackageName>_LIBRARIES ）将不可见。如果需要，可以手动实现该行为<a href="https://github.com/cpm-cmake/CPM.cmake/issues/132">find_package and CPMFindPackage have different behaviors · Issue #132 · cpm-cmake/CPM.cmake (github.com)</a>。</p><p>与fech_content差别,CPM.cmake 会检查任何添加的依赖项的版本号，如果另一个依赖项需要更新版,则会发出警告。<br>离线编译： CPM.cmake 将覆盖 CMake 的下载和更新命令，如果本地有所有依赖项，则可在离线状态下配置新的构建。<br>自动浅层克隆：如果提供了版本标签（如 v2.2.0）并使用了 CPM_SOURCE_CACHE，CPM.cmake 将执行依赖关系的浅层克隆，这应比完全克隆更快，同时使用的存储空间更少。可重写：通过设置 CMake 标志，所有 CPMAddPackage 都可配置为使用 find_package，从而轻松集成到可能需要通过系统的软件包管理器进行本地版本控制的项目中。软件包锁定文件可实现更简便的跨依赖关系管理。<br>每次编译时，可使用 CMake CLI 参数覆盖依赖关系。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(my-<span class="keyword">project</span>)</span><br><span class="line"><span class="keyword">include</span>(cmake/CPM.cmake)</span><br><span class="line">CPMAddPackage(<span class="string">&quot;gh:fmtlib/fmt#10.2.0&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(my-app main.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(my-app PRIVATE cxx_std_20)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-app fmt::fmt)</span><br></pre></td></tr></table></figure><p>上面的就使用<code>CPMAddPackage</code>添加了github上的fmtlib作者的fmt库,版本10.2.0</p><p>更多例子<a href="https://github.com/cpm-cmake/CPM.cmake/tree/master/examples">CPM.cmake/examples at master · cpm-cmake/CPM.cmake (github.com)</a></p><h2 id="CONAN"><a href="#CONAN" class="headerlink" title="CONAN"></a>CONAN</h2><p>这里做简单介绍,conan有仓库中心<a href="https://conan.io/center">Conan 2.0: C and C++ Open Source Package Manager</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conan</span><br></pre></td></tr></table></figure><p>在项目中创建<code>conanfile.txt</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[requires]</span><br><span class="line">zlib/1.2.11</span><br><span class="line"></span><br><span class="line">[generators]</span><br><span class="line">CMakeDeps</span><br><span class="line">CMakeToolchain</span><br></pre></td></tr></table></figure><p>generators表示将使用CMakeDeps来生成关于Zlib库文件安装位置的信息，CMakeToolchain通过CMake工具链文件传递构建信息给CMake</p><p>此外还要创建conan profile,里面提供本机系统信息,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan profile detect --force</span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912092357159.png" alt="image-20240912092357159"></p><p>生成的信息可以修改,比如改编译器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conan install . --output-folder=build --build=missing</span><br></pre></td></tr></table></figure><p>安装库,在build目录下会生成preset和conan_toolchain.cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(compressor C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(ZLIB REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ZLIB::ZLIB)</span><br></pre></td></tr></table></figure><p>再写个cmake文件,链接库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># assuming Visual Studio 15 2017 is your VS version and that it matches your default profile</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 15 2017&quot;</span> -DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;conan_toolchain.cmake&quot;</span></span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>利用toolchain文件导入包. </p><p>上面讲的都是包管理工具(实际上脱离不了相应的构建工具),最大的问题就是两者分开了,但事实上完全可以放在一起,就像rust的cargo,<code>cargo build</code>,<code>cargo add</code></p><h2 id="xmake"><a href="#xmake" class="headerlink" title="xmake"></a>xmake</h2><p>xmake包括了自带的构建工具和包管理,也有项目创建工具的功能.xmake使用lua配置. xmake create创建项目,可以选择语言和模板(竟然还包括zig)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912100635482.png" alt="image-20240912100635482"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create -P hello</span><br></pre></td></tr></table></figure><p>创建好后目录下有<code>xmake.lua</code>,使用xmake即可直接构建.<code>xmake run hello</code>运行程序,</p><p>在<code>xmake.lua</code>中常见配置就是创建可执行程序,库,添加头文件,设置语言标准等.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;library&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) # 设置生成的类型</span><br><span class="line">    add_files(<span class="string">&quot;src/library/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;library&quot;</span>) # 添加依赖</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外<code>add_headerfiles</code>添加头文件,<code>set_languages</code>设置语言版本.</p><p><code>xmake f -p</code>表示配置架构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake config -m debug xmake`</span><br><span class="line">xmake run -d hello</span><br></pre></td></tr></table></figure><p>可以进行debug</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p [macosx|linux|iphoneos ..] -a [x86_64|i386|arm64 ..] -m [debug|release]</span><br></pre></td></tr></table></figure><p>使用xmake配置项目,注意编译器设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++</span><br></pre></td></tr></table></figure><p>我在windows上使用clang++工具,配置llvm工具链即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p cross --toolchain=llvm --sdk=<span class="string">&quot;C:\Program Files\LLVM&quot;</span> </span><br><span class="line">xmake</span><br><span class="line">xmake run hello</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake -v <span class="comment"># 验证工具链配置</span></span><br></pre></td></tr></table></figure><p>或者使用mingw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p mingw</span><br></pre></td></tr></table></figure><p>xmake官方有<code>`xmake-repo</code>仓库用于下载包,</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;tbox 1.6.*&quot;</span>, <span class="string">&quot;libpng ~1.16&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;tbox&quot;</span>, <span class="string">&quot;libpng&quot;</span>, <span class="string">&quot;zlib&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面配置从官方仓库中添加了依赖,执行<code>xmake</code>进行构建,会拉取相关的源包，然后自动编译安装，最后编译项目，并链接依赖包,此外还可以设置第三方依赖,从vcpkg,conan等地方</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib&quot;</span>, <span class="string">&quot;vcpkg::pcre2&quot;</span>)</span><br></pre></td></tr></table></figure><p>此外还有独立的xrepo可用于下载包,可以指定平台,版本等,支持从vcpkg,conan中搜索下载.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xrepo install zlib tbox </span><br><span class="line">xrepo install <span class="string">&quot;zlib &gt;=1.2.0&quot;</span> </span><br><span class="line">xrepo install -p iphoneos -a arm64 zlib</span><br><span class="line">xrepo install vcpkg::zlib </span><br><span class="line">xrepo install conan::zlib/1.2.11 </span><br></pre></td></tr></table></figure><p>我写了下面<code>xmake.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">add_packages(<span class="string">&quot;fmt::fmt&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果说vcpkg重点是选好triplet、toolchainfile,那么xmake也是配好toolchain</p><p>我直接配置<code>xmake f -p windows</code>使用msvc能成功build,如果要使用clang,配置好平台和工具链即可,相比vcpkg要好一些,vcpkg官方对clang/llvm貌似没有那么上心,官方triplet都没有,只能用社区的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmake f -p windows  --toolchain=clang-cl </span><br><span class="line">xmake f -p windows  --toolchain=clang <span class="comment">#或者</span></span><br></pre></td></tr></table></figure><p><code>xmake show -l toolchains</code>查看所有的toolchains</p><p>或者在<code>xmake.lua</code>中使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_plat(<span class="built_in">os</span>.host())</span><br><span class="line">set_arch(<span class="built_in">os</span>.arch())</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>)</span><br><span class="line"># 或者直接统一设置</span><br><span class="line">set_toochains(<span class="string">&quot;clang&quot;</span>,&#123;palt=<span class="built_in">os</span>.host(),arch=<span class="built_in">os</span>.arch()&#125;)</span><br></pre></td></tr></table></figure><p>目前还存在头文件无法识别的问题</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912121858364.png" alt="image-20240912121858364" style="zoom:50%;" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>参考作者给出的解决<a href="https://github.com/xmake-io/xmake-vscode/issues/40">支持为vscode-cpptools提供intellisense配置信息 · Issue #40 · xmake-io/xmake-vscode (github.com)</a>生成<code>compile_commands.json</code>包含编译器,工作目录和头文件目录等信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmake project -k vsxmake -m <span class="string">&quot;debug,release&quot;</span> <span class="comment"># New vsproj generator (Recommended)</span></span><br><span class="line">xmake project -k vs -m <span class="string">&quot;debug,release&quot;</span></span><br><span class="line">xmake project -k cmake</span><br><span class="line">xmake project -k ninja</span><br><span class="line">xmake project -k compile_commands</span><br></pre></td></tr></table></figure><p>因为目前就langd和vscode的intellisense能检测文件中头文件目录信息等,需要这个文件</p><p>使用下来的体验就是写起来比cmake用的轻松,文档写的案例也比较全面.但是因为没有深度使用,一些细节不知道怎样.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为我已经在很多项目中使用了cmake,经验相对更多,xmake学习起来并不困难,搭配官方文档很容易搭建一个项目.</p><p>但目前还是推荐使用cmake+vcpkg/cpm.cmake方案,因为更成熟,解决方案更多.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要起因是我在逛Reddit帖子时,看到关于一些c++构建系统的评价. cmake似乎有些过于复杂,它与vcpkg,conan的包管理之间的”融合”可能在有些时候也显得麻烦. 一些人尝试了我没见过的选项,&lt;/p&gt;
&lt;p&gt;所以这里主要试试除了cmake之外的构建工具(这些选项中个人目前看好xmake),除了&lt;a href=&quot;https://xmake.io/#/getting_started&quot;&gt;xmake&lt;/a&gt;之外,还有&lt;a href=&quot;https://mesonbuild.com/&quot;&gt;The Meson Build system&lt;/a&gt;，&lt;a href=&quot;https://spack.io/about/&quot;&gt;About Spack - Spack&lt;/a&gt;，&lt;a href=&quot;https://bazel.google.cn/versions/7.3.0/about/intro?hl=zh-cn&quot;&gt;Bazel 简介 (google.cn)&lt;/a&gt;等等.我选择xmake主要原因是其自带的包管理和方便的写法&lt;br&gt;</summary>
    
    
    
    
    <category term="c++ build" scheme="https://www.sekyoro.top/tags/c-build/"/>
    
  </entry>
  
  <entry>
    <title>Dear-ImGUI:不太一样的GUI</title>
    <link href="https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/"/>
    <id>https://www.sekyoro.top/2024/09/11/Dear-ImGUI-%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E7%9A%84GUI/</id>
    <published>2024-09-11T07:00:54.000Z</published>
    <updated>2024-09-16T15:52:56.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.<br><span id="more"></span></p><p>这种立即模式可能受到一些游戏开发的喜爱,ImGui<a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a>直到最近还不停有commit,Unity也采用了类似模式构建控件<a href="https://docs.unity.cn/cn/2019.4/Manual/gui-Basics.html">IMGUI 基础知识 - Unity 手册</a>. 在Rust也有<a href="https://github.com/emilk/egui">emilk/egui: egui: an easy-to-use immediate mode GUI in Rust that runs on both web and native (github.com)</a>,Go也有<a href="https://gioui.org/">Gio UI</a>.</p><p>下面写个简单的ImGUI程序学习学习.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们把GUI分成了retained mode和immediate mode</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics06.png" alt="a diagram that shows retained-mode graphics."></p><p>保留模式(retained mode) API 是声明式的。应用程序通过图形基元（如形状和线条）构建场景。图形库将场景模型存储在内存中。要绘制帧，图形库会将场景转换为一组绘图命令。在帧与帧之间，图形库会将场景保存在内存中。要更改渲染的内容，应用程序会发出更新场景的命令，例如添加或删除一个形状。然后图形库负责重新绘制场景。</p><p><img data-src="https://learn.microsoft.com/en-us/windows/win32/learnwin32/images/graphics07.png" alt="a diagram that shows immediate-mode graphics."></p><p>即时模式 API (immediate mode)是程序性的。每次绘制新帧时，应用程序都会直接发出绘制命令。图形库不会在帧与帧之间存储场景模型。相反，应用程序会跟踪场景</p><p>保留模式 API 使用起来可能更简单，因为 API 会为您完成更多工作，如初始化、状态维护和清理。另一方面，它们通常灵活性较差，因为 API 强加了自己的场景模型。此外，保留模式 API 对内存的要求可能更高，因为它需要提供通用场景模型。使用即时模式 API，您可以实现有针对性的优化。</p><p>此外注意到还有DirectUI的说法,区分win32窗体<a href="https://www.zhihu.com/question/20580684"> DirectUI与GUI框架有什么区别，如MFC，QT，wxWidgets的区别是什么？ - 知乎 (zhihu.com)</a></p><blockquote><p>系统窗口的消息路由是操作系统负责的，比如按钮上的消息就会被自动分发给按钮的窗口过程。而DirectUI这类框架创建的窗口的消息是由应用程序负责的路由的，无论你点击了窗口中哪个按钮，消息统统分发给单一的窗口过程，它再根据鼠标的坐标判决应该由哪个对象进一步处理消息</p></blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>imgui背后需要调用图形backend和窗体调用. 它提供了几种不同的头文件,包括win32(窗体)+direcx11/12(图形api),glfw+opengl,sdl+opengl,glfw+vulkan等等.</p><p>这里我使用glfw+opengl.</p><p>你可以在在对应的官方仓库下载源码或者预编译包链接使用,但是为了更方便地使用,可以直接使用包管理器vcpkg等下载然后再cmake中加上两句即可. vcpkg具体使用可以参考<a href="https://www.sekyoro.top/2024/09/11/C-现代构建系统/#more">xmake:另一个C++现代构建系统 | Sekyoro的博客小屋</a>.</p><p>简单来说就是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir project &amp;&amp; <span class="built_in">cd</span> project</span><br><span class="line">vcpkg new --application</span><br><span class="line">vcpkg add port opengl</span><br><span class="line">cmake install <span class="comment"># 如果在cmakepresets中设置好了直接cmake --preset=&lt;preset_name&gt;即可</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>然后在<code>main.cpp</code>添加相应代码,执行程序</p><p><img data-src="https://s2.loli.net/2024/09/14/IdSPbTwpMn5U1XC.png" alt="image-20240914172255349"></p><blockquote><p>很多时候一些c++程序员喜欢把源码下载到本地然后进行编译,得到的库统一放在vendor/3rd_party目录,但是利用现代工具(vcpkg,conan等)可以方便地进行交叉编译(在宿主机上通过不同工具链得到其他架构的库/可执行程序),何乐而不为呢?</p></blockquote><p>其与Qt等<code>高等</code>框架相比,直接使用图形api和系统或在系统之上封装的窗口管理生成窗口、进行绘图.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">At</span> initialization:</span><br><span class="line">  <span class="keyword">call</span> ImGui::CreateContext()</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_Init() for <span class="number">each</span> backend.</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> the beginning of your frame:</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_NewFrame() for <span class="number">each</span> backend.</span><br><span class="line">  <span class="keyword">call</span> ImGui::NewFrame()</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> the end of your frame:</span><br><span class="line">  <span class="keyword">call</span> ImGui::Render()</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_RenderDrawData() for your Renderer backend.</span><br><span class="line"></span><br><span class="line"><span class="meta">At</span> shutdown:</span><br><span class="line">  <span class="keyword">call</span> ImGui_ImplXXXX_Shutdown() for <span class="number">each</span> backend.</span><br><span class="line">  <span class="keyword">call</span> ImGui::DestroyContext()</span><br></pre></td></tr></table></figure><p>基本逻辑如上,我们需要在<code>while</code>循环中针对每帧做动作,比如下面代码表示如果窗口最小化等待10ms再进行,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="comment">// Poll and handle events (inputs, window resize, etc.)</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetWindowAttrib</span>(window, GLFW_ICONIFIED) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ImGui_ImplGlfw_Sleep</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些简单代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> clicked = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 按钮</span></span><br><span class="line">       <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))</span><br><span class="line">           clicked++;</span><br><span class="line">       <span class="keyword">if</span> (clicked &amp; <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">           ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Thanks for clicking me!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 选择框</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">bool</span> check = <span class="literal">true</span>;</span><br><span class="line">       ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;checkbox&quot;</span>, &amp;check);</span><br><span class="line"><span class="comment">// 选择按钮</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio a&quot;</span>, &amp;e, <span class="number">0</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio b&quot;</span>, &amp;e, <span class="number">1</span>); ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">       ImGui::<span class="built_in">RadioButton</span>(<span class="string">&quot;radio c&quot;</span>, &amp;e, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">               ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">           ImGui::<span class="built_in">PushID</span>(i);</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.6f</span>, <span class="number">0.6f</span>));</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.7f</span>, <span class="number">0.7f</span>));</span><br><span class="line">           ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, (ImVec4)ImColor::<span class="built_in">HSV</span>(i / <span class="number">7.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>));</span><br><span class="line">           ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Click&quot;</span>);</span><br><span class="line">           ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);</span><br><span class="line">           ImGui::<span class="built_in">PopID</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Use AlignTextToFramePadding() to align text baseline to the baseline of framed widgets elements</span></span><br><span class="line">       <span class="comment">// (otherwise a Text+SameLine+Button sequence will have the text a little too high by default!)</span></span><br><span class="line">       <span class="comment">// See &#x27;Demo-&gt;Layout-&gt;Text Baseline Alignment&#x27; for details.</span></span><br><span class="line">       ImGui::<span class="built_in">AlignTextToFramePadding</span>();</span><br><span class="line">       ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hold to repeat:&quot;</span>);</span><br><span class="line">       ImGui::<span class="built_in">SameLine</span>();</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://github.com/ocornut/imgui">ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)</a></p></li><li><p><a href="https://blog.codingnow.com/2020/07/game_ui.html">云风的 BLOG: 游戏 UI 模块的选择 (codingnow.com)</a></p><p>如果你不想使用Qt庞然大物,也不想使用提供内置功能太少的界面库,可以试试SFML<a href="https://www.sfml-dev.org/">SFML (sfml-dev.org)</a>.</p></li><li><p><a href="https://tulach.cc/writing-gui-apps-for-windows-is-painful/">Writing GUI apps for Windows is painful - Samuel Tulach</a>一篇介绍windows上桌面程序开发框架选择的文章,提到了winui3,qt以及使用其他技术栈链接.dll库,比如wpf等.事实上我已经多次谈论界面开发/桌面开发/移动端开发,注意一个事实,一些库不只是用于界面绘制的,除去界面绘制,一些基本工具库的提供往往也非常有必要.所以在windows下使用微软带来的生态是很好的(wpf,maui,winui3等),在移动端下使用compose也很舒服.还有Flutter也吃Dart的生态. 此外也有很多使用web的技术,比如electron,tauri,<a href="https://pywebview.flowrl.com/">pywebview (flowrl.com)</a></p><p>很多时候没有必要考虑跨平台的需求(那就做web).</p><p>(delphi和lazarus有谁用过?)<a href="https://www.zhihu.com/question/54905309">用 Lazarus 做 GUI 程序合适吗？ - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html">ImGui Manual (pthom.github.io)</a>第三方文档</p></li><li><p>其他教程<a href="https://www.cnblogs.com/timefiles/p/17632348.html#打包程序">使用C++界面框架ImGUI开发一个简单程序 - 二次元攻城狮 - 博客园 (cnblogs.com)</a></p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前介绍过Qt,作为c++界面(事实上不只是界面,Qt本身已经成了写C++的一种工具了)工具,采用的是创建控件然后绑定事件处理的逻辑,与winform,WPF等都是类似的,但是这里介绍一种不太一样的GUI库,其使用immediate mode,也就是在每一帧进行处理,没有保留状态维护. 在游戏界面开发中受到热捧.&lt;br&gt;</summary>
    
    
    
    
    <category term="GUI" scheme="https://www.sekyoro.top/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>cs144:intro to computer network</title>
    <link href="https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/"/>
    <id>https://www.sekyoro.top/2024/09/01/cs144-intro-to-computer-network/</id>
    <published>2024-09-01T11:50:34.000Z</published>
    <updated>2024-09-12T12:47:21.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.<br><span id="more"></span></p><p>代码lian’jie<a href="https://github.com/drowning-in-codes/build-my-own-x/tree/main/cs144">build-my-own-x/cs144 at main · drowning-in-codes/build-my-own-x (github.com)</a></p><h2 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h2><p>第一个项目minnow,看看<code>CMakeLists.txt</code>,写得是真的好.</p><p>首先确保generator必须是Unix Makefiles,然后保证out of build(也就是src和build目录不同,使用cmake -B build)</p><p>然后添加其他辅助cmake脚本,这里通过<code>include</code>指令添加,应该是为了访问父作用域的变量. 然后添加头文件目录,最后使用<code>add_subdirectory</code>添加需要编译的子项目.每个目录下都是一个<code>CMakeLists.txt</code>,设置<code>CMAKE_EXPORT_COMPILE_COMMANDS</code>得到编译指令(也是为了搭配一些编辑器使用).光是CmakeLists.txt就学到很多c++项目组织的知识.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.24</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(minnow CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_GENERATOR&#125;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Unix Makefiles&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_MAKE_PROGRAM <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/scripts/make-parallel.sh&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Minnow must be built outside its source directory, e.g. `cmake -B build`.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(etc/build_type.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/cflags.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/scanners.cmake)</span><br><span class="line"><span class="keyword">include</span>(etc/tests.cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/util&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests&quot;</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/apps&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>在添加的cmake脚本中,包括设置构建类型的(Debug或Release),一些编译器设置,clang-tidy和format用于语法提示和格式化,以及一些测试.</p><p>在代码中,许多c++17和20新东西都用上了,比如string_view,span等,</p><p>第一次作业要求写一个bytestream的reader和writer,分别读取和写入字节流. 我看了一些网上的实现,太吓人了,还使用<code>`std::deque</code>等容器,根本没必要,还可能在提交测试时出现heap overflow. 直接使用string即可,熟悉一下一些STL常用操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="keyword">uint64_t</span> capacity) : <span class="built_in">capacity_</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::push</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  std::<span class="keyword">size_t</span> data_len = data.<span class="built_in">length</span>();</span><br><span class="line">  std::<span class="keyword">size_t</span> avai_cap = <span class="keyword">this</span>-&gt;<span class="built_in">available_capacity</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_len &gt;= avai_cap) &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + avai_cap);</span><br><span class="line">    push_counts += avai_cap;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">insert</span>(_buffer.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    push_counts += data_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  _is_closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> capacity_ - _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> push_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _is_closed &amp;&amp; _buffer.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> pop_counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  string_view sv&#123;&amp;*_buffer.<span class="built_in">begin</span>(), _buffer.<span class="built_in">size</span>()&#125;;</span><br><span class="line">  <span class="keyword">return</span> sv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader::pop</span><span class="params">(<span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">if</span> (_buffer.<span class="built_in">size</span>() &lt;= len) &#123;</span><br><span class="line">    pop_counts += _buffer.<span class="built_in">size</span>();</span><br><span class="line">    _buffer.<span class="built_in">clear</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _buffer.<span class="built_in">assign</span>(_buffer.<span class="built_in">begin</span>() + len, _buffer.<span class="built_in">end</span>());</span><br><span class="line">    pop_counts += len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">return</span> _buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/09/03/7M1R6WH3g8iKQdc.png" alt="image-20240903120538215"></p><blockquote><p>后面我看到有人使用queue\<string>,效果还不错.所以我又改了😅</p><p>逻辑是每次push数据,都是推一个新的string,如果没有超过容量直接推,如果超了就截断后再推.</p><p>pop数据时,如果queue中string数据长度大于len,就不需要将该数据pop掉,而是设置为removed_prefix,方便peek时返回. 如果小于等于,就将其推掉再看下一个string的长度.</p></blockquote><h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p>第一个实验就折磨了我很久,写一个对乱序(是指的发送的数据段的序列是乱的,数据段substring内部是顺序的)的字节流进行重排的reassembler.</p><p><img data-src="https://s2.loli.net/2024/09/06/gJCwbV4RtfLrW9j.png" alt="image-20240906172137248"></p><p>重点就是上面的图,绿色加红色的段落是固定长度并且只会往右移动到发送过来的数据最大长度.</p><p>如果来的数据段first_index为first_unasembled_index,那就说明来对了.但是在push到bytestream之前,需要注意可能有重叠部分,</p><p><img data-src="https://s2.loli.net/2024/09/06/cgsVmdDfLGSXWBj.png" alt="image-20240906172716413"></p><p>比如上面有重叠部分,需要截断数据,比较好的方法是将incoming data前面没有重叠的部分取出来作为新的数据,后面准备直接push到bytestream</p><p><img data-src="https://s2.loli.net/2024/09/06/RvQ3uFjrKMeIVwX.png" alt="image-20240906173236584"></p><p>有人就要问了,为啥不直接将这段数据直接都推进去,就像下图中红框这样,如果像上面那样截断,不就要后面多推一次吗？</p><p><img data-src="https://s2.loli.net/2024/09/06/84oJBaVHhO1PkDj.png" alt="image-20240906173340799"></p><p>理论上来说也是可行的,包括也可以像下面这样截断,但隐含的问题是,这两种方法后面的数据都有可能overlap.</p><p><img data-src="https://s2.loli.net/2024/09/06/wGFBxXy8jOcgWkr.png" alt="image-20240906173540255"></p><p>而像第一种截断方法中绿色那一段数据就不会有overlap.  而且后面的数据重复段可能不止一个,需要连续处理知道处理完后面的所有数据或者部分重叠.</p><p>如果是完全重叠,就可以直接删掉这段,比如下面的红色段数据.</p><p><img data-src="https://s2.loli.net/2024/09/06/UjCw2PEJ9mtbeAp.png" alt="image-20240906174432079"></p><p>除了对后面的数据做截断,针对排在前面的数据也是类似. 注意,在这里并没有对超过first_unaccepted_index的数据段进行截取.</p><p><img data-src="https://s2.loli.net/2024/09/06/letiLN4d5mMpsHS.png" alt="image-20240906173933135"></p><p>总的来说,首先需要对数据的first_index和大小进行调整,比如截断啥的. 使得它没有与其他数据段重叠.</p><p>然后就是判断更新后的first_index与first_unassemble_index,如果相等,push数据(由于在上一节push的实现中,如果数据长度大于capacity,就只会将数据填满,超过的数据忽略),否则放在一个map<uint64_t,string>中,称为substrings,注意这里有多种选择,你可以将其超过first_unassemble_index的段截断,也可以先直接推进去,后面再处理,但为了节省内存,可以直接先截断.</p><p>可能到这里有人以为已经结束了,但当推送了某个数据之后,可能后面的substrings就能使用上了,就需要进行处理.如果是next_assembled_idx(其实就是first_unassemble_idx==bytes_pushed),就继续推,因为前面存substrings中的数据时已经考虑到了截断超过first_unassemble_index的数据,数据长度加起来肯定小于容量,这里直接推进去就行了.</p><p><img data-src="https://s2.loli.net/2024/09/06/Czik8Pc4KM2rBHE.png" alt="image-20240906173613597" style="zoom:50%;" /></p><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><blockquote><p>TCP是一种协议，它在不可靠的数据报上可靠地传输一对流控制的字节流(每个方向一个)。双方或“peers”参与TCP连接，每个peers都充当(其自身输出字节流的)“发送者”和“接收者”</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/06/nzAsKGwy4xWNqH3.png" alt="image-20240906180021011"></p><p>首先需要实现一个32-bit的相对索引wrapper与64位绝对索引相互转换.</p><p><img data-src="https://s2.loli.net/2024/09/06/dD4tQgeqRLTm8vj.png" alt="image-20240906234140049"></p><p>而注意在接受的数据段(stream index),是直接从0开始,不包括SYN的.</p><p>从接收到的absolute seqno-&gt;seqno,也就是从64位转为32位,比较简单,可以采取取余或者直接<code>static_cat&lt;uint32_t&gt;</code>即可,相当于把多出的截断.从seqno-&gt;absolute seqno,有非常多可能,比如假设seqno-zero_point的值是144,那么就有可能是144+GAP*k,其中GAP是<code>1UL&lt;&lt;32</code>. 所以需要一个值帮助确定,checkpoint就是这个值,离它最近的就是这个absolute seqno. 需要做的就是求k. k是(checkpoint-absolute seqno)/(1UL&lt;&lt;32)的四舍五入值.  但是要注意,如果checpoint&lt;absolute seqno,上面的公式就会出问题.</p><p>当checpoint&lt;absolute seqno时,直接返回<code>seqno-zero_point</code>即可.</p><p>在此基础上需要实现TCP receiver.</p><p>它将(1)从peer的发送方接收消息并使用Reassembler重新组装字节流</p><p>(2)将包含确认号(ackno)和窗口大小的消息发送回peer的发送方.</p><p>注意SYN和FIN并不包含在数据payload中,但是在计算ackno时需要加上相应的值以确定需要的数据index. </p><p>接收到数据时,如果带有SYN则对应的seqno就是zero_point(并不是数据的开始,zero_point+1才是数据),我们本身需要的是发过来的数据在absolute seqno中的索引,但这个值我们无法确定,checkpoint可以设置为bytes_pushed也就是first_unassembled_index,因为这是我们需要的值.在获得absolute seqno后还需要-1除去SYN,然后再insert数据. 如果writer关闭则设置FIN关闭,方便后面send及时关闭.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPSenderMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Wrap32 seqno &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> SYN &#123;&#125;;</span><br><span class="line">std::string payload &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> FIN &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line"><span class="comment">// How many sequence numbers does this segment use?</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sequence_length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SYN + payload.<span class="built_in">size</span>() + FIN; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPReceiverMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">std::optional&lt;Wrap32&gt; ackno &#123;&#125;;</span><br><span class="line"><span class="keyword">uint16_t</span> window_size &#123;&#125;;</span><br><span class="line"><span class="keyword">bool</span> RST &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Construct with given Reassembler</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCPReceiver</span><span class="params">( Reassembler&amp;&amp; reassembler )</span> : reassembler_( std::move( reassembler ) ) &#123;</span>&#125;</span><br><span class="line"><span class="comment">// The TCPReceiver receives TCPSenderMessages from the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message )</span></span>;</span><br><span class="line"><span class="comment">// The TCPReceiver sends TCPReceiverMessages to the peer&#x27;s TCPSender.</span></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// Access the output (only Reader is accessible non-const)</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Reassembler&amp; <span class="title">reassembler</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_; &#125;</span><br><span class="line"><span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reassembler_.<span class="built_in">writer</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Reassembler reassembler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在send中,需要返回ackno和window_size,后者就是writer().available_capacity(),但注意如果初始化时超过了就设置MAX.</p><p>前者就是目前接收到的数据加上标志位.</p><p>发送数据时首先初始化SYN作为开始位置,开始位置之后的一个位置是数据位置.发送数据时携带这个标志和数据payload,同时每次只允许最多发送uint_32_t数据,所以发送数据时需要将原本64位的索引转成32位</p><blockquote><p>在TCP报头中，空间是宝贵的，流中的每个字节的索引不是用64位索引表示，而是用32位的“序列号”或“seqno”表示。这增加了复杂性</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/07/gE7IOc6ZdzyKbel.png" alt="image-20240907145920140"></p><p>当接收者拿到32位的相对索引时如何知道在绝对位置上的索引呢<img data-src="https://s2.loli.net/2024/09/07/HRkMqCVI5ApihuJ.png" alt="image-20240907151332005"></p><p>关键是确定checkpoint,因为absolute seqno可能是k*GAP+offset,offset是小于GAP的.</p><p>假设如下图,如果此时发送一个之前的重复段,实际的absolute seqno比较小,如果使用bytes_pushed,那么可能会导致得到的first_index比较大. 出现这种情况的前提是,bytes_pushed&gt;uint32_t,因为此时会有多个可能的绝对位置,如果再发送之前的数据,那么absolute seqno的first_index就会选择错误.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907152015454.png" alt="image-20240907152015454"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907155828700.png" alt="image-20240907155828700"></p><p>当我尝试这么测试时,要么报错oom要么timeout.</p><h2 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h2><p>实现TcpSender.在文档中需要要点都说了.但是有些细节还是容易忘.</p><p>首先在push方法中,什么时候发送数据?</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231650614.png" alt="image-20240908231650614"></p><p>只要有可读数据并且空余的window_size就能使用transmit读取数据.什么叫做空余的window_size,只要window_size大于0就能发送数据吗,事实上并不是,比如如果我连续发送了很多数据,但是window_size一直为0,我还需要不断发送直到读完所有数据吗,貌似也是可行的. 更好的方式是window_size如果小于outstanding_bytes的数量,那就先等着,直到接收到peer发来的ackno更新window_size.  每次发送的数据就是window_size-outstanding_bytes,但是有个MAX_PAYLOAD_SIZE的限制,另外注意发送的数据大小是包含SYN的,也就是说如果是开始的数据,window_size =100,那么只能发送99个数据.payload大小是99.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240907171424559.png" alt="image-20240907171424559"></p><p>如何确定sender需要发送FIN？</p><p>首先reader需要结束,也就是reader().is_finished() (注意不是bytes_bufferd==0,还需要reader关闭,因为还没有关闭时也有可能存在buffer为空的情况).此外剩余的数据已经小于window_size-outstanding_bytes(相当于peer还剩的空间).</p><p>然后发送数据,开启计时同时增加发送的index和outstanding_bytes,保存发送的信息. 当接收到ackno和window_size时进行更新窗口大小,并根据ackno删除数据,如果确实超过了保留数据的ackno+seq_len,那就更新ack_abs_seqno,此外重新设置timer,如果清空了outstanding_byte_stream,那就关闭定时器,否则还是打开但需要重置时间.tick方法计时器超时并且还有重传数据时,发送最早的重传数据,重置timer,如果window_size不为0,double重传时间,重传次数+1,背后的逻辑可能是,如果window_size为0,表示peer没有什么要接受的,没有那么急</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908234129034.png" alt="image-20240908234129034"></p><p>注意,当window_size为0时,说明peer没有需要的数据了,但如果依然能发送(&gt;outstanding_bytes),就需要多发送1byte数据来查看peer还能否扩展空间.如果没有数据了就不发了. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235508628.png" alt="image-20240908235508628"></p><p>想象一下,如果peer依然发送window_size=0,在tick中我们就会不断重试,直到超过次数然后退出.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908235847377.png" alt="image-20240908235847377" style="zoom:50%;" /></p><h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><p>使用之前的工具进行数据分析.无代码</p><h2 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h2><p>在有了TCP实现之后,还需要怎么封装才能传输信息?</p><ul><li>TCP-in-UDP-in-IP:TCP段可以在用户数据报的有效载荷中携带。在正常(用户空间)设置中工作时，这是最容易实现的:Linux提供了一个接口(“数据报套接字”，UDPSocket)，它允许应用程序只提供用户数据报的有效载荷和目标地址，内核负责构造UDP报头、IP报头和以太网报头，然后将数据包发送到适当的下一跳</li><li>内核确保每个套接字具有本地和远程地址和端口号的独占组合，并且由于内核负责将这些写入UDP和IP头，因此它可以保证不同应用程序之间的隔离</li><li>TCP-in-IP:在通常的用法中，TCP段几乎总是直接放在互联网数据报中，在IP和TCP头之间没有UDP头。这就是人们所说的“TCP/IP”.“这有点难以实施。Linux提供了一个称为TUN设备的接口，它允许应用程序提供一个完整的Internet数据报，内核负责其余的工作(写入以太网头，并实际通过物理以太网卡发送，等等)。但是应用程序必须自己构造完整的IP报头，而不仅仅是有效负载</li><li>TCP-in-IP-in-Ethernet: 在上述方法中仍然依赖Linux内核来实现部分网络堆栈。每次代码向TUN设备写入IP数据报时，Linux都必须用IP数据报作为有效负载构建一个适当的链路层(以太网)帧。这意味着Linux必须找出下一跳以太网目的地址，给定下一跳的IP地址。如果不知道,Linux广播一个查询:“谁声明了以下内容?IP地址?以太网地址是什么?，然后等待回复。这些功能由网络接口执行:一个将出站IP数据报转换为链路层(例如，以太网)帧的组件，反之亦然。(在实际系统中，网络接口通常有eth0、eth1、wlan0等名称)</li></ul><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240908231059785.png" alt="image-20240908231059785" style="zoom: 50%;" /></p><p>这一节说白了就是实现简单的ARP,保存IP地址与MAC(以太网)地址映射.</p><p>关键是两个方法,接受数据和发送数据.对于发送数据,如果在映射表中,那就直接发送,如果不在,那就需要发送arp消息,但前提是之前没有发送过或者发送后超过了一定时间,发送arp消息后timer置0.注意发送的arp请求消息中,目标以太网地址为0,广播地址在以太网地址字段中而不是arp中.arp消息是payload,以太网头是header.然后将要发送的消息和next_hop保存,等接受到相应的地址后再发送.对于接受消息,如果数据是ip数据报并且目标ip是自己,就接受消息并且更新映射表,如果是新的映射设置timer,否则不管.然后看新的映射是否跟保存的消息的目标ip相同,相同则发送.如果是arp消息,也更新映射与timer,如果是请求就发送自己的ip.否则根据更新的映射发送消息. 在tick中更新timer,并且如果超时就删除对应映射. 需要注意的是,什么时候需要开启timer,什么时候删除.</p><p>发送了arp消息时需要设置为0,接收到arp回应时删除对应arp请求的ip记录. 接收到新的映射时开启timer,超过30s后删除映射表和timer. </p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910202737584.png" alt="image-20240910202737584" style="zoom:67%;" /></p><h2 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h2><p>一个router有几个网络接口，可以在其中任何一个接口上接收Internet数据报.</p><p>router的工作是根据路由表转发它收到的数据报:路由表是一个规则列表，它告诉router，对于任何给定的数据报，</p><p>•发送哪个接口</p><p>•下一跳IP地址</p><p>实现一个路由器，它可以为给定的数据报得到这两个东西。</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240910204547680.png" alt="image-20240910204547680"></p><p>这里本身逻辑并不复杂,写一个路由表记录ip掩码和掩码后的地址,对应下一跳地址和interface. 首先遍历interface,拿到消息队列,对于每个消息ttl的ttl如果小于等于1,直接丢掉,否则拿去匹配路由表中,找到最长匹配的ip地址.</p><p>我一开始使用的路由表结构是map,但是发现一直过不了,改成multimap就过了,说明有重复的key,我的结构体如下,如果有重复key,表明掩码长度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;; #掩码后的地址</span><br><span class="line"><span class="keyword">uint8_t</span> prefix_length&#123;&#125;; # 前缀长度</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prefix_length &lt; ip_.prefix_length;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由两种解决方法,要么使用multimap允许重复key,要么将&lt;比较操作为修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> masked_ipaddr&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ip_addr&amp; ip_) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(prefix_length != ip_.prefix_length) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix_length&lt;ip_.prefix_length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> masked_ipaddr&lt;ip_.masked_ipaddr;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>c++20增加了<code>&lt;=&gt;</code>操作符和 std::strong_ordering,std::weak_ordering<br>,std::partial_ordering. 定义一个默认的<code>&lt;=&gt;</code>操作符基本就能允许所有比较,实在是太酷啦! 比较顺序与类中声明成员的顺序一致.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  std::string name&#123;&#125;;</span><br><span class="line">  <span class="keyword">double</span> value&#123;&#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Person &amp;) <span class="keyword">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p1&#123;.name = <span class="string">&quot;张三&quot;</span>, .value = <span class="number">12.</span>&#125;, p2&#123;.name = <span class="string">&quot;李四&quot;</span>, .value = <span class="number">13.</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;我们都一样&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h2><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912173600895.png" alt="image-20240912173600895"></p><p>lab7也是测试</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200347129.png" alt="image-20240912200347129"></p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240912200356663.png" alt="image-20240912200356663"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次计算机网络实验,从一开始的bytestream,到reassember,再到tcpsender,reader,最后写路由分配ip数据报. </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Kiprey/sponge/tree/master">Kiprey/sponge: CS144 Lab Assignments (github.com)</a></li><li><a href="https://github.com/Kenshin2438/CS144">Kenshin2438/CS144: CS 144: Introduction to Computer Networking, Winter 2024 (github.com)</a></li><li><a href="https://cs144.github.io/">CS 144: Introduction to Computer Networking</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始计划做点计算机课程lab,涉及到操作系统、并行分布式系统,计算机网络,数据库系统等等.&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>dive deeper into functional programming</title>
    <link href="https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/"/>
    <id>https://www.sekyoro.top/2024/08/17/dive-deeper-into-functional-programming/</id>
    <published>2024-08-17T06:49:47.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用<a href="https://ocaml.org/">ocaml.org</a>学习函数式编程.</p><span id="more"></span><p>相对来说,ocaml,elixir,scala以及clojure等在工业界用得比其他语言要多一点,主要原因个人认为还是对于大数据、多线程的处理以及语法上的可读性.  学习这些语言能帮助扩展思维以及在其他现代的编程语言中,你很可能会看见类似的设计和思想.</p><p>函数式语言的设计往往非常优雅严谨,以此达到编写正确优美的代码.下面以ocaml作介绍.</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>OCaml语法的主要部分是表达式。就像命令式语言中的程序主要由命令构建一样，函数式语言中的程序主要由表达式构建。表达式的例子包括2+2和increment 21</p><p>在函数式语言中，计算的主要任务是将表达式求值为一个值。值是一个表达式，它不需要执行任何计算。所以，<strong>所有的值都是表达式，但不是所有的表达式都是值</strong>。值的例子包括2、true和”yay!”</p><h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>表达式assert e求e的值。如果结果为真，则不再发生任何事情，整个表达式的求值为一个名为unit的特殊值。unit写作()，类型为unit。但如果结果为false，则会引发异常。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input1 = output1)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input2 = output2)</span><br><span class="line"><span class="keyword">let</span> <span class="literal">()</span> = <span class="keyword">assert</span> (f input3 = output3)</span><br></pre></td></tr></table></figure><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span> + <span class="number">5</span> &gt; <span class="number">2</span> <span class="keyword">then</span> <span class="string">&quot;yay!&quot;</span> <span class="keyword">else</span> <span class="string">&quot;boo!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span> <span class="keyword">in</span> x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意<code>let x = 42;;</code>是定义而不是表达式</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [fact n] is [n!].</span></span><br><span class="line"><span class="comment">    Requires: [n &gt;= 0]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> fact n = <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * fact (n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> inc x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> inc = <span class="keyword">fun</span> x -&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">square (inc <span class="number">5</span>);;</span><br><span class="line"><span class="number">5</span> |&gt; inc |&gt; square;;</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>这是在其他编程语言中非常常见的,包括map,filter,fold等等操作</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> add1 = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; (h + <span class="number">1</span>) :: add1 t</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst1 = add1 [<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> map f = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; f h :: map f t</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [add1 lst] adds 1 to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> add1 = map (<span class="keyword">fun</span> x -&gt; x + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(** [concat_bang lst] concatenates &quot;!&quot; to each element of [lst]. *)</span></span><br><span class="line"><span class="keyword">let</span> concat_bang = map (<span class="keyword">fun</span> x -&gt; x ^ <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p x = print_int x; print_newline<span class="literal">()</span>; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lst = map p [<span class="number">1</span>; <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> filter p = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">[]</span></span><br><span class="line">  | h :: t -&gt; <span class="keyword">if</span> p h <span class="keyword">then</span> h :: filter p t <span class="keyword">else</span> filter p t</span><br></pre></td></tr></table></figure><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> combine op init = <span class="keyword">function</span></span><br><span class="line">            | <span class="literal">[]</span> -&gt; init</span><br><span class="line">            | h::t -&gt; op h (combine op init t)</span><br><span class="line"><span class="keyword">let</span> sum = combine ( + ) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> concat = combine (^) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="primitive-types和values"><a href="#primitive-types和values" class="headerlink" title="primitive types和values"></a>primitive types和values</h2><p>基本类型是内置的和最基本的类型:整数、浮点数、字符、字符串和布尔值。它们将被识别为类似于其他编程语言中的基本类型.</p><p>除了上面之外,Ocaml还有许多东西,但我也就止于此了.目前我主要关注的还高阶函数</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://cs3110.github.io/textbook/chapters/intro/past.html">1.1. The Past of OCaml — OCaml Programming: Correct + Efficient + Beautiful (cs3110.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在许多编程语言中都能看到一些函数式编程,其最初起源于大学实验室、数学推理的思想,虽然在目前大型软件的源代码中相对OOP编程并没有那么多,但是在一些核心数据处理中利用函数式编程能一定程度上保证程序正确性.这里使用&lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org&lt;/a&gt;学习函数式编程.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CUDA101</title>
    <link href="https://www.sekyoro.top/2024/08/16/CUDA101/"/>
    <id>https://www.sekyoro.top/2024/08/16/CUDA101/</id>
    <published>2024-08-16T10:23:41.000Z</published>
    <updated>2024-08-29T12:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>作为既对AI又对sys、hpc感兴趣的人来说,cuda编程应该是不可不看的,我也早有耳闻.这里简单学习一下.<br><span id="more"></span></p><p>目前AI大模型的推理以及AI+HPC、深度学习系统构建等都需要了解cuda以及使用cuda编程,通过使用cuda、c++以及pybind写一些深度学习算子等提升运行速度都是一些常见应用途径.</p><h2 id="介绍CUDA"><a href="#介绍CUDA" class="headerlink" title="介绍CUDA"></a>介绍CUDA</h2><blockquote><p><a href="https://www.geeksforgeeks.org/how-to-run-cuda-c-c-on-jupyter-notebook-in-google-colaboratory/">CUDA</a> stands for Compute Unified Device Architecture. It is an extension of C/C++ programming. CUDA is a programming language that uses the Graphical Processing Unit (GPU). It is a parallel computing platform and an API (Application Programming Interface) model, Compute Unified Device Architecture was developed by Nvidia. This allows computations to be performed in parallel while providing well-formed speed. Using CUDA, one can harness the power of the Nvidia GPU to perform common computing tasks, such as processing matrices and other linear algebra operations, rather than simply performing graphical calculations.</p></blockquote><p><img data-src="https://media.geeksforgeeks.org/wp-content/uploads/20211007112954/UntitledDiagram1.jpg" alt="img" style="zoom:67%;" /></p><ul><li>上图展示了16个并行(流)多(streaming multiprocessor)处理块(digrams)</li><li>每个并行多处理块有8个并行处理器(streanming processors),所以一共128个并行处理器</li><li>每个并行处理器有一个乘加单元 (Multiplication and Addition Unit)和一个加单元(multiplication unit).</li><li>一张GT200显卡有30个并行多处理器,每个处理器有8个并行处理器,所以一共240个并行处理器,有多余1的TFLOP处理能力</li><li>每个流处理器都是线程，每个应用程序可以运行数千个线程</li><li>G80卡有16个流多处理器(SMs)，每个SM有8个流处理器(SPs)，即总共128个SPs，每个流多处理器支持768个线程(注意:不是每个SP)。</li><li>最终，每个流式多处理器有 8 个 SP 后，每个 SP 最多支持 <strong>768/8 = 96 个线程</strong>。可在 128 个 SP 上运行的线程总数 - 128* 96 = 12 228 次(=16*768)</li><li>因此，这些处理器被称为大规模并行处理器(massively parallel)。</li><li>G80 芯片的内存带宽为 86.4GB/s。</li><li>G80 芯片的内存带宽为 86.4GB/s，与 CPU 之间的通信通道为 8GB/s（4GB/s 上传到 CPU RAM，4GB/s 从 CPU RAM 下载）。</li></ul><h4 id="CUDA工作"><a href="#CUDA工作" class="headerlink" title="CUDA工作"></a>CUDA工作</h4><ul><li>GPU 一次运行一个内核（一组任务）。</li><li>每个内核由独立的 ALU 组块组成。</li><li>每个区块包含线程，线程是计算的层次。</li><li>每个块中的线程通常共同计算一个值。</li><li>同一区块中的线程可以共享内存。</li><li>在 CUDA 中，从 CPU 向 GPU 发送信息通常是计算中最典型的部分。</li><li>对每个线程而言，本地内存速度最快，共享内存次之，全局、静态和纹理内存速度最慢。</li></ul><h4 id="CUDA以及工作流程"><a href="#CUDA以及工作流程" class="headerlink" title="CUDA以及工作流程"></a>CUDA以及工作流程</h4><ul><li>将数据加载到 CPU 内存</li><li>将数据从 CPU 复制到 GPU 内存 - 例如，cudaMemcpy(…, cudaMemcpyHostToDevice)</li><li>使用设备变量调用 GPU 内核 - 例如，kernel&lt;&lt;&lt;&gt;&gt; (gpuVar)</li><li>将结果从 GPU 复制到 CPU 内存 - 例如，cudaMemcpy(…, cudaMemcpyDeviceToHost)</li><li>在 CPU 上使用结果</li></ul><h2 id="编写CUDA代码"><a href="#编写CUDA代码" class="headerlink" title="编写CUDA代码"></a>编写CUDA代码</h2><p>需要在Nvidia显卡下安装cudatoolkit,以使用nvcc编译器和一些库.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__global__ void cuda_hello()&#123;</span><br><span class="line">    printf(&quot;Hello World from GPU!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cuda_hello&lt;&lt;&lt;1,1&gt;&gt;&gt;(); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_<em>global_</em>说明符表示在设备(GPU)上运行的函数.这样的函数可以通过宿主代码调用,例如示例中的main()函数,也被称为“<em>kernel</em>”</p><p>当调用内核时，它的执行配置通过&lt;&lt;&lt;…&gt;&gt;&gt;语法，例如cuda_hello&lt;&lt;<1,1>&gt;&gt;()。在CUDA术语中，这被称为“<em>kernel launch</em>”</p><p>CPU和GPU是独立的实体。它们都有自己的内存空间。CPU不能直接访问GPU内存，反之亦然。在CUDA术语中，CPU内存称为主机内存，GPU内存称为设备内存。指向CPU和GPU内存的指针分别称为主机指针和设备指针.</p><p>对于GPU可以访问的数据，它必须呈现在设备内存中。CUDA提供了用于分配设备内存和主机与设备内存之间数据传输的api。</p><ol><li>分为宿主内存给宿主数据</li><li>分配设备内存</li><li>将输入数据从宿主内存转到设备内存</li><li>执行kernels(_<em>global\</em>_标识 )</li><li>将输出从设备转移到宿主</li></ol><p>CUDA提供了几个用于分配设备内存的函数。最常见的是<code>cudaMalloc()</code>和<code>cudaFree()</code></p><p>分配了GPU内存后需要将cpu内存上的数据copy到设备上,利用<code>cudaMemcpy</code></p><p>然后调用kernel(内核执行配置&lt;<1,1>&gt;&gt;表示内核启动时只有1个线程),在设备上执行,最后进行free<code>cudaFree(void *devPtr);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaMalloc(void **devPtr, size_t count);</span><br><span class="line">cudaFree(void *devPtr);</span><br><span class="line">cudaMemcpy(void *dst, void *src, size_t count, cudaMemcpyKind kind)</span><br></pre></td></tr></table></figure><h4 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h4><p>NVIDIA提供了一个名为nvprof的命令行分析器工具，它可以更深入地了解CUDA程序的性能。</p><p>CUDA使用内核执行配置&lt;&lt;&lt;…&gt;&gt;&gt;告诉CUDA<strong>运行时在GPU上启动多少线程</strong></p><p>CUDA将线程组织成一个称为“thread block”的组。内核可以启动多个线程块，组织成一个“grid”结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; <span class="string">M , T &gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>表示启动M个线程块,每个线程块包括T个线程.</p><h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>CUDA为访问线程信息提供了内置变量。其中的<code>threadIdx.x</code>和<code>blockDim.x</code>分别表示,一个块内线程的索引以及一个块中线程数量.</p><p>假设在一个块内的多个线程执行并行程序.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__global__ void vector_add(float *out, float *a, float *b, int n) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    int stride = 1</span><br><span class="line">    for(int i = index; i &lt; n; i += stride)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial02/01_parallel_thread.png" alt="parallel thread"></p><p>假设N个数据,一共256个线程,那么对于第k个线程,它会执行N/256次iteration,每次执行kernel中的代码</p><h4 id="thread-blocks"><a href="#thread-blocks" class="headerlink" title="thread blocks"></a>thread blocks</h4><p>CUDA gpu有几个并行处理器，称为流多处理器或SMs。每个SM由多个并行处理器组成，可以运行多个并发线程块。为了利用CUDA gpu，内核应该启动多个线程块。</p><p>对于block,有<code>blockIdx.x</code>以及<code>gridDim.x</code>分别表示块索引和块的数量.</p><p><img data-src="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial02/02_parallel_block.png" alt="parallel block"></p><p>要将线程分配给特定元素，我们需要知道每个线程的唯一索引。该指数可计算如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int tid <span class="operator">=</span> blockIdx.<span class="keyword">x</span> * blockDim.<span class="keyword">x</span> + threadaddx.<span class="keyword">x</span></span><br></pre></td></tr></table></figure><p>为了利用并行多线程的优势(否则就是多个线程计算相同的代码),需要将对应的数据索引修改为线程的索引.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 100000</span><br><span class="line">__global__ void addOfblocks(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">  int stride = blockDim.x * gridDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i += stride) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line">__global__ void addOfThreads(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = threadIdx.x;</span><br><span class="line">  int stride = blockDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i += blockDim) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  float *a, *out;</span><br><span class="line"></span><br><span class="line">  cudaMallocManaged(&amp;a, N * sizeof(float));</span><br><span class="line">  cudaMallocManaged(&amp;out, N * sizeof(float));</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = 2;</span><br><span class="line">    b[i] = 4;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add&lt;&lt;&lt;2, 4&gt;&gt;&gt;(N, a, b);</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">  cudaFree(a);</span><br><span class="line">  cudaFree(b);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 10000000</span><br><span class="line">__global__ void vector_add(float* out, float* a, float* b, int n) &#123;</span><br><span class="line">  int stride = 1;</span><br><span class="line">  for (int i = 0; i &lt; n; i += stride) &#123;</span><br><span class="line">    out[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__global__ void cuda_hello() &#123;</span><br><span class="line">  printf(&quot;Hello from block %d, thread %d\n&quot;, blockDim.x, threadIdx.x);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  cuda_hello&lt;&lt;&lt;1, 4&gt;&gt;&gt;();</span><br><span class="line">  float *a, *b, *out;</span><br><span class="line">  float *d_a, *d_b, *d_out;</span><br><span class="line">  a = (float*)malloc(N * sizeof(float));</span><br><span class="line">  b = (float*)malloc(N * sizeof(float));</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    b[i] = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  out = (float*)malloc(N * sizeof(float));</span><br><span class="line">  cudaMalloc((void**)&amp;d_b, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_b, b, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  cudaMalloc((void**)&amp;d_out, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_out, out, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  cudaMalloc((void**)&amp;d_a, sizeof(float) * N);</span><br><span class="line">  cudaMemcpy(d_a, a, sizeof(float) * N, cudaMemcpyHostToDevice);</span><br><span class="line">  vector_add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">  cudaMemcpy(out, d_out, sizeof(float) * N, cudaMemcpyDeviceToHost);</span><br><span class="line">  printf(&quot;out[0] = %f\n&quot;, out[0]);</span><br><span class="line">  cudaFree(d_a);</span><br><span class="line">  free(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// Kernel function to add the elements of two arrays</span><br><span class="line">__global__ void add(int n, float *x, float *y) &#123;</span><br><span class="line">  int idx = threadIdx.x;</span><br><span class="line">  int stride = blockDim.x;</span><br><span class="line">  for (int i = idx; i &lt; n; i+=stride) y[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  int N = 1 &lt;&lt; 20;</span><br><span class="line">  float *x, *y;</span><br><span class="line"></span><br><span class="line">  // Allocate Unified Memory – accessible from CPU or GPU</span><br><span class="line">  cudaMallocManaged(&amp;x, N * sizeof(float));</span><br><span class="line">  cudaMallocManaged(&amp;y, N * sizeof(float));</span><br><span class="line"></span><br><span class="line">  // initialize x and y arrays on the host</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    x[i] = 1.0f;</span><br><span class="line">    y[i] = 2.0f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Run kernel on 1M elements on the GPU</span><br><span class="line">  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(N, x, y);</span><br><span class="line"></span><br><span class="line">  // Wait for GPU to finish before accessing on host</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">  // Check for errors (all values should be 3.0f)</span><br><span class="line">  float maxError = 0.0f;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) maxError = fmax(maxError, fabs(y[i] - 3.0f));</span><br><span class="line">  std::cout &lt;&lt; &quot;Max error: &quot; &lt;&lt; maxError &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // Free memory</span><br><span class="line">  cudaFree(x);</span><br><span class="line">  cudaFree(y);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ol><li><a href="https://github.com/cuda-mode/lectures?tab=readme-ov-file">cuda-mode/lectures: Material for cuda-mode lectures (github.com)</a></li><li><a href="https://github.com/CodedK/CUDA-by-Example-source-code-for-the-book-s-examples-/tree/master">CodedK/CUDA-by-Example-source-code-for-the-book-s-examples-: CUDA by Example, written by two senior members of the CUDA software platform team, shows programmers how to employ this new technology. The authors introduce each area of CUDA development through working examples. (github.com)</a></li><li><a href="https://gist.github.com/diorahman/648478c2c5c24d819f0f">CUDA Books: Self taught (github.com)</a> maybe this is what all we need.</li><li><a href="https://developer.nvidia.com/blog/even-easier-introduction-cuda/">An Even Easier Introduction to CUDA | NVIDIA Technical Blog</a></li><li><a href="https://github.com/whutbd/cuda-learn-note?tab=readme-ov-file">whutbd/cuda-learn-note: 🎉CUDA 笔记 / 高频面试题汇总 / C++笔记，个人笔记，更新随缘: sgemm、sgemv、warp reduce、block reduce、dot product、elementwise、softmax、layernorm、rmsnorm、hist etc. (github.com)</a></li><li><a href="https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/">Tutorial 01: Say Hello to CUDA - CUDA Tutorial (cuda-tutorial.readthedocs.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为既对AI又对sys、hpc感兴趣的人来说,cuda编程应该是不可不看的,我也早有耳闻.这里简单学习一下.&lt;br&gt;</summary>
    
    
    
    
    <category term="cuda" scheme="https://www.sekyoro.top/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>typst学习与工具使用</title>
    <link href="https://www.sekyoro.top/2024/08/11/typst%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sekyoro.top/2024/08/11/typst%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-11T08:51:38.000Z</published>
    <updated>2024-08-29T12:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>目前使用Latex的的一些问题,也是很多新手常常遇到的</p><ul><li>一些命令不知道名字或者不知道是否有类似的命令,<strong>官方没有友好的reference</strong>.</li><li><strong>报错信息</strong>有些让人疑惑,一些标记语法写法让程序员很难受.</li><li><strong>Latex编译速度并不快</strong></li><li>本地编写Latex光装环境就难倒一批人.</li><li>一些库之间冲突太多,有些时候排版也不自然.</li></ul><p>于是我想尝试一些typst作为写一些小文章、简历甚至slides.</p><span id="more"></span><p>官方<a href="https://typst.app/">Typst: Compose papers faster</a>提供了在线的工具<a href="https://typst.app/">Typst: Compose papers faster</a>,目前社区也挺活跃的,当然写学术论文可能还是Latex占据绝大多数生态,不过在写个人文章或者简历方面Typst还是有优势的</p><p>下面以官方介绍和使用Latex的人的视角学学Typst.首先可以使用vscode安装相关插件或者官方在线工具方便协作(希望后期能超越Overleaf).</p><h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a>Scripting</h2><blockquote><p>像写代码一样写typst</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>在Typst中，标记和代码融合为一体。<strong>除了最常见的元素(加粗、斜体等表示)外，所有元素都是用函数创建的</strong>。为了尽可能方便，Typst提供了紧凑的语法来将代码表达式嵌入到标记中:用#符号引入表达式，在表达式完成后继续正常的标记解析。如果一个字符将继续表达式，但应被解释为文本，则表达式可以强制以分号(;)结束。</p><h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>有两种块,code blocks和content block,可以随意地嵌套</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#&#123;</span><br><span class="line">  let a = [from]</span><br><span class="line">  let b = [*world*]</span><br><span class="line">  [hello ]</span><br><span class="line">  a + [ the ] + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定和解构"><a href="#绑定和解构" class="headerlink" title="绑定和解构"></a>绑定和解构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#let name = &quot;Typst&quot;</span><br><span class="line">This is #name&#x27;s documentation.</span><br><span class="line">It explains #name.</span><br><span class="line"></span><br><span class="line">#let add(x, y) = x + y</span><br><span class="line">Sum is #add(2, 3).</span><br></pre></td></tr></table></figure><p>Let绑定也可以用来解构数组和字典。在这种情况下，赋值的左侧应该镜像一个数组或字典。. .操作符可以在模式中使用一次，以收集数组或字典项的剩余部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#let (x, y) = (1, 2)</span><br><span class="line">The coordinates are #x, #y.</span><br><span class="line"></span><br><span class="line">#let (a, .., b) = (1, 2, 3, 4)</span><br><span class="line">The first element is #a.</span><br><span class="line">The last element is #b.</span><br><span class="line"></span><br><span class="line">#let books = (</span><br><span class="line">  Shakespeare: &quot;Hamlet&quot;,</span><br><span class="line">  Homer: &quot;The Odyssey&quot;,</span><br><span class="line">  Austen: &quot;Persuasion&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#let (Austen,) = books</span><br><span class="line">Austen wrote #Austen.</span><br><span class="line"></span><br><span class="line">#let (Homer: h) = books</span><br><span class="line">Homer wrote #h.</span><br><span class="line"></span><br><span class="line">#let (Homer, ..other) = books</span><br><span class="line">#for (author, title) in other [</span><br><span class="line">  #author wrote #title.</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>if和loops</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#if 1 &lt; 2 [</span><br><span class="line">  This is shown</span><br><span class="line">] else [</span><br><span class="line">  This is not.</span><br><span class="line">]</span><br><span class="line">#for c in &quot;ABC&quot; [</span><br><span class="line">  #c is a letter.</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#let n = 2</span><br><span class="line">#while n &lt; 10 &#123;</span><br><span class="line">  n = (n * 2) - 1</span><br><span class="line">  (n,)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>众所周知,我们常用的一些操作包括针对字体,包括斜体、加粗、各种数学格式，针对图(Figure)、表(Table,常用三线表)、公式(包括内联的以及占据整行的)￥%……&amp;*（|</p><p><img data-src="https://s2.loli.net/2024/08/11/ygxDBYOMmH2pCv5.png" alt="image-20240811172259678"></p><p>此外针对论文,有引用,论文参考,作者介绍(在Latex中常用<code>\thanks</code>)等等.上面列举了一些常用 素.</p><p>Typst目前的command有markup模式(默认)和code模式,markup模式就像是输入正常的内容,在进阶一点就是通过一些简单的标记markup改变内容表现,code模式及看起来更强大,能调用许多命令.</p><p>通过#使用code模式,[]在code模式中将使用content.</p><div class="table-container"><table><thead><tr><th>New mode</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Code</td><td>Prefix the code with <code>#</code></td><td><code>Number: #(1 + 2)</code></td></tr><tr><td>Math</td><td>Surround equation with <script type="math/tex">..</script></td><td><script type="math/tex">-x$ is the opposite of $x</script></td></tr><tr><td>Markup</td><td>Surround markup with <code>[..]</code></td><td><code>let name = [*Typst!*]</code></td></tr></tbody></table></div><h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p>code模式就像函数一样,有参数,也需要content(相当于输入).</p><blockquote><p>一个函数可以有多个参数。有些参数是位置参数。</p><p>许多函数使用命名参数而不是位置参数来提高可读性。</p></blockquote><p><img data-src="https://s2.loli.net/2024/08/11/iRjep4UnkyCWsOb.png" alt="image-20240811183015272" style="zoom: 80%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typst is an #underline[alternative]</span><br><span class="line">to LaTeX.</span><br><span class="line"></span><br><span class="line">#rect(fill: aqua)[Get started here!]</span><br></pre></td></tr></table></figure><h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Data type</th><th style="text-align:left">Example</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/content/">Content</a></td><td style="text-align:left"><code>[*fast* typesetting]</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/str/">String</a></td><td style="text-align:left"><code>&quot;Pietro S. Author&quot;</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/int/">Integer</a></td><td style="text-align:left"><code>23</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/foundations/float/">Floating point number</a></td><td style="text-align:left"><code>1.459</code></td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/layout/length/">Absolute length</a></td><td style="text-align:left"><code>12pt</code>, <code>5in</code>, <code>0.3cm</code>, …</td></tr><tr><td style="text-align:left"><a href="https://typst.app/docs/reference/layout/ratio/">Relative length</a></td><td style="text-align:left"><code>65%</code></td></tr></tbody></table></div><blockquote><p>内容和字符串之间的区别在于，内容可以包含标记，包括函数调用，而字符串实际上只是一个普通的字符序列</p></blockquote><p>Typst提供控制流结构和操作符，例如用于添加内容的+或用于检查两个变量之间是否相等的==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if 1 &lt; 2 [</span><br><span class="line">  This is shown</span><br><span class="line">] else [</span><br><span class="line">  This is not.</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="show-rule"><a href="#show-rule" class="headerlink" title="show rule"></a>show rule</h2><p>使用show规则，您可以重新定义Typst如何显示某些元素。指定Typst应该以不同的方式显示哪些元素以及它们的外观。Show规则可以应用于文本实例、许多函数，甚至整个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#show &quot;ArtosFlow&quot;: name =&gt; box[</span><br><span class="line">  #box(image(</span><br><span class="line">    &quot;logo.svg&quot;,</span><br><span class="line">    height: 0.7em,</span><br><span class="line">  ))</span><br><span class="line">  #name</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/08/11/VjBAwbrCaTmlitu.png" alt="image-20240811220712931" style="zoom:50%;" /></p><p>上面第一个也可以省略内容参数,直接写函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#show</span>: <span class="selector-tag">project</span><span class="selector-class">.with</span>(</span><br><span class="line">  <span class="attribute">theme</span>: rgb(<span class="string">&quot;#0F83C0&quot;</span>),</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">&quot;proanimer&quot;</span>,</span><br><span class="line">  <span class="attribute">title</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="attribute">contact</span>:(</span><br><span class="line">    contact(</span><br><span class="line">      <span class="attribute">text</span>: <span class="string">&quot;personal blog&quot;</span>,</span><br><span class="line">      <span class="attribute">link</span>: <span class="string">&quot;https://sekyoro.top&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    contact(</span><br><span class="line">      <span class="attribute">text</span>: <span class="string">&quot;gmail&quot;</span>,</span><br><span class="line">      <span class="attribute">link</span>:<span class="string">&quot;mailto:bukalala174@gmail.com&quot;</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="set-rule"><a href="#set-rule" class="headerlink" title="set rule"></a>set rule</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#set heading(numbering: &quot;I.&quot;)</span><br><span class="line">#set text(</span><br><span class="line">  font: &quot;New Computer Modern&quot;</span><br><span class="line">)</span><br><span class="line">#set text(</span><br><span class="line">  font: &quot;New Computer Modern&quot;,</span><br><span class="line">  size: 10pt</span><br><span class="line">)</span><br><span class="line">#set page(</span><br><span class="line">  paper: &quot;a6&quot;,</span><br><span class="line">  margin: (x: 1.8cm, y: 1.5cm),</span><br><span class="line">)</span><br><span class="line">#set par(</span><br><span class="line">  justify: true,</span><br><span class="line">  leading: 0.52em,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>show和set是两种全局设置样式的表达式,差别是show 更细致,针对选择的元素</p><ul><li><a href="https://typst.app/docs/reference/text/text/"><code>text</code></a> to set font family, size, color, and other properties of text</li><li><a href="https://typst.app/docs/reference/layout/page/"><code>page</code></a> to set the page size, margins, headers, enable columns, and footers</li><li><a href="https://typst.app/docs/reference/model/par/"><code>par</code></a> to justify paragraphs, set line spacing, and more</li><li><a href="https://typst.app/docs/reference/model/heading/"><code>heading</code></a> to set the appearance of headings and enable numbering</li><li><a href="https://typst.app/docs/reference/model/document/"><code>document</code></a> to set the metadata contained in the PDF output, such as title and autho</li></ul><h3 id="Field获取"><a href="#Field获取" class="headerlink" title="Field获取"></a>Field获取</h3><p>可以使用点表示法访问值上的字段。值可以是:</p><ul><li>a <a href="https://typst.app/docs/reference/foundations/dictionary/">dictionary</a> that has the specified key,</li><li>a <a href="https://typst.app/docs/reference/symbols/symbol/">symbol</a> that has the specified modifier,</li><li>a <a href="https://typst.app/docs/reference/foundations/module/">module</a> containing the specified definition,</li><li><a href="https://typst.app/docs/reference/foundations/content/">content</a> consisting of an element that has the specified field. The available fields match the arguments of the <a href="https://typst.app/docs/reference/foundations/function/#element-functions">element function</a> that were given when the element was constructed.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#let dict = (greet: &quot;Hello&quot;)</span><br><span class="line">#dict.greet \</span><br><span class="line">#emoji.face</span><br><span class="line"></span><br><span class="line">#let it = [= Heading]</span><br><span class="line">#it.body \</span><br><span class="line">#it.depth</span><br></pre></td></tr></table></figure><h2 id="实战写一个简历"><a href="#实战写一个简历" class="headerlink" title="实战写一个简历"></a>实战写一个简历</h2><p>你并不需要看每一个方法的介绍,看多了也没用,先来看看其他人怎么写的.</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先需要一个基本模板,模板中包括<strong>设置一些基本值</strong>,以及<strong>一些辅助函数</strong>.</p><p>基本值包括字体、页面等配置.一般使用<code>#set</code>和<code>#show</code>设置. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#set par(justify: true)</span><br><span class="line">#set text(</span><br><span class="line">font: &quot;Linux Libertine&quot;,</span><br><span class="line">size: 11pt,</span><br><span class="line">) </span><br><span class="line">#set page(</span><br><span class="line">paper: &quot;us-letter&quot;,</span><br><span class="line">header: align(</span><br><span class="line">  right + horizon,</span><br><span class="line">  title</span><br><span class="line">),</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line">//设置页面,段落与字体</span><br></pre></td></tr></table></figure><p>考虑通过一个show rule和函数包装起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#let conf(title,doc) = &#123;</span><br><span class="line">  set par(justify: true,)</span><br><span class="line">  set text(font:&quot;0xProto Nerd Font Propo&quot;,size:11pt)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  &quot;Paper title&quot;,</span><br><span class="line">  doc</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用命名参数,这样需要在写函数时设置默认值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#let conf(</span><br><span class="line">  title: none,</span><br><span class="line">  authors: (),</span><br><span class="line">  abstract: [],</span><br><span class="line">  doc,</span><br><span class="line">) = &#123;</span><br><span class="line">  // Set and show rules from before.</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  set align(center)</span><br><span class="line">  text(17pt, title)</span><br><span class="line"></span><br><span class="line">  let count = authors.len()</span><br><span class="line">  let ncols = calc.min(count, 3)</span><br><span class="line">  grid(</span><br><span class="line">    columns: (1fr,) * ncols,</span><br><span class="line">    row-gutter: 24pt,</span><br><span class="line">    ..authors.map(author =&gt; [</span><br><span class="line">      #author.name \</span><br><span class="line">      #author.affiliation \</span><br><span class="line">      #link(&quot;mailto:&quot; + author.email)</span><br><span class="line">    ]),</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  par(justify: false)[</span><br><span class="line">    *Abstract* \</span><br><span class="line">    #abstract</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  set align(left)</span><br><span class="line">  columns(2, doc)</span><br><span class="line">&#125;</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  title: [Towards Improved Modelling],</span><br><span class="line">  authors: (</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Theresa Tungsten&quot;,</span><br><span class="line">      affiliation: &quot;Artos Institute&quot;,</span><br><span class="line">      email: &quot;tung@artos.edu&quot;,</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Eugene Deklan&quot;,</span><br><span class="line">      affiliation: &quot;Honduras State&quot;,</span><br><span class="line">      email: &quot;e.deklan@hstate.hn&quot;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  abstract: lorem(80),</span><br><span class="line">  doc,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在单独的文件中写模板,使用<code>import</code>导入并使用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;conf.typ&quot;: conf</span><br><span class="line">#show: doc =&gt; conf(</span><br><span class="line">  title: [</span><br><span class="line">    Towards Improved Modelling</span><br><span class="line">  ],</span><br><span class="line">  authors: (</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Theresa Tungsten&quot;,</span><br><span class="line">      affiliation: &quot;Artos Institute&quot;,</span><br><span class="line">      email: &quot;tung@artos.edu&quot;,</span><br><span class="line">    ),</span><br><span class="line">    (</span><br><span class="line">      name: &quot;Eugene Deklan&quot;,</span><br><span class="line">      affiliation: &quot;Honduras State&quot;,</span><br><span class="line">      email: &quot;e.deklan@hstate.hn&quot;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  abstract: lorem(80),</span><br><span class="line">  doc,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">= Introduction</span><br><span class="line">#lorem(90)</span><br><span class="line"></span><br><span class="line">== Motivation</span><br><span class="line">#lorem(140)</span><br><span class="line"></span><br><span class="line">== Problem Statement</span><br><span class="line">#lorem(50)</span><br><span class="line"></span><br><span class="line">= Related Work</span><br><span class="line">#lorem(200)</span><br></pre></td></tr></table></figure><p>也可以使用<code>#import &quot;temp.typ&quot;: *</code>导入去掉命名空间. </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Call a function.</span><br><span class="line">#list([A], [B])</span><br><span class="line"></span><br><span class="line">// Named arguments and trailing</span><br><span class="line">// content blocks.</span><br><span class="line">#enum(start: 2)[A][B]</span><br><span class="line"></span><br><span class="line">// Version without parentheses.</span><br><span class="line">#list[A][B]</span><br></pre></td></tr></table></figure><p>函数是Typst的基本构建块。Typst提供了各种排版任务的函数。此外，您编写的标记是由函数支持的，所有的样式都是通过函数实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#let alert(body, fill: red) = &#123;</span><br><span class="line">  set text(white)</span><br><span class="line">  set align(center)</span><br><span class="line">  rect(</span><br><span class="line">    fill: fill,</span><br><span class="line">    inset: 8pt,</span><br><span class="line">    radius: 4pt,</span><br><span class="line">    [*Warning:\ #body*],</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#alert[</span><br><span class="line">  Danger is imminent!</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#alert(fill: blue)[</span><br><span class="line">  KEEP OFF TRACKS</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>函数有<code>with</code>和<code>where</code>,<code>with</code>返回一个预先应用了给定参数的新函数</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个选择器，该选择器筛选属于此函数的元素，其字段具有给定参数的值</span></span><br><span class="line">#show heading.where(level: 2): set text(blue)</span><br><span class="line"><span class="section">= Section</span></span><br><span class="line"><span class="section">== Subsection</span></span><br><span class="line"><span class="section">=== Sub-subection</span></span><br></pre></td></tr></table></figure><h3 id="看看别人的"><a href="#看看别人的" class="headerlink" title="看看别人的"></a>看看别人的</h3><p>我在Github上搜刮了一堆别人的模板,写的很不错. 主要使用的方法就是上面提到的函数、set rule,show rule以及map,join等方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#let contact(text:&quot;&quot;,link:none) = &#123;</span><br><span class="line">  (text:text,link:link)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let subSection(title:&quot;&quot;,titleEnd:none,subTitle:none,subTitleEnd:none,content:[]) = &#123;</span><br><span class="line">  (title:title,titleEnd:titleEnd,subTitle:subTitle,subTitleEnd:subTitleEnd,content:content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let section(title:&quot;&quot;,content:subSection()) = &#123;</span><br><span class="line">  (title:title,content:content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#let project(</span><br><span class="line">  theme:rgb(&quot;#4273B0&quot;),</span><br><span class="line">  name:&quot;&quot;,</span><br><span class="line">  email:none,</span><br><span class="line">  title:none,</span><br><span class="line">  contact:((text:[],link:&quot;&quot;)),</span><br><span class="line">  skills:(</span><br><span class="line">    languages:()</span><br><span class="line">  ),</span><br><span class="line">  main:(</span><br><span class="line">   ( title:&quot;&quot;,content:[])</span><br><span class="line">  ),</span><br><span class="line">  sidebar:(),</span><br><span class="line">  body</span><br><span class="line">) = &#123;</span><br><span class="line">  let backgroundTitle(content) = &#123;</span><br><span class="line">    align(center,box(fill:theme,text(white,size:1.25em,weight:&quot;bold&quot;,upper(content)),width:1fr,inset:0.3em))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let secondaryTitle(content) = &#123;</span><br><span class="line">    text(weight:&quot;bold&quot;,size:1.125em,upper(content))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let italicColorTitle(content) = &#123;</span><br><span class="line">    text(weight:&quot;bold&quot;,style:&quot;italic&quot;,size:1.125em,theme,content)</span><br><span class="line">  &#125;</span><br><span class="line">  let contactColumn = align(center)[#contact.map(c =&gt; &#123;</span><br><span class="line">    if c.link == none [</span><br><span class="line">      #c.text\</span><br><span class="line">    ] else [</span><br><span class="line">      #underline(link(c.link,text(theme,c.text)))\</span><br><span class="line">    ]</span><br><span class="line">  &#125;).join()]</span><br><span class="line"></span><br><span class="line">  grid(</span><br><span class="line">    columns:(1fr,2fr),</span><br><span class="line">    column-gutter:2em,</span><br><span class="line">    contactColumn,</span><br><span class="line">    titleColumn</span><br><span class="line">  )</span><br><span class="line">  set par(justify: true)</span><br><span class="line">  let formattedLanguageSkills = [</span><br><span class="line">    #text(skills.languages.join(&quot; • &quot;))</span><br><span class="line">  ]</span><br><span class="line">  let createLeftRight(left:[],right:none)=&#123;</span><br><span class="line">    if(right == none) &#123;</span><br><span class="line">      align(start,text(left))</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      grid(</span><br><span class="line">        columns:(1fr,1fr),</span><br><span class="line">        align(start,text(left)),</span><br><span class="line">        align(end,right) </span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let parseSubSections(subSections) = &#123;</span><br><span class="line">    subSections.map(s=&gt;&#123;</span><br><span class="line">      [</span><br><span class="line">        #createLeftRight(</span><br><span class="line">          left:secondaryTitle(s.title),</span><br><span class="line">          right:if s.titleEnd != none [</span><br><span class="line">            #italicColorTitle(s.titleEnd)</span><br><span class="line">          ]</span><br><span class="line">        )</span><br><span class="line">        #if s.subTitle != none or s.subTitleEnd != none [</span><br><span class="line">          #text(top-edge: 0.2em,</span><br><span class="line">          createLeftRight(left: italicColorTitle(s.subTile),right:s.subTitleEnd)</span><br><span class="line">          )</span><br><span class="line">        ]</span><br><span class="line">        #s.content</span><br><span class="line">      ]</span><br><span class="line">    &#125;).join()</span><br><span class="line">  &#125;</span><br><span class="line">  let parseSection(seciton) = &#123;</span><br><span class="line">    section.map(m=&gt;&#123;</span><br><span class="line">      [</span><br><span class="line">        #backgroundTitle(m.title),</span><br><span class="line">        #parseSubSections(m.content)</span><br><span class="line">      ]</span><br><span class="line">    &#125;).join()</span><br><span class="line">  &#125;</span><br><span class="line">  let mainSection = parseSection(main)</span><br><span class="line">  let sidebarSection = parseSection(sidebar)</span><br><span class="line">  grid(</span><br><span class="line">    columns: (1fr,2fr),</span><br><span class="line">  column-gutter: 1em,</span><br><span class="line">  sidebarSection,</span><br><span class="line">  mainSection</span><br><span class="line">  )</span><br><span class="line">// Main body.</span><br><span class="line">  set par(justify:true)</span><br><span class="line">  show: columns.with(3,gutter:1.3em)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;template.typ&quot;: *</span><br><span class="line"></span><br><span class="line">#set page(</span><br><span class="line">  margin:(</span><br><span class="line">    left: 10mm,</span><br><span class="line">    right: 10mm,</span><br><span class="line">    top: 15mm,</span><br><span class="line">    bottom: 15mm</span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">#set text(font: &quot;Mulish&quot;)</span><br><span class="line"></span><br><span class="line">#show: project.with(</span><br><span class="line">  theme: rgb(&quot;#0F83C0&quot;),</span><br><span class="line">  name: &quot;proanimer&quot;,</span><br><span class="line">  title: &quot;Software Engineer&quot;,</span><br><span class="line">  contact:(</span><br><span class="line">    contact(</span><br><span class="line">      text: &quot;personal blog&quot;,</span><br><span class="line">      link: &quot;https://sekyoro.top&quot;</span><br><span class="line">    ),</span><br><span class="line">    contact(</span><br><span class="line">      text: &quot;gmail&quot;,</span><br><span class="line">      link:&quot;mailto:bukalala174@gmail.com&quot;</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  main:(</span><br><span class="line">    section(</span><br><span class="line">      title:&quot;Work Experience&quot;,</span><br><span class="line">      content:(</span><br><span class="line">        subSection(</span><br><span class="line">          title: &quot;Freelancer&quot;,</span><br><span class="line">          subTitle: &quot;Software Engineer&quot;,</span><br><span class="line">          content:list(</span><br><span class="line">            [&quot;Developed a personal blog using Gatsby and React, with a focus on performance and accessibility.&quot;],</span><br><span class="line">            [&quot;Implemented a custom CMS using React and Firebase, allowing for easy content management.&quot;],</span><br><span class="line">            [&quot;Optimized the blog for SEO, resulting in a 50% increase in organic traffic.&quot;],</span><br><span class="line">            [&quot;Designed and implemented a custom theme, resulting in a 30% increase in user engagement.&quot;]</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  sidebar:(</span><br><span class="line">    section(</span><br><span class="line">      title: &quot;Skills&quot;,</span><br><span class="line">      content:(</span><br><span class="line">        subSection(</span><br><span class="line">          title: &quot;Languages&quot;,</span><br><span class="line">          content: list(</span><br><span class="line">            [&quot;JavaScript&quot;, &quot;TypeScript&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      section(</span><br><span class="line">        title:&quot;Education&quot;,</span><br><span class="line">        content:(</span><br><span class="line">          subSection(</span><br><span class="line">            title: &quot;University of British Columbia&quot;,</span><br><span class="line">            titleEnd: &quot;Vancouver, BC&quot;,</span><br><span class="line">            subTitle: &quot;Bachelor of Computer Science&quot;,</span><br><span class="line">            subTitleEnd: &quot;(2018 - 2022)&quot;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>肯定没有必要使用typst写简历的,主要还是想替代Latex写点小论文或者文章,可以拿简历练练手.</p><p>如果真需要简历可以在网上填写信息直接生成.</p><h2 id="如何写一个幻灯片"><a href="#如何写一个幻灯片" class="headerlink" title="如何写一个幻灯片"></a>如何写一个幻灯片</h2><blockquote><p>用手拖来拖去制作幻灯片实在太麻烦了,我们喜欢简洁、可控与重用.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 为了跨项目重用构建块,可以创建和导入Typst包.包导入被指定为名称空间、名称和版本的三元组</span><br><span class="line">#import &quot;@preview/example:0.1.0&quot;: add</span><br><span class="line">#add(2, 7)</span><br></pre></td></tr></table></figure><p>使用编程的方式写ppt主要目的是为了方便写公式,图片摆放以及更加简洁.这里使用touying包制作,目前typst都是生成pdf格式的,也完全可以使用相关软件播放.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;@preview/touying:0.4.2&quot;: *</span><br><span class="line"></span><br><span class="line">#let s = themes.simple.register()</span><br><span class="line">#let (init, slides) = utils.methods(s)</span><br><span class="line">#show: init</span><br><span class="line"></span><br><span class="line">#let (slide, empty-slide) = utils.slides(s)</span><br><span class="line">#show: slides</span><br><span class="line"></span><br><span class="line">= Title</span><br><span class="line"></span><br><span class="line">This is written in Typst.</span><br><span class="line"></span><br><span class="line">== First Slide</span><br><span class="line"></span><br><span class="line">Hello, Touying!</span><br><span class="line">This is written in Typst.</span><br><span class="line">Attention = $frac(Q*K^(T),sqrt(d))*V$</span><br><span class="line"></span><br><span class="line">#pause</span><br><span class="line"></span><br><span class="line">Hello, Typst!</span><br></pre></td></tr></table></figure><p>最后说一下,利用<a href="https://github.com/jgm/pandoc">jgm/pandoc: Universal markup converter (github.com)</a>完全可以实现latex与typst互换.</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>目前使用感觉还是很不错,优点包括两个</p><ul><li>使用命令语法对程序员友好,官方文档全面</li><li>编译速度快,本地写也很方便</li></ul><p>如果要说缺点就是 生态相对Latex没那么好,如果想要实现一些效果网上可能没有现成方法,有些东西目前也没有支持<a href="https://typst.app/docs/roadmap/">Roadmap – Typst Documentation</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://typst.app/docs">Typst Documentation</a></li><li><a href="https://typst.app/universe/package/touying/">touying – Typst Universe</a> typst写幻灯片, 此外Latex也有beamer<a href="https://latex-beamer.com/quick-start/">LaTeX Beamer introduction / Quick-start guide - LaTeX Beamer (latex-beamer.com)</a>库类似的功能</li><li><a href="https://github.com/jgm/pandoc">jgm/pandoc: Universal markup converter (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前使用Latex的的一些问题,也是很多新手常常遇到的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些命令不知道名字或者不知道是否有类似的命令,&lt;strong&gt;官方没有友好的reference&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报错信息&lt;/strong&gt;有些让人疑惑,一些标记语法写法让程序员很难受.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Latex编译速度并不快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本地编写Latex光装环境就难倒一批人.&lt;/li&gt;
&lt;li&gt;一些库之间冲突太多,有些时候排版也不自然.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是我想尝试一些typst作为写一些小文章、简历甚至slides.&lt;/p&gt;</summary>
    
    
    
    
    <category term="写作" scheme="https://www.sekyoro.top/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>profile a deep learning model</title>
    <link href="https://www.sekyoro.top/2024/07/30/profile-a-deep-learning-model/"/>
    <id>https://www.sekyoro.top/2024/07/30/profile-a-deep-learning-model/</id>
    <published>2024-07-30T07:34:36.000Z</published>
    <updated>2024-07-31T03:54:33.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是大型软件、算法开发中容易被忽视同时也并不简单的一环,如何分析一个程序.这涉及到分析内存、使用一系列现有工具并进行可能冗长的测试. 但不管怎样,这是走向成熟应用关键的一步,</p><span id="more"></span><h3 id="如何进行性能分析"><a href="#如何进行性能分析" class="headerlink" title="如何进行性能分析"></a>如何进行性能分析</h3><blockquote><p>过早的性能分析是万恶之源</p></blockquote><p>你可以先完成程序的基本功能再进行优化,分析的方式和工具很多.最基础的包括计时.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure><p>考虑到一个程序执行时间包含太多部分,比如如果你的电脑同时跑着太多程序并且内存不太够,造成的中断等也会影响时间.</p><p>对于工具来说,需要区分真实时间、用户时间和系统时间.通常来说,用户时间+系统时间代表了进程所消耗的实际 CPU .</p><ul><li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）；</li><li><em>User</em> - CPU 执行用户代码所花费的时间；</li><li><em>Sys</em> - CPU 执行系统内核代码所花费的时间</li></ul><p>对于cpu,内存,事件分析以及可视化等,都有一系列工具处理,具体可看<a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h3 id="深度学习模型的性能分析"><a href="#深度学习模型的性能分析" class="headerlink" title="深度学习模型的性能分析"></a>深度学习模型的性能分析</h3><p>如何评估一个模型在实际部署或者推理时的效果,计算量和参数都是重要因素,一个限制GPU/CPU,一个限制内存.<br>此外对于图像或视频,fps也是重要因素,对于大模型而言就是输出token的速度,说白了就是输出时间,影响了实时性和用户使用体验,个人认为这个因素也跟计算量和参数相关.<br>那么如何计算模型计算量和参数量呢?<br>根据字面意思,参数量好理解,无非几种网络结构,每种网络结构都或多或少有参数,每个参数当作f32或者其他类型计算即可. 当然实际推理或者部署完全可以使用量化的方法得到整数,甚至是i8类型.这样就把参数量降低了,此外浮点数变成了整数,事实上计算也降低了复杂度,因为浮点数计算在CPU/GPU上往往更复杂.</p><p>这样一想,计算参数量就比较简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_param</span>(<span class="params">model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Calculate the number of parameters in the model.</span></span><br><span class="line"><span class="string">    :param model: model</span></span><br><span class="line"><span class="string">    :return: number of parameters</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    param_num =  <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">    <span class="built_in">print</span>(param_num*<span class="number">4</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">&#x27;MB&#x27;</span>) <span class="comment"># assume dtype float32</span></span><br></pre></td></tr></table></figure><p>那如何计算计算量呢,由于浮点数和整数运算上在CPU计算的不同,我们只考虑更为复杂的浮点数计算,就有了FLOPs. FLOPS计算如下,卷积层和全连接计算不同</p><p><img data-src="https://s2.loli.net/2024/07/30/QchEs9vxK1unXjH.png" alt="image-20240730111224462"></p><p>还有些地方使用的是MACs和MAdds,</p><p>MAC：Multiply Accumulate，乘加运算。乘积累加运算（英语：Multiply Accumulate, MAC）是在数字信号处理器或一些微处理器中的特殊运算。实现此运算操作的硬件电路单元，被称为“乘数累加器”。这种运算的操作，是将乘法的乘积结果和累加器的值相加，再存入累加器：</p><script type="math/tex; mode=display">a ← a + b × c</script><p>使用MAC可以将原本需要的两个指令操作减少到一个指令操作，从而提高运算效率。</p><blockquote><p>MAdds 本质上与 MACs 相同，都是指一次乘法和一次加法的组合。术语 MAdds 更常见于一些文献中，尤其是早期的文献。实际上，在大多数情况下，MACs 和 MAdds 可以互换使用.</p><p>1个 MACs 包含一个乘法操作与一个加法操作，大约包含2个 FLOPs。因此，通常 MACs 与 FLOPs 存在一个2倍的关系。(但是很多时候又会把它们会混淆合在一起)</p></blockquote><p>抽象地高度来说</p><blockquote><ul><li>计算量是指网络模型需要计算的<strong>运算次数</strong>，参数量是指网络模型自带的<strong>参数数量</strong>多少</li><li>计算量对应<strong>时间复杂度</strong>，参数量对应于<strong>空间复杂度</strong></li><li>计算量决定了<strong>网络执行时间的长短</strong>，参数量决定了占用显存的量</li></ul></blockquote><p><a href="https://blog.csdn.net/qq_33952811/article/details/124276599">5种方法获取Torch网络模型参数量计算量等信息_查看模型参数量-CSDN博客</a></p><h3 id="fvcore"><a href="#fvcore" class="headerlink" title="fvcore"></a>fvcore</h3><p>Meta的开源工具,包含pytorch layers,计算flop,计算参数,</p><p><strong>FlopCountAnalysis</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from fvcore<span class="selector-class">.nn</span> import FlopCountAnalysis</span><br><span class="line">flops = FlopCountAnalysis(model, input)</span><br><span class="line">flops<span class="selector-class">.total</span>()</span><br><span class="line">flops<span class="selector-class">.by_operator</span>()</span><br><span class="line"><span class="function"><span class="title">Counter</span><span class="params">(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">194616</span>, <span class="string">&#x27;addmm&#x27;</span>: <span class="number">80040</span>&#125;)</span></span></span><br><span class="line">flops<span class="selector-class">.by_module</span>()</span><br><span class="line">Counter(&#123;<span class="string">&#x27;&#x27;</span>: <span class="number">274656</span>, <span class="string">&#x27;conv1&#x27;</span>: <span class="number">48600</span>,</span><br><span class="line">         <span class="string">&#x27;conv2&#x27;</span>: <span class="number">146016</span>, <span class="string">&#x27;fc1&#x27;</span>: <span class="number">69120</span>,</span><br><span class="line">         <span class="string">&#x27;fc2&#x27;</span>: <span class="number">10080</span>, <span class="string">&#x27;fc3&#x27;</span>: <span class="number">840</span>&#125;)</span><br><span class="line">flops<span class="selector-class">.by_module_and_operator</span>()</span><br><span class="line">&#123;<span class="string">&#x27;&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">194616</span>, <span class="string">&#x27;addmm&#x27;</span>: <span class="number">80040</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;conv1&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">48600</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;conv2&#x27;</span>: Counter(&#123;<span class="string">&#x27;conv&#x27;</span>: <span class="number">146016</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc1&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">69120</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc2&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">10080</span>&#125;),</span><br><span class="line"> <span class="string">&#x27;fc3&#x27;</span>: Counter(&#123;<span class="string">&#x27;addmm&#x27;</span>: <span class="number">840</span>&#125;)&#125;</span><br></pre></td></tr></table></figure><p><strong>flop_count_table</strong></p><p>Format the per-module parameters and flops of a model in a table</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(flop_count_table(FlopCountAnalysis(model, inputs)))</span><br></pre></td></tr></table></figure><p>可以单独看某个模块的参数量和计算量.</p><h3 id="torch-profiler"><a href="#torch-profiler" class="headerlink" title="torch profiler"></a>torch profiler</h3><p>pytorch官方工具</p><blockquote><p>PyTorch Profiler是一个允许在训练和推理期间收集性能指标的工具。Profiler的上下文管理器API可以用来更好地理解哪些模型操作符是最昂贵的，检查它们的输入形状和堆栈跟踪，研究设备内核活动并可视化执行跟踪</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">with</span> profile(activities=[ProfilerActivity.CUDA], record_shapes=<span class="literal">True</span>, use_cuda=<span class="literal">True</span>) <span class="keyword">as</span> prof:</span><br><span class="line">        <span class="keyword">with</span> record_function(<span class="string">&quot;model_inference&quot;</span>):</span><br><span class="line">            model(input_data[<span class="string">&#x27;ego&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;GPU time sorted operators:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prof.key_averages().table(sort_by=<span class="string">&quot;cuda_time_total&quot;</span>, row_limit=<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPU time sorted operators:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prof.key_averages().table(sort_by=<span class="string">&quot;cpu_time_total&quot;</span>, row_limit=<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面计算了GPU和CPU的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.profiler.profile(</span><br><span class="line">    activities=[</span><br><span class="line">        torch.profiler.ProfilerActivity.CPU,</span><br><span class="line">        torch.profiler.ProfilerActivity.CUDA,</span><br><span class="line">    ]</span><br><span class="line">) <span class="keyword">as</span> p:</span><br><span class="line">    code_to_profile()</span><br><span class="line"><span class="built_in">print</span>(p.key_averages().table(</span><br><span class="line">    sort_by=<span class="string">&quot;self_cuda_time_total&quot;</span>, row_limit=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/31/3yWSVITxsYGHbR8.png" alt="image-20240731115415621"></p><h3 id="deepspeed"><a href="#deepspeed" class="headerlink" title="deepspeed"></a>deepspeed</h3><p>大模型训练的加速框架,微软开源的.一般的模型上面两个足以.这里不过多介绍.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> deepspeed.profiling.flops_profiler <span class="keyword">import</span> FlopsProfiler</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line">prof = FlopsProfiler(model)</span><br><span class="line"></span><br><span class="line">profile_step = <span class="number">5</span></span><br><span class="line">print_profile= <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">  <span class="comment"># start profiling at training step &quot;profile_step&quot;</span></span><br><span class="line">  <span class="keyword">if</span> step == profile_step:</span><br><span class="line">    prof.start_profile()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># forward() method</span></span><br><span class="line">  loss = model(batch)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># end profiling and print output</span></span><br><span class="line">  <span class="keyword">if</span> step == profile_step: <span class="comment"># if using multi nodes, check global_rank == 0 as well</span></span><br><span class="line">    prof.stop_profile()</span><br><span class="line">    flops = prof.get_total_flops()</span><br><span class="line">    macs = prof.get_total_macs()</span><br><span class="line">    params = prof.get_total_params()</span><br><span class="line">    <span class="keyword">if</span> print_profile:</span><br><span class="line">        prof.print_model_profile(profile_step=profile_step)</span><br><span class="line">    prof.end_profile()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># runs backpropagation</span></span><br><span class="line">  loss.backward()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># weight update</span></span><br><span class="line">  optimizer.step()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>除了上面几个之外,还有thop,stat以及ptflops等,其中一个问题时,很多库要求给出输出的tensor shape,但实际情况是输入的是一个list或者dict然后在模型中进行处理,为了避免模型改动,我推荐可以使用thop.</p></blockquote><h3 id="运行模型时间"><a href="#运行模型时间" class="headerlink" title="运行模型时间"></a>运行模型时间</h3><p>前面讲到如果要测试程序时间,并没有想的那么简单.在pytorch中提供了<code>torch.cuda.Event</code></p><p><a href="https://github.com/yifanlu0227/HEAL/blob/4882bd02514725fa5e2e5717d410de739f33790e/opencood/tools/profiler/params_calc.py">HEAL/opencood/tools/profiler/params_calc.py at 4882bd02514725fa5e2e5717d410de739f33790e · yifanlu0227/HEAL (github.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_throughput_cuda_event</span>(<span class="params">model, data</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start inference throughput performance test&quot;</span>)</span><br><span class="line">    run_num = <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;warm up ...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># warm up</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">            output = model(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;warm up done.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># synchronize 等待所有 GPU 任务处理完才返回 CPU 主线程</span></span><br><span class="line">    torch.cuda.synchronize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置用于测量时间的 cuda Event, 这是PyTorch 官方推荐的接口</span></span><br><span class="line">    starter, ender = torch.cuda.Event(enable_timing=<span class="literal">True</span>), torch.cuda.Event(enable_timing=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 初始化一个时间容器</span></span><br><span class="line">    run_num = <span class="number">200</span></span><br><span class="line">    timings = np.zeros((run_num,))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start testing ...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">            starter.record()</span><br><span class="line">            output = model(data)</span><br><span class="line">            ender.record()</span><br><span class="line">            torch.cuda.synchronize() <span class="comment"># 等待GPU任务完成</span></span><br><span class="line">            curr_time = starter.elapsed_time(ender) <span class="comment"># 从 starter 到 ender 之间用时,单位为毫秒</span></span><br><span class="line">            timings[i] = curr_time / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    infer_thro = run_num / timings.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;inference throughput (cuda event): &quot;</span>, infer_thro)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> infer_thro</span><br></pre></td></tr></table></figure><p>经过我自己测试,如果显存足够的情况下,很多时候直接使用time结果类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(run_num):</span><br><span class="line">    output = model(data)</span><br><span class="line">end_time = time.time()</span><br><span class="line">infer_thro = run_num / (end_time - start_time)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><p><a href="https://missing-semester-cn.github.io/2020/debugging-profiling/">调试及性能分析 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p></li><li><p><a href="https://discuss.pytorch.org/t/correct-way-to-calculate-flops-in-model/67198/14">Correct way to calculate FLOPS in model - PyTorch Forums</a></p><p>以下是我看到的分析深度学习模型计算量和参数量的工具</p><ul><li><a href="https://pytorch.org/docs/stable/profiler.html">torch.profiler — PyTorch 2.4 documentation</a></li><li><a href="https://www.deepspeed.ai/tutorials/flops-profiler/">Flops Profiler - DeepSpeed</a></li><li><a href="https://github.com/facebookresearch/fvcore">facebookresearch/fvcore: Collection of common code that’s shared among different research projects in FAIR computer vision team. (github.com)</a> </li></ul></li></ol><p>profiler <a href="https://github.com/yifanlu0227/HEAL/tree/4882bd02514725fa5e2e5717d410de739f33790e/opencood/tools/profiler">HEAL/opencood/tools/profiler at 4882bd02514725fa5e2e5717d410de739f33790e · yifanlu0227/HEAL (github.com)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是大型软件、算法开发中容易被忽视同时也并不简单的一环,如何分析一个程序.这涉及到分析内存、使用一系列现有工具并进行可能冗长的测试. 但不管怎样,这是走向成熟应用关键的一步,&lt;/p&gt;</summary>
    
    
    
    
    <category term="deep learning" scheme="https://www.sekyoro.top/tags/deep-learning/"/>
    
    <category term="profiler" scheme="https://www.sekyoro.top/tags/profiler/"/>
    
  </entry>
  
  <entry>
    <title>Go+HTMX: web开发降低心智负担的一种选择?</title>
    <link href="https://www.sekyoro.top/2024/07/27/go-htmx-web%E5%BC%80%E5%8F%91%E9%99%8D%E4%BD%8E%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85%E7%9A%84%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9/"/>
    <id>https://www.sekyoro.top/2024/07/27/go-htmx-web%E5%BC%80%E5%8F%91%E9%99%8D%E4%BD%8E%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85%E7%9A%84%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9/</id>
    <published>2024-07-27T02:35:43.000Z</published>
    <updated>2024-07-28T08:53:33.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>众所周知,一段时间前我一直在关注web开发框架,总的来说,大同小异. 如何进行快速开发小应用,是一个并不简单回答的问题.这里我给出一个解决方案:Go+HTMX.<br><span id="more"></span></p><p>这两个技术我不过多介绍,htmx顾名思义,在html上封了一层提供与后端交互的功能. 使用Go因为它的简洁且自带GC,不像c++和rust需要仔细小心管理内存,没有选用Java/C#也是因为后两者使用通常都要带上巨大的库(大型库会带来依赖上的安装、管理以及心智负担),在开发小应用时往往没有必要.  HTMX主要承担了一部分js的作用.</p><p>htmlx只有14k的大小,没有其他依赖,增强了html的功能. 再次说明,我介绍这个技术栈目的是为了快速开发中小应用,如果为了工作或是进一步学习,推荐Java/C#/Go等,再不济也是Python/PHP/Ruby.搭配vue/react/svelte/solid.</p><p>关于Go的web开发,常用Gin作为框架,主要写REST API和自带的模板引擎解析html,这里不多赘述.</p><p>下面介绍htmx的一些重要功能</p><h2 id="HTMX"><a href="#HTMX" class="headerlink" title="HTMX"></a>HTMX</h2><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>使用html的属性发送请求.</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Attribute</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-get/">hx-get</a></td><td style="text-align:left">Issues a <code>GET</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-post/">hx-post</a></td><td style="text-align:left">Issues a <code>POST</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-put/">hx-put</a></td><td style="text-align:left">Issues a <code>PUT</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-patch/">hx-patch</a></td><td style="text-align:left">Issues a <code>PATCH</code> request to the given URL</td></tr><tr><td style="text-align:left"><a href="https://htmx.org/attributes/hx-delete/">hx-delete</a></td><td style="text-align:left">Issues a <code>DELETE</code> request to the given URL</td></tr></tbody></table></div><h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><p>通过<code>hx-trigger</code>设置触发动作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-post</span>=<span class="string">&quot;/mouse_entered&quot;</span> <span class="attr">hx-trigger</span>=<span class="string">&quot;mouseenter&quot;</span>&gt;</span></span><br><span class="line">    [Here Mouse, Mouse!]</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以设置mofiers和filters修改默认行为.</p><p>还可以使用轮询</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-get</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">hx-trigger</span>=<span class="string">&quot;every 2s&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-get</span>=<span class="string">&quot;/messages&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-trigger</span>=<span class="string">&quot;load delay:1s&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-swap</span>=<span class="string">&quot;outerHTML&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置indicator表明已经发出请求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-get</span>=<span class="string">&quot;/click&quot;</span>&gt;</span></span><br><span class="line">    Click Me!</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;htmx-indicator&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/spinner.gif&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.htmx-request</span> <span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.htmx-request</span><span class="selector-class">.htmx-indicator</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当htmx发出请求时，它将把一个htmx-request类放到一个元素上(如果指定，可以是请求元素或另一个元素)。htmx-request类会使带有html-indicator类的子元素的不透明度变为1。</p><p>可以设置修改的元素.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-get</span>=<span class="string">&quot;/click&quot;</span> <span class="attr">hx-indicator</span>=<span class="string">&quot;#indicator&quot;</span>&gt;</span></span><br><span class="line">        Click Me!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;indicator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;htmx-indicator&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/spinner.gif&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>响应默认加载到请求的元素中,可以修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-get</span>=<span class="string">&quot;/trigger_delay&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-trigger</span>=<span class="string">&quot;keyup delay:500ms changed&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hx-target</span>=<span class="string">&quot;#search-results&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search-results&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>htmx提供了几种不同的方法来将返回的HTML交换到DOM.默认情况下,内容会替换目标元素的innerHTML.可以通过使用hx-swap属性来修改这个值:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>innerHTML</code></td><td style="text-align:left">the default, puts the content inside the target element</td></tr><tr><td style="text-align:left"><code>outerHTML</code></td><td style="text-align:left">replaces the entire target element with the returned content</td></tr><tr><td style="text-align:left"><code>afterbegin</code></td><td style="text-align:left">prepends the content before the first child inside the target</td></tr><tr><td style="text-align:left"><code>beforebegin</code></td><td style="text-align:left">prepends the content before the target in the target’s parent element</td></tr><tr><td style="text-align:left"><code>beforeend</code></td><td style="text-align:left">appends the content after the last child inside the target</td></tr><tr><td style="text-align:left"><code>afterend</code></td><td style="text-align:left">appends the content after the target in the target’s parent element</td></tr><tr><td style="text-align:left"><code>delete</code></td><td style="text-align:left">deletes the target element regardless of the response</td></tr><tr><td style="text-align:left"><code>none</code></td><td style="text-align:left">does not append content from response (<a href="https://htmx.org/docs/#oob_swaps">Out of Band Swaps</a> and <a href="https://htmx.org/docs/#response-headers">Response Headers</a> will still be processed)</td></tr></tbody></table></div><p>以上就是htmx中Ajax的基本使用,如果知道ajax的运作,那么使用就不会太难.</p><h3 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;Are you sure?&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-delete</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Delete My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-put</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Update My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个button继承了hx-confirm的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;Are you sure?&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-delete</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Delete My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-put</span>=<span class="string">&quot;/account&quot;</span>&gt;</span></span><br><span class="line">        Update My Account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">hx-confirm</span>=<span class="string">&quot;unset&quot;</span> <span class="attr">hx-get</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">        Cancel</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用unset取消</p><h3 id="增强表单和链接"><a href="#增强表单和链接" class="headerlink" title="增强表单和链接"></a>增强表单和链接</h3><p>HTML支持使用hx-boost属性“增强”常规HTML锚和表单.该属性将把所有锚标记和表单转换为AJAX请求,默认情况下,这些请求以页面主体为目标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hx-boost</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog&quot;</span>&gt;</span>Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个div中的锚标记将向/blog发出一个AJAX GET请求，并将响应交换到body标记中</p><h3 id="配置响应处理"><a href="#配置响应处理" class="headerlink" title="配置响应处理"></a>配置响应处理</h3><p>htmx期望对它发出的AJAX请求的响应是HTML,通常是HTML片段(尽管与hx-select标记匹配的完整HTML文档也很有用).然后,HTML将返回的HTML交换到指定目标的文档中,并使用指定的交换策略.<br>有时您可能不希望在交换中执行任何操作,但仍然可能触发客户端事件.<br>对于这种情况,默认情况下,您可以返回204 - No Content响应代码，并且html将忽略响应的内容.<br>在服务器错误响应的事件中(例如404或501)，html将触发html:responseerror事件，你可以处理。<br>如果出现连接错误，将触发html:sendError事件。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">responseHandling: [</span><br><span class="line">     &#123;code:<span class="string">&quot;204&quot;</span>, swap: <span class="literal">false</span>&#125;,   <span class="comment">// 204 - No Content by default does nothing, but is not an error</span></span><br><span class="line">     &#123;code:<span class="string">&quot;[23]..&quot;</span>, swap: <span class="literal">true</span>&#125;, <span class="comment">// 200 &amp; 300 responses are non-errors and are swapped</span></span><br><span class="line">     &#123;code:<span class="string">&quot;[45]..&quot;</span>, swap: <span class="literal">false</span>, <span class="keyword">error</span>:<span class="literal">true</span>&#125;, <span class="comment">// 400 &amp; 500 responses are not swapped and are errors</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>可以配置下面这些选项:</p><ul><li><code>code</code> - a String representing a regular expression that will be tested against response codes.</li><li><code>swap</code> - <code>true</code> if the response should be swapped into the DOM, <code>false</code> otherwise</li><li><code>error</code> - <code>true</code> if htmx should treat this response as an error</li><li><code>ignoreTitle</code> - <code>true</code> if htmx should ignore title tags in the response</li><li><code>select</code> - A CSS selector to use to select content from the response</li><li><code>target</code> - A CSS selector specifying an alternative target for the response</li><li><code>swapOverride</code> - An alternative swap mechanism for the response</li></ul><h3 id="配置请求头和响应头"><a href="#配置请求头和响应头" class="headerlink" title="配置请求头和响应头"></a>配置请求头和响应头</h3><h4 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h4><p>htmx includes a number of useful headers in requests:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Header</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>HX-Boosted</code></td><td style="text-align:left">indicates that the request is via an element using <a href="https://htmx.org/attributes/hx-boost/">hx-boost</a></td></tr><tr><td style="text-align:left"><code>HX-Current-URL</code></td><td style="text-align:left">the current URL of the browser</td></tr><tr><td style="text-align:left"><code>HX-History-Restore-Request</code></td><td style="text-align:left">“true” if the request is for history restoration after a miss in the local history cache</td></tr><tr><td style="text-align:left"><code>HX-Prompt</code></td><td style="text-align:left">the user response to an <a href="https://htmx.org/attributes/hx-prompt/">hx-prompt</a></td></tr><tr><td style="text-align:left"><code>HX-Request</code></td><td style="text-align:left">always “true”</td></tr><tr><td style="text-align:left"><code>HX-Target</code></td><td style="text-align:left">the <code>id</code> of the target element if it exists</td></tr><tr><td style="text-align:left"><code>HX-Trigger-Name</code></td><td style="text-align:left">the <code>name</code> of the triggered element if it exists</td></tr><tr><td style="text-align:left"><code>HX-Trigger</code></td><td style="text-align:left">the <code>id</code> of the triggered element if it exists</td></tr></tbody></table></div><h4 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h4><ul><li><a href="https://htmx.org/headers/hx-location/"><code>HX-Location</code></a> - allows you to do a client-side redirect that does not do a full page reload</li><li><a href="https://htmx.org/headers/hx-push-url/"><code>HX-Push-Url</code></a> - pushes a new url into the history stack</li><li><code>HX-Redirect</code> - can be used to do a client-side redirect to a new location</li><li><code>HX-Refresh</code> - if set to “true” the client-side will do a full refresh of the page</li><li><a href="https://htmx.org/headers/hx-replace-url/"><code>HX-Replace-Url</code></a> - replaces the current URL in the location bar</li><li><code>HX-Reswap</code> - allows you to specify how the response will be swapped. See <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> for possible values</li><li><code>HX-Retarget</code> - a CSS selector that updates the target of the content update to a different element on the page</li><li><code>HX-Reselect</code> - a CSS selector that allows you to choose which part of the response is used to be swapped in. Overrides an existing <a href="https://htmx.org/attributes/hx-select/"><code>hx-select</code></a> on the triggering element</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger</code></a> - allows you to trigger client-side events</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger-After-Settle</code></a> - allows you to trigger client-side events after the settle step</li><li><a href="https://htmx.org/headers/hx-trigger/"><code>HX-Trigger-After-Swap</code></a> - allows you to trigger client-side events after the swap step</li></ul><p>htmx请求的顺序:</p><ul><li>元素被trigger<ul><li>收集需要发送的数据</li><li><code>htmx-request</code>类被放在元素上</li><li>通过AJAX异步地请求<ul><li>获得响应后与 <code>htmx-swapping</code>类地内容转换</li><li>可选的swap延迟</li><li>实际交换内容完成<ul><li><code>htmx-swapping</code> 类被移除</li><li><code>htmx-added</code> 类被添加到每个更改的元素上</li><li><code>htmx-settling</code> 类添加到target上</li><li>默认延迟</li><li>DOM完成</li><li><code>htmx-settling</code> 被移除</li><li><code>htmx-added</code>类被移除</li></ul></li></ul></li></ul></li></ul><h3 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h3><ol><li><a href="https://www.youtube.com/watch?v=jeT8m7490Pg">https://www.youtube.com/watch?v=jeT8m7490Pg</a></li><li><a href="https://htmx.org/"> htmx - high power tools for html</a>事实上,htmx是有争议的技术,但不妨碍它依旧很受欢迎</li><li><a href="https://golang-china.github.io/gopl-zh/ch1/ch1-01.html">Hello, World - Go语言圣经 (golang-china.github.io)</a></li><li><a href="https://golang.google.cn/learn/">Get Started - The Go Programming Language (google.cn)</a></li><li>More htmx examples<a href="https://htmx.org/examples/"> htmx ~ Examples</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知,一段时间前我一直在关注web开发框架,总的来说,大同小异. 如何进行快速开发小应用,是一个并不简单回答的问题.这里我给出一个解决方案:Go+HTMX.&lt;br&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.sekyoro.top/tags/web/"/>
    
    <category term="htmx" scheme="https://www.sekyoro.top/tags/htmx/"/>
    
  </entry>
  
  <entry>
    <title>building makemore</title>
    <link href="https://www.sekyoro.top/2024/07/24/building-makemore/"/>
    <id>https://www.sekyoro.top/2024/07/24/building-makemore/</id>
    <published>2024-07-24T03:12:49.000Z</published>
    <updated>2024-09-25T15:42:57.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://karpathy.ai/zero-to-hero.html">Neural Networks: Zero To Hero (karpathy.ai)</a><br><span id="more"></span></p><h3 id="读取文件并设置vocab"><a href="#读取文件并设置vocab" class="headerlink" title="读取文件并设置vocab"></a>读取文件并设置vocab</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">words = <span class="built_in">open</span>(<span class="string">&quot;name.txt&quot;</span>).read().splitlines()</span><br><span class="line"><span class="comment"># build the vocabulary of characters and mappings to/from integers</span></span><br><span class="line">chars = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&quot;&quot;</span>.join(words))))</span><br><span class="line">stoi = &#123;s: i + <span class="number">1</span> <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(chars)&#125;</span><br><span class="line">stoi[<span class="string">&quot;.&quot;</span>] = <span class="number">0</span></span><br><span class="line">itos = &#123;i: s <span class="keyword">for</span> s, i <span class="keyword">in</span> stoi.items()&#125;</span><br><span class="line"><span class="built_in">print</span>(itos)</span><br></pre></td></tr></table></figure><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dataset</span>(<span class="params">words</span>):</span></span><br><span class="line">    X, Y = [], []</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">        <span class="comment"># print(w)</span></span><br><span class="line">        context = [<span class="number">0</span>] * block_size</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> w + <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            ix = stoi[ch]</span><br><span class="line">            X.append(context)</span><br><span class="line">            Y.append(ix)</span><br><span class="line">            <span class="comment"># print(&#x27;&#x27;.join(itos[i] for i in context), &#x27;---&gt;&#x27;, itos[ix])</span></span><br><span class="line">            context = context[<span class="number">1</span>:] + [ix]  <span class="comment"># crop and append</span></span><br><span class="line"></span><br><span class="line">    X = torch.tensor(X)</span><br><span class="line">    Y = torch.tensor(Y)</span><br><span class="line">    <span class="built_in">print</span>(X.shape, Y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line">random.shuffle(words)</span><br><span class="line">n1 = <span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(words))</span><br><span class="line">n2 = <span class="built_in">int</span>(<span class="number">0.9</span> * <span class="built_in">len</span>(words))</span><br><span class="line"></span><br><span class="line">Xtr, Ytr = build_dataset(words[:n1])</span><br><span class="line">Xdev, Ydev = build_dataset(words[n1:n2])</span><br><span class="line">Xte, Yte = build_dataset(words[n2:])</span><br></pre></td></tr></table></figure><h3 id="获取embedding"><a href="#获取embedding" class="headerlink" title="获取embedding"></a>获取embedding</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C = torch.randn((<span class="number">27</span>, <span class="number">10</span>), generator=g)</span><br><span class="line">W1 = torch.randn((<span class="number">30</span>, <span class="number">200</span>), generator=g)</span><br><span class="line">b1 = torch.randn(<span class="number">200</span>, generator=g)</span><br><span class="line">W2 = torch.randn((<span class="number">200</span>, <span class="number">27</span>), generator=g)</span><br><span class="line">b2 = torch.randn(<span class="number">27</span>, generator=g)</span><br><span class="line">parameters = [C, W1, b1, W2, b2]</span><br><span class="line"><span class="built_in">sum</span>(p.nelement() <span class="keyword">for</span> p <span class="keyword">in</span> parameters)  <span class="comment"># number of parameters in total</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> parameters:</span><br><span class="line">    p.requires_grad = <span class="literal">True</span></span><br><span class="line">emb = C[Xtr]</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">= torch.randn((<span class="number">27</span>, <span class="number">10</span>), generator=g)</span><br><span class="line">W1 = torch.randn((<span class="number">30</span>, <span class="number">200</span>), generator=g)</span><br><span class="line">b1 = torch.randn(<span class="number">200</span>, generator=g)</span><br><span class="line">W2 = torch.randn((<span class="number">200</span>, <span class="number">27</span>), generator=g)</span><br><span class="line">b2 = torch.randn(<span class="number">27</span>, generator=g)</span><br><span class="line">parameters = [C, W1, b1, W2, b2]</span><br><span class="line"><span class="built_in">sum</span>(p.nelement() <span class="keyword">for</span> p <span class="keyword">in</span> parameters)  <span class="comment"># number of parameters in total</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> parameters:</span><br><span class="line">    p.requires_grad = <span class="literal">True</span></span><br><span class="line">lre = torch.linspace(-<span class="number">3</span>, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">lrs = <span class="number">10</span>**lre</span><br><span class="line">lri = []</span><br><span class="line">lossi = []</span><br><span class="line">stepi = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200000</span>):</span><br><span class="line">    <span class="comment"># minibatch construct</span></span><br><span class="line">    ix = torch.randint(<span class="number">0</span>, Xtr.shape[<span class="number">0</span>], (<span class="number">32</span>,))</span><br><span class="line">    <span class="comment"># forward pass</span></span><br><span class="line">    emb = C[Xtr[ix]]  <span class="comment"># (32, 3, 2)</span></span><br><span class="line">    h = torch.tanh(emb.view(-<span class="number">1</span>, <span class="number">30</span>) @ W1 + b1)  <span class="comment"># (32, 100)</span></span><br><span class="line">    logits = h @ W2 + b2  <span class="comment"># (32, 27)</span></span><br><span class="line">    loss = F.cross_entropy(logits, Ytr[ix])</span><br><span class="line">    <span class="comment"># print(loss.item())</span></span><br><span class="line">    <span class="comment"># backward pass</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> parameters:</span><br><span class="line">        p.grad = <span class="literal">None</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update</span></span><br><span class="line">    <span class="comment"># lr = lrs[i]</span></span><br><span class="line">    lr = <span class="number">0.1</span> <span class="keyword">if</span> i &lt; <span class="number">100000</span> <span class="keyword">else</span> <span class="number">0.01</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> parameters:</span><br><span class="line">        p.data += -lr * p.grad</span><br><span class="line">    <span class="comment"># track stats</span></span><br><span class="line">    <span class="comment"># lri.append(lre[i])</span></span><br><span class="line">    stepi.append(i)</span><br><span class="line">    lossi.append(loss.log10().item())</span><br></pre></td></tr></table></figure><h2 id="经典网络"><a href="#经典网络" class="headerlink" title="经典网络"></a>经典网络</h2><h3 id="Linear"><a href="#Linear" class="headerlink" title="Linear"></a>Linear</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fan_in, fan_out, bias=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.weight = torch.randn((fan_in, fan_out)) / fan_in**<span class="number">0.5</span>  <span class="comment"># note: kaiming init</span></span><br><span class="line">        self.bias = torch.zeros(fan_out) <span class="keyword">if</span> bias <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.out = x @ self.weight</span><br><span class="line">        <span class="keyword">if</span> self.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.out += self.bias</span><br><span class="line">        <span class="keyword">return</span> self.out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parameters</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [self.weight] + ([] <span class="keyword">if</span> self.bias <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> [self.bias])</span><br></pre></td></tr></table></figure><h3 id="BatchNorm"><a href="#BatchNorm" class="headerlink" title="BatchNorm"></a>BatchNorm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchNorm1d</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, eps=<span class="number">1e-5</span>, momentum=<span class="number">0.1</span></span>):</span></span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        self.training = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># parameters (trained with backprop)</span></span><br><span class="line">        self.gamma = torch.ones(dim)</span><br><span class="line">        self.beta = torch.zeros(dim)</span><br><span class="line">        <span class="comment"># buffers (trained with a running &#x27;momentum update&#x27;)</span></span><br><span class="line">        self.running_mean = torch.zeros(dim)</span><br><span class="line">        self.running_var = torch.ones(dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># calculate the forward pass</span></span><br><span class="line">        <span class="keyword">if</span> self.training:</span><br><span class="line">            xmean = x.mean(<span class="number">0</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># batch mean</span></span><br><span class="line">            xvar = x.var(<span class="number">0</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># batch variance</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xmean = self.running_mean</span><br><span class="line">            xvar = self.running_var</span><br><span class="line">        xhat = (x - xmean) / torch.sqrt(xvar + self.eps)  <span class="comment"># normalize to unit variance</span></span><br><span class="line">        self.out = self.gamma * xhat + self.beta</span><br><span class="line">        <span class="comment"># update the buffers</span></span><br><span class="line">        <span class="keyword">if</span> self.training:</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                self.running_mean = (</span><br><span class="line">                    <span class="number">1</span> - self.momentum</span><br><span class="line">                ) * self.running_mean + self.momentum * xmean</span><br><span class="line">                self.running_var = (</span><br><span class="line">                    <span class="number">1</span> - self.momentum</span><br><span class="line">                ) * self.running_var + self.momentum * xvar</span><br><span class="line">        <span class="keyword">return</span> self.out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parameters</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [self.gamma, self.beta]</span><br></pre></td></tr></table></figure><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Embedding</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_embeddings, embedding_dim</span>):</span></span><br><span class="line">        self.weight = torch.randn((num_embeddings, embedding_dim))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, IX</span>):</span></span><br><span class="line">        self.out = self.weight[IX]</span><br><span class="line">        <span class="keyword">return</span> self.out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parameters</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [self.weight]</span><br></pre></td></tr></table></figure><h3 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tanh</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.out = torch.tanh(x)</span><br><span class="line">        <span class="keyword">return</span> self.out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parameters</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="Norm"><a href="#Norm" class="headerlink" title="Norm"></a>Norm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line">time_steps = <span class="number">3</span></span><br><span class="line">embedding_dim = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.randn(batch_size, time_steps, embedding_dim)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nn.BatchNorm1d</span></span><br><span class="line"><span class="comment"># https://pytorch.org/docs/stable/generated/torch.nn.BatchNorm1d.html</span></span><br><span class="line"></span><br><span class="line">m = nn.BatchNorm1d(embedding_dim)</span><br><span class="line">out = m(<span class="built_in">input</span>.transpose(-<span class="number">1</span>, -<span class="number">2</span>)).transpose(-<span class="number">1</span>, -<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手写 batch norm</span></span><br><span class="line">x_mean = <span class="built_in">input</span>.mean(dim=(<span class="number">0</span>, <span class="number">1</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">x_std = <span class="built_in">input</span>.std(dim=(<span class="number">0</span>, <span class="number">1</span>), unbiased=<span class="literal">False</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">output = (<span class="built_in">input</span> - x_mean) / (x_std + <span class="number">1e-5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nn.LayerNorm</span></span><br><span class="line"><span class="comment"># https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html#torch.nn.LayerNorm</span></span><br><span class="line">m_ln = nn.LayerNorm(normalized_shape=embedding_dim, elementwise_affine=<span class="literal">False</span>)</span><br><span class="line">out_ln = m_ln(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line">x_mean_ln = <span class="built_in">input</span>.mean(dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">x_std_ln = <span class="built_in">input</span>.std(dim=-<span class="number">1</span>, unbiased=<span class="literal">False</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">output_ln = (<span class="built_in">input</span> - x_mean_ln) / (x_std_ln + <span class="number">1e-5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nn.InstanceNorm</span></span><br><span class="line">m_In = nn.InstanceNorm1d(embedding_dim)</span><br><span class="line">out_In = m_In(<span class="built_in">input</span>.transpose(-<span class="number">1</span>, -<span class="number">2</span>)).transpose(-<span class="number">1</span>, -<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">x_mean_In = <span class="built_in">input</span>.mean(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">x_std_In = <span class="built_in">input</span>.std(dim=<span class="number">1</span>, unbiased=<span class="literal">False</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">output_In = (<span class="built_in">input</span> - x_mean_In) / (x_std_In + <span class="number">1e-5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nn.GroupNorm</span></span><br><span class="line">num_groups = <span class="number">2</span></span><br><span class="line">m_GN = nn.GroupNorm(num_groups=num_groups, num_channels=embedding_dim)</span><br><span class="line">out_Gn = m_GN(<span class="built_in">input</span>.transpose(-<span class="number">1</span>, -<span class="number">2</span>)).transpose(-<span class="number">1</span>, -<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">group_inputx = torch.split(</span><br><span class="line">    <span class="built_in">input</span>, split_size_or_sections=embedding_dim // num_groups, dim=-<span class="number">1</span></span><br><span class="line">)</span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> g_inputx <span class="keyword">in</span> group_inputx:</span><br><span class="line">    gn_mean = g_inputx.mean(dim=(<span class="number">1</span>, <span class="number">2</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">    gn_std = g_inputx.std(dim=(<span class="number">1</span>, <span class="number">2</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">    gn_result = (g_inputx - gn_mean) / (gn_std + <span class="number">1e-5</span>)</span><br><span class="line">    results.append(gn_result)</span><br><span class="line"></span><br><span class="line">results = torch.cat(results, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># weight normalization</span></span><br><span class="line"><span class="comment"># https://pytorch.org/docs/stable/generated/torch.nn.utils.weight_norm.html</span></span><br><span class="line">module = nn.Linear(embedding_dim, <span class="number">10</span>)</span><br><span class="line">m_wn = nn.utils.weight_norm(module, dim=<span class="number">0</span>)</span><br><span class="line">wn_linear_output = m_wn(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">weight_direction = module.weight / (module.weight.norm(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>))</span><br><span class="line">weight_magnitude = torch.tensor(</span><br><span class="line">    [module.weight[i:].norm() <span class="keyword">for</span> i <span class="keyword">in</span> torch.arange(module.weight.size(<span class="number">0</span>))],</span><br><span class="line">    dtype=torch.float32,</span><br><span class="line">).unsqueeze(-<span class="number">1</span>)</span><br><span class="line">output_wn = (</span><br><span class="line">    <span class="built_in">input</span> @ weight_direction.transpose(-<span class="number">1</span>, -<span class="number">2</span>) * weight_magnitude.transpose(-<span class="number">1</span>, -<span class="number">2</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://karpathy.ai/zero-to-hero.html&quot;&gt;Neural Networks: Zero To Hero (karpathy.ai)&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>BTMC:重返Modern Cpp</title>
    <link href="https://www.sekyoro.top/2024/07/21/BTMC-%E9%87%8D%E8%BF%94Modern-Cpp/"/>
    <id>https://www.sekyoro.top/2024/07/21/BTMC-%E9%87%8D%E8%BF%94Modern-Cpp/</id>
    <published>2024-07-21T07:13:09.000Z</published>
    <updated>2024-09-28T14:58:42.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前写过modern cpp学习,但是只是过了一遍文字. 最近我在使用c++重写karpathy的micrograd,学到了很多.这里记录一下重要的东西</p><span id="more"></span><h3 id="模板黑魔法"><a href="#模板黑魔法" class="headerlink" title="模板黑魔法"></a>模板黑魔法</h3><blockquote><p>黑魔法是常人无法参透的,这里仅作简单介绍</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = Fibonacci&lt;N<span class="number">-1</span>&gt;::value + Fibonacci&lt;N<span class="number">-2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;</span><span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(10) = &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否有 size 成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_size</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> std::true_type <span class="title">test</span><span class="params">(<span class="keyword">decltype</span>(&amp;U::size))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="keyword">decltype</span>(test&lt;T&gt;(<span class="number">0</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A has size: &quot;</span> &lt;&lt; has_size&lt;A&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;B has size: &quot;</span> &lt;&lt; has_size&lt;B&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_integral_v&lt;T&gt;, <span class="string">&quot;T must be an integral type&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">10</span>);      <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">// process(3.14); // 错误,编译时会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_assignable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_assignable_v&lt;T&amp;, T&gt;())</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; is assignable.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; is not assignable.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_assignable&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    check_assignable&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>模板元编程</strong>：在编译时执行计算,生成和优化代码.</li><li><strong>SFINAE</strong>：当模板参数替换失败时,编译器不会报错,而是忽略该模板.</li><li><strong>静态断言</strong>：在编译时进行断言,确保某些条件成立.</li><li><strong>类型 traits</strong>：查询和操作类型信息.</li></ul><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>模板特化是C++模板机制中的一个重要特性,它允许程序员针对特定的数据类型或一组数据类型对模板进行定制.当编译器遇到一个特化的模板实例时,它会使用特化版本而不是通用模板版本.这可以用于优化特定类型的性能,处理不同数据类型之间的差异,或者实现完全不同的行为.</p><h4 id="模板特化概述"><a href="#模板特化概述" class="headerlink" title="模板特化概述"></a>模板特化概述</h4><p>假设你有一个模板函数<code>identity</code>,它的作用是返回传入的参数本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">identity</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">identity</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h4><p>你可以为特定类型（如<code>std::string</code>）特化这个模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">std::string identity&lt;std::string&gt;(<span class="keyword">const</span> std::string&amp; s) &#123;</span><br><span class="line">    <span class="comment">// 可以添加一些特定于std::string的操作</span></span><br><span class="line">    <span class="comment">// 例如,转换为大写</span></span><br><span class="line">    std::string result = s;</span><br><span class="line">    std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中,对于<code>std::string</code>类型,<code>identity</code>函数将返回一个全部字符转为大写的字符串,而对其他类型则保持原样.</p><h4 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h4><p>类模板也可以被特化.例如,假设我们有一个类模板<code>Box</code>,它可以存储任何类型的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> </span>&#123; data = value; &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以为<code>int</code>类型特化<code>Box</code>类,以便为整数添加额外的功能,比如自动增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; data = value + <span class="number">1</span>; &#125; <span class="comment">// 自动增加</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样,<code>Box&lt;int&gt;</code>的行为就与<code>Box&lt;T&gt;</code>的通用版本不同了.</p><h4 id="完全特化与部分特化"><a href="#完全特化与部分特化" class="headerlink" title="完全特化与部分特化"></a>完全特化与部分特化</h4><p>完全特化是指为模板的所有参数指定特定类型,如上面的例子所示.部分特化是指只指定模板的部分参数,通常用于多参数模板,例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特化Pair&lt;int, int&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数模板实例化"><a href="#函数模板实例化" class="headerlink" title="函数模板实例化"></a>函数模板实例化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> z = max&lt;<span class="keyword">int</span>&gt;(x, y); <span class="comment">// 函数模板实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="限定类型"><a href="#限定类型" class="headerlink" title="限定类型"></a>限定类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> = std::<span class="keyword">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;&gt;&gt;</span><br><span class="line">class NumericWrapper &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>c++20以上使用<strong>concept</strong>能够好做限制,这里不做详细介绍.<a href="https://en.cppreference.com/w/cpp/concepts">Concepts library (since C++20) - cppreference.com</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> NumericType = std::is_arithmetic_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;NumericType T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumericWrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">int</span>&gt; <span class="title">intWrapper</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">double</span>&gt; <span class="title">doubleWrapper</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的声明会导致编译错误</span></span><br><span class="line">    <span class="comment">// NumericWrapper&lt;std::string&gt; stringWrapper(&quot;Hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SFINAE与enable-if"><a href="#SFINAE与enable-if" class="headerlink" title="SFINAE与enable_if"></a>SFINAE与enable_if</h4><p>使用 <code>std::enable_if</code> 和 SFINAE（Substitution Failure Is Not An Error,替代错误不是错误）来限定类型.这种方法允许你在模板的定义阶段就排除不符合要求的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">class NumericWrapper &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumericWrapper</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_arithmetic_v&lt;T&gt;&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumericWrapper</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">int</span>&gt; <span class="title">intWrapper</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">NumericWrapper&lt;<span class="keyword">double</span>&gt; <span class="title">doubleWrapper</span><span class="params">(<span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的声明不会导致编译错误,但会生成一个空模板实例</span></span><br><span class="line">    <span class="function">NumericWrapper&lt;std::string&gt; <span class="title">stringWrapper</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>; <span class="comment">// 不符合要求的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>模板特化常用于：</p><ul><li>为特定类型提供更高效的实现.</li><li>解决某些类型不适用的通用算法问题.</li><li>提供对基本类型和用户定义类型的统一接口,同时保持内部实现的差异性.</li></ul><h3 id="智能指针的使用场景"><a href="#智能指针的使用场景" class="headerlink" title="智能指针的使用场景"></a>智能指针的使用场景</h3><p>智能指针是C++中用来自动管理动态分配内存的一种手段,能帮助避免内存泄漏和其他与手动管理内存相关的问题.</p><p>智能指针本身也是指针,但是会通过编译器自动管理,表现行为像一个栈上的变量一样,在作用域之外就会自动析构.</p><p><code>std::unique_ptr</code>是一种独占所有权的智能指针,它保证了对所指向对象的独占访问.这意味着在同一时刻,只有一个<code>std::unique_ptr</code>可以指向同一个对象.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用new分配内存,并使用std::unique_ptr管理</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::make_unique简化创建过程</span></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; uptr2 = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问智能指针所指向的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uptr points to: &quot;</span> &lt;&lt; *uptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uptr2 points to: &quot;</span> &lt;&lt; *uptr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr在离开作用域时自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::shared_ptr</code>允许多个指针共享同一对象的所有权.当最后一个指向该对象的<code>std::shared_ptr</code>销毁时,对象的内存会被释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr1 = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sptr1复制所有权</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr2 = sptr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问智能指针所指向的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr1 points to: &quot;</span> &lt;&lt; *sptr1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sptr2 points to: &quot;</span> &lt;&lt; *sptr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shared_ptr在引用计数变为0时释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::weak_ptr不增加引用计数,它用于观察std::shared_ptr所管理的对象,而不会影响对象的生命周期.当std::shared_ptr不再存在时,std::weak_ptr可以被用来检查对象是否还活着,并锁定一个std::shared_ptr.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个weak_ptr</span></span><br><span class="line">    std::weak_ptr&lt;<span class="keyword">int</span>&gt; wptr = sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查weak_ptr是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="keyword">int</span>&gt; sptr2 = wptr.<span class="built_in">lock</span>(); <span class="comment">// 锁定一个shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wptr points to: &quot;</span> &lt;&lt; *sptr2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放shared_ptr,观察weak_ptr的行为</span></span><br><span class="line">    sptr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查weak_ptr是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The object has been deleted.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板类的友元函数重载-lt-lt-符号"><a href="#模板类的友元函数重载-lt-lt-符号" class="headerlink" title="模板类的友元函数重载&lt;&lt;符号"></a>模板类的友元函数重载&lt;&lt;符号</h3><p>给一个模板类写个友元函数重载<code>&lt;&lt;</code>方便ostream输出信息,但是报错链接出错.</p><p><a href="https://blog.csdn.net/Move_now/article/details/64530664">函数模板和友元重载运算符报”无法解析的外部符”的解决方法_输出运算符重载 无法解析-CSDN博客</a></p><p><strong>两次编译的函数头不一样,因为友元函数并不属于类的成员函数,所以需要单独声明此友元函数是函数模板</strong>,如果没有声明,但是后面在实现的时候又使用了<code>template &lt;class T&gt;</code>,就会导致错误的发生.</p><h3 id="右值和移动"><a href="#右值和移动" class="headerlink" title="右值和移动"></a>右值和移动</h3><blockquote><p>Use std::move(x) to turn x, an l-value, to an r-value so  that you can immediately take its resources</p></blockquote><ul><li><p><strong>泛左值</strong>（“泛化 (generalized)”的左值）是一个<strong>求值可确定某个对象或函数的标识的表达式</strong>；</p></li><li><p>纯右值</p><p>（“纯 (pure)”的右值）是求值符合下列之一的表达式：</p><ul><li>计算某个运算符的操作数的值（这种纯右值没有<em>结果对象</em>）</li><li>初始化某个对象（称这种纯右值有一个<em>结果对象</em>）</li></ul></li><li><p><strong>亡值</strong>（“将亡 (expiring)”的值）是代表它的资源能够被重新使用的对象或位域的泛左值；</p></li><li><strong>左值 (lvalue)</strong> 是并非亡值的泛左值；</li></ul><p>移动语义允许在对象从一个位置移动到另一个位置时,通过移动而非复制对象的状态,从而避免了昂贵的复制操作.这在处理大型对象或资源（如文件句柄、智能指针）时尤其重要,因为移动语义可以显著提升性能.</p><p>右值通常用来表示临时对象或字面量,这些对象在表达式求值后就不再需要.例如,函数返回的临时对象、构造函数参数中的字面量等都是右值</p><p>右值引用用于实现移动语义</p><h3 id="OOP-in-C"><a href="#OOP-in-C" class="headerlink" title="OOP in C++"></a>OOP in C++</h3><blockquote><p>C++中的面向对象设计也许并不好或者说糟糕</p></blockquote><p>编译器会为每个类默认生成特别方法,包括</p><ul><li>无参构造</li><li>拷贝构造</li><li>拷贝赋值</li><li>移动构造</li><li>移动赋值</li><li>析构方法</li></ul><p>如果类中的变量没有人为内存的分配,也许你并不需要显式声明拷贝、移动与析构方法.</p><p>当声明拷贝构造、赋值时,最好声明移动构造、赋值以及析构方法.</p><p><code>std::move</code>在移动构造、赋值中使用,表明需要使用移动操作,而不要在main中使用.</p><h4 id="Type-Safety"><a href="#Type-Safety" class="headerlink" title="Type Safety"></a>Type Safety</h4><blockquote><p>Type Safety: The extent to  which a language prevents  typing errors</p></blockquote><p>使用<code>std::optional</code></p><h2 id="Beyond-C-2a"><a href="#Beyond-C-2a" class="headerlink" title="Beyond C++2a"></a>Beyond C++2a</h2><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requries</span>(T a, T b) &#123;</span><br><span class="line">  a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">requires</span> Addable&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Addable T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制泛型中参数的类型. </p><p><img data-src="https://s2.loli.net/2024/08/19/C6l2sNhcEtTBwa7.png" alt="image-20240819005006425"></p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>目前我认为模块机制在c++生态用得不是很多,权当了解即可.模块允许程序员为代码定义 API</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该名称仅用作导入模块的标识符,不会引入新的作用域或命名空间,模块导出的任何名称仍然在导出时所在的作用域中</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">module</span> myModule</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">import</span> myModule</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sayHello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.geeksforgeeks.org/modules-in-cpp-20/">Modules in C++ 20 - GeeksforGeeks</a></p><p><strong>代码可能由多个类、多个文件、几个函数和包括模板在内的各种辅助工具组成</strong>.通过关键字 export,可以指定导出的内容为模块的 API,该模块包装提供特定功能的所有代码,所以可以为在不同文件中实现组件,定义一个干净的 API</p><p>模块可由多个文件定义,模块文件扩展名<code>.cppm</code>(不同编译器可能不一样),主模块接口单元中定义模块定义<code>export module xxx</code>.</p><p>模块文件不仅仅是一个改进的头文件.模块文件可以同时扮演头文件和源文件的角色, 可以包含声明和定义.<strong>模块文件中,不必使用内联或预处理器保护来指定定义.当模块导出的实体在不同翻译单元导入时,不能违反同一定义规则</strong></p><p>源模块文件不需要特定的文件扩展名,预编译模块文件也没有标准化后缀, 这是由编译器决定的</p><p><img data-src="https://s2.loli.net/2024/09/28/6ODXNghetL4ZjVr.png" alt="image-20240928204219427"></p><p>导入模块,模块不会自动引入新的命名空间,,在导出模块时所处的作用域中使用导出的模块符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Square</span><br></pre></td></tr></table></figure><p>可以将模块中的所有内容,导出到具有其命名空间中. 要么声明命名空间,在命名空间中export内容,要么将要export的内容都放在namespace中再export整个命名空间.</p><p>模块由多个模块单元组成.模块单元是属于一个模块的翻译单元</p><p>所有模块单元都必须以某种方式编译,只包含声明 (传统代码中的头文件),也需要进行某种预编译.因此,这些文件总可转换成某种特定于平台的内部格式,以避免不得不一次又一次地 (预) 编 译相同的代码.</p><p>除了主要的模块接口单元,C++ 还提供了另外三种单元类型来将模块的代码拆分为多个文件:</p><ul><li>模块实现单元允许开发者在自己的文件中实现定义,这样就可以单独编译 (类似于传统的 C++ 源代码在.cpp 文件中)</li><li>内部分区允许开发者在单独的文件中,提供仅在模块内可见的声明和定义</li><li>接口分区允许开发者将导出的模块 API 拆分为多个文件</li></ul><h4 id="主接口"><a href="#主接口" class="headerlink" title="主接口"></a>主接口</h4><p><strong>带有全局模块的主接口</strong></p><p>主接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module; // 全局模块</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">// 声明模块</span><br><span class="line">export module Mod1;</span><br><span class="line">struct Order &#123;</span><br><span class="line">  int count;</span><br><span class="line">  std::string name;</span><br><span class="line">  double price;</span><br><span class="line">  Order(int c, const std::string &amp;n, double p) : count&#123;c&#125;, name&#123;n&#125;, price&#123;p&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>模块实现单元</strong></p><p>模块实现单元不导出任何东西.导出只允许在模块 (主接口或接口分区) 的接口文件中进行,这些文件是用 export module 声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">module</span> Mod1;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Customer::sumPrice</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Order &amp;od : orders) &#123;</span><br><span class="line">    sum += od.count * od.price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Customer::averagePrice</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orders.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现单元也可以有全局模块,模块实现单元使用传统 C++ 翻译单元的文件扩展名 (大多数情况下是.cpp),编译器就像处理其 他非模块的 C++ 代码一样处理</p><p><strong>使用模块</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mod1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部分区"><a href="#内部分区" class="headerlink" title="内部分区"></a>内部分区</h4><p>使用内部分区可以<strong>在单独的文件中声明和定义模块的内部类型和函数</strong>.分区还可以用于在单独的文件中定义导出接口的各个部分</p><p>主接口必须导入内部分区,因为它使用 Order 类型.通过导入,分区在模块的所有单元中都可用.若主接口不需要 Order 类型,也不导入内部分区,则所有需要 Order 类型的模块单元都必须直接导入内部分区.</p><p>不支持 Mod2:Order:Main 的子分区,主接口只能使用名称<code>:Order</code>来导入这个分区.该文件使用了另一个新的文件扩展名:.cppp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">module Mod2:Order; // internal partition declaration</span><br><span class="line">struct Order &#123;</span><br><span class="line">  int count;</span><br><span class="line">  Order(int c) : count(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export module Mod2;</span><br><span class="line">import :Order;</span><br></pre></td></tr></table></figure><p>分区只是模块的内部实现方面.对于代码的用户来说,代码是在主模块中、实现中还是在内部分区中都无关紧要,但<strong>不能导出内部分区中的代码</strong>.</p><h4 id="接口分区"><a href="#接口分区" class="headerlink" title="接口分区"></a>接口分区</h4><p>给分区写接口,将模块的接口拆分为多个文件,可以声明接口分区,这些分区本身可以导出相应的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">export module Mod3:Customer;</span><br><span class="line"></span><br><span class="line">import :Order;</span><br><span class="line">export class Customer &#123;</span><br><span class="line">private:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::vector&lt;Order&gt; orders;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  Customer(const std::string &amp;n) : name(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主接口是指定模块导出内容的唯一地方,但主模块可以将导出委托给接口分区.这样做的 方法是将导入的接口分区作为一个整体直接导出.<strong>不允许导入接口分区,而不导出接口分区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export module Mod3;</span><br><span class="line">export import :Customer; //通过同时导入接口分区和导出接口分区 (两个关键字都要写),主接口导出分区 Customer 的接口作为自己的接口</span><br></pre></td></tr></table></figure><p>要导出导入的符号,可以使用 using</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export module MyMod; // declare module</span><br><span class="line">export import OtherModule;//export all symbls form othermodule</span><br><span class="line">import LogModule // import to export</span><br><span class="line">export using LogModule::Logger;</span><br></pre></td></tr></table></figure><h4 id="私有模块"><a href="#私有模块" class="headerlink" title="私有模块"></a>私有模块</h4><p>若在主接口中声明一个模块,有时可能需要一个私有模块.这允许开发者在主接口中拥有声明 和定义,这些声明和定义对任何其他模块或翻译单元都是不可见或不可达的.使用私有模块片段的 一种方法是禁用导出类或函数的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export module MyMod;</span><br><span class="line"></span><br><span class="line">export class C;</span><br><span class="line">export void print(const C &amp;c);</span><br><span class="line">module :private;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">private:</span><br><span class="line">  int value;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  void print() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print(const C &amp;c) &#123; c.print(); &#125;</span><br></pre></td></tr></table></figure><p>通过将定义移动到私有模块中,导入代码就不能再使用其中的任何定义</p><h4 id="编译器具体实践"><a href="#编译器具体实践" class="headerlink" title="编译器具体实践"></a>编译器具体实践</h4><p><img data-src="https://s2.loli.net/2024/09/28/5tsEg6hSp8ryTOm.png" alt="image-20240928222536772"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主接口将所有内容集合在一起,并指定导出给模块用户的内容 (通过直接导出符号或导出导入的接口分区). 拥有的模块单元类型取决于 C++ 源文件中的模块声明 (可以在注释和预处理器命令的全局模块之后): </p><ul><li>export module name; 主接口.对于每个模块,只能在 C++ 程序中存在一次.</li><li>module name; 仅提供定义 (可能使用局部声明) 的实现单元.想要多少提供多少.</li><li>module name:partname; 一个内部分区,声明和定义仅在模块内使用.可以有多个分区,但是对于每个 partname,只能 有一个内部分区文件.</li><li>export module name:partname; 一个接口分区.可以有多个接口分区,但是对于每个 partname,只能有一个接口分区文件</li></ul><p>使用传统头文件的基本方法是使用全局模块. </p><ul><li>用 module 开启模块; </li><li>在进行模块声明之前放置所有必要的预处理器命令:</li><li>包含的头文件中未使用的所有内容都将丢弃.</li><li>使用的所有内容都将获得模块链接,所以只在整个模块单元中可见,而在其他模块单元和模 块外部都不可见.</li><li>在 #include 之前使用 #define</li></ul><p>对于标准的 C++ 头文件,已经可以使 用 import,然后可以在模块中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> ModTest;</span><br><span class="line"><span class="keyword">import</span> &lt;chrono&gt;</span><br></pre></td></tr></table></figure><p>此功能只保证在标准 C++ 头文件上工作,不适用于 C++ 使用的标准 C 头文件</p><p>若想在模块中封装定义,以便导入代码只看到声明,并且仍然希望在主接口中拥有定义,必须 将定义放在私有模块中</p><h3 id="std-ranges"><a href="#std-ranges" class="headerlink" title="std::ranges"></a>std::ranges</h3><p>引入头文件<code>#include&lt;ranges&gt;</code>和<code>#include&lt;algorithms&gt;</code></p><p>常用的一些算法通常是对迭代器进行操作(STL)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>()+<span class="number">1</span>,v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>在引入ranges后,有了更加统一的方法</p><blockquote><p>ranges是“项的集合”或“可迭代的东西”的抽象.最基本的定义只要求在ranges上存在begin()和end()</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::ranges::<span class="built_in">sort</span>(std::views::<span class="built_in">drop</span>(v,<span class="number">5</span>));</span><br><span class="line">std::ranges::<span class="built_in">sort</span>(std::views::<span class="built_in">reverse</span>(v));</span><br><span class="line">std::ranges::<span class="built_in">sort</span>(std::views::<span class="built_in">drop</span>(std::views::<span class="built_in">reverse</span>(v),<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>有多个关于ranges的concept</p><div class="table-container"><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td><code>std::ranges::input_range</code></td><td>can be iterated from beginning to end <strong>at least once</strong></td></tr><tr><td><code>std::ranges::forward_range</code></td><td>can be iterated from beginning to end <strong>multiple times</strong></td></tr><tr><td><code>std::ranges::bidirectional_range</code></td><td>iterator can also move backwards with <code>--</code></td></tr><tr><td><code>std::ranges::random_access_range</code></td><td>you can jump to elements <strong>in constant-time</strong> <code>[]</code></td></tr><tr><td><code>std::ranges::contiguous_range</code></td><td>elements are always stored consecutively in memory</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>std::forward_list</code></th><th style="text-align:center"><code>std::list</code></th><th style="text-align:center"><code>std::deque</code></th><th style="text-align:center"><code>std::array</code></th><th style="text-align:center"><code>std::vector</code></th><th></th></tr></thead><tbody><tr><td style="text-align:center"><code>std::ranges::input_range</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::forward_range</code></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::bidirectional_range</code></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::random_access_range</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td>✅</td></tr><tr><td style="text-align:center"><code>std::ranges::contiguous_range</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✅</td><td>✅</td></tr></tbody></table></div><p>views的一个关键特性是,无论它们应用了什么转换,它们都是在请求元素的时候进行的,而不是在创建views的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> v = vec | std::views::reverse | std::views::<span class="built_in">drop</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *v.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>views是一种特定类型的ranges,在std::ranges::view中被形式化.</p><h3 id="C-20之后定义比较运算符"><a href="#C-20之后定义比较运算符" class="headerlink" title="C++20之后定义比较运算符"></a>C++20之后定义比较运算符</h3><p>为了检查是否相等,现在定义 == 操作符就够了. <strong>当编译器找不到表达式的匹配声明 a!=b 时,编译器会重写表达式并查找!(a\==b).若这不起作用,编译器也会尝试改变操作数的顺序,所以也会尝试!(b==a)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> TypeA&amp;, <span class="keyword">const</span> TypeB&amp;);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">struct NullTerm &#123;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">auto</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *pos == <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// end is where iterator points to \verb+&#x27;\0&#x27;+</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于所有的关系操作符,没有等价的规则说定义小于操作符就足够了.但现在,只需要定义新的操作符 &lt;=&gt; 即可.</p><p>通常,== 可以通过定义 == 和!= 操作符来处理对象的相等性,而 &lt;=&gt; 操作符通过定义关系操作 符来处理对象的顺序.若通过 =default 声明操作符 &lt;=&gt;,则可以使用了一个特殊的规则,即默认成员操作符 &lt;=&gt;:</p><p>• 若比较成员不抛出异常,则是 noexcept </p><p>• 若可在编译时比较成员,则是 constexpr </p><p>• 因为重写,还可以支持第一个操作数的隐式类型转换</p><p>通常情况下,== 和 &lt;=&gt; 操作符处理不同但相关的事情: • == 操作符定义相等性,可由相等操作符 == 和!= 使用. • &lt;=&gt; 操作符定义了排序,可以由关系操作符 &lt;、&lt;=、&gt; 和 &gt;= 使用</p><h3 id="auto类型推断"><a href="#auto类型推断" class="headerlink" title="auto类型推断"></a>auto类型推断</h3><p>c++20之后,在普通函数中即可使用.使用 auto 替代模板参数 T,该特性也称为“函数模板化”的语法</p><p> 因为带有 auto 的函数是函数模板,所以适用于函数模板的所有规则.从而不能在一个翻译单元 (CPP 文件) 中实现带有自动参数的函数,并在另一个翻译单元中调用.</p><p>对于具有 auto 参数的函数,实现存在于头文件,以便可以在多个 CPP 文件中使用(否则,必须在一个翻译单元中显式地实例化函数).另一方面,因为函数模板总是内联,所以不需要声明为内联</p><h3 id="模板约束与concept"><a href="#模板约束与concept" class="headerlink" title="模板约束与concept"></a>模板约束与concept</h3><p>concept是用于约束模板参数的, 当然约束模板参数可以不使用concept,而是使用type_traits提供的约束,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">requires</span> <span class="params">(!std::is_pointer_v&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a,T b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b&lt;a? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面略显繁琐,如果将约束形象化,声明为类似变量一样的东西,这样就引入了concept.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> IsPointer = std::is_pointer_v&lt;T&gt;</span><br></pre></td></tr></table></figure><p>concept可以约束别名模板、变量模板、成员函数和非类型模板参数.</p><p>概念可同时检查语法和语义约束: </p><p>• 语法约束在编译时,可以检查是否满足某些功能需求 (“是否支持特定的操作?”或“特定操 作是否产生特定类型?”).</p><p> • 语义约束满足了某些只能在运行时检查的需求 (“操作是否具有相同的效果?”或“对特定值 执行相同的操作是否总是产生相同的结果?”). </p><p>有时,概念允许开发者通过接口来指定是否满足语义约束,从而将语义约束转换为语法约束.</p><p>语义约束的一些例子<br><img data-src="https://s2.loli.net/2024/09/20/z4EiTPGMILDpFW2.png" alt="image-20240920171820648"></p><ul><li>概念应该分组</li><li>谨慎定义概念</li><li>概念与类型特征和布尔表达式</li></ul><p>C++17 引入了编译时 if,允许根据特定的编译时条件切换代码.当泛型代码必须为不同类型的参数提供不同的实现,但签名相同时,使用这种方法比提供重载 或特化的模板更具可读性.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Coll, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Coll&amp; coll, <span class="keyword">const</span> T&amp; val)</span> <span class="comment">// for floating-point value types</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_floating_point_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">... <span class="comment">// special code for floating-point values</span></span><br><span class="line"> &#125;</span><br><span class="line"> coll.<span class="built_in">push_back</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requires 子句使用关键字 requires 和编译时布尔表达式来限制模板的可用性.</p><p>布尔表达式可以是: </p><p>• 编译时的布尔表达式 </p><p>• 概念 </p><p>• requires 表达式 </p><p>可以使用布尔表达式的地方都可以使用约束 (特别是以 if constexpr 作为条件的).</p><p>编译时布尔表达式包括类型谓词(比如类型特征),编译时变量和编译时函数.</p><p>简单需求</p><p>需求表达式,需求表达式 (不同于 requires 子句) 提供了一种简单而灵活的语法,用于在一个或多个模板参数 上指定多个需求: • 必需的类型定义 • 表达式必须有效 • 对表达式产生类型的要求</p><p>类型需求,类型需求是在使用类型名称时必须格式良好的表达式,所以名称必须定义为有效类型.</p><p>复合需求允许将简单需求和类型需求结合起来,可以指定一个表达式 (大括号内),然后添加以 下一个或两个: </p><p>• noexcept 要求表达式保证不抛出异常</p><p> • -&gt; type-constraint 将概念应用于表达式的求值</p><p>且不能在 requires 表达式的结果中,使用带有类型特性的嵌套表达式.要么先定义相应的概念,要么使用嵌套需求.</p><p>嵌套需求可用于在 requires 表达式中指定附加约束.以 requires 开头,后跟一个编译时布尔表 达式,该表达式本身也可能是或使用 requires 表达式.嵌套需求的好处是,可以确保编译时表达式 (使用所需表达式的参数或子表达式) 产生特定的结果,而不是仅仅确保表达式有效.</p><p>标准概念</p><p><img data-src="https://s2.loli.net/2024/09/22/FPW1c6ewD2tHvAC.png" alt="image-20240922104301734"></p><h4 id="视图的范围性"><a href="#视图的范围性" class="headerlink" title="视图的范围性"></a>视图的范围性</h4><p>容器和字符串不是视图,因为不够轻量级: 没有提供低成本的复制构造函数,所以必须复制元 素.</p><p>使用容器作为视图:</p><p>• 通过将容器传递给范围适配器 std::views::all(),可以显式地将容器转换为视图. </p><p>• 通过将 begin 迭代器和 end(哨兵) 或大小传递给 std::ranges::subrange 或 std::views::counted(),可以显式地将容器的元素转换为视图. </p><p>• 可以通过将容器传递给其中一个自适应视图来隐式地将其转换为视图,这些视图通常通过将 容器隐式地转换为视图来获取容器</p><p>所有对作为左值传递的范围 (作为第一个构造函数参数或使用管道) 进行操作的视图,都在内部 存储对传递范围的引用. 使用视图时,底层范围必须存在</p><p>• std::counted_iterator 用于迭代器,该迭代器本身有一个计数来指定范围的结束 </p><p>• std::common_iterator 用于公共迭代器类型,可用于不同类型的两个迭代器</p><p> • std::default_sentinel_t 用于结束迭代器,强制迭代器检查其结束</p><p> • std::unreachable_sentinel_t 表示永远无法到达的 end 迭代器,表示无限范围</p><p> • std::move_sentinel 用于将副本映射到 move 的 end 迭代器</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="static-inline和extern-链接类型"><a href="#static-inline和extern-链接类型" class="headerlink" title="static,inline和extern. 链接类型"></a>static,inline和extern. 链接类型</h3><p>链接使用linker将多个编译得到.o文件链接为可执行程序. 多个链接单元不允许重复定义的变量或函数等.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909213919267.png" alt="image-20240909213919267"></p><p>inline,避免多次定义<br>inline 修饰的函数具有外部链接属性(externallinkage).在链接时,只会保留一个定义.C++17 引入了内联变量（inline variable）的概念,<strong>允许在头文件中定义变量而不会违反 One Definition Rule（ODR）</strong>.<br>要声明内联变量,可以在变量声明前加上 inline 关键字.这告诉编译器允许多个编译单元中都有这个变量的定义,而不会引发 ODR 错误<br>static,内部链接属性(internal linkage),修饰的全局变量的作用域仅限于定义它的文件.这意味着其他文件无法访问该变量,使用 static 可以避免命名冲突,因为每个源文件中的 static变量是独立的,即使它们同名也不会互相干扰<br>extern,用于声明一个全局变量或函数,表明该变量或函数在其他文件中定义.它允许在一个文件中使用另一个文件中定义的变量<br>当 extern 用于声明一个变量或函数时,它指定该符号具有外部链接属性<br>通常在头文件中定义/声明全局变量,以便其他源文件可以包含该头文件并使用这些变量<br>在多个文件中重复定义同名的 extern 变量,会导致链接错误<br>外部链接属性意味着该符号可以被程序中的其他翻译单元访问.<br>对于函数,默认情况下它们就具有外部链接属性,无需使用 extern 关键字.</p><blockquote><p>在 C++ 中,类的成员方法如果在类的定义中直接实现,则默认是 <strong>inline</strong> 的.内联函数具有外部链接属性,是弱符号.在类外实现默认不是inline,对应强符号.</p><p>一般将不需要内联的成员函数的定义编写在.cpp文件中,这样可以避免此类错误,这样多个其他文件引入头文件时不会造成重定义.</p></blockquote><h3 id="模板声明和定义放一个文件的目的"><a href="#模板声明和定义放一个文件的目的" class="headerlink" title="模板声明和定义放一个文件的目的."></a>模板声明和定义放一个文件的目的.</h3><p>在使用模板时,这种习惯性做法将变得不再有用,<strong>因为当实例化一个模板时,编译器必须看到模板确切的定义,而不仅仅是它的声明</strong>.因此,最好的办法就是将模板的声明和定义都放置在同一个.h文件</p><p>因为在编译时模板并不能生成真正的二进制代码,而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现,在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在,所以它只能找到模板类或函数的声明而找不到实现,而只好创建一个符号寄希望于链接程序找地址.但模板类或函数的实现并不能被编译成二进制代码,结果链接程序找不到地址只好报错了.</p><h3 id="现代c-中类似函数式编程思想中的一些操作-比如filter-map-reduce-fold-等"><a href="#现代c-中类似函数式编程思想中的一些操作-比如filter-map-reduce-fold-等" class="headerlink" title="现代c++中类似函数式编程思想中的一些操作,比如filter,map,reduce(fold)等"></a>现代c++中类似函数式编程思想中的一些操作,比如filter,map,reduce(fold)等</h3><ol><li><code>std::transform</code> (类似 map)</li></ol><p><code>std::transform</code> 是 C++ 标准库中的一个算法,位于 <code>&lt;algorithm&gt;</code> 头文件中.它可以对容器中的元素应用一个函数,并将结果存储到另一个容器中.这类似于函数式编程中的 <code>map</code> 操作.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">squares</span><span class="params">(numbers.size())</span></span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), squares.<span class="built_in">begin</span>(), [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);</span><br></pre></td></tr></table></figure><ol><li><code>std::remove_if和std::erase</code> (类似 filter)</li></ol><p>虽然 C++ 标准库中没有直接对应 <code>filter</code> 的算法,但可以使用 <code>std::remove_if</code> 和 <code>std::erase</code> 来实现类似的功能.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">numbers.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;), numbers.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>注意remove和remove_if一般需要搭配std::erase进行实际删除,因为前两者会返回一个新容器,而旧的容器没有被改变. 被remove的值会在后面,前面的值保持原来的相对位置,使用erase(new_it_end,old_end)进行删除.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 谓词：如果元素是偶数,则返回 true</span></span><br><span class="line">    <span class="keyword">auto</span> is_even = [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::ranges::remove_if 将偶数元素移到容器的末尾</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = std::ranges::<span class="built_in">remove_if</span>(numbers, is_even);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::erase 删除这些元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(new_end, numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：1 3 5 7 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::views中存在filter可以在不改变原数据实现上述功能,或者使用copy_if搭配</p><blockquote><p>视图是一种在范围上应用并执行某些操作的东西.视图不拥有数据,它的复制、移动或赋值时间复杂度为常数.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; evenNumbers;</span><br><span class="line">    std::<span class="built_in">copy_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(evenNumbers), isEven);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : evenNumbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Output: 2 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>std::back_inserter</code> 返回一个后向插入迭代器</strong>,当被解引用并赋值时,会在容器末尾执行 <code>push_back()</code> 操作.</li><li><strong>允许通常会覆盖元素的算法</strong>（如 <code>std::copy</code>）改为在容器末尾插入新元素.</li><li><strong>可与支持 <code>push_back()</code> 成员函数的容器一起使用</strong>,例如 <code>std::vector</code> 和 <code>std::deque</code>.</li><li><strong>不能用于不支持 <code>push_back()</code> 的容器</strong>,如 <code>std::set</code> 或 <code>std::map</code>,这种情况下可以使用 <code>std::inserter</code> 代替.</li><li><p><strong>使用 <code>std::back_inserter</code> 比在算法循环内手动调用 <code>push_back()</code> 更高效</strong>.</p></li><li><p><code>std::accumulate</code> (类似 reduce/fold)</p></li></ol><p><code>std::accumulate</code> 是 C++ 标准库中的一个算法,位于 <code>&lt;numeric&gt;</code> 头文件中.它可以对容器中的元素进行累积操作,类似于函数式编程中的 <code>reduce</code> 或 <code>fold</code> 操作.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>c++中也有std::reduce, 更适合于可以并行处理的场景,尤其是当操作是可交换和可结合的（例如加法和乘法）时.以选择不提供初始值,在这种情况下,它会默认构造一个初始值.这可能导致潜在的问题</p><ol><li><code>std::ranges</code> (C++20 中的函数式编程风格)</li></ol><p>C++20 引入了 <code>std::ranges</code> 库,它提供了一种更函数式编程风格的操作容器的方式.使用 <code>std::views</code> 命名空间中的算法,可以实现类似 <code>map</code>、<code>filter</code> 和 <code>reduce</code> 的操作.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> squares = numbers | std::views::<span class="built_in">transform</span>([](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);</span><br></pre></td></tr></table></figure><ol><li>Lambda 表达式</li></ol><p>C++11 引入了 lambda 表达式,它允许你定义匿名函数.Lambda 表达式可以与上述算法一起使用,提供了类似函数式编程中的 <code>map</code>、<code>filter</code> 和 <code>reduce</code> 的功能.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="keyword">int</span> acc, <span class="keyword">int</span> x) &#123; <span class="keyword">return</span> acc + x; &#125;);</span><br></pre></td></tr></table></figure><p>使用mutable使得lambda函数可以修改闭包的值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按引用捕获</span></span><br><span class="line">   <span class="keyword">auto</span> modifyByReference = [&amp;value]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">       value += <span class="number">5</span>; <span class="comment">// 修改外部变量</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>上面我最想提到的就是std::ranges和std::views,有了它们通过<code>|</code>符号,才有了函数式编程的感觉😋 下面更细致介绍一下</p><p>C++20 引入了 <strong>Ranges</strong> 库,这是对传统算法和迭代器库的扩展和概括,使得操作数据结构（如数组、向量等）更加简洁和强大.</p><ul><li><p><strong>范围（Range）</strong>：范围是一个可以迭代的对象,通常由两个迭代器（一个指向起始位置,另一个指向结束位置）表示.C++ 标准库中的容器（如 <code>std::vector</code> 和 <code>std::list</code>）都是范围的实现.</p></li><li><p><strong>适配器（Adaptor）</strong>：范围适配器是用于转换一个范围为另一个范围的功能.例如,<code>std::views::filter</code> 可以创建一个新范围,其中只包含满足特定条件的元素.</p></li><li><blockquote><p>视图不拥有数据.因此,视图不会延长其数据的生命周期.因此,视图只能对左值操作.如果在临时范围上定义视图,则编译将失败.</p></blockquote></li></ul><ol><li><p><strong>组合性</strong>：Ranges 允许将多个算法通过管道符号 <code>|</code> 组合在一起,形成更简洁的代码.例如,可以将过滤和变换操作组合在一起,而无需创建中间容器.</p></li><li><p><strong>惰性求值</strong>：许多范围适配器是惰性求值的,意味着它们不会立即计算结果,而是在实际需要时才会执行.这可以提高性能,尤其是在处理大型数据集时.</p></li><li><p><strong>简化语法</strong>：使用 Ranges,可以避免显式地获取迭代器的繁琐步骤,直接在容器上调用算法.</p></li><li><p><strong>并行支持</strong>：C++20 Ranges 还支持并行执行,允许在多核处理器上高效地处理数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用copy_if拷贝数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; even_numbers;</span><br><span class="line"></span><br><span class="line">    std::ranges::<span class="built_in">copy_if</span>(numbers, std::<span class="built_in">back_inserter</span>(even_numbers), [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : even_numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用filter和transform变换容器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围适配器过滤出偶数并平方</span></span><br><span class="line">    <span class="keyword">auto</span> even_squares = numbers </span><br><span class="line">                        | std::views::<span class="built_in">filter</span>([](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">                        | std::views::<span class="built_in">transform</span>([](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n * n; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : even_squares) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 4 16 36</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有std::views::reverse,take,drop等等操作.在我看来可以直接使用ranges替代很多algorithm中的操作了. </p><h4 id="范围算法-Range-Algorithms"><a href="#范围算法-Range-Algorithms" class="headerlink" title="范围算法(Range Algorithms)"></a>范围算法(Range Algorithms)</h4><p><code>std::ranges::copy</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpp<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; destination;</span><br><span class="line">std::ranges::<span class="built_in">copy</span>(numbers, std::<span class="built_in">back_inserter</span>(destination));</span><br></pre></td></tr></table></figure><p><code>std::ranges::transform</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppstd::vector&lt;<span class="keyword">int</span>&gt; transformed;</span><br><span class="line">std::ranges::<span class="built_in">transform</span>(numbers, std::<span class="built_in">back_inserter</span>(transformed), [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppint count = std::ranges::<span class="built_in">count_if</span>(numbers, [](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Even numbers count: &quot;</span> &lt;&lt; count; <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><p><code>std::ranges::for_each</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::views::filter 过滤偶数,然后遍历并打印</span></span><br><span class="line">    std::ranges::for_each(numbers | std::views::<span class="built_in">filter</span>([](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;),</span><br><span class="line">                           [](<span class="keyword">int</span> n) &#123;</span><br><span class="line">                               std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                           &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::views::iota</code>是一个范围工厂,用于通过逐渐增加初始值来创建元素序列.这个序列可以是有限的或无限的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: std::views::<span class="built_in">iota</span>(<span class="number">0</span>, <span class="number">10</span>)) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: std::views::<span class="built_in">iota</span>(<span class="number">0</span>) | std::views::<span class="built_in">take</span>(<span class="number">10</span>)) vec2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec == vec2: &quot;</span> &lt;&lt; (vec == vec2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: vec) std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于map也有像python那样的操作了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">&quot;jack&quot;</span>,  <span class="number">10086</span>&#125;,&#123;<span class="string">&quot;black&quot;</span>, <span class="number">10010</span>&#125;&#125;;                                </span><br><span class="line">    <span class="keyword">auto</span> names = std::views::<span class="built_in">keys</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;name: names) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> values = std::views::<span class="built_in">values</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;value: values) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_42896106/article/details/128737878">C++ 20 新特性 ranges 精讲_c++ ranges-CSDN博客</a></p></li></ol><h3 id="decay蜕变类型"><a href="#decay蜕变类型" class="headerlink" title="decay蜕变类型"></a>decay蜕变类型</h3><p><code>std::decay</code> 是 C++ 标准库中的一个类型特征,用于对类型进行转换,主要用于在模板编程中简化类型处理.它的主要功能是将类型转换为其“衰变”类型（decayed type）</p><p>具体来说,<code>std::decay</code> 进行以下三种类型转换：</p><ol><li><strong>去除引用</strong>：如果类型是引用类型（如 <code>int&amp;</code> 或 <code>const int&amp;</code>）,<code>std::decay</code> 会去掉引用,返回原始类型（如 <code>int</code>）.</li><li><strong>去除常量和易变性修饰符</strong>：如果类型是常量（<code>const</code>）或易变（<code>volatile</code>）的,<code>std::decay</code> 会去掉这些修饰符.</li><li><strong>数组和函数转换</strong>：如果类型是数组（如 <code>int</code>）或函数（如 <code>int()</code>）,<code>std::decay</code> 会将其转换为指针类型（如 <code>int*</code> 或 <code>int(*)()</code>）.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">int</span>&gt;::type, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">int</span>&amp;&gt;::type, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp;&gt;::type, <span class="keyword">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="keyword">int</span>[<span class="number">10</span>]&gt;::type, <span class="keyword">int</span>*&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数类型</span></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;std::decay&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;::type, <span class="built_in"><span class="keyword">void</span></span>(*)(<span class="keyword">int</span>)&gt;::value &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>volatile</code> 是 C++ 中的一个类型修饰符,用于告诉编译器某个变量的值可能会在程序的控制之外发生变化.这意味着编译器在优化代码时不应假设该变量的值是固定的</p></blockquote><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>​    在 <code>multimap</code> 中,键可以重复.这意味着多个键值对可以具有相同的键,而在 <code>map</code> 中,键是唯一的,插入相同的键会覆盖之前的值.</p><p><code>multimap</code> 通常是基于红黑树实现的,这使得插入、删除和查找操作的时间复杂度为 O(log n),其中 n 是元素的数量.<code>multimap</code> 不支持使用下标运算符（<code>[]</code>）或 <code>at()</code> 方法直接访问元素,因为相同的键可能对应多个值.</p><p>​    要访问特定键的所有值,可以使用 <code>equal_range()</code> 方法,该方法返回一个包含所有匹配键的值的迭代器范围.</p><p>​    <code>multimap</code> 中的元素是按照键的顺序存储的,默认情况下,使用 <code>std::less&lt;Key&gt;</code> 进行排序,确保元素按升序排列.相同的键值会按照插入顺序排列</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.learncpp.com/">Learn C++ – Skill up with our free tutorials (learncpp.com)</a></li><li><a href="https://cplusplus.com/">cplusplus.com</a></li><li><a href="https://en.cppreference.com/w/">cppreference.com</a></li><li><a href="https://changkun.de/modern-cpp/">现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly (changkun.de)</a></li><li><a href="https://learn-cpp.guyutongxue.site/">首页 | 谷雨同学的 C++ 教程 (guyutongxue.site)</a></li><li><a href="https://web.stanford.edu/class/cs106l/index.html">CS 106L: Standard C++ Programming (stanford.edu)</a></li><li>Best Practices<a href="https://lefticus.gitbooks.io/cpp-best-practices/content">https://lefticus.gitbooks.io/cpp-best-practices/content</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/?view=msvc-170">Cpp 文档 - 入门、教程、参考. | Microsoft Learn</a></li></ul><p>cpp书单<a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">c++ faq - The Definitive C++ Book Guide and List - Stack Overflow</a></p><p>感谢大模型的辅助</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过modern cpp学习,但是只是过了一遍文字. 最近我在使用c++重写karpathy的micrograd,学到了很多.这里记录一下重要的东西&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://www.sekyoro.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>学习llama3</title>
    <link href="https://www.sekyoro.top/2024/07/08/%E5%AD%A6%E4%B9%A0llama3/"/>
    <id>https://www.sekyoro.top/2024/07/08/%E5%AD%A6%E4%B9%A0llama3/</id>
    <published>2024-07-08T06:44:29.000Z</published>
    <updated>2024-07-08T15:22:46.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>llama3是meta开源的大模型,在开源大模型中占着重要地位,在这之前可能是Mistral,目前也有gemma2,Qwen2以及微软的Phi3等.<br><span id="more"></span></p><p>llama表现很不错,<a href="https://toloka.ai/llm-leaderboard/">LLM Leaderboard (toloka.ai)</a>,很多模型都是在它基础上微调得到的.</p><p>这里将llama介绍分为位置编码,transformer层,ffn层以及其中的norm的改进.</p><p>llama3相比于llama2,上下文窗口增大,tokenizer从sentencepiece变为tiktoken,token数也增多了.</p><div class="table-container"><table><thead><tr><th><strong>Feature</strong></th><th><strong>LLaMa 2</strong></th><th><strong>LLaMa 3</strong></th></tr></thead><tbody><tr><td><strong>Training Data Size</strong></td><td>2 trillion tokens</td><td>15 trillion tokens (7x larger)</td></tr><tr><td><strong>Context Window</strong></td><td>4K tokens</td><td>8k tokens</td></tr><tr><td><strong>Focus Area</strong></td><td>General language understanding</td><td>Nuance, context, complex tasks</td></tr><tr><td><strong>False Refusal Rate</strong></td><td>Higher</td><td>Lower</td></tr><tr><td><strong>Response Diversity</strong></td><td>Lower</td><td>Higher</td></tr><tr><td><strong>Code Generation</strong></td><td>Limited capability</td><td>Enhanced capability</td></tr></tbody></table></div><h2 id="旋转位置编码"><a href="#旋转位置编码" class="headerlink" title="旋转位置编码"></a>旋转位置编码</h2><blockquote><p>旋转位置嵌入（RoPE）是一种用于基于transformer模型的技术，可将位置信息纳入标记表示中。与依赖正弦和余弦函数的传统位置编码不同，<strong>RoPE 利用旋转矩阵来编码绝对和相对位置信息</strong>。这种方法的提出是为了提高位置嵌入在transformer中的有效性。Meta的LLaMA、清华的ChatGLM都采用了RoPE</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\mathrm{RoPE}(x,m)& =xe^{mi\theta} \\\langle\mathrm{RoPE}(q_j,m),\mathrm{RoPE}(k_j,n)\rangle & =\langle q_je^{mi\theta},k_je^{ni\theta}\rangle  \\&=q_jk_je^{mi\theta}\overline{e^{ni\theta}} \\&=q_jk_je^{(m-n)i\theta} \\&=\mathrm{RoPE}(q_jk_j,m-n)\end{aligned}\begin{aligned}\mathrm{RoPE}(x,m)& =xe^{mi\theta} \\\langle\mathrm{RoPE}(q_j,m),\mathrm{RoPE}(k_j,n)\rangle & =\langle q_je^{mi\theta},k_je^{ni\theta}\rangle  \\&=q_jk_je^{mi\theta}\overline{e^{ni\theta}} \\&=q_jk_je^{(m-n)i\theta} \\&=\mathrm{RoPE}(q_jk_j,m-n)\end{aligned}</script><p>在llama3中代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precompute_freqs_cis</span>(<span class="params">dim: <span class="built_in">int</span>, end: <span class="built_in">int</span>, theta: <span class="built_in">float</span> = <span class="number">10000.0</span></span>):</span></span><br><span class="line">    freqs = <span class="number">1.0</span> / (theta ** (torch.arange(<span class="number">0</span>, dim, <span class="number">2</span>)[: (dim // <span class="number">2</span>)].<span class="built_in">float</span>() / dim)) <span class="comment"># 一个位置上的特征</span></span><br><span class="line">    t = torch.arange(end, device=freqs.device, dtype=torch.float32)</span><br><span class="line">    freqs = torch.outer(t, freqs)</span><br><span class="line">    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)  <span class="comment"># complex64 # 得到e^freqs^ shape [T,dim//2]</span></span><br><span class="line">    <span class="keyword">return</span> freqs_cis</span><br><span class="line"></span><br><span class="line">self.freqs_cis = precompute_freqs_cis(</span><br><span class="line">    params.dim // params.n_heads,</span><br><span class="line">    params.max_seq_len * <span class="number">2</span>,</span><br><span class="line">    params.rope_theta,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshape_for_broadcast</span>(<span class="params">freqs_cis: torch.Tensor, x: torch.Tensor</span>):</span></span><br><span class="line">    ndim = x.ndim</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= <span class="number">1</span> &lt; ndim</span><br><span class="line">    <span class="keyword">assert</span> freqs_cis.shape == (x.shape[<span class="number">1</span>], x.shape[-<span class="number">1</span>])</span><br><span class="line">    shape = [d <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> i == ndim - <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(x.shape)]</span><br><span class="line">    <span class="keyword">return</span> freqs_cis.view(*shape)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_rotary_emb</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        xq: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">        xk: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">        freqs_cis: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor, torch.Tensor]:</span></span><br><span class="line">    xq_ = torch.view_as_complex(xq.<span class="built_in">float</span>().reshape(*xq.shape[:-<span class="number">1</span>], -<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">#shape [bs,seq_len,dim//2,2] -&gt; [bs,seq_len,dim]</span></span><br><span class="line">    xk_ = torch.view_as_complex(xk.<span class="built_in">float</span>().reshape(*xk.shape[:-<span class="number">1</span>], -<span class="number">1</span>, <span class="number">2</span>))<span class="comment">#shape [bs,seq_len,dim//2,2] -&gt; [bs,seq_len,dim]</span></span><br><span class="line">    freqs_cis = reshape_for_broadcast(freqs_cis, xq_) <span class="comment"># [1,seq_len,dim]</span></span><br><span class="line">    xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(<span class="number">3</span>)<span class="comment">#[bs,seq_len,dim//2,2] type float32 -&gt; </span></span><br><span class="line">    xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> xq_out.type_as(xq), xk_out.type_as(xk)</span><br><span class="line"></span><br><span class="line">xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis)</span><br></pre></td></tr></table></figure><p>计算freqs_cis,其是一个复数,旋转编码通常应用在q和k上.</p><script type="math/tex; mode=display">\mathrm{RoPE}(x_m^{(1)},x_m^{(2)},m)=\begin{bmatrix}\cos(m\theta)&-\sin(m\theta)\\\sin(m\theta)&\cos(m\theta)\end{bmatrix}\begin{bmatrix}x_m^{(1)}\\x_m^{(2)}\end{bmatrix}=\begin{bmatrix}x_m^{(1)}\cos(m\theta)-x_m^{(2)}\sin(m\theta)\\x_m^{(2)}\cos(m\theta)+x_m^{(1)}\sin(m\theta)\end{bmatrix}\\\Theta=\theta_i=10,000^{-\frac{2(i-1)}d},where(i\in[1,2,\ldots,d])\text{ for the $\frac{d}{2}$ pairs of features.}</script><p>下面是另一种实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RotaryPositionalEmbeddings</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, d: <span class="built_in">int</span>, base: <span class="built_in">int</span> = <span class="number">10_000</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.base = base</span><br><span class="line">        self.d = d</span><br><span class="line">        self.cos_cached = <span class="literal">None</span></span><br><span class="line">        self.sin_cached = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_cache</span>(<span class="params">self, x: torch.Tensor</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.cos_cached <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.shape[<span class="number">0</span>] &lt;= self.cos_cached.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        seq_len = x.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># THETA = 10,000^(-2*i/d) or 1/10,000^(2i/d)</span></span><br><span class="line">        theta = <span class="number">1.</span> / (self.base ** (torch.arange(<span class="number">0</span>, self.d, <span class="number">2</span>).<span class="built_in">float</span>() / self.d)).to(x.device)</span><br><span class="line">        <span class="comment"># Position index [0,1,...]</span></span><br><span class="line">        seq_idx = torch.arange(seq_len, device=x.device).<span class="built_in">float</span>().to(x.device)</span><br><span class="line"></span><br><span class="line">        idx_theta = torch.einsum(<span class="string">&#x27;n,d-&gt;nd&#x27;</span>, seq_idx,</span><br><span class="line">                                 theta)  <span class="comment"># Calculates m*(THETA) = [ [0, 0...], [THETA_1, THETA_2...THETA_d/2], ... [seq-1*(THETA_1), seq-1*(THETA_2)...] ]</span></span><br><span class="line"></span><br><span class="line">        idx_theta2 = torch.cat([idx_theta, idx_theta],</span><br><span class="line">                               dim=<span class="number">1</span>)  <span class="comment"># [THETA_1, THETA_2...THETA_d/2] -&gt; [THETA_1, THETA_2...THETA_d]</span></span><br><span class="line">        self.cos_cached = idx_theta2.cos()[:, <span class="literal">None</span>, <span class="literal">None</span>, :]  <span class="comment"># Cache [cosTHETA_1, cosTHETA_2...cosTHETA_d]</span></span><br><span class="line">        self.sin_cached = idx_theta2.sin()[:, <span class="literal">None</span>, <span class="literal">None</span>, :]  <span class="comment"># cache [sinTHETA_1, sinTHETA_2...sinTHETA_d]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_neg_half</span>(<span class="params">self, x: torch.Tensor</span>):</span></span><br><span class="line">        d_2 = self.d // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat([-x[:, :, :, d_2:], x[:, :, :, :d_2]], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x: torch.Tensor</span>):</span></span><br><span class="line">        self._build_cache(x)</span><br><span class="line">        neg_half_x = self._neg_half(x)</span><br><span class="line">        x_rope = (x * self.cos_cached[:x.shape[<span class="number">0</span>]]) + (neg_half_x * self.sin_cached[:x.shape[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> x_rope</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">    x = x[:, <span class="literal">None</span>, <span class="literal">None</span>, :]</span><br><span class="line"></span><br><span class="line">    p = RotaryPositionalEmbeddings(<span class="number">4</span>)(x)</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{bmatrix}x_m^{(i)}\\x_m^{(i+d/2)}\end{bmatrix}=\begin{bmatrix}x_m^{(i)}\cos(m\theta_i)-x_m^{(i+d/2)}\sin(m\theta_i)\\x_m^{(i+d/2)}\cos(m\theta_i)+x_m^{(i)}\sin(m\theta_i)\end{bmatrix}</script><h2 id="RSMNorm"><a href="#RSMNorm" class="headerlink" title="RSMNorm"></a>RSMNorm</h2><p>另一种规范化的方式,方法是在2019年的论文中提出的<a href="https://arxiv.org/pdf/1910.07467">1910.07467 (arxiv.org)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSNorm</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim: <span class="built_in">int</span>, eps: <span class="built_in">float</span> = <span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.weight = nn.Parameter(torch.ones(dim))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_norm</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * torch.rsqrt(x.<span class="built_in">pow</span>(<span class="number">2</span>).mean(-<span class="number">1</span>, keepdim=<span class="literal">True</span>) + self.eps)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        output = self._norm(x.<span class="built_in">float</span>()).type_as(x)</span><br><span class="line">        <span class="keyword">return</span> output * self.weight</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">y=\frac{x}{\sqrt{\text{RMS}[x]+\epsilon}}*\gamma</script><p>在llama3中,有三个地方使用,在attention,ffn以及在所有transformer layer之后,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = x + self.attention(self.attention_norm(x), start_pos, freqs_cis, mask)</span><br><span class="line">out = h + self.feed_forward(self.ffn_norm(h))</span><br></pre></td></tr></table></figure><h2 id="GroupQuery-Attention-amp-amp-KVcache"><a href="#GroupQuery-Attention-amp-amp-KVcache" class="headerlink" title="GroupQuery Attention&amp;&amp;KVcache"></a>GroupQuery Attention&amp;&amp;KVcache</h2><p>GroupQuery:query的head数是kv的head数的若干倍.</p><p>KV cache:在生成新的token时,K和V往往改变不大,也就不需要怎么计算,所以只需要存下计算的值即可.这是节约显存的操作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, args: ModelArgs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n_kv_heads = args.n_heads <span class="keyword">if</span> args.n_kv_heads <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> args.n_kv_heads</span><br><span class="line">        model_parallel_size = fs_init.get_model_parallel_world_size()</span><br><span class="line">        self.n_local_heads = args.n_heads // model_parallel_size</span><br><span class="line">        self.n_local_kv_heads = self.n_kv_heads // model_parallel_size</span><br><span class="line">        self.n_rep = self.n_local_heads // self.n_local_kv_heads</span><br><span class="line">        self.head_dim = args.dim // args.n_heads</span><br><span class="line"></span><br><span class="line">        self.wq = ColumnParallelLinear(</span><br><span class="line">            args.dim,</span><br><span class="line">            args.n_heads * self.head_dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            gather_output=<span class="literal">False</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line">        self.wk = ColumnParallelLinear(</span><br><span class="line">            args.dim,</span><br><span class="line">            self.n_kv_heads * self.head_dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            gather_output=<span class="literal">False</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line">        self.wv = ColumnParallelLinear(</span><br><span class="line">            args.dim,</span><br><span class="line">            self.n_kv_heads * self.head_dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            gather_output=<span class="literal">False</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line">        self.wo = RowParallelLinear(</span><br><span class="line">            args.n_heads * self.head_dim,</span><br><span class="line">            args.dim,</span><br><span class="line">            bias=<span class="literal">False</span>,</span><br><span class="line">            input_is_parallel=<span class="literal">True</span>,</span><br><span class="line">            init_method=<span class="keyword">lambda</span> x: x,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.cache_k = torch.zeros(</span><br><span class="line">            (</span><br><span class="line">                args.max_batch_size,</span><br><span class="line">                args.max_seq_len,</span><br><span class="line">                self.n_local_kv_heads,</span><br><span class="line">                self.head_dim,</span><br><span class="line">            )</span><br><span class="line">        ).cuda()</span><br><span class="line">        self.cache_v = torch.zeros(</span><br><span class="line">            (</span><br><span class="line">                args.max_batch_size,</span><br><span class="line">                args.max_seq_len,</span><br><span class="line">                self.n_local_kv_heads,</span><br><span class="line">                self.head_dim,</span><br><span class="line">            )</span><br><span class="line">        ).cuda()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            x: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            start_pos: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            freqs_cis: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            mask: <span class="type">Optional</span>[torch.Tensor],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        bsz, seqlen, _ = x.shape</span><br><span class="line">        xq, xk, xv = self.wq(x), self.wk(x), self.wv(x)</span><br><span class="line"></span><br><span class="line">        xq = xq.view(bsz, seqlen, self.n_local_heads, self.head_dim)</span><br><span class="line">        xk = xk.view(bsz, seqlen, self.n_local_kv_heads, self.head_dim)</span><br><span class="line">        xv = xv.view(bsz, seqlen, self.n_local_kv_heads, self.head_dim)</span><br><span class="line"></span><br><span class="line">        xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis)</span><br><span class="line"></span><br><span class="line">        self.cache_k = self.cache_k.to(xq)</span><br><span class="line">        self.cache_v = self.cache_v.to(xq)</span><br><span class="line"></span><br><span class="line">        self.cache_k[:bsz, start_pos: start_pos + seqlen] = xk</span><br><span class="line">        self.cache_v[:bsz, start_pos: start_pos + seqlen] = xv</span><br><span class="line"></span><br><span class="line">        keys = self.cache_k[:bsz, : start_pos + seqlen]</span><br><span class="line">        values = self.cache_v[:bsz, : start_pos + seqlen]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># repeat k/v heads if n_kv_heads &lt; n_heads</span></span><br><span class="line">        keys = repeat_kv(</span><br><span class="line">            keys, self.n_rep</span><br><span class="line">        )  <span class="comment"># (bs, cache_len + seqlen, n_local_heads, head_dim)</span></span><br><span class="line">        values = repeat_kv(</span><br><span class="line">            values, self.n_rep</span><br><span class="line">        )  <span class="comment"># (bs, cache_len + seqlen, n_local_heads, head_dim)</span></span><br><span class="line"></span><br><span class="line">        xq = xq.transpose(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># (bs, n_local_heads, seqlen, head_dim)</span></span><br><span class="line">        keys = keys.transpose(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># (bs, n_local_heads, cache_len + seqlen, head_dim)</span></span><br><span class="line">        values = values.transpose(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        )  <span class="comment"># (bs, n_local_heads, cache_len + seqlen, head_dim)</span></span><br><span class="line">        scores = torch.matmul(xq, keys.transpose(<span class="number">2</span>, <span class="number">3</span>)) / math.sqrt(self.head_dim)</span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            scores = scores + mask  <span class="comment"># (bs, n_local_heads, seqlen, cache_len + seqlen)</span></span><br><span class="line">        scores = F.softmax(scores.<span class="built_in">float</span>(), dim=-<span class="number">1</span>).type_as(xq)</span><br><span class="line">        output = torch.matmul(scores, values)  <span class="comment"># (bs, n_local_heads, seqlen, head_dim)</span></span><br><span class="line">        output = output.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(bsz, seqlen, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.wo(output)</span><br></pre></td></tr></table></figure><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transformer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, params: ModelArgs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.params = params</span><br><span class="line">        self.vocab_size = params.vocab_size</span><br><span class="line">        self.n_layers = params.n_layers</span><br><span class="line"></span><br><span class="line">        self.tok_embeddings = VocabParallelEmbedding(</span><br><span class="line">            params.vocab_size, params.dim, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.layers = torch.nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> layer_id <span class="keyword">in</span> <span class="built_in">range</span>(params.n_layers):</span><br><span class="line">            self.layers.append(TransformerBlock(layer_id, params))</span><br><span class="line"></span><br><span class="line">        self.norm = RMSNorm(params.dim, eps=params.norm_eps)</span><br><span class="line">        self.output = ColumnParallelLinear(</span><br><span class="line">            params.dim, params.vocab_size, bias=<span class="literal">False</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.freqs_cis = precompute_freqs_cis(</span><br><span class="line">            params.dim // params.n_heads,</span><br><span class="line">            params.max_seq_len * <span class="number">2</span>,</span><br><span class="line">            params.rope_theta,</span><br><span class="line">        )</span><br><span class="line"><span class="meta">    @torch.inference_mode()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, tokens: torch.Tensor, start_pos: <span class="built_in">int</span></span>):</span></span><br><span class="line">        _bsz, seqlen = tokens.shape</span><br><span class="line">        h = self.tok_embeddings(tokens)</span><br><span class="line">        self.freqs_cis = self.freqs_cis.to(h.device)</span><br><span class="line">        freqs_cis = self.freqs_cis[start_pos: start_pos + seqlen]</span><br><span class="line"></span><br><span class="line">        mask = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> seqlen &gt; <span class="number">1</span>:</span><br><span class="line">            mask = torch.full((seqlen, seqlen), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), device=tokens.device)</span><br><span class="line"></span><br><span class="line">            mask = torch.triu(mask, diagonal=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># When performing key-value caching, we compute the attention scores</span></span><br><span class="line">            <span class="comment"># only for the new sequence. Thus, the matrix of scores is of size</span></span><br><span class="line">            <span class="comment"># (seqlen, cache_len + seqlen), and the only masked entries are (i, j) for</span></span><br><span class="line">            <span class="comment"># j &gt; cache_len + i, since row i corresponds to token cache_len + i.</span></span><br><span class="line">            mask = torch.hstack(</span><br><span class="line">                [torch.zeros((seqlen, start_pos), device=tokens.device), mask]</span><br><span class="line">            ).type_as(h)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            h = layer(h, start_pos, freqs_cis, mask)</span><br><span class="line">        h = self.norm(h)</span><br><span class="line">        output = self.output(h).<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformerBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, layer_id: <span class="built_in">int</span>, args: ModelArgs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n_heads = args.n_heads</span><br><span class="line">        self.dim = args.dim</span><br><span class="line">        self.head_dim = args.dim // args.n_heads</span><br><span class="line">        self.attention = Attention(args)</span><br><span class="line">        self.feed_forward = FeedForward(</span><br><span class="line">            dim=args.dim,</span><br><span class="line">            hidden_dim=<span class="number">4</span> * args.dim,</span><br><span class="line">            multiple_of=args.multiple_of,</span><br><span class="line">            ffn_dim_multiplier=args.ffn_dim_multiplier,</span><br><span class="line">        )</span><br><span class="line">        self.layer_id = layer_id</span><br><span class="line">        self.attention_norm = RMSNorm(args.dim, eps=args.norm_eps)</span><br><span class="line">        self.ffn_norm = RMSNorm(args.dim, eps=args.norm_eps)</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            x: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            start_pos: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            freqs_cis: torch.Tensor,</span></span></span><br><span class="line"><span class="params"><span class="function">            mask: <span class="type">Optional</span>[torch.Tensor],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        h = x + self.attention(self.attention_norm(x), start_pos, freqs_cis, mask)</span><br><span class="line">        out = h + self.feed_forward(self.ffn_norm(h))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="silu激活函数"><a href="#silu激活函数" class="headerlink" title="silu激活函数"></a>silu激活函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedForward</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            dim: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            hidden_dim: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            multiple_of: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            ffn_dim_multiplier: <span class="type">Optional</span>[<span class="built_in">float</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        hidden_dim = <span class="built_in">int</span>(<span class="number">2</span> * hidden_dim / <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># custom dim factor multiplier</span></span><br><span class="line">        <span class="keyword">if</span> ffn_dim_multiplier <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hidden_dim = <span class="built_in">int</span>(ffn_dim_multiplier * hidden_dim)</span><br><span class="line">        hidden_dim = multiple_of * ((hidden_dim + multiple_of - <span class="number">1</span>) // multiple_of)</span><br><span class="line"></span><br><span class="line">        self.w1 = ColumnParallelLinear(</span><br><span class="line">            dim, hidden_dim, bias=<span class="literal">False</span>, gather_output=<span class="literal">False</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line">        self.w2 = RowParallelLinear(</span><br><span class="line">            hidden_dim, dim, bias=<span class="literal">False</span>, input_is_parallel=<span class="literal">True</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line">        self.w3 = ColumnParallelLinear(</span><br><span class="line">            dim, hidden_dim, bias=<span class="literal">False</span>, gather_output=<span class="literal">False</span>, init_method=<span class="keyword">lambda</span> x: x</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.w2(F.silu(self.w1(x)) * self.w3(x)) <span class="comment">#注意这里与一般的ffn差别,F.silu(self.w1(x))起了类似gate的作用</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pytorch.org/docs/stable/_images/SiLU.png" alt="../_images/SiLU.png" style="zoom:67%;" /></p><script type="math/tex; mode=display">silu(x)=x*σ(x)</script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/naklecha/llama3-from-scratch">naklecha/llama3-from-scratch: llama3 implementation one matrix multiplication at a time (github.com)</a></li><li><a href="https://github.com/meta-llama/llama3">github.com</a></li><li><a href="https://github.com/aju22/RoPE-PyTorch/blob/main/RoPE.ipynb">RoPE-PyTorch/RoPE.ipynb at main · aju22/RoPE-PyTorch (github.com)</a></li><li><a href="https://nn.labml.ai/transformers/rope/index.html">Rotary Positional Embeddings (RoPE) (labml.ai)</a></li><li><a href="https://mett29.github.io/posts/kv-cache/">What is the KV cache? | Matt Log (mett29.github.io)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;llama3是meta开源的大模型,在开源大模型中占着重要地位,在这之前可能是Mistral,目前也有gemma2,Qwen2以及微软的Phi3等.&lt;br&gt;</summary>
    
    
    
    
    <category term="llm" scheme="https://www.sekyoro.top/tags/llm/"/>
    
  </entry>
  
  <entry>
    <title>from grad to tensor</title>
    <link href="https://www.sekyoro.top/2024/07/08/from-grad-to-tensor/"/>
    <id>https://www.sekyoro.top/2024/07/08/from-grad-to-tensor/</id>
    <published>2024-07-08T02:09:09.000Z</published>
    <updated>2024-07-16T14:40:36.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>inspired by <a href="https://github.com/karpathy/micrograd">karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)</a>and <a href="https://nrehiew.github.io/blog/pytorch/">Taking PyTorch for Granted | wh (nrehiew.github.io)</a>. </p><p>感谢Karpathy以及x上所有真心探讨技术的网友.这属于karpathy的<a href="https://github.com/karpathy/nn-zero-to-hero?tab=readme-ov-file">karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero ,(github.com)</a>课程.事实上他还有很多值得一看的课程和repos.</p><span id="more"></span><p>tensor分成哪些部分?</p><blockquote><p>一个tensor可以分为元数据区和存储区（Storage）</p><p>信息区主要保存着tensor的形状（size）、步长（stride）、数据类型（type）,storage_offset,layout等信息,而真正的<strong>数据则保存成连续数组,存储在存储区</strong></p></blockquote><h3 id="tensor的存储"><a href="#tensor的存储" class="headerlink" title="tensor的存储"></a>tensor的存储</h3><p>tensor数据底层存储是<strong>连续的</strong>,<del>相对应的就是链表</del>. pytorch使用Storage类存储数据. 可以使用tensor.storage()访问存储的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = torch.arange(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(data.storage().dtype)</span><br><span class="line"><span class="built_in">print</span>(data.storage().device)</span><br><span class="line"><span class="built_in">print</span>(data.storage().data_ptr()) <span class="comment">#这里 存储数据也能访问数据的属性</span></span><br></pre></td></tr></table></figure><blockquote><p>All storage classes except for <a href="https://pytorch.org/docs/stable/storage.html#torch.UntypedStorage"><code>torch.UntypedStorage</code></a> will be removed in the future, and <a href="https://pytorch.org/docs/stable/storage.html#torch.UntypedStorage"><code>torch.UntypedStorage</code></a> will be used in all cases.</p></blockquote><p>但是在最新的python中除了untypedstorage类其他都已经deprecated了,而在untypedstorage中数据是字节类型,并且也无法调用<code>dtype</code>这些属性,变得更加纯粹了.</p><p><img data-src="https://s2.loli.net/2024/07/10/Ns8SM3QlpoeB4Ix.png" alt="image-20240710221322389"></p><p>事实上,大多数类似的数据都是这样的,比如常用库numpy.</p><p><img data-src="https://www.tomasbeuzen.com/python-programming-for-data-science/_images/numpy_paper.png" alt="img" style="zoom:150%;" /></p><h3 id="tensor的访问"><a href="#tensor的访问" class="headerlink" title="tensor的访问"></a>tensor的访问</h3><p>pytorch数据存储是一维的,但是会根据它的一些元数据改变对它的”解释”,而影响解释的元数据就是tride (<code>as_strided</code>可以使得两个tensor的size,stride和storage_offset一致)</p><blockquote><p><strong>stride</strong> stride是从一个元素到指定维度的另一个元素的间隔数,如果不指定维度,就返回在每个维度上的stride的tuple</p><p>Stride is the jump necessary to go from one element to the next one in the specified dimension <a href="https://pytorch.org/docs/stable/generated/torch.Tensor.dim.html#torch.Tensor.dim"><code>dim</code></a>. </p><p>A tuple of all strides is returned when no argument is passed in. Otherwise, an integer value is returned as the stride in the particular dimension <a href="https://pytorch.org/docs/stable/generated/torch.Tensor.dim.html#torch.Tensor.dim"><code>dim</code></a>.</p><p><strong>storage_offset</strong>  返回tensor的第一个元素与storage的第一个元素的偏移量。</p><p>Returns <code>self</code> tensor’s offset in the underlying storage in terms of number of storage elements (not bytes).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&gt;x.storage_offset()</span><br><span class="line">&gt;x[<span class="number">3</span>:].storage_offset()</span><br></pre></td></tr></table></figure></blockquote><p>pytorch中tensor存储区的数据是连续的,而stride规定了如何访问.访问的方式就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = torch.randn(<span class="number">1</span>,<span class="number">20</span>,<span class="number">20</span>) </span><br><span class="line">stride = data.stride() <span class="comment"># -&gt; (400, 20, 1)</span></span><br><span class="line">data[<span class="number">0</span>][<span class="number">2</span>][<span class="number">3</span>] -&gt;  <span class="number">0</span>*stride[<span class="number">0</span>]+<span class="number">2</span>*stride[<span class="number">2</span>]+<span class="number">3</span>*stride[<span class="number">3</span>]-&gt;也就是说这个数据在第<span class="number">2</span>*<span class="number">20</span>+<span class="number">3</span>*<span class="number">1</span>=<span class="number">43</span>个</span><br></pre></td></tr></table></figure><p>注意torch存储数据是行优先,也就是说,像下面这样的数据,第二个是0.6960而不是-0.5163. 所以访问时就类似索引乘以对应的行/列数,从这个角度来看,stride就是一个映射函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">1.6427</span>,  <span class="number">0.6960</span>,  <span class="number">0.7865</span>,  <span class="number">0.9934</span>,  <span class="number">0.4952</span>],</span><br><span class="line">        [-<span class="number">0.5163</span>, -<span class="number">0.0823</span>, -<span class="number">1.2630</span>, -<span class="number">0.9474</span>,  <span class="number">1.1055</span>],</span><br><span class="line">        [ <span class="number">0.1538</span>,  <span class="number">1.0177</span>, -<span class="number">1.8064</span>,  <span class="number">0.6440</span>, -<span class="number">1.4661</span>],</span><br><span class="line">        [ <span class="number">0.3305</span>,  <span class="number">0.2681</span>,  <span class="number">0.2768</span>, -<span class="number">0.3924</span>,  <span class="number">0.1743</span>],</span><br><span class="line">        [-<span class="number">0.8965</span>, -<span class="number">0.5499</span>, -<span class="number">0.4545</span>, -<span class="number">1.1470</span>,  <span class="number">0.6883</span>]])</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/10/s7ZuEzmD3vnAoiH.png" alt="image-20240710220152997"></p><h3 id="tensor操作"><a href="#tensor操作" class="headerlink" title="tensor操作"></a>tensor操作</h3><p>可以对tensor的数据进行操作,比如下面运算,会改变tensor的存储数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = torch.randn((<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line">stride = data.stride()</span><br><span class="line"><span class="built_in">print</span>(data, stride)</span><br><span class="line">data[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(data, stride)</span><br><span class="line">data.add_(torch.ones((<span class="number">4</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(data, stride)</span><br></pre></td></tr></table></figure><p>但是有些操作不会,其只会返回数据相同(指的是数据在底层存储上相同)的<strong>视图</strong>(view),这些操作包括<code>t()</code>,<code>expand</code>,<code>transpose</code>,<code>permute</code>,<code>view</code>,<code>squeeze</code>等等,操作后的tensor数据不变(也就是views),但stride<strong>可能</strong>会改变,也就是说解释数据的方式会变.</p><blockquote><p>底层存储并没有改变,只需将映射函数从旧形状的坐标系调整为新形状的坐标系。 如果映射函数已经将形状作为输入,那么只需更改形状属性即可。</p></blockquote><ul><li><code>reshape()</code>、<code>reshape_as()</code> 和 <code>flatten()</code> 可以返回视图或新张量,所以后续代码不要假定它返回的存储数据是否跟原本输入相同.</li><li>如果输入的张量已经连续,<code>contiguous()</code> 会返回自身,否则会通过复制数据返回一个新的连续张量.</li></ul><p>下面一个例子报错原因,就是stride的问题,具体来说,这里转置之后stride变了,size没变,使得后续的view操作不满足条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>) <span class="comment"># 3 x 3 stride (3,1)  size(3,3)</span></span><br><span class="line">x.t().view(<span class="number">1</span>, -<span class="number">1</span>) <span class="comment"># x.t() stride (1,3)  size(3,3)</span></span><br><span class="line"><span class="comment"># &gt;&gt; RuntimeError: view size is not compatible with input tensor&#x27;s </span></span><br><span class="line"><span class="comment"># size and stride. Use .reshape() instead</span></span><br></pre></td></tr></table></figure><p>首先,<code>view</code>作用是返回一个存储数据相同,但shape/size可能不同的视图,要求新的视图与输入数据<strong>相兼容</strong>( 1.<strong>新的视图的每个dimension必须是输入的子空间</strong>或者2.<strong>新的视图的维度满足下面条件</strong>（连续性),否则不能得到新的视图.</p><script type="math/tex; mode=display">假设得到的新的tensor维度涉及d,..,d+k,对其中所有维度要求:\\\text{stride}[i]=\text{stride}[i+1]\times\text{size}[i+1]</script><blockquote><p>如果不清楚是否可以执行 view()，建议使用 reshape()</p><p>reshape:如果形状兼容,则返回视图,否则返回拷贝(相当于调用 contiguous)</p></blockquote><p>view之后size变为(1,9),这符合条件1,也就是size相符,再看这里(1,9)表明第二个维度跨域(span across)了原本输入的两个维度,而原本输入的两个维度中的第一个维度需要满足连续性条件,但是 stride[0] =  1 , stride[1]*size[1] = 1*3=3 不符合,所以view操作失败.</p><p>更抽象地说,因为没有办法在不改变底层数据的情况下对张量进行flatten处理.</p><blockquote><p>我们能否从tensor的stride(3,1)推得tensor size是(3,3)?</p><p>答案是不能,它的size也完全可以是(4,3). 反过来size也不能推出stride.</p></blockquote><p>在上面的例子中,比如底层数据是[1,2,3,4,5,6,7,8,9],stride是[3,1]. 也就是说在第一个维度下,数据到相同维度的下个数据间隔为3,同理第二个维度间隔为1,</p><p>经过转置之后,因为解释数据的方式变了,因为需要改变解释数据的方式,所以stride需要改变为(1,3).  再进行view(1,-1),如果不报错的话,size就是(1,9),你可能会认为结果不就是[[1,4,7,2,5,8…]]吗,但这个tensor的stride为多少呢? 是(9,1)吗,并不是.为什么呢,</p><p>因为底层数据[1,2,3,4,5,6,7,8,9],要查找第二个维度上的数据,比如1到4,在底层数据中是stride是3,而4到7也是3,所以是stride是(9,3),然而这跟size(1,9)不匹配(stride乘起来应该跟size乘起来应该相同,这是最起码的保证).</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="string">[[1, 2, 3],</span></span><br><span class="line"><span class="string">        [4, 5, 6],</span></span><br><span class="line"><span class="string">        [7, 8, 9]]</span>) </span><br><span class="line">        ⬇⬇</span><br><span class="line">        tensor(<span class="string">[[1, 4, 7],</span></span><br><span class="line"><span class="string">        [2, 5, 8],</span></span><br><span class="line"><span class="string">        [3, 6, 9]]</span>)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2024/07/13/XRp2T8JgGrNQBwY.png" alt="在这里插入图片描述" style="zoom: 67%;" /></p><h3 id="tensor的广播"><a href="#tensor的广播" class="headerlink" title="tensor的广播"></a>tensor的广播</h3><p>PyTorch 的广播规则:(如何说一个tensor是可广播的)</p><ul><li><p>两个张量必须至少有一个维度</p></li><li><p>从最右边的维开始,两个维必须大小相等,其中一个为 1 或者其中一个不存在。</p><blockquote><p>Two tensors are “broadcastable” if the following rules hold:</p><ul><li>Each tensor has at least one dimension.</li><li>When iterating over the dimension sizes, starting at the trailing dimension, the dimension sizes must either be equal, one of them is 1, or one of them does not exist.</li></ul><p><a href="https://pytorch.org/docs/stable/notes/broadcasting.html#broadcasting-semantics">Broadcasting semantics — PyTorch 2.3 documentation</a></p><p>If two tensors <code>x</code>, <code>y</code> are “broadcastable”, the resulting tensor size is calculated as follows:</p><ul><li>If the number of dimensions of <code>x</code> and <code>y</code> are not equal, prepend 1 to the dimensions of the tensor with fewer dimensions to make them equal length.</li><li>Then, for each dimension size, the resulting dimension size is the max of the sizes of <code>x</code> and <code>y</code> along that dimension.</li></ul></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from https://nrehiew.github.io/blog/pytorch/</span></span><br><span class="line"><span class="keyword">for</span> each dimension, starting from the right:</span><br><span class="line"><span class="keyword">if</span> both shapes have this dimension:</span><br><span class="line"><span class="keyword">if</span> they are different:</span><br><span class="line">neither is 1: error</span><br><span class="line"><span class="keyword">else</span>: use larger dimension </span><br><span class="line"><span class="keyword">else</span> they are the same: use dimension</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">use whichever dimension exists</span><br></pre></td></tr></table></figure><p>广播,不存在数据copy.这意味着,如果将一个小张量广播到一个大得多的形状,就不会产生内存或性能开销。</p><p>其次,由于较小张量中使用的实际元素是相同的,因此梯度会沿着这个较小维度中的项目累积.这在调试梯度或执行涉及广播的自定义自动梯度函数时特别有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.empty(  <span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(x+y).size()</span><br><span class="line"></span><br><span class="line">x=torch.empty(<span class="number">1</span>)</span><br><span class="line">y=torch.empty(<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">(x+y).size()</span><br><span class="line"></span><br><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.empty(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(x+y).size()</span><br></pre></td></tr></table></figure><p>如果一个 PyTorch 操作支持广播,那么它的张量数据就会自动扩展为大小相等的数据(无需复制数据),所以本质上也是返回一个视图.</p><h3 id="利用矩阵乘法进行广播"><a href="#利用矩阵乘法进行广播" class="headerlink" title="利用矩阵乘法进行广播"></a>利用矩阵乘法进行广播</h3><p>矩阵是二维的,但是tensor是不限制的.</p><p><strong>多维tensor如何相乘的呢?</strong></p><ol><li>取两个张量的最后两个维度,检查它们是否可以相乘.如果不能,则出错</li><li>广播剩余维数.结果形状为 [广播后的维数] + [矩阵乘法的结果形状]。</li><li>将 [广播后的维数] 作为批处理维度，执行batched matrix multiplication(其实就是矩阵乘法,但是两个相乘的矩阵分别来自不同的batch中的相同的index)</li></ol><p>使用torch.matmul进行tensor相乘,它的计算方式如下</p><ul><li><p>如果都是一维,进行点乘</p></li><li><p>如果都是二维,进行矩阵乘,,如果是1维和二维,在一维度之前添加一个维度在进行矩阵乘,乘完之后再去掉.</p></li><li><p>如果是二维和1维,进行矩阵-向量乘法,得到向量.</p></li><li><p>如果两个参数都至少为 1 维,且至少一个参数为 N 维(N &gt; 2),则返回一个batched matrix multiplication.</p><p>如果第一个参数是一维的,那么在进行batched matrix multiplication,会在其维度前添加一维,然后删除.</p><p>如果第二个参数是一维的,则在其维度后加上 1,以便进行batched matrix multiply,并在运算后删除.</p><p>非矩阵(即批处理)维度将被广播(因此必须是<strong>可广播的</strong>)</p><p>比如(jx1xnxn)和(kxnxn)得到(jxkxnxn),在batch上广播得到(jxk),简单来说就是最后两维(不够进行广播)进行相乘,除了后面两维,其他维度直接进行广播.</p></li></ul><blockquote><p>注意:广播逻辑在确定输入是否可广播时，只查看批次维度，而不查看矩阵维度。</p><p>这跟上面的广播逻辑不同.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn((<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 3 x 4 x 1 x 2</span></span><br><span class="line">b = torch.randn((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 1 x 2 x 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix Multiply Shape: 1x2 @ 2x3 -&gt; 1x3</span></span><br><span class="line"><span class="comment"># Batch Shape: We broadcast (3, 4) and (1) -&gt; (3, 4)</span></span><br><span class="line"><span class="comment"># Result shape: 3 x 4 x 1 x 3</span></span><br><span class="line">c = torch.zeros((<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># iterate over the batch dimensions of (3, 4)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">a_slice = a[i][j] <span class="comment"># 1 x 2</span></span><br><span class="line">b_slice = b[<span class="number">0</span>] <span class="comment"># 2 x 3</span></span><br><span class="line">c[i][j] = a_slice @ b_slice <span class="comment"># 1 x 3</span></span><br><span class="line"><span class="keyword">assert</span> torch.equal(torch.matmul(a, b), c)</span><br></pre></td></tr></table></figure><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>PyTorch 的核心是它的自动微分引擎.一般来说,<strong>每次在两个张量之间进行微分操作时,PyTorch 都会通过回调函数自动构建出整个计算图. 然后,当调用 .backward() 时,每个张量的梯度都会被更新</strong>. 这是 PyTorch 最大的抽象.</p><p>从标量的求导开始扩展到高维,这并不困难.首先需要理解标量的基本运算中的加/减法,乘法,幂、指以及对数.一个softmax操作就包含了加,幂指的操作.</p><p> 可以将矩阵乘法看作是多个标量值的一系列乘法和加法运算,只需指定这些标量运算的后向运算,两个矩阵相乘的导数就自然而然地产生了.</p><p>从标量的角度来考虑梯度还有一个好处，就是可以直观地了解张量操作对梯度的影响。</p><p>例如，.reshape()、.transpose()、.cat 和 .split()等操作不会影响单个值及其在标量的梯度。 因此这些操作对张量梯度的影响自然就是操作梯度本身。 </p><p>例如,使用 .reshape(-1) 对张量进行扁平化处理,对梯度的影响与调用 .reshape(-1) 对张量的梯度的影响相同。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h4><p>不使用 GPU 也能实现的优化方法.</p><p> 一种可能的优化方法是利用内存访问模式,而不是改变算法。 回想一下,在给定 A @ B 的情况下，我们正在重复计算 A 中的一行和 B 中的一列的点乘. </p><p>简单的解决方法是转置,将其转为列主模式(column-first),这样每次从内存加载时,我们就可以在同一缓存行中加载 B 列中的正确项目.</p><p>转置是一种O(N) 操作，因此只适用于较大的矩阵.</p><p>另一种无需缓存的算法是对矩阵块进行运算，而不是一次性对整个矩阵进行运算。 这就是所谓的<strong>块矩阵乘法</strong>。 其原理是将矩阵分解成较小的块，然后在这些块上执行矩阵乘法。 这样做的另一个好处是减少了高速缓存的读取次数，因为我们现在是在矩阵的较小块上进行运算。</p><h4 id="内存和中间值"><a href="#内存和中间值" class="headerlink" title="内存和中间值"></a>内存和中间值</h4><blockquote><p>这里原文<a href="https://nrehiew.github.io/blog/pytorch/">Taking PyTorch for Granted | wh (nrehiew.github.io)</a>似乎有typos,我进行了修正</p></blockquote><p>在反向传播时,符合直觉的想法是保留中间值的梯度,以便后续计算leaf tensor的梯度.但是有些时候并不需要中间值的梯度</p><p>比如(a*b)+(c*d)=e,进行反向传播求e在a的梯度时如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_t1 = a * b</span><br><span class="line">_t2 = c * d</span><br><span class="line">e = _t1 + _t2</span><br></pre></td></tr></table></figure><p>其实就是求b,所以并不需要保留_t1和_t2的值.</p><h3 id="micrograd-from-scratch"><a href="#micrograd-from-scratch" class="headerlink" title="micrograd from scratch"></a>micrograd from scratch</h3><p>此外还有个tinygrad的项目也是受此启发,在pytorch和micrograd中得到改进.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/karpathy/micrograd">karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)</a></li><li><a href="https://github.com/karpathy/nn-zero-to-hero?tab=readme-ov-file">karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero (github.com)</a></li><li><a href="https://github.com/karpathy/nanoGPT">karpathy/nanoGPT: The simplest, fastest repository for training/finetuning medium-sized GPTs. (github.com)</a></li><li><a href="https://blog.csdn.net/weixin_44008424/article/details/110764494">pytorch笔记（一）——tensor的storage()、stride()、storage_offset（）_pytorch storage-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_46653437/article/details/108742525">PyTorch中张量的shape和stride的关系_shape和strides-CSDN博客</a></li><li><a href="http://blog.ezyang.com/2019/05/pytorch-internals/">PyTorch internals : ezyang’s blog</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;inspired by &lt;a href=&quot;https://github.com/karpathy/micrograd&quot;&gt;karpathy/micrograd: A tiny scalar-valued autograd engine and a neural net library on top of it with PyTorch-like API (github.com)&lt;/a&gt;and &lt;a href=&quot;https://nrehiew.github.io/blog/pytorch/&quot;&gt;Taking PyTorch for Granted | wh (nrehiew.github.io)&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;感谢Karpathy以及x上所有真心探讨技术的网友.这属于karpathy的&lt;a href=&quot;https://github.com/karpathy/nn-zero-to-hero?tab=readme-ov-file&quot;&gt;karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero ,(github.com)&lt;/a&gt;课程.事实上他还有很多值得一看的课程和repos.&lt;/p&gt;</summary>
    
    
    
    
    <category term="tensor" scheme="https://www.sekyoro.top/tags/tensor/"/>
    
  </entry>
  
  <entry>
    <title>i3wm,Neovim与Alacritty的使用与配置</title>
    <link href="https://www.sekyoro.top/2024/07/06/i3wm%E3%80%81Neovim%E4%B8%8EAlacritty%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.sekyoro.top/2024/07/06/i3wm%E3%80%81Neovim%E4%B8%8EAlacritty%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/</id>
    <published>2024-07-06T03:54:41.000Z</published>
    <updated>2024-07-06T15:11:39.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>常用的窗口管理器,编辑器与终端模拟器等等<br><span id="more"></span><br>这些工具都有相对的优劣,我个人觉得<strong>生态</strong>,<strong>稳定性</strong>是两个非常重要的因素. 生态好就会有不断的更新和维护,稳定性会让用户更好的长期适应.</p><h3 id="i3wm"><a href="#i3wm" class="headerlink" title="i3wm"></a>i3wm</h3><p>i3wm是个基于x11的窗口管理器,生态很强<a href="https://github.com/fz-wu/i3_user_guide_Chinese">fz-wu/i3_user_guide_Chinese: i3wm官方指南,方便同学们学习i3wm. i3是一个平铺式的窗口管理器 (github.com)</a></p><p><img data-src="https://i3wm.org/docs/modes.png" alt="Container modes"></p><p>类似的还有awesome wm,dwm,也有基于wayland的compositor hyprland(没有使用hyprland也是因为感觉还不太稳定,等过段时间再看看).详情看<a href="https://wiki.archlinux.org/title/Comparison_of_tiling_window_managers">Comparison of tiling window managers - ArchWiki (archlinux.org)</a>和<a href="https://wiki.archlinux.org/title/Wayland#Tiling">Wayland - ArchWiki (archlinux.org)</a></p><p>具体配置文档<a href="https://i3wm.org/docs/userguide.html#configuring">i3: i3 User’s Guide (i3wm.org)</a></p><p>一个例子<a href="https://github.com/levinit/i3wm-config/blob/master/i3/config">i3wm-config/i3/config at master · levinit/i3wm-config (github.com)</a></p><p>i3本身不支持透明等功能,还需要安装其他工具<a href="https://zocoxx.com/archlinux-i3wm.html">ArchLinux系统i3wm配置及体验记录 – ZocoXX</a>,<a href="https://levinit.github.io/i3wm-config/#:~:text=编辑 i3%2Fconfig 文件可切换模式。,随机模式：自动切换壁纸，将要用作壁纸的图片放到 ~%2FPictures%2Fwallpapers 即可。">i3wm-config | my i3wm config (levinit.github.io)</a></p><h3 id="awesomewm"><a href="#awesomewm" class="headerlink" title="awesomewm"></a>awesomewm</h3><p>使用lua配置,相对i3的文本配置,个人认为更友好,上手门槛更低.<a href="https://github.com/atsepkov/awesome-awesome-wm">atsepkov/awesome-awesome-wm: A curated list of awesome tools/scripts/configs for Awesome Window Manager. (github.com)</a>,除了本身窗口管理外,还有查看CPU资源,图片等工具需要额外安装.</p><p>所以比较方便的做法就是clone其他人的配置😅</p><p><strong>i3</strong></p><ul><li><a href="https://github.com/addy-dclxvi/i3-starterpack">addy-dclxvi/i3-starterpack: A simple guide (and example of configuration) to install i3 &amp; its and essentials packages, then make them look eye candy. (github.com)</a></li><li><a href="https://github.com/sainathadapa/i3-wm-config">sainathadapa/i3-wm-config: I3 tiling window manager configuration (github.com)</a></li><li><a href="https://github.com/levinit/i3wm-config">levinit/i3wm-config: my i3wm config (github.com)</a></li><li><a href="https://github.com/typecraft-dev/dotfiles">typecraft-dev/dotfiles (github.com)</a></li></ul><p><strong>awesome</strong></p><ul><li><a href="https://github.com/raven2cz/dotfiles">raven2cz/dotfiles: Dotfiles are the customization files in GNU/Linux. This repository assembly together all my others github config repos to one union. You can choose this global conf for your system or check other repos.</a></li><li><a href="https://github.com/pw4ever/awesome-wm-config">pw4ever/awesome-wm-config: awesome window manager config with persistent dynamic tagging (github.com)</a></li></ul><p><strong>hyprland</strong><a href="https://wiki.hyprland.org/Configuring/">Configuring – Hyprland Wiki</a></p><ul><li><a href="https://github.com/SolDoesTech/hyprland">SolDoesTech/hyprland: collection of dot config files for hyprland with a simple install script for a fresh Arch linux with yay (github.com)</a></li><li><a href="https://github.com/notwidow/hyprland">notwidow/hyprland: hyprland config (github.com)</a></li><li><a href="https://github.com/AhmedSaadi0/my-hyprland-config/blob/main/hyprland.conf">my-hyprland-config/hyprland.conf at main · AhmedSaadi0/my-hyprland-config (github.com)</a></li></ul><p>个人感觉还是hyprland的配置和文档好,但是使用上bug可能不少.</p><h3 id="Neovim"><a href="#Neovim" class="headerlink" title="Neovim"></a>Neovim</h3><p>基于vim的编辑器,更好地进行配置、安装插件.</p><p>主要是需要了解neovim的一些配置语法,如果为了方便直接使用lazyvim等配置即可.</p><p><a href="https://neovim.io/doc/user/lua-guide.html">Lua-guide - Neovim docs</a> neovim使用vim.*等变量替代了原本的vimscript,不过你依然可以使用vim.cmd执行vimscript,使用vim.fn执行函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim.cmd(<span class="string">&quot;colorscheme habamax&quot;</span>)</span><br><span class="line">vim.cmd.highlight(&#123; <span class="string">&quot;Error&quot;</span>, <span class="string">&quot;guibg=red&quot;</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(vim.fn.printf(<span class="string">&#x27;Hello from %s&#x27;</span>, <span class="string">&#x27;Lua&#x27;</span>))</span><br><span class="line"><span class="keyword">local</span> reversed_list = vim.fn.<span class="built_in">reverse</span>(&#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> &#125;)</span><br><span class="line">vim.<span class="built_in">print</span>(reversed_list) <span class="comment">-- &#123; &quot;c&quot;, &quot;b&quot;, &quot;a&quot; &#125;</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">print_stdout</span><span class="params">(chan_id, data, name)</span></span></span><br><span class="line">  <span class="built_in">print</span>(data[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.fn.jobstart(<span class="string">&#x27;ls&#x27;</span>, &#123; on_stdout = print_stdout &#125;)</span><br></pre></td></tr></table></figure><h4 id="vim-变量"><a href="#vim-变量" class="headerlink" title="vim.*变量"></a>vim.*变量</h4><p><a href="https://neovim.io/doc/user/lua.html#vim.g">vim.g</a>: global variables (<a href="https://neovim.io/doc/user/eval.html#g%3A">g:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.b">vim.b</a>: variables for the current buffer (<a href="https://neovim.io/doc/user/eval.html#b%3A">b:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.w">vim.w</a>: variables for the current window (<a href="https://neovim.io/doc/user/eval.html#w%3A">w:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.t">vim.t</a>: variables for the current tabpage (<a href="https://neovim.io/doc/user/eval.html#t%3A">t:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.v">vim.v</a>: predefined Vim variables (<a href="https://neovim.io/doc/user/eval.html#v%3A">v:</a>)</p><p><a href="https://neovim.io/doc/user/lua.html#vim.env">vim.env</a>: environment variables defined in the editor session</p><h4 id="设置options"><a href="#设置options" class="headerlink" title="设置options"></a>设置options</h4><p>options就是vim中的表现比如set smarttab</p><p>设置全局和本地选项（例如在 init.lua 中）最方便的方法是通过 vim.opt.<br>设置全局和本地选项最方便的方法是通过 vim.opt 和它的朋友们：<br>vim.opt: 行为类似于 :set<br>vim.opt_global: 行为类似于 :setglobal<br>vim.opt_local：行为类似于 :setlocal</p><h5 id="vim-opt"><a href="#vim-opt" class="headerlink" title="vim.opt"></a>vim.opt</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim.opt.smarttab = <span class="literal">true</span></span><br><span class="line">vim.opt.smarttab = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>代价是不能直接访问选项值，而必须<br>使用 vim.opt:get()：</p><h5 id="vim-o"><a href="#vim-o" class="headerlink" title="vim.o"></a>vim.o</h5><p>有一种更直接的类似变量的访问方式,使用 vim.o<br>vim.o：行为类似于 :set<br>vim.go：行为类似于 :setglobal<br>vim.bo：用于缓冲区选项<br>vim.wo：用于窗口的选项</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim.o.smarttab = <span class="literal">false</span> <span class="comment">-- :set nosmarttab</span></span><br><span class="line"><span class="built_in">print</span>(vim.o.smarttab)</span><br><span class="line"><span class="comment">--&gt; false</span></span><br><span class="line">vim.o.listchars = <span class="string">&#x27;space:_,tab:&gt;~&#x27;</span> <span class="comment">-- :set listchars=&#x27;space:_,tab:&gt;~&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(vim.o.listchars)</span><br><span class="line"><span class="comment">--&gt; &#x27;space:_,tab:&gt;~&#x27;</span></span><br><span class="line">vim.o.isfname = vim.o.isfname .. <span class="string">&#x27;,@-@&#x27;</span> <span class="comment">-- :set isfname+=@-@</span></span><br><span class="line"><span class="built_in">print</span>(vim.o.isfname)</span><br><span class="line"><span class="comment">--&gt; &#x27;@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@&#x27;</span></span><br><span class="line">vim.bo.shiftwidth = <span class="number">4</span> <span class="comment">-- :setlocal shiftwidth=4</span></span><br><span class="line"><span class="built_in">print</span>(vim.bo.shiftwidth)</span><br><span class="line"><span class="comment">--&gt; 4</span></span><br><span class="line">vim.bo[<span class="number">4</span>].expandtab = <span class="literal">true</span> <span class="comment">-- sets expandtab to true in buffer 4</span></span><br><span class="line">vim.wo.number = <span class="literal">true</span>       <span class="comment">-- sets number to true in current window</span></span><br><span class="line">vim.wo[<span class="number">0</span>].number = <span class="literal">true</span>    <span class="comment">-- same as above</span></span><br><span class="line">vim.wo[<span class="number">0</span>][<span class="number">0</span>].number = <span class="literal">true</span> <span class="comment">-- sets number to true in current buffer</span></span><br><span class="line">                           <span class="comment">-- in current window only</span></span><br><span class="line"><span class="built_in">print</span>(vim.wo[<span class="number">0</span>].number)    <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><h4 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h4><p>设置执行命令的快捷键.</p><p>可以使用 vim.keymap.set() 创建映射。该函数需要三个参数：<br>{mode} 是一个字符串或字符串表，包含映射生效的模式前缀。前缀是 :map-modes 中列出的前缀，或 :map! 中的”!”，或 :map 中的空字符串。<br>{lhs} 是一个字符串，包含应触发映射的键序列。<br>{rhs} 是包含 Vim 命令或 Lua 函数的字符串，当输入 {lhs} 时应执行该命令或函数。空字符串等同于 <Nop>，表示禁用按键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Normal mode mapping for Vim command</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Leader&gt;ex1&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;echo &quot;Example 1&quot;&lt;cr&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">-- Normal and Command-line mode mapping for Vim command</span></span><br><span class="line">vim.keymap.set(&#123;<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, <span class="string">&#x27;&lt;Leader&gt;ex2&#x27;</span>, <span class="string">&#x27;&lt;cmd&gt;echo &quot;Example 2&quot;&lt;cr&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">-- Normal mode mapping for Lua function</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Leader&gt;ex3&#x27;</span>, vim.treesitter.start)</span><br><span class="line"><span class="comment">-- Normal mode mapping for Lua function with arguments</span></span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;Leader&gt;ex4&#x27;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&#x27;Example 4&#x27;</span>) <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><h4 id="Autocommands"><a href="#Autocommands" class="headerlink" title="Autocommands"></a>Autocommands</h4><p>自动命令是一个 Vim 命令或一个 Lua 函数，每当触发一个或多个事件（如文件被打开）时就会自动执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  command = <span class="string">&quot;echo &#x27;Entering a C or C++ file&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">-- Same autocommand written with a Lua function instead</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123;<span class="string">&quot;BufEnter&quot;</span>, <span class="string">&quot;BufWinEnter&quot;</span>&#125;, &#123;</span><br><span class="line">  pattern = &#123;<span class="string">&quot;*.c&quot;</span>, <span class="string">&quot;*.h&quot;</span>&#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;Entering a C or C++ file&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">-- User event triggered by MyPlugin</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;User&quot;</span>, &#123;</span><br><span class="line">  pattern = <span class="string">&quot;MyPlugin&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;My Plugin Works!&quot;</span>) <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="User-commands"><a href="#User-commands" class="headerlink" title="User commands"></a>User commands</h4><p>用户命令可通过 nvim_create_user_command() 创建。该函数须要三个参数：<br>命令名称字符串（必须以大写字母开头，以区别于内置命令）；<br>一个包含 Vim 命令或 Lua 函数的字符串，命令调用时执行该字符串；<br>包含命令属性的表格；此外，它还可以包含关键字 desc（描述命令的字符串）、force（设置为 false 以避免替换已存在的同名命令）和 preview（用于 :command-preview 的 Lua 函数）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim.api.nvim_create_user_command(<span class="string">&#x27;Test&#x27;</span>, <span class="string">&#x27;echo &quot;It works!&quot;&#x27;</span>, &#123;&#125;)</span><br><span class="line">vim.cmd.Test()</span><br><span class="line"><span class="comment">--&gt; It works!</span></span><br></pre></td></tr></table></figure><p>可以使用lazyvim,lunarvim,Astrovim或者nvchad等配置文件,已经为我们配置好了很多东西.</p><h4 id="LazyVim"><a href="#LazyVim" class="headerlink" title="LazyVim"></a>LazyVim</h4><p><code>lazyvim</code>规定了每个lazyvim的库应该怎么编写,编写方式按照文档规定.<code>nvchad</code>,<code>astrovim</code>都是按照这种方式的.</p><p>默认keymaps<a href="https://www.lazyvim.org/keymaps">⌨️ Keymaps | LazyVim</a></p><p><a href="https://www.lazyvim.org/configuration/plugins">Plugins | LazyVim</a></p><p>拿Lazyvim举例,相当于packer.nvim等插件管理器的替代,<code>lazy.vim</code>中默认设置如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  root = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy&quot;</span>, <span class="comment">-- directory where plugins will be installed</span></span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- Set this to `true` to have all your plugins lazy-loaded by default.</span></span><br><span class="line">    <span class="comment">-- Only do this if you know what you are doing, as it can lead to unexpected behavior.</span></span><br><span class="line">    lazy = <span class="literal">false</span>, <span class="comment">-- should plugins be lazy-loaded?</span></span><br><span class="line">    <span class="comment">-- It&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your Neovim install.</span></span><br><span class="line">    version = <span class="literal">nil</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">    <span class="comment">-- default `cond` you can use to globally disable a lot of plugins</span></span><br><span class="line">    <span class="comment">-- when running inside vscode for example</span></span><br><span class="line">    cond = <span class="literal">nil</span>, <span class="comment">---@type boolean|fun(self:LazyPlugin):boolean|nil</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">-- leave nil when passing the spec as the first argument to setup()</span></span><br><span class="line">  spec = <span class="literal">nil</span>, <span class="comment">---@type LazySpec</span></span><br><span class="line">  local_spec = <span class="literal">true</span>, <span class="comment">-- load project specific .lazy.lua spec files. They will be added at the end of the spec.</span></span><br><span class="line">  lockfile = vim.fn.stdpath(<span class="string">&quot;config&quot;</span>) .. <span class="string">&quot;/lazy-lock.json&quot;</span>, <span class="comment">-- lockfile generated after running update.</span></span><br><span class="line">  <span class="comment">---@type number? limit the maximum amount of concurrent tasks</span></span><br><span class="line">  concurrency = jit.<span class="built_in">os</span>:<span class="built_in">find</span>(<span class="string">&quot;Windows&quot;</span>) <span class="keyword">and</span> (vim.uv.available_parallelism() * <span class="number">2</span>) <span class="keyword">or</span> <span class="literal">nil</span>,</span><br><span class="line">  git = &#123;</span><br><span class="line">    <span class="comment">-- defaults for the `Lazy log` command</span></span><br><span class="line">    <span class="comment">-- log = &#123; &quot;--since=3 days ago&quot; &#125;, -- show commits from the last 3 days</span></span><br><span class="line">    <span class="built_in">log</span> = &#123; <span class="string">&quot;-8&quot;</span> &#125;, <span class="comment">-- show the last 8 commits</span></span><br><span class="line">    timeout = <span class="number">120</span>, <span class="comment">-- kill processes that take more than 2 minutes</span></span><br><span class="line">    url_format = <span class="string">&quot;https://github.com/%s.git&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy.nvim requires git &gt;=2.19.0. If you really want to use lazy with an older version,</span></span><br><span class="line">    <span class="comment">-- then set the below to false. This should work, but is NOT supported and will</span></span><br><span class="line">    <span class="comment">-- increase downloads a lot.</span></span><br><span class="line">    filter = <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pkg = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>,</span><br><span class="line">    cache = vim.fn.stdpath(<span class="string">&quot;state&quot;</span>) .. <span class="string">&quot;/lazy/pkg-cache.lua&quot;</span>,</span><br><span class="line">    versions = <span class="literal">true</span>, <span class="comment">-- Honor versions in pkg sources</span></span><br><span class="line">    <span class="comment">-- the first package source that is found for a plugin will be used.</span></span><br><span class="line">    sources = &#123;</span><br><span class="line">      <span class="string">&quot;lazy&quot;</span>,</span><br><span class="line">      <span class="string">&quot;rockspec&quot;</span>,</span><br><span class="line">      <span class="string">&quot;packspec&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  rocks = &#123;</span><br><span class="line">    root = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy-rocks&quot;</span>,</span><br><span class="line">    server = <span class="string">&quot;https://nvim-neorocks.github.io/rocks-binaries/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  dev = &#123;</span><br><span class="line">    <span class="comment">---@type string | fun(plugin: LazyPlugin): string directory where you store your local plugin projects</span></span><br><span class="line">    <span class="built_in">path</span> = <span class="string">&quot;~/projects&quot;</span>,</span><br><span class="line">    <span class="comment">---@type string[] plugins that match these patterns will use your local versions instead of being fetched from GitHub</span></span><br><span class="line">    patterns = &#123;&#125;, <span class="comment">-- For example &#123;&quot;folke&quot;&#125;</span></span><br><span class="line">    fallback = <span class="literal">false</span>, <span class="comment">-- Fallback to git when local plugin doesn&#x27;t exist</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123;</span><br><span class="line">    <span class="comment">-- install missing plugins on startup. This doesn&#x27;t increase startup time.</span></span><br><span class="line">    missing = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">-- try to load one of these colorschemes when starting an installation during startup</span></span><br><span class="line">    colorscheme = &#123; <span class="string">&quot;habamax&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ui = &#123;</span><br><span class="line">    <span class="comment">-- a number &lt;1 is a percentage., &gt;1 is a fixed size</span></span><br><span class="line">    size = &#123; width = <span class="number">0.8</span>, height = <span class="number">0.8</span> &#125;,</span><br><span class="line">    <span class="built_in">wrap</span> = <span class="literal">true</span>, <span class="comment">-- wrap the lines in the ui</span></span><br><span class="line">    <span class="comment">-- The border to use for the UI window. Accepts same border values as |nvim_open_win()|.</span></span><br><span class="line">    border = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="comment">-- The backdrop opacity. 0 is fully opaque, 100 is fully transparent.</span></span><br><span class="line">    backdrop = <span class="number">60</span>,</span><br><span class="line">    title = <span class="literal">nil</span>, <span class="comment">---@type string only works when border is not &quot;none&quot;</span></span><br><span class="line">    title_pos = <span class="string">&quot;center&quot;</span>, <span class="comment">---@type &quot;center&quot; | &quot;left&quot; | &quot;right&quot;</span></span><br><span class="line">    <span class="comment">-- Show pills on top of the Lazy window</span></span><br><span class="line">    pills = <span class="literal">true</span>, <span class="comment">---@type boolean</span></span><br><span class="line">    icons = &#123;</span><br><span class="line">      cmd = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      <span class="built_in">config</span> = <span class="string">&quot;&quot;</span>,</span><br><span class="line">      event = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      favorite = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      ft = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      init = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      import = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      keys = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      lazy = <span class="string">&quot;󰒲 &quot;</span>,</span><br><span class="line">      <span class="built_in">loaded</span> = <span class="string">&quot;●&quot;</span>,</span><br><span class="line">      not_loaded = <span class="string">&quot;○&quot;</span>,</span><br><span class="line">      plugin = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      runtime = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      <span class="built_in">require</span> = <span class="string">&quot;󰢱 &quot;</span>,</span><br><span class="line">      source = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      start = <span class="string">&quot; &quot;</span>,</span><br><span class="line">      task = <span class="string">&quot;✔ &quot;</span>,</span><br><span class="line">      list = &#123;</span><br><span class="line">        <span class="string">&quot;●&quot;</span>,</span><br><span class="line">        <span class="string">&quot;➜&quot;</span>,</span><br><span class="line">        <span class="string">&quot;★&quot;</span>,</span><br><span class="line">        <span class="string">&quot;‒&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">-- leave nil, to automatically select a browser depending on your OS.</span></span><br><span class="line">    <span class="comment">-- If you want to use a specific browser, you can define it here</span></span><br><span class="line">    browser = <span class="literal">nil</span>, <span class="comment">---@type string?</span></span><br><span class="line">    throttle = <span class="number">20</span>, <span class="comment">-- how frequently should the ui process render events</span></span><br><span class="line">    custom_keys = &#123;</span><br><span class="line">      <span class="comment">-- You can define custom key maps here. If present, the description will</span></span><br><span class="line">      <span class="comment">-- be shown in the help menu.</span></span><br><span class="line">      <span class="comment">-- To disable one of the defaults, set it to false.</span></span><br><span class="line"></span><br><span class="line">      [<span class="string">&quot;&lt;localleader&gt;l&quot;</span>] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(plugin)</span></span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;lazy.util&quot;</span>).float_term(&#123; <span class="string">&quot;lazygit&quot;</span>, <span class="string">&quot;log&quot;</span> &#125;, &#123;</span><br><span class="line">            cwd = plugin.dir,</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">        desc = <span class="string">&quot;Open lazygit log&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      [<span class="string">&quot;&lt;localleader&gt;t&quot;</span>] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(plugin)</span></span></span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;lazy.util&quot;</span>).float_term(<span class="literal">nil</span>, &#123;</span><br><span class="line">            cwd = plugin.dir,</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">        desc = <span class="string">&quot;Open terminal in plugin dir&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  diff = &#123;</span><br><span class="line">    <span class="comment">-- diff command &lt;d&gt; can be one of:</span></span><br><span class="line">    <span class="comment">-- * browser: opens the github compare view. Note that this is always mapped to &lt;K&gt; as well,</span></span><br><span class="line">    <span class="comment">--   so you can have a different command for diff &lt;d&gt;</span></span><br><span class="line">    <span class="comment">-- * git: will run git diff and open a buffer with filetype git</span></span><br><span class="line">    <span class="comment">-- * terminal_git: will open a pseudo terminal with git diff</span></span><br><span class="line">    <span class="comment">-- * diffview.nvim: will open Diffview to show the diff</span></span><br><span class="line">    cmd = <span class="string">&quot;git&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  checker = &#123;</span><br><span class="line">    <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">    enabled = <span class="literal">false</span>,</span><br><span class="line">    concurrency = <span class="literal">nil</span>, <span class="comment">---@type number? set to 1 to check for updates very slowly</span></span><br><span class="line">    notify = <span class="literal">true</span>, <span class="comment">-- get a notification when new updates are found</span></span><br><span class="line">    frequency = <span class="number">3600</span>, <span class="comment">-- check for updates every hour</span></span><br><span class="line">    check_pinned = <span class="literal">false</span>, <span class="comment">-- check for pinned packages that can&#x27;t be updated</span></span><br><span class="line">  &#125;,</span><br><span class="line">  change_detection = &#123;</span><br><span class="line">    <span class="comment">-- automatically check for config file changes and reload the ui</span></span><br><span class="line">    enabled = <span class="literal">true</span>,</span><br><span class="line">    notify = <span class="literal">true</span>, <span class="comment">-- get a notification when changes are found</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance = &#123;</span><br><span class="line">    cache = &#123;</span><br><span class="line">      enabled = <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    reset_packpath = <span class="literal">true</span>, <span class="comment">-- reset the package path to improve startup time</span></span><br><span class="line">    rtp = &#123;</span><br><span class="line">      reset = <span class="literal">true</span>, <span class="comment">-- reset the runtime path to $VIMRUNTIME and your config directory</span></span><br><span class="line">      <span class="comment">---@type string[]</span></span><br><span class="line">      paths = &#123;&#125;, <span class="comment">-- add any custom paths here that you want to includes in the rtp</span></span><br><span class="line">      <span class="comment">---@type string[] list any plugins you want to disable here</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="comment">-- &quot;gzip&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwPlugin&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;tarPlugin&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;tohtml&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;tutor&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;zipPlugin&quot;,</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">-- lazy can generate helptags from the headings in markdown readme files,</span></span><br><span class="line">  <span class="comment">-- so :help works even for plugins that don&#x27;t have vim docs.</span></span><br><span class="line">  <span class="comment">-- when the readme opens with :help it will be correctly displayed as markdown</span></span><br><span class="line">  readme = &#123;</span><br><span class="line">    enabled = <span class="literal">true</span>,</span><br><span class="line">    root = vim.fn.stdpath(<span class="string">&quot;state&quot;</span>) .. <span class="string">&quot;/lazy/readme&quot;</span>,</span><br><span class="line">    files = &#123; <span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;lua/**/README.md&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">-- only generate markdown helptags for plugins that dont have docs</span></span><br><span class="line">    skip_if_doc_exists = <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  state = vim.fn.stdpath(<span class="string">&quot;state&quot;</span>) .. <span class="string">&quot;/lazy/state.json&quot;</span>, <span class="comment">-- state info for checker and other things</span></span><br><span class="line">  <span class="comment">-- Enable profiling of lazy.nvim. This will add some overhead,</span></span><br><span class="line">  <span class="comment">-- so only enable this when you are debugging lazy.nvim</span></span><br><span class="line">  profiling = &#123;</span><br><span class="line">    <span class="comment">-- Enables extra stats on the debug tab related to the loader cache.</span></span><br><span class="line">    <span class="comment">-- Additionally gathers stats about all package.loaders</span></span><br><span class="line">    loader = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- Track each new require in the Lazy profiling tab</span></span><br><span class="line">    <span class="built_in">require</span> = <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options.lua</code>中配置了一些全局变量以及vim许多属性.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This file is automatically loaded by plugins.core</span></span><br><span class="line">vim.g.mapleader = <span class="string">&quot; &quot;</span></span><br><span class="line">vim.g.maplocalleader = <span class="string">&quot;\\&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim auto format</span></span><br><span class="line">vim.g.autoformat = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim picker to use.</span></span><br><span class="line"><span class="comment">-- Can be one of: telescope, fzf</span></span><br><span class="line"><span class="comment">-- Leave it to &quot;auto&quot; to automatically use the picker</span></span><br><span class="line"><span class="comment">-- enabled with `:LazyExtras`</span></span><br><span class="line">vim.g.lazyvim_picker = <span class="string">&quot;auto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim root dir detection</span></span><br><span class="line"><span class="comment">-- Each entry can be:</span></span><br><span class="line"><span class="comment">-- * the name of a detector function like `lsp` or `cwd`</span></span><br><span class="line"><span class="comment">-- * a pattern or array of patterns like `.git` or `lua`.</span></span><br><span class="line"><span class="comment">-- * a function with signature `function(buf) -&gt; string|string[]`</span></span><br><span class="line">vim.g.root_spec = &#123; <span class="string">&quot;lsp&quot;</span>, &#123; <span class="string">&quot;.git&quot;</span>, <span class="string">&quot;lua&quot;</span> &#125;, <span class="string">&quot;cwd&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LazyVim automatically configures lazygit:</span></span><br><span class="line"><span class="comment">--  * theme, based on the active colorscheme.</span></span><br><span class="line"><span class="comment">--  * editorPreset to nvim-remote</span></span><br><span class="line"><span class="comment">--  * enables nerd font icons</span></span><br><span class="line"><span class="comment">-- Set to false to disable.</span></span><br><span class="line">vim.g.lazygit_config = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Options for the LazyVim statuscolumn</span></span><br><span class="line">vim.g.lazyvim_statuscolumn = &#123;</span><br><span class="line">  folds_open = <span class="literal">false</span>, <span class="comment">-- show fold sign when fold is open</span></span><br><span class="line">  folds_githl = <span class="literal">false</span>, <span class="comment">-- highlight fold sign with git sign color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Optionally setup the terminal to use</span></span><br><span class="line"><span class="comment">-- This sets `vim.o.shell` and does some additional configuration for:</span></span><br><span class="line"><span class="comment">-- * pwsh</span></span><br><span class="line"><span class="comment">-- * powershell</span></span><br><span class="line"><span class="comment">-- LazyVim.terminal.setup(&quot;pwsh&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hide deprecation warnings</span></span><br><span class="line">vim.g.deprecation_warnings = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set filetype to `bigfile` for files larger than 1.5 MB</span></span><br><span class="line"><span class="comment">-- Only vim syntax will be enabled (with the correct filetype)</span></span><br><span class="line"><span class="comment">-- LSP, treesitter and other ft plugins will be disabled.</span></span><br><span class="line"><span class="comment">-- mini.animate will also be disabled.</span></span><br><span class="line">vim.g.bigfile_size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1.5</span> <span class="comment">-- 1.5 MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Show the current document symbols location from Trouble in lualine</span></span><br><span class="line">vim.g.trouble_lualine = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"></span><br><span class="line">opt.autowrite = <span class="literal">true</span> <span class="comment">-- Enable auto write</span></span><br><span class="line"><span class="comment">-- only set clipboard if not in ssh, to make sure the OSC 52</span></span><br><span class="line"><span class="comment">-- integration works automatically. Requires Neovim &gt;= 0.10.0</span></span><br><span class="line">opt.clipboard = vim.env.SSH_TTY <span class="keyword">and</span> <span class="string">&quot;&quot;</span> <span class="keyword">or</span> <span class="string">&quot;unnamedplus&quot;</span> <span class="comment">-- Sync with system clipboard</span></span><br><span class="line">opt.completeopt = <span class="string">&quot;menu,menuone,noselect&quot;</span></span><br><span class="line">opt.conceallevel = <span class="number">2</span> <span class="comment">-- Hide * markup for bold and italic, but not markers with substitutions</span></span><br><span class="line">opt.confirm = <span class="literal">true</span> <span class="comment">-- Confirm to save changes before exiting modified buffer</span></span><br><span class="line">opt.cursorline = <span class="literal">true</span> <span class="comment">-- Enable highlighting of the current line</span></span><br><span class="line">opt.expandtab = <span class="literal">true</span> <span class="comment">-- Use spaces instead of tabs</span></span><br><span class="line">opt.fillchars = &#123;</span><br><span class="line">  foldopen = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  foldclose = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  fold = <span class="string">&quot; &quot;</span>,</span><br><span class="line">  foldsep = <span class="string">&quot; &quot;</span>,</span><br><span class="line">  diff = <span class="string">&quot;╱&quot;</span>,</span><br><span class="line">  eob = <span class="string">&quot; &quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">opt.foldlevel = <span class="number">99</span></span><br><span class="line">opt.formatexpr = <span class="string">&quot;v:lua.require&#x27;lazyvim.util&#x27;.format.formatexpr()&quot;</span></span><br><span class="line">opt.formatoptions = <span class="string">&quot;jcroqlnt&quot;</span> <span class="comment">-- tcqj</span></span><br><span class="line">opt.grepformat = <span class="string">&quot;%f:%l:%c:%m&quot;</span></span><br><span class="line">opt.grepprg = <span class="string">&quot;rg --vimgrep&quot;</span></span><br><span class="line">opt.ignorecase = <span class="literal">true</span> <span class="comment">-- Ignore case</span></span><br><span class="line">opt.inccommand = <span class="string">&quot;nosplit&quot;</span> <span class="comment">-- preview incremental substitute</span></span><br><span class="line">opt.jumpoptions = <span class="string">&quot;view&quot;</span></span><br><span class="line">opt.laststatus = <span class="number">3</span> <span class="comment">-- global statusline</span></span><br><span class="line">opt.linebreak = <span class="literal">true</span> <span class="comment">-- Wrap lines at convenient points</span></span><br><span class="line">opt.list = <span class="literal">true</span> <span class="comment">-- Show some invisible characters (tabs...</span></span><br><span class="line">opt.mouse = <span class="string">&quot;a&quot;</span> <span class="comment">-- Enable mouse mode</span></span><br><span class="line">opt.number = <span class="literal">true</span> <span class="comment">-- Print line number</span></span><br><span class="line">opt.pumblend = <span class="number">10</span> <span class="comment">-- Popup blend</span></span><br><span class="line">opt.pumheight = <span class="number">10</span> <span class="comment">-- Maximum number of entries in a popup</span></span><br><span class="line">opt.relativenumber = <span class="literal">true</span> <span class="comment">-- Relative line numbers</span></span><br><span class="line">opt.scrolloff = <span class="number">4</span> <span class="comment">-- Lines of context</span></span><br><span class="line">opt.sessionoptions = &#123; <span class="string">&quot;buffers&quot;</span>, <span class="string">&quot;curdir&quot;</span>, <span class="string">&quot;tabpages&quot;</span>, <span class="string">&quot;winsize&quot;</span>, <span class="string">&quot;help&quot;</span>, <span class="string">&quot;globals&quot;</span>, <span class="string">&quot;skiprtp&quot;</span>, <span class="string">&quot;folds&quot;</span> &#125;</span><br><span class="line">opt.shiftround = <span class="literal">true</span> <span class="comment">-- Round indent</span></span><br><span class="line">opt.shiftwidth = <span class="number">2</span> <span class="comment">-- Size of an indent</span></span><br><span class="line">opt.shortmess:append(&#123; W = <span class="literal">true</span>, I = <span class="literal">true</span>, c = <span class="literal">true</span>, C = <span class="literal">true</span> &#125;)</span><br><span class="line">opt.showmode = <span class="literal">false</span> <span class="comment">-- Dont show mode since we have a statusline</span></span><br><span class="line">opt.sidescrolloff = <span class="number">8</span> <span class="comment">-- Columns of context</span></span><br><span class="line">opt.signcolumn = <span class="string">&quot;yes&quot;</span> <span class="comment">-- Always show the signcolumn, otherwise it would shift the text each time</span></span><br><span class="line">opt.smartcase = <span class="literal">true</span> <span class="comment">-- Don&#x27;t ignore case with capitals</span></span><br><span class="line">opt.smartindent = <span class="literal">true</span> <span class="comment">-- Insert indents automatically</span></span><br><span class="line">opt.spelllang = &#123; <span class="string">&quot;en&quot;</span> &#125;</span><br><span class="line">opt.spelloptions:append(<span class="string">&quot;noplainbuffer&quot;</span>)</span><br><span class="line">opt.splitbelow = <span class="literal">true</span> <span class="comment">-- Put new windows below current</span></span><br><span class="line">opt.splitkeep = <span class="string">&quot;screen&quot;</span></span><br><span class="line">opt.splitright = <span class="literal">true</span> <span class="comment">-- Put new windows right of current</span></span><br><span class="line">opt.statuscolumn = <span class="string">[[%!v:lua.require&#x27;lazyvim.util&#x27;.ui.statuscolumn()]]</span></span><br><span class="line">opt.tabstop = <span class="number">2</span> <span class="comment">-- Number of spaces tabs count for</span></span><br><span class="line">opt.termguicolors = <span class="literal">true</span> <span class="comment">-- True color support</span></span><br><span class="line">opt.timeoutlen = vim.g.vscode <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">or</span> <span class="number">300</span> <span class="comment">-- Lower than default (1000) to quickly trigger which-key</span></span><br><span class="line">opt.undofile = <span class="literal">true</span></span><br><span class="line">opt.undolevels = <span class="number">10000</span></span><br><span class="line">opt.updatetime = <span class="number">200</span> <span class="comment">-- Save swap file and trigger CursorHold</span></span><br><span class="line">opt.virtualedit = <span class="string">&quot;block&quot;</span> <span class="comment">-- Allow cursor to move where there is no text in visual block mode</span></span><br><span class="line">opt.wildmode = <span class="string">&quot;longest:full,full&quot;</span> <span class="comment">-- Command-line completion mode</span></span><br><span class="line">opt.winminwidth = <span class="number">5</span> <span class="comment">-- Minimum window width</span></span><br><span class="line">opt.<span class="built_in">wrap</span> = <span class="literal">false</span> <span class="comment">-- Disable line wrap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> vim.fn.has(<span class="string">&quot;nvim-0.10&quot;</span>) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  opt.smoothscroll = <span class="literal">true</span></span><br><span class="line">  opt.foldexpr = <span class="string">&quot;v:lua.require&#x27;lazyvim.util&#x27;.ui.foldexpr()&quot;</span></span><br><span class="line">  opt.foldmethod = <span class="string">&quot;expr&quot;</span></span><br><span class="line">  opt.foldtext = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  opt.foldmethod = <span class="string">&quot;indent&quot;</span></span><br><span class="line">  opt.foldtext = <span class="string">&quot;v:lua.require&#x27;lazyvim.util&#x27;.ui.foldtext()&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fix markdown indentation settings</span></span><br><span class="line">vim.g.markdown_recommended_style = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>自定义的一些keymap如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This file is automatically loaded by lazyvim.config.init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- DO NOT USE `LazyVim.safe_keymap_set` IN YOUR OWN CONFIG!!</span></span><br><span class="line"><span class="comment">-- use `vim.keymap.set` instead</span></span><br><span class="line"><span class="keyword">local</span> map = LazyVim.safe_keymap_set</span><br><span class="line"></span><br><span class="line"><span class="comment">-- better up/down</span></span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gj&#x27; : &#x27;j&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Down&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;&lt;Down&gt;&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gj&#x27; : &#x27;j&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Down&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gk&#x27; : &#x27;k&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Up&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">map(&#123; <span class="string">&quot;n&quot;</span>, <span class="string">&quot;x&quot;</span> &#125;, <span class="string">&quot;&lt;Up&gt;&quot;</span>, <span class="string">&quot;v:count == 0 ? &#x27;gk&#x27; : &#x27;k&#x27;&quot;</span>, &#123; desc = <span class="string">&quot;Up&quot;</span>, expr = <span class="literal">true</span>, silent = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Move to window using the &lt;ctrl&gt; hjkl keys</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-h&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;h&quot;</span>, &#123; desc = <span class="string">&quot;Go to Left Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-j&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;j&quot;</span>, &#123; desc = <span class="string">&quot;Go to Lower Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-k&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;k&quot;</span>, &#123; desc = <span class="string">&quot;Go to Upper Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-l&gt;&quot;</span>, <span class="string">&quot;&lt;C-w&gt;l&quot;</span>, &#123; desc = <span class="string">&quot;Go to Right Window&quot;</span>, remap = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Resize window using &lt;ctrl&gt; arrow keys</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Up&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;resize +2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Increase Window Height&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Down&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;resize -2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Decrease Window Height&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Left&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;vertical resize -2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Decrease Window Width&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;C-Right&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;vertical resize +2&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Increase Window Width&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Move Lines</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;A-j&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;m .+1&lt;cr&gt;==&quot;</span>, &#123; desc = <span class="string">&quot;Move Down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;A-k&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;m .-2&lt;cr&gt;==&quot;</span>, &#123; desc = <span class="string">&quot;Move Up&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;A-j&gt;&quot;</span>, <span class="string">&quot;&lt;esc&gt;&lt;cmd&gt;m .+1&lt;cr&gt;==gi&quot;</span>, &#123; desc = <span class="string">&quot;Move Down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;&lt;A-k&gt;&quot;</span>, <span class="string">&quot;&lt;esc&gt;&lt;cmd&gt;m .-2&lt;cr&gt;==gi&quot;</span>, &#123; desc = <span class="string">&quot;Move Up&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;A-j&gt;&quot;</span>, <span class="string">&quot;:m &#x27;&gt;+1&lt;cr&gt;gv=gv&quot;</span>, &#123; desc = <span class="string">&quot;Move Down&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;A-k&gt;&quot;</span>, <span class="string">&quot;:m &#x27;&lt;-2&lt;cr&gt;gv=gv&quot;</span>, &#123; desc = <span class="string">&quot;Move Up&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- buffers</span></span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-h&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bprevious&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Prev Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;S-l&gt;&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bnext&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Next Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;[b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bprevious&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Prev Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;]b&quot;</span>, <span class="string">&quot;&lt;cmd&gt;bnext&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Next Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;bb&quot;</span>, <span class="string">&quot;&lt;cmd&gt;e #&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Switch to Other Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;`&quot;</span>, <span class="string">&quot;&lt;cmd&gt;e #&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Switch to Other Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;bd&quot;</span>, LazyVim.ui.bufremove, &#123; desc = <span class="string">&quot;Delete Buffer&quot;</span> &#125;)</span><br><span class="line">map(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;&lt;leader&gt;bD&quot;</span>, <span class="string">&quot;&lt;cmd&gt;:bd&lt;cr&gt;&quot;</span>, &#123; desc = <span class="string">&quot;Delete Buffer and Window&quot;</span> &#125;)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>autocmd.lua</code>如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This file is automatically loaded by lazyvim.config.init.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">augroup</span><span class="params">(name)</span></span></span><br><span class="line">  <span class="keyword">return</span> vim.api.nvim_create_augroup(<span class="string">&quot;lazyvim_&quot;</span> .. name, &#123; clear = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check if we need to reload the file when it changed</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FocusGained&quot;</span>, <span class="string">&quot;TermClose&quot;</span>, <span class="string">&quot;TermLeave&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;checktime&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> vim.o.buftype ~= <span class="string">&quot;nofile&quot;</span> <span class="keyword">then</span></span><br><span class="line">      vim.cmd(<span class="string">&quot;checktime&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Highlight on yank</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;TextYankPost&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;highlight_yank&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.highlight.on_yank()</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- resize splits if window got resized</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;VimResized&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;resize_splits&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> current_tab = vim.fn.tabpagenr()</span><br><span class="line">    vim.cmd(<span class="string">&quot;tabdo wincmd =&quot;</span>)</span><br><span class="line">    vim.cmd(<span class="string">&quot;tabnext &quot;</span> .. current_tab)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- go to last loc when opening a buffer</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;BufReadPost&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;last_loc&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    <span class="keyword">local</span> exclude = &#123; <span class="string">&quot;gitcommit&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">local</span> buf = event.buf</span><br><span class="line">    <span class="keyword">if</span> vim.tbl_contains(exclude, vim.bo[buf].filetype) <span class="keyword">or</span> vim.b[buf].lazyvim_last_loc <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    vim.b[buf].lazyvim_last_loc = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">local</span> mark = vim.api.nvim_buf_get_mark(buf, <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">    <span class="keyword">local</span> lcount = vim.api.nvim_buf_line_count(buf)</span><br><span class="line">    <span class="keyword">if</span> mark[<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> mark[<span class="number">1</span>] &lt;= lcount <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">pcall</span>(vim.api.nvim_win_set_cursor, <span class="number">0</span>, mark)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- close some filetypes with &lt;q&gt;</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;FileType&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;close_with_q&quot;</span>),</span><br><span class="line">  pattern = &#123;</span><br><span class="line">    <span class="string">&quot;PlenaryTestPopup&quot;</span>,</span><br><span class="line">    <span class="string">&quot;help&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lspinfo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;notify&quot;</span>,</span><br><span class="line">    <span class="string">&quot;qf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;spectre_panel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;startuptime&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tsplayground&quot;</span>,</span><br><span class="line">    <span class="string">&quot;neotest-output&quot;</span>,</span><br><span class="line">    <span class="string">&quot;checkhealth&quot;</span>,</span><br><span class="line">    <span class="string">&quot;neotest-summary&quot;</span>,</span><br><span class="line">    <span class="string">&quot;neotest-output-panel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dbout&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gitsigns.blame&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    vim.bo[event.buf].buflisted = <span class="literal">false</span></span><br><span class="line">    vim.keymap.set(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;&lt;cmd&gt;close&lt;cr&gt;&quot;</span>, &#123; buffer = event.buf, silent = <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- make it easier to close man-files when opened inline</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;FileType&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;man_unlisted&quot;</span>),</span><br><span class="line">  pattern = &#123; <span class="string">&quot;man&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    vim.bo[event.buf].buflisted = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- wrap and check for spell in text filetypes</span></span><br><span class="line">vim.api.nvim_create_autocmd(<span class="string">&quot;FileType&quot;</span>, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;wrap_spell&quot;</span>),</span><br><span class="line">  pattern = &#123; <span class="string">&quot;*.txt&quot;</span>, <span class="string">&quot;*.tex&quot;</span>, <span class="string">&quot;*.typ&quot;</span>, <span class="string">&quot;gitcommit&quot;</span>, <span class="string">&quot;markdown&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.opt_local.<span class="built_in">wrap</span> = <span class="literal">true</span></span><br><span class="line">    vim.opt_local.spell = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fix conceallevel for json files</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FileType&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;json_conceal&quot;</span>),</span><br><span class="line">  pattern = &#123; <span class="string">&quot;json&quot;</span>, <span class="string">&quot;jsonc&quot;</span>, <span class="string">&quot;json5&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.opt_local.conceallevel = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Auto create dir when saving a file, in case some intermediate directory does not exist</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;BufWritePre&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;auto_create_dir&quot;</span>),</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span></span><br><span class="line">    <span class="keyword">if</span> event.<span class="built_in">match</span>:<span class="built_in">match</span>(<span class="string">&quot;^%w%w+:[\\/][\\/]&quot;</span>) <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> file = vim.uv.fs_realpath(event.<span class="built_in">match</span>) <span class="keyword">or</span> event.<span class="built_in">match</span></span><br><span class="line">    vim.fn.mkdir(vim.fn.fnamemodify(file, <span class="string">&quot;:p:h&quot;</span>), <span class="string">&quot;p&quot;</span>)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.filetype.add(&#123;</span><br><span class="line">  pattern = &#123;</span><br><span class="line">    [<span class="string">&quot;.*&quot;</span>] = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span><span class="params">(path, buf)</span></span></span><br><span class="line">        <span class="keyword">return</span> vim.bo[buf]</span><br><span class="line">            <span class="keyword">and</span> vim.bo[buf].filetype ~= <span class="string">&quot;bigfile&quot;</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">path</span></span><br><span class="line">            <span class="keyword">and</span> vim.fn.getfsize(<span class="built_in">path</span>) &gt; vim.g.bigfile_size</span><br><span class="line">            <span class="keyword">and</span> <span class="string">&quot;bigfile&quot;</span></span><br><span class="line">          <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">end</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FileType&quot;</span> &#125;, &#123;</span><br><span class="line">  group = augroup(<span class="string">&quot;bigfile&quot;</span>),</span><br><span class="line">  pattern = <span class="string">&quot;bigfile&quot;</span>,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">(ev)</span></span></span><br><span class="line">    vim.b.minianimate_disable = <span class="literal">true</span></span><br><span class="line">    vim.schedule(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      vim.bo[ev.buf].syntax = vim.filetype.<span class="built_in">match</span>(&#123; buf = ev.buf &#125;) <span class="keyword">or</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="如何配置Lazyvim"><a href="#如何配置Lazyvim" class="headerlink" title="如何配置Lazyvim"></a>如何配置Lazyvim</h5><p>lazyvim的官方建议:</p><ol><li>文件结构如下,可以在plugins文件夹中设置</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/.config/nvim</span><br><span class="line">├── <span class="keyword">lua</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── lazy.<span class="keyword">lua</span></span><br><span class="line">│   └── plugins</span><br><span class="line">│       ├── spec1.<span class="keyword">lua</span></span><br><span class="line">│       ├── **</span><br><span class="line">│       └── spec2.<span class="keyword">lua</span></span><br><span class="line">└── init.<span class="keyword">lua</span></span><br></pre></td></tr></table></figure><p>默认的<code>lazy.lua</code>大概长下面这样,通过lazy.lua修改一些简单配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy/lazy.nvim&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (vim.uv <span class="keyword">or</span> vim.loop).fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> lazyrepo = <span class="string">&quot;https://github.com/folke/lazy.nvim.git&quot;</span></span><br><span class="line">  <span class="keyword">local</span> out = vim.fn.system(&#123; <span class="string">&quot;git&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;--filter=blob:none&quot;</span>, <span class="string">&quot;--branch=stable&quot;</span>, lazyrepo, lazypath &#125;)</span><br><span class="line">  <span class="keyword">if</span> vim.v.shell_error ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    vim.api.nvim_echo(&#123;</span><br><span class="line">      &#123; <span class="string">&quot;Failed to clone lazy.nvim:\n&quot;</span>, <span class="string">&quot;ErrorMsg&quot;</span> &#125;,</span><br><span class="line">      &#123; out, <span class="string">&quot;WarningMsg&quot;</span> &#125;,</span><br><span class="line">      &#123; <span class="string">&quot;\nPress any key to exit...&quot;</span> &#125;,</span><br><span class="line">    &#125;, <span class="literal">true</span>, &#123;&#125;)</span><br><span class="line">    vim.fn.getchar()</span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">exit</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(&#123;</span><br><span class="line">  spec = &#123;</span><br><span class="line">    <span class="comment">-- add LazyVim and import its plugins</span></span><br><span class="line">    &#123; <span class="string">&quot;LazyVim/LazyVim&quot;</span>, import = <span class="string">&quot;lazyvim.plugins&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">-- import/override with your plugins</span></span><br><span class="line">    &#123; import = <span class="string">&quot;plugins&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  defaults = &#123;</span><br><span class="line">    <span class="comment">-- By default, only LazyVim plugins will be lazy-loaded. Your custom plugins will load during startup.</span></span><br><span class="line">    <span class="comment">-- If you know what you&#x27;re doing, you can set this to `true` to have all your custom plugins lazy-loaded by default.</span></span><br><span class="line">    lazy = <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">-- It&#x27;s recommended to leave version=false for now, since a lot the plugin that support versioning,</span></span><br><span class="line">    <span class="comment">-- have outdated releases, which may break your Neovim install.</span></span><br><span class="line">    version = <span class="literal">false</span>, <span class="comment">-- always use the latest git commit</span></span><br><span class="line">    <span class="comment">-- version = &quot;*&quot;, -- try installing the latest stable version for plugins that support semver</span></span><br><span class="line">  &#125;,</span><br><span class="line">  install = &#123; colorscheme = &#123; <span class="string">&quot;tokyonight&quot;</span>, <span class="string">&quot;habamax&quot;</span> &#125; &#125;,</span><br><span class="line">  checker = &#123; enabled = <span class="literal">true</span> &#125;, <span class="comment">-- automatically check for plugin updates</span></span><br><span class="line">  performance = &#123;</span><br><span class="line">    rtp = &#123;</span><br><span class="line">      <span class="comment">-- disable some rtp plugins</span></span><br><span class="line">      disabled_plugins = &#123;</span><br><span class="line">        <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">        <span class="comment">-- &quot;matchit&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;matchparen&quot;,</span></span><br><span class="line">        <span class="comment">-- &quot;netrwPlugin&quot;,</span></span><br><span class="line">        <span class="string">&quot;tarPlugin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tohtml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tutor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zipPlugin&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="pugin-spec"><a href="#pugin-spec" class="headerlink" title="pugin spec"></a>pugin spec</h5><p>可以这样修改插件的一些选项<a href="https://lazy.folke.io/spec">🔌 Plugin Spec | lazy.nvim (folke.io)</a></p><p>此外通过plugin spec下载或者更改插件的配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="comment">-- the colorscheme should be available when starting Neovim</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;folke/tokyonight.nvim&quot;</span>,</span><br><span class="line">    lazy = <span class="literal">false</span>, <span class="comment">-- make sure we load this during startup if it is your main colorscheme</span></span><br><span class="line">    priority = <span class="number">1000</span>, <span class="comment">-- make sure to load this before all the other start plugins</span></span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="comment">-- load the colorscheme here</span></span><br><span class="line">      vim.cmd(<span class="string">[[colorscheme tokyonight]]</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- I have a separate config.mappings file where I require which-key.</span></span><br><span class="line">  <span class="comment">-- With lazy the plugin will be automatically loaded when it is required somewhere</span></span><br><span class="line">  &#123; <span class="string">&quot;folke/which-key.nvim&quot;</span>, lazy = <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;nvim-neorg/neorg&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy-load on filetype</span></span><br><span class="line">    ft = <span class="string">&quot;norg&quot;</span>,</span><br><span class="line">    <span class="comment">-- options for neorg. This will automatically call `require(&quot;neorg&quot;).setup(opts)`</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="built_in">load</span> = &#123;</span><br><span class="line">        [<span class="string">&quot;core.defaults&quot;</span>] = &#123;&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dstein64/vim-startuptime&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy-load on a command</span></span><br><span class="line">    cmd = <span class="string">&quot;StartupTime&quot;</span>,</span><br><span class="line">    <span class="comment">-- init is called during startup. Configuration for vim plugins typically should be set in an init function</span></span><br><span class="line">    init = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      vim.g.startuptime_tries = <span class="number">10</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;hrsh7th/nvim-cmp&quot;</span>,</span><br><span class="line">    <span class="comment">-- load cmp on InsertEnter</span></span><br><span class="line">    event = <span class="string">&quot;InsertEnter&quot;</span>,</span><br><span class="line">    <span class="comment">-- these dependencies will only be loaded when cmp loads</span></span><br><span class="line">    <span class="comment">-- dependencies are always lazy-loaded unless specified otherwise</span></span><br><span class="line">    dependencies = &#123;</span><br><span class="line">      <span class="string">&quot;hrsh7th/cmp-nvim-lsp&quot;</span>,</span><br><span class="line">      <span class="string">&quot;hrsh7th/cmp-buffer&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- if some code requires a module from an unloaded plugin, it will be automatically loaded.</span></span><br><span class="line">  <span class="comment">-- So for api plugins like devicons, we can always set lazy=true</span></span><br><span class="line">  &#123; <span class="string">&quot;nvim-tree/nvim-web-devicons&quot;</span>, lazy = <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- you can use the VeryLazy event for things that can</span></span><br><span class="line">  <span class="comment">-- load later and are not important for the initial UI</span></span><br><span class="line">  &#123; <span class="string">&quot;stevearc/dressing.nvim&quot;</span>, event = <span class="string">&quot;VeryLazy&quot;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Wansmer/treesj&quot;</span>,</span><br><span class="line">    keys = &#123;</span><br><span class="line">      &#123; <span class="string">&quot;J&quot;</span>, <span class="string">&quot;&lt;cmd&gt;TSJToggle&lt;cr&gt;&quot;</span>, desc = <span class="string">&quot;Join Toggle&quot;</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    opts = &#123; use_default_keymaps = <span class="literal">false</span>, max_join_length = <span class="number">150</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;monaqa/dial.nvim&quot;</span>,</span><br><span class="line">    <span class="comment">-- lazy-load on keys</span></span><br><span class="line">    <span class="comment">-- mode is `n` by default. For more advanced options, check the section on key mappings</span></span><br><span class="line">    keys = &#123; <span class="string">&quot;&lt;C-a&gt;&quot;</span>, &#123; <span class="string">&quot;&lt;C-x&gt;&quot;</span>, mode = <span class="string">&quot;n&quot;</span> &#125; &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- local plugins need to be explicitly configured with dir</span></span><br><span class="line">  &#123; dir = <span class="string">&quot;~/projects/secret.nvim&quot;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- you can use a custom url to fetch a plugin</span></span><br><span class="line">  &#123; url = <span class="string">&quot;git@github.com:folke/noice.nvim.git&quot;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- local plugins can also be configured with the dev option.</span></span><br><span class="line">  <span class="comment">-- This will use &#123;config.dev.path&#125;/noice.nvim/ instead of fetching it from GitHub</span></span><br><span class="line">  <span class="comment">-- With the dev option, you can easily switch between the local and installed version of a plugin</span></span><br><span class="line">  &#123; <span class="string">&quot;folke/noice.nvim&quot;</span>, dev = <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><strong>[1]</strong></td><td><code>string?</code></td><td>Short plugin url. Will be expanded using <a href="https://lazy.folke.io/configuration"><code>config.git.url_format</code></a>. Can also be a <code>url</code> or <code>dir</code>.</td></tr><tr><td><strong>dependencies</strong></td><td><code>LazySpec[]</code></td><td>A list of plugin names or plugin specs that should be loaded when the plugin loads. Dependencies are always lazy-loaded unless specified otherwise. When specifying a name, make sure the plugin spec has been defined somewhere else.</td></tr><tr><td><strong>enabled</strong></td><td><code>boolean?</code> or <code>fun():boolean</code></td><td>When <code>false</code>, or if the <code>function</code> returns false, then this plugin will not be included in the spec</td></tr><tr><td><strong>cond</strong></td><td><code>boolean?</code> or <code>fun(LazyPlugin):boolean</code></td><td>Behaves the same as <code>enabled</code>, but won’t uninstall the plugin when the condition is <code>false</code>. Useful to disable some plugins in vscode, or firenvim for example.</td></tr><tr><td><strong>priority</strong></td><td><code>number?</code></td><td>Only useful for <strong>start</strong> plugins (<code>lazy=false</code>) to force loading certain plugins first. Default priority is <code>50</code>. It’s recommended to set this to a high number for colorschemes</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>init</strong></th><th><code>fun(LazyPlugin)</code></th><th><code>init</code> functions are always executed during. Mostly useful for setting <code>vim.g.*</code> configuration used by <strong>Vim</strong> plugins startup</th></tr></thead><tbody><tr><td><strong>opts</strong></td><td><code>table</code> or <code>fun(LazyPlugin, opts:table)</code></td><td><code>opts</code> should be a table (will be merged with parent specs), return a table (replaces parent specs) or should change a table. The table will be passed to the <code>Plugin.config()</code> function. Setting this value will imply <code>Plugin.config()</code></td></tr><tr><td><strong>config</strong></td><td><code>fun(LazyPlugin, opts:table)</code> or <code>true</code></td><td><code>config</code> is executed when the plugin loads. The default implementation will automatically run <code>require(MAIN).setup(opts)</code> if <code>opts</code> or <code>config = true</code> is set. Lazy uses several heuristics to determine the plugin’s <code>MAIN</code> module automatically based on the plugin’s <strong>name</strong>. <em>(<code>opts</code> is the recommended way to configure plugins)</em>.</td></tr><tr><td><strong>main</strong></td><td><code>string?</code></td><td>You can specify the <code>main</code> module to use for <code>config()</code> and <code>opts()</code>, in case it can not be determined automatically. See <code>config()</code></td></tr><tr><td><strong>build</strong></td><td><code>fun(LazyPlugin)</code> or <code>string</code> or <code>false</code> or a list of build commands</td><td><code>build</code> is executed when a plugin is installed or updated. See <a href="https://lazy.folke.io/developers#building">Building</a> for more information.</td></tr></tbody></table></div><h5 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h5><p>添加插件非常简单，只需将插件规格添加到 lua/plugins/*.lua 下的某个文件中即可。可以在其中创建任意数量的文件。允许缓存所有插件spec。<br>规格更改更新时将自动重新加载，因此 :Lazy UI 始终是最新的。</p><p>可以在 lua/plugins 文件夹中为每个插件创建一个文件,也可以为某些功能创建一个包含所有插件规格的独立文件.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="comment">-- add symbols-outline</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;simrat39/symbols-outline.nvim&quot;</span>,</span><br><span class="line">    cmd = <span class="string">&quot;SymbolsOutline&quot;</span>, # 根据命令进行懒惰加载</span><br><span class="line">    keys = &#123; &#123; <span class="string">&quot;&lt;leader&gt;cs&quot;</span>, <span class="string">&quot;&lt;cmd&gt;SymbolsOutline&lt;cr&gt;&quot;</span>, desc = <span class="string">&quot;Symbols Outline&quot;</span> &#125; &#125;, #Lazy-<span class="built_in">load</span> on key mapping</span><br><span class="line">    opts = &#123;</span><br><span class="line">      <span class="comment">-- add your options that should be passed to the setup() function here</span></span><br><span class="line">      position = <span class="string">&quot;right&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒加载规则</strong></p><p>lazy.nvim 可自动懒加载 Lua 模块. 这意味着,如果你有一个懒加载的插件 A 和一个需要插件 A 的模块的插件 B,那么插件 A 将按照预期按需加载。</p><p>此外,还可以对事件(events)、命令(cmd)、文件类型(filetype)和按键映射(key mappings)进行懒加载.</p><p>当以下情况之一为真时，插件将被懒加载：</p><ul><li>该插件仅作为依赖项(dependency)存在于plugin spec中</li><li>它有一个事件、cmd、ft 或keys关键字</li><li>config.defaults.lazy == true</li></ul><p><strong>自定义Plugin Specs</strong></p><p>默认合并规则：</p><p>cmd：将使用自定义命令扩展命令列表<br>event：事件列表，将使用自定义事件进行扩展<br>ft：文件类型列表将使用自定义文件类型进行扩展<br>keys：键映射列表，将使用自定义键映射进行扩展<br>opts：自定义选项将与默认选项合并<br>dependencies：依赖项列表将使用自定义依赖项进行扩展<br>任何其他属性都将<strong>覆盖</strong>默认值,比如spec</p><p>也就是说如果lazyvim中有了你想下载的插件,你可通过在plugins目录下添加一个lua文件修改,如果你想添加一个没有的插件,操作是一样的,无非是少了一些默认的配置<strong>.</strong></p><blockquote><p>在可能的情况下，始终使用 opts 而不是 config。</p></blockquote><p><strong>增加或者禁用插件keymap</strong></p><p>添加 keys= 的规则。</p><p>也可以通过设置默认 keymap 为 false 来禁用.要覆盖一个关键映射,只需添加一个具有相同 lhs 和新 rhs 的关键映射(也就是按键相同,操作不同)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="string">&quot;nvim-telescope/telescope.nvim&quot;</span>,</span><br><span class="line">  keys = &#123;</span><br><span class="line">    <span class="comment">-- disable the keymap to grep files</span></span><br><span class="line">    &#123;<span class="string">&quot;&lt;leader&gt;/&quot;</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">    <span class="comment">-- change a keymap</span></span><br><span class="line">    &#123; <span class="string">&quot;&lt;leader&gt;ff&quot;</span>, <span class="string">&quot;&lt;cmd&gt;Telescope find_files&lt;cr&gt;&quot;</span>, desc = <span class="string">&quot;Find Files&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">-- add a keymap to browse plugin files</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;&lt;leader&gt;fp&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">require</span>(<span class="string">&quot;telescope.builtin&quot;</span>).find_files(&#123; cwd = <span class="built_in">require</span>(<span class="string">&quot;lazy.core.config&quot;</span>).options.root &#125;) <span class="keyword">end</span>,</span><br><span class="line">      desc = <span class="string">&quot;Find Plugin File&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ul><li>如果想去的缓冲区离您所在的位置很近，请使用 H 和 L。</li><li>否则，如果缓冲区已打开，请使用 \<leader>，</li><li>对于其他文件，使用 <leader><space>。</li><li>使用 \<leader>bd 关闭不再需要的缓冲区</li><li>使用 \<leader>ss 快速跳转到所处缓冲区中的函数</li><li><p>使用 \<c-o>、\<c-i> 和 gd 浏览代码</p></li><li><p>使用 \<leader>bp 可以固定缓冲区，使用 \<leader>bP 可以删除所有未固定的缓冲区</p></li><li>在你将来想做但现在不需要的文件中添加 TODO,并删除它们的缓冲区,git 会跟踪它们</li><li>如果要禁用某个缓冲区的自动格式化，则为该缓冲区设置 <code>vim.b.autoformat = false</code>。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Disable autoformat for lua files</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;FileType&quot;</span> &#125;, &#123;</span><br><span class="line">  pattern = &#123; <span class="string">&quot;lua&quot;</span> &#125;,</span><br><span class="line">  callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    vim.b.autoformat = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以使用 <code>&lt;leader&gt;uf</code>来启用该缓冲区的自动格式化。</p><p>除了layvim的配置,neotree等使用的插件的配置也应该看看</p><p>如果你想学习vim,可以通过vim tutor或者在线的vim adventure练习.</p><h3 id="Alacritty"><a href="#Alacritty" class="headerlink" title="Alacritty"></a>Alacritty</h3><p>GPU加速的终端模拟器,保持了最小的核心功能,没有窗口分割等(如果想要更多功能,考虑使用wezterm(基本不需要什么配置),配置使用lua).</p><p>Alacritty的配置非常轻松,使用.toml<a href="https://alacritty.org/config-alacritty.html">Alacritty</a>,结构比较清晰</p><p>下面是一个例子</p><p><a href="https://github.com/TwiggieSmallz/Default-Alacritty-TOML-Config/blob/main/alacritty.toml">Default-Alacritty-TOML-Config/alacritty.toml at main · TwiggieSmallz/Default-Alacritty-TOML-Config (github.com)</a></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[GENERAL]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ENV]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[WINDOW]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[SCROLLING]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[FONT]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[SELECTION]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[TERMINAL]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[CURSOR]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[HINTS]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">size</span> = <span class="number">12.0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.bold]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Bold&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.bold_italic]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Bold Italic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.italic]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Italic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[font.normal]</span></span><br><span class="line"><span class="attr">family</span> = <span class="string">&quot;monospace&quot;</span></span><br><span class="line"><span class="attr">style</span> = <span class="string">&quot;Regular&quot;</span></span><br></pre></td></tr></table></figure><h3 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h3><p>有许多操作具体我也在学习,欢迎交流.感觉目前使用neovim写点小demo还是不错的,大项目可以使用jetbrains的IDE.</p><p>如果你想geek一点,使用arch的文档以及常用的软件<a href="https://wiki.archlinux.org/">ArchWiki (archlinux.org)</a>和<a href="https://github.com/ihchiz/Awesome-Linux-Software-zh_CN#窗口管理">ihchiz/Awesome-Linux-Software-zh_CN: 🐧 一个 Linux 上超赞的应用，软件，工具以及其它资源的集中地。 (github.com)</a>,下载和使用这类软件非常全面和方便. 可以考虑使用<a href="https://github.com/archcraft-os">Archcraft (github.com)</a>试试,自带许多配置文件.</p><p>也可以看看我介绍的一些日常开发setup<a href="https://protool-ten.vercel.app/setup/setup.html">protools (protool-ten.vercel.app)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用的窗口管理器,编辑器与终端模拟器等等&lt;br&gt;</summary>
    
    
    
    
    <category term="setup" scheme="https://www.sekyoro.top/tags/setup/"/>
    
  </entry>
  
  <entry>
    <title>协作感知算法:三</title>
    <link href="https://www.sekyoro.top/2024/06/30/%E5%8D%8F%E4%BD%9C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E4%B8%89/"/>
    <id>https://www.sekyoro.top/2024/06/30/%E5%8D%8F%E4%BD%9C%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E4%B8%89/</id>
    <published>2024-06-30T05:46:08.000Z</published>
    <updated>2024-09-29T07:43:18.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一些稍微新一点或者之前没看到的想法还不错的协同感知论文<br><span id="more"></span></p><h2 id="More-Robust"><a href="#More-Robust" class="headerlink" title="More Robust"></a>More Robust</h2><p>提升检测精度,尤其是在位置噪声较大的情况下</p><h3 id="Self-Localized-Collaborative-Perception"><a href="#Self-Localized-Collaborative-Perception" class="headerlink" title="Self-Localized Collaborative Perception"></a>Self-Localized Collaborative Perception</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>协作感知因其能够解决单智能体感知中的几个固有挑战（包括遮挡和超出范围问题）而受到广泛关注。然而，现有的<strong>协作感知系统严重依赖精确的定位系统来在智能体之间建立一致的空间坐标系</strong>。这种依赖使它们容易受到大型姿势错误或恶意攻击的影响，从而导致感知性能大幅降低。</p><p>为了解决这个问题，提出了 CoBEVGlue，这是一种新颖的自定位协作感知系统，无需使用外部定位系统即可实现更全面、更稳健的协作。CoBEVGlue 的核心是一个新颖的空间对齐模块，它通过有效匹配跨智能体的共可见对象来提供智能体之间的相对姿态。我们在真实数据集和模拟数据集上验证了我们的方法。</p><p>结果表明，i） CoBEVGlue 在<strong>任意定位噪声和攻击下实现了最先进的检测性能</strong>;ii） <strong>空间对齐模块可以与大多数以前的方法无缝集成</strong>，将它们的性能平均提高 57.7%</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>准确的感知对于自动驾驶汽车的导航和安全至关重要 。尽管大规模数据集 和强大的模型 推动了进步，但单智能体感知本身受到遮挡和远程问题 的限制，这可能导致灾难性的后果。利用现代通信技术，目前对协作感知的研究使多个智能体之间能够共享感知信息，从根本上提高了感知性能。</p><p>在高质量数据集和创新协作技术的推动下，协作感知系统有可能显著提高交通网络的安全性</p><p>在这个新兴的协作感知领域，大多数主流工作都做出了一个过于简化的假设：<strong>每个代理使用的全局定位系统（通常是 GPS 或 SLAM）足够精确，可以建立一个一致的协作空间坐标系</strong></p><p>然而，来自真实世界协作感知数据集V2V4Real和DAIR-V2X 的快照显示，即使经过细致和资源密集型的离线校准，地面实况定位仍然存在噪声。在<strong>计算限制和实时约束下，这些不准确之处在实际应用中可能会更加严重</strong>。</p><p>此外，定位系统容易受到长期存在但仍未解决的攻击。这些攻击允许攻击者随意操纵位置，进一步破坏定位系统的可靠性。这种显著噪声和恶意攻击的普遍挑战与早期工作所考虑的理想场景形成鲜明对比，这些工作主要关注轻微的姿态不准确，未能超越大噪声下无协作的基线.</p><p>为了消除对可能不可靠的外部定位系统的依赖，<strong>一种直接的解决方案是通过点云配准推断协作智能体的相对姿态，这种技术在多智能体协作系统中得到广泛应用。点云配准方法应用最近邻算法来识别广泛的3D点集之间的对应关系，然后是稳健的技术来计算这些假定对应关系的转换</strong>。尽管这些方法被证明对协作映射等延迟容忍应用有效，但对于带宽受限的协作感知系统来说，大量3D数据的实时传输是不切实际的。因此，在创建一个没有定位错误的系统，同时保持实际应用的通信效率方面，存在明显的差距。</p><p>为了填补这一空白，提出了 CoBEVGlue，这是一种自定位的协作感知系统，专为多个智能体设计，无需依赖外部定位系统即可实现更全面的感知，从而在降低通信成本的同时实现效率。CoBEVGlue 遵循以前的协作感知系统 的管道，并使用其关键的空间对齐模块 BEVGlue 来估计智能体与每个智能体检测和跟踪的物体之间的相对姿态。</p><p>BEVGlue <strong>背后的核心思想是从跨代理的鸟瞰感知数据中搜索共见对象，并计算与这些共见对象的相对变换，确保一致的协作空间坐标系</strong>。(The core idea behind BEVGlue is to search for the co-visible objects from the bird’s eye view perceptual data across agents and calculate the relative transformation with these co-visible objects, ensuring a consistent spatial coordinate system for collaboration.)确保一致的空间坐标系以进行协作。BEVGlue 包括三个关键组件：i） 对象图建模(object graph modeling)，将<strong>每个智能体的观察结果转换为具有丰富信息的对象图，包括对象形状、航向、跟踪 ID 和对象之间不变的空间关系</strong>;ii） 时间一致的最大子图检测，它有效地利用对象图中的空间和时间数据来检测最大的公共子图，遵循严格的空间同构约束和时间一致性;iii） 相对姿态计算，它<strong>使用检测到的公共子图计算代理之间的姿态关系</strong>，而无需使用耗时的异常值拒绝算法。</p><p>拟议的 CoBEVGlue 系统具有三个显着优势：</p><p>i） 它独立于外部定位设备运行，展示了其对噪音和恶意攻击的弹性</p><p>ii） 它带来的通信开销很小，因为 CoBEVGlue 仅使用带有跟踪 ID 的对象边界框来估计代理之间的相对姿势</p><p>;iii） 其核心模块 BEVGlue 通过在<strong>检测到的公共子图之间</strong>保持严格的空间同构约束和匹配结果之间随时间的时间一致性来确保高质量的匹配结果。</p><p>为了评估所提出的方法的有效性，考虑了三个数据集上的协作式3D目标检测任务：OPV2V、DAIR-V2X和V2V4Real，涵盖模拟和真实世界场景。结果表明，CoBEVGlue 赋予了强大的协作感知系统的性能与依赖精确定位信息的系统相当，并在存在定位噪声和攻击时实现了最先进的检测性能</p><p>为了获得对定位噪声的抵抗力，以前的工作考虑了两种主要方法：<strong>基于学习和基于匹配</strong>。基于学习的方法旨在构建健壮的网络架构，以减少姿态错误的影响。例如，V2VNet（稳健性） 设计了姿态回归、全局一致性和注意力聚合模块来纠正相对姿态并专注于姿态误差较小的邻居;V2X-ViT 使用多尺度窗口注意力来捕获各种范围内的特征。另一方面，基于匹配的方法<strong>寻求开发健壮的框架或网络架构。示例包括 FPV-RCNN和 CoAlign，它们使用基于 IoU 的匹配策略估计代理之间的相对姿势</strong>。但是，它们只能纠正外部定位中的微小不准确之处，因为这些方法依赖于基本精确的初始相对姿势。当噪声较大或存在攻击时，它们的性能会显著下降。<strong>相比之下，我们的工作认为协作感知独立于外部定位系统</strong></p><p>尽管本文的最终目标是提高检测能力，但<strong>点云配准方法的进步激发了我们提出新颖的自定位协作感知系统</strong>。传统的点云配准方法专注于改进迭代最近点 （ICP） 算法及其变体  导致了收敛和噪声弹性的改进。最近典型的点云配准工作流程包括提取<strong>本地 3D 特征描述符和进行配准。为了提取 3D 局部描述符，快速点特征直方图等传统方法利用了手工制作的特征</strong>。</p><p>最近的技术为此目的采用了基于学习的方法。在配准方面，<strong>传统方法通常采用最近邻算法进行匹配，并采用稳健优化来剔除异常值</strong>，而<strong>现代深度配准方法则利用自注意机制来确定对应关系</strong>。SGAligner率先使用预构建的 3D 场景图进行配准。然而，与前面的策略类似，它需要传输密集的点云和高维特征。这些方法广泛应用于容忍延迟的多智能体系统，如协同映射和 3D 场景图生成.但是，协作对象检测任务需要实时进行精确的相对姿态估计。遗憾的是，<strong>V2X 网络难以实时传输点云配准方法所需的密集点云和特征。为了克服这一限制</strong>，我们的方法优先考虑对象级注册，仅用 8 个 float 数字表示每个对象(To overcome this limitation, our approach prioritizes object-level registration, representing each object with just eight float numbers.)。这项创新显著降低了计算协作自动驾驶汽车之间相对姿态所需的带宽和计算成本，从而有效地解决了传输困境(This innovation markedly reduces the bandwidth necessary and computation cost for calculating relative poses among collaborative autonomous vehicles, thus efficiently resolving the transmission dilemma)</p><p>最大公共子图（Maximum Common Subgraph Detection,MCS）检测问题被归类为NPhard，在各个科学领域中都至关重要，需要平衡精度和计算效率的算法。传统方法主要采用分支定界算法和将 MCS 检测转化为最大团问题的技术. 机器学习的最新进展已经看到了图神经网络和强化学习在 MCS 检测中的应用，MCS 检测试图学习合适的启发式方法来进行图匹配。尽管他们进行了创新，但它们仍然受到搜索空间探索的启发式性质的限制，并且在最坏的情况下会受到指数级时间复杂度的影响。在这项工作中，我们<strong>使用几何不变对象姿态图对每个代理检测到的边界框进行建模，并利用空间约束和时间一致性来有效地解决问题。</strong></p><p><img data-src="https://s2.loli.net/2024/09/03/TPz1njuNZGi7Qbc.png" alt="image-20240903155532374"></p><script type="math/tex; mode=display">\begin{aligned}\mathbf{F}_i^t,\mathbf{D}_i^t& =f_{\text{detection}\&\text{tracking}}\left(\mathbf{O}_i^t\right), \\\xi_{j\to i}^t& =f_{\mathrm{BEVGlue}}\left(\mathrm{D}_i^t,\mathrm{D}_j^t\right), \\\mathbf{F}_{j\to i}^t& =f_{\text{transform}}\left(\mathbf{F}_j^t,\xi_{j\to i}^t\right), \\\mathbf{F}_{i}^{\prime}t& =f_{\mathrm{fusion}}\left(\{\mathbf{F}_{j\to i}^t\}_{j=1,2,\cdots,N}\right), \\\mathbf{B}_i^t& =f_{\mathrm{decoder}}\left(\mathbf{F}_i^{'t}\right), \end{aligned}</script><p>精确的姿态信息<strong>要求每个代理利用外部定位系统来获取其全局位置并计算协作者之间的相对变换</strong>。这种对外部定位的依赖充满了挑战，包括容易受到噪声干扰和恶意攻击造成的潜在安全漏洞。<strong>BEVGlue 旨在通过利用感知数据来确保准确的相对姿态估计来解决这些问题</strong>，从而增强协作感知的弹性和有效性。</p><p>为了估计智能体之间的相对姿态 ξt j→i，BEVGlue 的主要思想是识别共可见的物体，然后根据这些共见物体计算变换。为了挖掘智能体之间的这种内部对应关系，BEVGlue 提出了三个模块：（i） 对象图建模，（ii） 时间一致的最大公共子图检测，以及 （iii） 相对姿态计算。</p><p><strong>Object Graph Modeling</strong></p><p>鉴于极点和参考方向在物理世界中具有清晰和单一的定义，因此可以实现不同对象图之间边缘特征计算的一致性。具体来说，如果在基于智能体 j 计算智能体图 Gt j 上的边缘特征 e^t^<em>j,mn</em> 时，节点 m 和 n 的检测结果对于第 i 个和第 j 个智能体都是准确的，则它与 e^t^<em>i,mn</em> 相同。</p><p>对象图提供了一种创新方法来对每个代理的观察进行建模：i） 节点属性包含时间跟踪数据，这有助于保持随时间推移的匹配一致性;ii） 边缘特征在从不同代理的角度得出的对象图中是一致的，这意味着应用于 D^t^<em>i</em> 的旋转和平移不会改变 e^t^ <em>i,mn</em> 的值。这意味着，当两个对象同时被不同的代理观察时，无论视角如何变化，边缘属性都保持一致。</p><p>对象图提供了一种创新方法来对每个代理的观察进行建模：i） <strong>节点属性包含时间跟踪数据，这有助于保持随时间推移的匹配一致性</strong>;ii） <strong>边缘特征在从不同代理的角度得出的对象图中是一致的</strong>，这意味着应用于 D^t^<em>i</em> 的旋转和平移不会改变 e^t^<em>i,mn</em> 的值。这意味着，当两个对象同时被不同的代理观察时，无论视角如何变化，边缘属性都保持一致</p><blockquote><p>每个代理根据自己的检测结构建模一个对象图,图中有一些节点和边.</p><p>每个节点属性包括bbox的宽高和id,边节点属性包括相对距离,相对航向角和航向角相对</p></blockquote><p><img data-src="https://s2.loli.net/2024/09/03/2oyQWEVrpMiRLhA.png" alt="image-20240903170504372"></p><script type="math/tex; mode=display">\mathcal{H}_{(i,j)}^t=f_{\mathrm{MCS}}\left(\mathcal{G}_i^t,\mathcal{G}_j^t,\mathcal{H}_{(i,j)}^{t-1}\right).</script><p>上面的MCS函数可以分为三个过程.具体我就不说了,这篇文章一般,在一些介绍上还有点含糊不清.</p><p><img data-src="https://s2.loli.net/2024/09/05/NxJjAighnW1tEVX.png" alt="image-20240905150424806"></p><h2 id="More-domain-invariant"><a href="#More-domain-invariant" class="headerlink" title="More domain-invariant"></a>More domain-invariant</h2><p>提升迁移性,在仿真数据集上训练能在真实数据集上保证良好的效果.</p><h3 id="V2X-DGW-Domain-Generalization-for-Multi-agent-Perception-under-Adverse-Weather-Conditions"><a href="#V2X-DGW-Domain-Generalization-for-Multi-agent-Perception-under-Adverse-Weather-Conditions" class="headerlink" title="V2X-DGW: Domain Generalization for Multi-agent Perception under Adverse Weather Conditions"></a>V2X-DGW: Domain Generalization for Multi-agent Perception under Adverse Weather Conditions</h3><p>当前基于激光雷达的V2X ( Vehicle-to- Everything )多智能体感知系统在三维目标检测方面取得了显著的成功。虽然这些模型在训练好的清洁天气中表现良好，但它们在未见到的不利天气条件下与真实世界的域差距进行了斗争。在本文中，我们提出了一种在恶劣天气条件下基于多智能体感知系统的激光雷达三维目标检测的领域泛化方法，命名为V2X - DGW。我们的研究不仅在干净的天气下确保良好的多智能体性能，而且在未见到的恶劣天气条件下，只对干净的天气数据进行学习</p><p>为了推进该领域的研究，我们模拟了三种常见的不利天气条件对两个广泛使用的多智能体数据集的影响，从而创建了两个新的基准数据集：OPV2V-w和V2XSet-w。为此，我们首先引入自适应天气增强( AWA )来模拟不可观测的不利天气条件，然后提出两种用于泛化表示学习的对齐方式：信赖域天气不变对齐( TWA )和Agent感知对比对齐( ACA )。大量的实验结果表明，我们的V2X - DGW在看不见的恶劣天气条件下取得了改善。</p><h3 id="DUSA"><a href="#DUSA" class="headerlink" title="DUSA"></a>DUSA</h3><p>车联网( Vehicle-to-Ething，V2X )协同感知对于自动驾驶的推进至关重要。然而，实现高精度的V2X感知需要大量有标注的真实世界数据，这些数据通常是昂贵和难以获得的。由于模拟数据可以以极低的成本大规模生产，因此受到了广泛的关注</p><p>然而，模拟数据与真实世界数据之间显著的域差距，包括传感器类型、反射模式和道路环境的差异，往往导致在模拟数据上训练的模型在真实世界数据上评估时性能较差。此外，现实世界中的协作智能体之间仍然存在着域间鸿沟，例如，不同类型的传感器可能安装在具有不同外在特征的自动驾驶车辆和路边基础设施上，进一步增加了sim2现实泛化的难度</p><p><img data-src="C:\Users\proanimer\AppData\Roaming\Typora\typora-user-images\image-20240929101617316.png" alt="image-20240929101617316"></p><h3 id="MACP"><a href="#MACP" class="headerlink" title="MACP"></a>MACP</h3><p>车车通信( V2V )通信通过使信息共享能够”看穿遮挡物”，极大地增强了联网和自动驾驶汽车( CAV )的感知能力，从而带来了显著的性能提升。然而，当现有的单智能体模型表现出显著的泛化能力时，从头开始开发和训练复杂的多智能体感知模型可能是昂贵的和不必要的。在本文中，我们提出了一个新的框架MACP，它配备了一个具有合作能力的单智能体预训练模型。我们通过确定从单Agent转移到合作设置的关键挑战来实现这一目标，通过冻结其大部分参数和增加一些轻量级模块来调整模型。我们在实验中证明了所提出的框架可以有效地利用合作观测，并且在模拟和真实世界的合作感知基准中优于其他最先进的方法，同时需要更少的可调参数，并减少通信成本。</p><p><img data-src="https://s2.loli.net/2024/09/29/WfTrsqiKGkDpS91.png" alt="image-20240929132344516"></p><p><img data-src="https://s2.loli.net/2024/09/29/X6mFURq2snjBpdI.png" alt="image-20240929132352900"></p><h3 id="DI-V2X"><a href="#DI-V2X" class="headerlink" title="DI-V2X"></a>DI-V2X</h3><p>近年来，车联网( Vehicle-to- Everything，V2X )协同感知技术因其能够融合车辆、基础设施等多种智能体的信息来增强场景理解而受到广泛关注。然而，目前的工作往往将每个智能体的信息同等对待，忽略了由于每个智能体使用不同的LiDAR传感器而导致的固有域间隙，从而导致次优的性能。</p><p>在本文中，我们提出了DI - V2X，旨在通过一个新的蒸馏框架来学习领域不变的表示，以减轻V2X 3D目标检测中的领域差异。DI - V2X包括3个核心组件：域混合实例增强( DMA )模块、递进域不变蒸馏( PDD )模块和域自适应融合( DAF )模块。具体来说，DMA在训练过程中为教师和学生模型建立一个领域混合的3D实例库，从而产生对齐的数据表示。其次，PDD鼓励来自不同领域的学生模型逐步学习面向教师的领域不变特征表示，其中智能体之间的重叠区域被用作指导，以促进蒸馏过程</p><p>此外，DAF通过引入校准感知的领域自适应注意力来缩小学生之间的领域差距。在具有挑战性的DAIR - V2X和V2XSet基准数据集上的大量实验表明，DI-V2X取得了显著的性能，超过了之前所有的V2X模型。</p><p><img data-src="https://s2.loli.net/2024/09/29/QP28Dm3t7NwdnhK.png" alt="image-20240929132645073"></p><p><img data-src="https://s2.loli.net/2024/09/29/SAHcN3o58tRB9rM.png" alt="image-20240929133151152"></p><h3 id="SR2ViT"><a href="#SR2ViT" class="headerlink" title="SR2ViT"></a>SR2ViT</h3><p>由于缺乏足够的真实多智能体数据且标注耗时，现有的多智能体协同感知算法通常选择模拟的传感器数据进行训练和验证。然而，当这些经过仿真训练的模型被部署到真实世界时，由于仿真数据和真实数据之间存在显著的领域差距，感知性能会下降。在本文中，我们提出了第一个使用新型视觉转换器的多智能体协作感知的仿真到现实迁移学习框架，命名为S2R - ViT，它同时考虑了模拟数据和真实数据之间的部署差距和特征差距。</p><p>我们研究了这两种类型的域间隙的影响，并提出了一种新的不确定感知视觉转换器来有效地缓解部署间隙，并提出了一种基于代理的特征自适应模块，通过代理间和代理内的鉴别器来减小特征间隙。在公开的多智能体协同感知数据集OPV2V和V2V4Real上的大量实验表明，本文提出的S2R-ViT方法能够有效地弥补仿真与现实之间的差距，在基于点云的三维目标检测中显著优于其他方法。</p><p><img data-src="https://s2.loli.net/2024/09/29/7OZjSxI13oFKVDv.png" alt="image-20240929132912542"></p><p><img data-src="https://s2.loli.net/2024/09/29/pFDRZrwqghMW1B3.png" alt="image-20240929132924856"></p><h2 id="More-Communication-efficient"><a href="#More-Communication-efficient" class="headerlink" title="More Communication-efficient"></a>More Communication-efficient</h2><p>减少传输的数据大小,使得通信更高效.</p><h3 id="ERMVP-Communication-Efficient-and-Collaboration-Robust-Multi-Vehicle-Perception-in-Challenging-Environments"><a href="#ERMVP-Communication-Efficient-and-Collaboration-Robust-Multi-Vehicle-Perception-in-Challenging-Environments" class="headerlink" title="ERMVP: Communication-Efficient and Collaboration-Robust Multi-Vehicle Perception in Challenging Environments"></a>ERMVP: Communication-Efficient and Collaboration-Robust Multi-Vehicle Perception in Challenging Environments</h3><p>​    协作感知通过使自动驾驶汽车能够交换互补信息来提高感知性能。尽管它有可能彻底改变移动行业，但各种环境中的挑战，如<strong>通信带宽限制</strong>、定位错误和<strong>信息聚合效率低下</strong>，阻碍了它在实际应用中的实施。在这项工作中，我们提出了 ERMVP，这是一种在具有挑战性的环境中进行通信高效和协作的鲁棒多车辆感知方法。具体来说，ERMVP 具有三个明显的优势i） 它利用分层特征采样策略来抽象一组具有代表性的特征向量，使用更少的通信开销实现高效通信;ii） 它采用稀疏一致性特征来执行精确的空间位置校准，有效减轻车辆定位错误的影响;iii） 引入了一种开创性的特征融合和交互范式，以在不同车辆和数据源之间集成整体空间语义。</p><p>自动驾驶汽车被广泛认为是提高道路安全和交通效率的重要手段。这些车辆配备了激光雷达、摄像头和其他传感器，能够准确感知周围环境，以确保安全可靠的运行。<strong>然而，单车感知系统不可避免地存在缺点 ，例如传感器视野有限，容易被遮挡，以及由于数据稀疏和低分辨率而难以检测远处物体。</strong></p><p>最近，车对车 （V2V） 通信技术和深度学习的进步刺激了协作感知技术的创新和进步。这项技术允许互联自动驾驶汽车 （CAV） 共享传感数据，从而实现更全面的环境感知.</p><p>​    尽管协作感知技术在移动出行行业转型方面显示出巨大潜力，但其实际应用面临一些挑战，包括通信带宽限制、<strong>定位错误和信息聚合效率低下</strong></p><p>在实际场景中，无线通信资源和可靠性的约束严重阻碍了延迟敏感协作感知的有效性。虽然最近的工作通过精心设计的机制实现了感知性能和通信带宽之间的平衡，但这些方法有其局限性，因为它们主要考虑信息压缩而不是空间冗余。这种狭窄的关注点会加剧高压缩比下的性能下降.</p><p>​    此外,复杂的动态环境会导致定位错误，从而导致相对变换估计不准确和空间特征错位。这种相对姿势噪声会产生误导性特征，从而对协作感知的有效性产生不利影响。现有的方法试图通过密集的计算来优化整体姿态，但高延迟使其不适合实时动态感知.同时,协作方法只关注聚合信息，而忽视了自我载体固有的感知优势.此范例容易受到协作噪声引入的扰动的影响,包括异步运动模糊和不准确的投影.这样的缺点成为实现最佳感知性能的瓶颈.</p><p>相比之下，<strong>以自我为中心的特征可能包含不受协作噪声影响的局部准确空间位置信息</strong>。因此，建立务实的协作感知系统的首要任务是有效克服上述挑战.</p><p><img data-src="https://s2.loli.net/2024/09/05/5dxPGSYCcNgRBbn.png" alt="image-20240905153336761"></p><p>基于这些观察提出了 ERMVP，这是一种在具有挑战性的环境中通信高效且协作稳健的多车辆感知方法。具体来说,（i） 首先设计了一种高级滤波器和合并特征采样策略来解决无线通信资源的局限性。此策略同时考虑类间和类内冗余关系，以从冗余特征中抽象出一组精炼的特征向量，从而使用更少的通信开销实现高效通信.(ii)其次，我们引入了一个即插即用功能空间校准模块，以减轻车辆定位错误的影响。该模块巧妙地利用共识稀疏前景特征来对齐自我车辆和合作者之间的相对姿态关系，而无需任何精确的姿态监督。(iii)此外提出了一种开创性的特征融合和交互范式,以整合整体空间语义。</p><p>该范式包括两个关键组件:第一个是基于注意力的特征融合模块，在本地和全局注意力之间交替,以融合来自不同车辆的异构信息.</p><p>第二种是准确性增强特征交互策略,它利用以自我为中心的特征中固有的准确位置信息来增强融合特征提供的丰富语义信息.</p><p>• 我们提出了 ERMVP，这是一种<strong>通信高效</strong>且<strong>协作稳健</strong>的多车辆感知方法，它<strong>解决了通信带宽限制、定位错误和信息聚合效率挑战</strong>。</p><p>• 我们开发了一个过滤和合并特征采样策略来提高通信效率，一个用<strong>于精确空间特征对齐的特征空间校准模块，以及两个信息聚合组件来优化融合过程。</strong></p><p>• 我们对真实世界和模拟数据集进行了广泛的实验。结果表明了我们方法的优越性和所提出组件的必要性。</p><h5 id="Filter-and-Merge-Feature-Sampling"><a href="#Filter-and-Merge-Feature-Sampling" class="headerlink" title="Filter and Merge Feature Sampling"></a>Filter and Merge Feature Sampling</h5><p>以前的工作利用了精心设计的机制，如信息熵通信选择 [37] 和空间异质性映射来减少所需的传输带宽。</p><p>然而，这些方法主要关注前台和后台特征之间的类间冗余，而忽略了特征之间的类内冗余，从而导致次优压缩。为了解决这一差距，我们引入了一种高级过滤和合并特征采样策略 （FMS）。该策略同时考虑了类间和类内冗余关系，有效地从原始特征图中提取了一组简洁而独特的特征向量，从而更有效地减少了通信开销。FMS 由以下两个核心组件组成。</p><p>Filter Sampler(滤波器采样器).在对象检测中，包含对象的前景区域比背景区域更重要。因此，我们将减少空间冗余的想法实现到特征过滤器采样器模块中，旨在保留感知上重要但稀疏的特征向量集。由于显式学习二进制采样器是不可行的，因此我们开发了一种置信度过滤器策略.最初,为特征图生成检测置信度图。它反映了不同空间区域的感知重要性，较高的级别表示潜在的对象区域，较低的级别通常表示冗余的背景区域.</p><script type="math/tex; mode=display">C_i=\Phi_{\mathrm{con_gen}}\left(F_i\right)\in[0,1]^{H\times W}</script><p>其中 Φcon_gen（·） 表示具有检测解码器结构的置信度生成网络。然后对置信度图进行阈值处理，然后进行非极大值抑制，从而产生二进制掩码 B。</p><script type="math/tex; mode=display">\tilde{F}_{i}=B\odot F_{i}</script><p>Merge Sampler(合并采样器):在用滤波器采样器提取详细的前景特征向量集后，我们<strong>使用合并采样器进行额外的优化，通过加权合并来提炼相似或重复的前景特征向量</strong>。该过程分为三个阶段：信息驱动的<strong>特征分组</strong>、注意力启发的<strong>特征合并</strong>和基于索引的<strong>特征重建</strong>(information-driven feature grouping, attention-inspired feature merging, and index-based feature reconstruction.)</p><ol><li><p>应用最近邻聚类算法的变体对前景特征向量集进行分组.给定一组特征向量 $F^{~}_{i}$ =[x1，x2,…,xL] 和集群中心 $X_c$，我们计算每个特征向量的指标 δi。</p><p>δi 的计算方法是最小特征距离减去到任何其他聚类中心向量的平均像素距离</p></li></ol><script type="math/tex; mode=display">\delta_i=\min_{j:x_j\in X_c}\left(\left\|x_i-x_j\right\|_2^2-\gamma\left\|p(x_i),p(x_j)\right\|_2^2\right)</script><ol><li>合并特征向量的一种简单策略是平均集群中的每个特征向量。但是，此方案可能会受到异常值特征向量的严重影响。从注意力机制中汲取灵感，利<strong>用置信度分数作为指导来量化每个特征的重要性</strong>。因此，第 i 个簇 Gi 的合并特征向量 ̃ 习 计算为</li></ol><script type="math/tex; mode=display">\widetilde{x}_i=\frac{\sum_{j\in G_i}c_jx_j}{\sum_{j\in G_i}c_j}</script><ol><li>在特征分组和合并过程中，每个特征向量都分配给一个集群，每个集群由一个合并的向量表示。<strong>维护原始特征向量和合并特征向量之间的索引对应关系的记录</strong>。利用这个索引记录，自我车辆确保合并的特征向量被映射到它们的相应位置，从而重建特征图</li></ol><p>定位错误可能导致车辆之间的特征图错位。这种错位会导致自我车辆误解物体的位置，从而导致感知能力下降，为了应对这一挑战，引入了特征空间校准模块 （FSC） 来促进精确的特征对齐</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909091549936.png" alt="image-20240909091549936"></p><p>涉及三个阶段：一致性匹配、几何验证和误差调制。</p><p>​    将自我车辆的拟议匹配区域表示为 P，将协作车辆在嘈杂姿势条件下识别的区域表示为 Q。利用 P 和 Q，构建了一个加权二分图，其中每条边的权重由节点之间的距离决定，封装在成本矩阵中。然后将匹配过程转换为线性分配任务，目的是确定具有最低累积边缘权重的匹配结果。此过程将生成匹配的对 M</p><p>​    由于对象位于专用区域和检测噪声，可能会出现无效匹配。为了解决这个问题，我们利用 RANSAC 来过滤和筛选一组与预期几何变换一致的匹配项。首先，选择一个随机匹配子集Ms ，然后利用奇异值分解计算变换矩阵Γ s .当Γ s应用于Ms内的所有对时，如果这些对之间的变换后距离保持在阈值η以下，则认为该集合是正确对齐的。阈值η反映了原始协作框架内允许的定位误差。这个过程是迭代进行的，以确定与最大正确匹配数相关的最佳变换矩阵。最终得到一个最优的精化变换矩阵Γ r，并将其应用于后续的空间标定操作中，得到对齐后的特征’ Zj = Γ rZj</p><p>​    为了增强校准方法在各种环境下的适应性，我们融入了<strong>误差调制策略。该策略旨在实现定位误差与标定过程中产生的估计误差之间的平衡</strong>。它测量了自我和协作特征在调整状态和原始状态下的重叠比例。</p><h4 id="Attention-based-Feature-Fusion"><a href="#Attention-based-Feature-Fusion" class="headerlink" title="Attention-based Feature Fusion"></a>Attention-based Feature Fusion</h4><p>在多车辆协作场景中，车辆能够捕获来自不同空间区域的异构信息。为了高效地融合来自多个车辆的感知特征，我们提出了一种注意力特征融合方法( AFF )。AFF利用交替的局部和全局注意力，在遮挡变化的交通场景中实现位置级别的精确匹配，并捕获道路拓扑和交通状态的全局语义注意力</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909094342791.png" alt="image-20240909094342791"></p><p>该模块允许系统从局部视图分析空间相关性,同时也捕获全局特征响应,确保在动态、复杂和遮挡变化的交通场景中实现高效和精确的感知.最后得到融合特征H~i~</p><h4 id="Accuracy-Enhanced-Feature-Interaction"><a href="#Accuracy-Enhanced-Feature-Interaction" class="headerlink" title="Accuracy Enhanced Feature Interaction"></a>Accuracy Enhanced Feature Interaction</h4><p>​    先前的工作已经证明了融合特征可以提供更丰富的语义信息，从而提高感知性能。然而，它们可能会受到协作噪声的影响，如异步运动模糊和不准确的投影,这会损害准确的位置信息,成为感知性能最优实现的瓶颈.以自我为中心的特征可能包含局部关键的空间位置信息,而不受协作噪声的影响.</p><p>​    为此,我们提出了一种准确性增强的特征交互( Accuracy Enhanced Feature Interaction，AEI )策略,该策略利用自我中心特征固有的准确位置信息来增强协同融合特征提供的丰富语义信息.</p><p><img data-src="https://proanimer-img.oss-cn-shanghai.aliyuncs.com/alimg/image-20240909105358537.png" alt="image-20240909105358537"></p><h3 id="Pragmatic-Communication-in-Multi-Agent-Collaborative-Perception"><a href="#Pragmatic-Communication-in-Multi-Agent-Collaborative-Perception" class="headerlink" title="Pragmatic Communication in Multi-Agent Collaborative Perception"></a>Pragmatic Communication in Multi-Agent Collaborative Perception</h3><p>​    多智能体协同感知的目标是使智能体通过通信交换互补的感知信息，从而实现更全面的感知。协同感知保证了扩展的可视性，通过障碍物和识别小的、远距离的目标，从而实现对环境的彻底理解。它为从根本上克服单智能体感知的物理局限性提供了一个很有前途的方向，如视场受限、遮挡、远距离等问题。作为自主系统的最前沿，协作感知可以增强感知能力，并在各种现实世界的应用中进一步提高系统的功能和安全性，包括自动驾驶机器人技术和无人驾驶.</p><p>​    为了应对这一挑战，关键在于在通信预算范围内优化消息以满足每个智能体的特定感知任务需求。一种直接的方法是在传统的香农通信范式中使用信源编码。该方法将原始数据编码为一系列代码，将较短的代码分配给频繁数据，将较长的代码分配给稀有数据，在不损失信息的情况下创建紧凑的表示。在协同感知的背景下，该方法在支持者端有效地将感知数据压缩为消息，并在接收者端确保无损复制.</p><p>​    这种方法提高了通信效率，同时保留了对包括感知在内的一般下游任务的效用。然而，这种Shannon范式在需要为特定下游任务定制通信的场景中具有根本的局限性，因为它不可避免地浪费了无关的资源数据。例如，在相机-传感器-智能体协作的车辆检测任务中，香农范式对每个像素进行统一编码，而不区分非必要的背景和关键的车辆像素。这些背景像素在无助于检测性能的情况下极大地浪费了通信资源，从而影响了感知-通信的权衡。</p><p><img data-src="https://s2.loli.net/2024/09/27/91bnQjD42X5pgKv.png" alt="image-20240927101227163"></p><p><img data-src="https://s2.loli.net/2024/09/27/WIlBh9KuiGpb3t1.png" alt="image-20240927103143478"></p><p>spatial confidence map+VQVAE</p><h4 id="Information-filling-driven-message-selection"><a href="#Information-filling-driven-message-selection" class="headerlink" title="Information-filling-driven message selection"></a>Information-filling-driven message selection</h4><p>为了有效地选择支持其他Agent的紧凑协作消息，核心思想是使每个代理能够有限制地选择相关的消息与其他代理共享；然后，这些非冗余消息共同满足彼此的信息需求。例如，在遮挡场景中，来自支持者的额外信息有助于智能体检测丢失的物体。然而，来自多个支持者的信息被过度填充，浪费了沟通资源。因此，集体协调对于避免冗余和提供更多有益信息至关重要。为了实现这一点，提出的方法有两个关键步骤：information disclosure,其中智能体相互分享它们在特定区域的可用信息.  filling-driven optimization,其中每个智能体局部优化对其他智能体的支持性信息</p><script type="math/tex; mode=display">\mathrm{C}_i=\Phi_\text{generator}(\mathcal{F}_i)\in[0,1]^{H\times W}</script><script type="math/tex; mode=display">\begin{aligned}&\{\mathbf{M}_{i\to j}^{*}\}_{i,j} = \mathrm{argmax}\sum_{\mathbf{M}}^{N}f_{\mathrm{min}}\left(\mathbf{C}_{j}+\sum_{i=1,i\neq j}^{N}\mathbf{M}_{i\to j}\odot\mathbf{C}_{i},u\right) \\&\mathrm{where}\sum_{i,j=1,j\neq i}^{N}\mathrm{M}_{i\to j}\leq b,\mathrm{M}_{i\to j}\in\{0,1\}^{H\times W}\end{aligned}</script><h4 id="Codebook-based-message-representation"><a href="#Codebook-based-message-representation" class="headerlink" title="Codebook-based message representation"></a>Codebook-based message representation</h4><p><strong>Codebook learning</strong></p><script type="math/tex; mode=display">\mathbf{D}^*=\arg\min_\mathbf{D}\sum_{\mathcal{F}\in\mathcal{F}}\sum_{h,w}\min_\ell\left(\Psi(\mathbf{D}_{[\ell]})+\left\|\mathcal{F}_{[h,w]}-\mathbf{D}_{[\ell]}\right\|_2^2\right)</script><p><img data-src="https://s2.loli.net/2024/09/27/iAXLZvUyNznEbCW.png" alt="image-20240927112420781"></p><p>令D = [d1，d2，· · ·，d~nL~]∈R^C×nL^为codebook，其中D [l] = d~l~∈R^C^为第l个码字,nL为codebook个数。</p><p>Ψ ( · )表示用D [l]代替F[ h , w]所获得的检测性能.第一项反映了下游检测任务的要求,第二项反映了原始特征向量与编码之间的重构误差</p><p>这种近似对重构是有损的，而对感知任务是无损的，能够在不牺牲感知能力的情况下降低通信成本</p><p><strong>Code index representation</strong></p><p>在共享codebook D的基础上,每个智能体可以通过一系列码本索引I~i→j~来替代所选择的稀疏特征图Z~i→j~</p><script type="math/tex; mode=display">\left(\mathcal{I}_{i\to j}\right)_{[h,w]}=\arg\min_\ell\left\|\left(\mathcal{Z}_{i\to j}\right)_{[h,w]}-\mathbf{D}_{[\ell]}\right\|_2^2</script><h3 id="Message-decoding-and-fusion"><a href="#Message-decoding-and-fusion" class="headerlink" title="Message decoding and fusion"></a>Message decoding and fusion</h3><p>消息解码根据接收到的codebook索引和共享codebook重构支持特征</p><p>给定接收到的消息P~j→i~ = I~j→i~,解码特征图位于( h , w)处的$\widehat{\mathcal{Z}}<em>{j\to i}\in\mathbb{R}^{H\times W\times C}$元素为$(\widehat{\mathcal{Z}}</em>{j\to i})<em>{[h,w]}=\mathbf{D}</em>{[\mathcal{I}<em>{j\to i}[h,w]]}$。随后，消息融合将这些解码后的特征图进行聚合以增强个体特征，通过非参数逐点最大融合实现。对于第i个agent，给定重构特征$\widehat{z}</em>{j\to i}$ .增强的BEV特征为$\mathcal{H}<em>i=\max</em>{j\in\mathcal{N}<em>i}(\mathcal{F}_i,\widehat{\mathcal{Z}}</em>{j\to i}) \in \mathbb{R}^{H\times W\times C}$，其中N~i~是第i个Agent的连通合作者，max ( · )最大化每个代理空间位置上来自多个Agent的相应特征</p><p>对增强后的特征H~i~进行解码得到检测结果O~i~</p><h3 id="What-Makes-Good-Collaborative-Views-Contrastive-Mutual-Information-Maximization-for-Multi-Agent-Perception"><a href="#What-Makes-Good-Collaborative-Views-Contrastive-Mutual-Information-Maximization-for-Multi-Agent-Perception" class="headerlink" title="What Makes Good Collaborative Views? Contrastive Mutual Information Maximization for Multi-Agent Perception"></a>What Makes Good Collaborative Views? Contrastive Mutual Information Maximization for Multi-Agent Perception</h3><h2 id="Towards-Label-Efficient"><a href="#Towards-Label-Efficient" class="headerlink" title="Towards Label Efficient"></a>Towards Label Efficient</h2><h3 id="COˆ3-Cooperative-Unsupervised-3D-Representation-Learning-for-Autonomous-Driving"><a href="#COˆ3-Cooperative-Unsupervised-3D-Representation-Learning-for-Autonomous-Driving" class="headerlink" title="COˆ3: Cooperative Unsupervised 3D Representation Learning for Autonomous Driving"></a>COˆ3: Cooperative Unsupervised 3D Representation Learning for Autonomous Driving</h3><h4 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h4><p>针对室内场景点云的无监督对比学习已经取得了巨大的成功。然而，室外场景点云的无监督表示学习仍然具有挑战性，因为以前的方法需要重建整个场景并捕获对比目标的部分视图。这在有运动物体、障碍物和传感器的室外场景中是不可行的。在本文中，我们提出了CO ( 3，即协同对比学习和上下文形状预测，以无监督的方式学习室外场景点云的三维表示。与现有方法相比，CO3有几个优点。( 1 )利用车载侧和基础设施侧的LiDAR点云<strong>构建足够差异但同时保持共同语义信息的视图进行对比学习，比以往方法构建的视图更合适</strong>。( 2 )在对比目标的基础上，<strong>提出了上下文形状预测作为预训练目标，为无监督的三维点云表示学习带来了更多与任务相关的信息，有利于将学习到的表示迁移到下游的检测任务中</strong>。( 3 )与以往的方法相比，CO ( 3 )学习到的表示可以迁移到不同类型的LiDAR传感器采集的室外场景数据集上。( 4 ) CO ( 3在Once和KITTI d上都改进了当前最先进的方法</p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>​    激光雷达作为室外环境中最可靠的传感器，能够精确地测量物体的三维位置，机器人和计算机视觉领域都对激光雷达点云的感知任务表现出强烈的兴趣，包括三维物体检测、分割和跟踪，这些任务对于自动驾驶系统至关重要。迄今为止，在详细的标注数据上从头开始随机初始化和直接训练仍然占据着该领域的主导地位。与此相反，最近图像领域的研究工作侧重于从图像构建具有不同视角对比目标的无监督表示学习</p><p>他们以无监督的方式使用ImageNet 等大规模数据集对2D骨干网络进行预训练，并使用预训练的骨干网络在不同的数据集上初始化下游神经网络，在2D目标检测中实现了从头开始训练的显著性能提升。受这些成功的启发，结合自动驾驶车辆中丰富的未    标记数据探索了室外场景点云的无监督表示学习，以提高三维目标检测任务的性能。在过去的十年中，从无标签数据中学习三维表示在单目标和室内场景点云中取得了巨大的成功。对于单个物体的点云，如CAD模型，先前的工作通过最小化对比损失来预训练3D编码器来预测全局表示，并针对包括物体分类和配准在内的低级下游任务。为了将这一思想扩展到室内场景点云的高层感知任务，Point Contrast 提出重建整个室内场景，从两个不同的姿态采集部分点云，并将其作为对比学习中的两个视图来学习稠密的(点级或三维像素水平)表示</p><p><img data-src="https://s2.loli.net/2024/09/12/Q2bxeyYMCcFtz5K.png" alt="image-20240912213954703"></p><h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><h3 id="SiCP-Simultaneous-Individual-and-Cooperative-Perception-for-3D-Object-Detection-in-Connected-and-Automated-Vehicles"><a href="#SiCP-Simultaneous-Individual-and-Cooperative-Perception-for-3D-Object-Detection-in-Connected-and-Automated-Vehicles" class="headerlink" title="SiCP: Simultaneous Individual and Cooperative Perception for 3D Object Detection in Connected and Automated Vehicles"></a>SiCP: Simultaneous Individual and Cooperative Perception for 3D Object Detection in Connected and Automated Vehicles</h3><p>传统的车联网和自动驾驶车辆的协同感知是通过融合来自两个或多个车辆的特征图来实现的。然而，与独立的3D检测模型相比，缺乏来自其他车辆的共享特征图会导致协作感知模型的3D目标检测性能显著下降。这一缺陷阻碍了合作感知的采用，因为车辆资源通常不足以同时使用两种感知模型。</p><p>为了解决这个问题提出了一个通用的框架，即同时的个人和合作感知( Simultaneous Personal and Cooperative Perception，SiCP )，它支持广泛的最新独立感知主干，并通过一个新颖的双感知网络( Dual-Perception Network，DP-Net )来增强它们，以促进个人和合作感知。除了其仅有0.13 M参数的轻量级特性外，DP - Net具有鲁棒性，并且在特征图融合过程中保留了关键的梯度信息。在V2V4Real和OPV2V数据集上的综合评估表明，得益于DP - Net，SiCP在保持独立感知解决方案性能的同时，超越了最先进的合作感知解决方案。</p><h3 id="TransIFF-An-Instance-Level-Feature-Fusion-Framework-for-Vehicle-Infrastructure-Cooperative-3D-Detection-with-Transformers"><a href="#TransIFF-An-Instance-Level-Feature-Fusion-Framework-for-Vehicle-Infrastructure-Cooperative-3D-Detection-with-Transformers" class="headerlink" title="TransIFF: An Instance-Level Feature Fusion Framework for Vehicle-Infrastructure Cooperative 3D Detection with Transformers"></a>TransIFF: An Instance-Level Feature Fusion Framework for Vehicle-Infrastructure Cooperative 3D Detection with Transformers</h3><p><img data-src="https://s2.loli.net/2024/09/29/CRH32uyWOKGefIX.png" alt="image-20240929153235022"></p><p>车辆和基础设施之间的合作对于增强自动驾驶的安全性至关重要。协作感知目前面临着两个重大而矛盾的挑战：融合精度和通信带宽。以往传递特征的中级融合方法相比早期融合和后期融合在精度和带宽上取得了平衡，但<strong>通常存在feature misalignment和domain gaps的问题，bandwitdth usage仍然达不到工业应用标准</strong></p><p>在本文中提出了TransIFF，一种带有Transformer的instance-level特征融合框架，可以有效地减少带宽占用。此外，它可以对齐车辆和基础设施特征之间的域间隙，并提高特征融合的鲁棒性，从而获得较高的协作感知精度</p><p>TransIFF由3个部分组成:车辆侧网络、基础设施侧网络和车辆-基础设施融合网络.最初,车辆端和基础设施端网络独立生成实例级特征</p><p>最初，车辆端和基础设施端网络独立生成实例级特征。随后，基础设施侧的实例级特征被传输到车辆，显著降低了通信带宽的使用。</p><p>最后，在车路融合网络中，设计了跨域适应( Cross-Domain Adaptation，CDA )模块对齐特征域，紧接着设计了Feature Magnet模块对实例特征进行自适应融合，实现了鲁棒的特征融合</p><p>​    得益于基础设施侧传感器的高安装高度，无人驾驶车辆通过接收基础设施侧传感器的信息，实现全局视角和远距离感知，显著提高了感知能力</p><p>​    车路协同感知面临的挑战之一是信息需要从基础设施侧设备发送到自动驾驶汽车，这需要通信带宽资源。然而，工业通信系统在实时性方面难以承担巨大的通信消耗</p><p>​    因此，如何在保证协作感知准确性的同时降低通信带宽消耗至关重要。中间融合传输特征信息，提供了带宽占用和精度之间的权衡。</p><p>然而，尽管与早期融合相比数据量减少，中间融合的带宽占用仍然达不到工业标准。而且，<strong>大多数中间融合方法面临空间对齐的挑战，对车辆与基础设施侧设备之间的实时位姿提出了很高的要求</strong>，导致特征融合的鲁棒性不足。</p><p>​    此外，<strong>来自车辆侧和基础设施侧传感器的特征属于两个域，特征中的域间隙也会影响协同感知的准确性</strong>。</p><p>在这项工作中，我们提出了一种基于Transformer的鲁棒有效的实例级特征融合框架TransIFF。我们的核心思想是通过传递实例级特征而不是整个特征来减少带宽消耗，同时通过对齐域间隙来提高协同感知的精度，并通过一个可以摆脱对高精度位姿依赖的转换器来实现鲁棒和自适应的特征融合</p><p><img data-src="https://s2.loli.net/2024/09/29/YSQu4vcAMRmW1Ik.png" alt="image-20240929154153968"></p><p><img data-src="https://s2.loli.net/2024/09/29/PbLXy7mO63e8GYE.png" alt="image-20240929154315251"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/CatOneTwo/Collaborative-Perception-in-Autonomous-Driving/tree/main?tab=readme-ov-file">CatOneTwo/Collaborative-Perception-in-Autonomous-Driving: (2023 ITSM) Collaborative Perception in Autonomous Driving: Methods, Datasets and Challenges (github.com)</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些稍微新一点或者之前没看到的想法还不错的协同感知论文&lt;br&gt;</summary>
    
    
    
    
    <category term="collaborative perception" scheme="https://www.sekyoro.top/tags/collaborative-perception/"/>
    
  </entry>
  
  <entry>
    <title>Rust learning:from germ to grave</title>
    <link href="https://www.sekyoro.top/2024/06/29/Rust-learning-from-germ-to-grave/"/>
    <id>https://www.sekyoro.top/2024/06/29/Rust-learning-from-germ-to-grave/</id>
    <published>2024-06-29T04:51:24.000Z</published>
    <updated>2024-08-29T12:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Rust官方推荐的三个资料,分别是The Rust programming language,Rust by examples以及ruslings,已经相当充足了.包括相对全面的书,代码例子以及方便的互动式exercises.个人觉得,the book相当于字典,虽然其实还有内容更多的reference,而examples更加易懂上手,rustlings相当于刷题,把关键东西了解一遍.</p><p>所以从这三个东西入手开始Rust学习之旅,一些地方会跟c++对比.<br><span id="more"></span></p><h3 id="宏macro"><a href="#宏macro" class="headerlink" title="宏macro"></a>宏macro</h3><p>术语宏指的是Rust中的一系列特性:带有macro_rules的声明性宏!还有三种过程宏:</p><ul><li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute used on structs and enums</li><li>Attribute-like macros that define custom attributes usable on any item</li><li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量binding"><a href="#变量binding" class="headerlink" title="变量binding"></a>变量binding</h3><p>知识点:</p><ol><li>不变性 Rust默认不可变,不像c++到处声明const</li><li>scope和shadowing 主要有variable shadowing,也就是可以重声明,在c++中不允许</li><li>将一个mut的值赋值给non-mut的值,在那个域内,non-mute的值也不能被改变</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">5</span>; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="string">&quot;T-H-R-E-E&quot;</span>; <span class="comment">// don&#x27;t change this line</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Spell a Number : &#123;&#125;&quot;</span>, number);</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>; <span class="comment">// don&#x27;t rename this variable</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number plus two is : &#123;&#125;&quot;</span>, number + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> _mutable_integer = <span class="number">7i32</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Shadowing by immutable `_mutable_integer`</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> _mutable_integer = _mutable_integer;</span><br><span class="line">        </span><br><span class="line">        _mutable_integer = <span class="number">50</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// `_mutable_integer` goes out of scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok! `_mutable_integer` is not frozen in this scope</span></span><br><span class="line">    _mutable_integer = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h3><h4 id="字面量和操作符"><a href="#字面量和操作符" class="headerlink" title="字面量和操作符"></a>字面量和操作符</h4><ol><li>推荐在使用字面量是后面加上类型.</li><li>原生类型本身可以printable</li></ol><p>元组、数组与slices. </p><p>元组,通过()表示,通过.num索引,可以使用#[derive(Debug)]实现方法打印.</p><p>数组 [T;length]声明,编译时已知.</p><p>切片(Slices)与数组类似,但它们的长度在编译时是未知的。相反,切片是一个由两个字(word)组成的对象:第一个字是指向数据的指针,第二个字是切片的长度。字的大小与 <code>usize</code> 类型相同,由处理器架构决定,例如在 x86-64 上为 64 位。切片可用于借用数组的一部分,它的类型签名为 <code>&amp;[T]</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function borrows a slice.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">analyze_slice</span></span>(slice: &amp;[<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;First element of the slice: &#123;&#125;&quot;</span>, slice[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The slice has &#123;&#125; elements&quot;</span>, slice.len());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xs: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// All elements can be initialized to the same value.</span></span><br><span class="line"><span class="keyword">let</span> ys: [<span class="built_in">i32</span>; <span class="number">500</span>] = [<span class="number">0</span>; <span class="number">500</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Borrow the whole array as a slice.&quot;</span>);</span><br><span class="line">analyze_slice(&amp;xs);</span><br></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><h4 id="structures"><a href="#structures" class="headerlink" title="structures"></a>structures</h4><p>使用 <code>struct</code> 关键字可以创建三种类型的结构体(struct):</p><ol><li>元组结构体(Tuple structs)，基本上是命名元组。</li><li>经典的 C 风格结构体。</li><li>无字段的单元结构体(Unit structs)，在泛型编程中很有用。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A unit struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Unit</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>(<span class="built_in">i32</span>, <span class="built_in">f32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct with two fields</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f32</span>,</span><br><span class="line">    y: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>(<span class="built_in">i32</span>, <span class="built_in">f32</span>);</span><br><span class="line"><span class="comment">// Instantiate a tuple struct</span></span><br><span class="line"><span class="keyword">let</span> pair = Pair(<span class="number">1</span>, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access the fields of a tuple struct</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, pair.<span class="number">0</span>, pair.<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destructure a tuple struct</span></span><br><span class="line"><span class="keyword">let</span> Pair(integer, decimal) = pair;</span><br></pre></td></tr></table></figure><h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><p><code>enum</code>关键字允许创建一个可以是几种不同变体(variant)之一的类型。任何在结构体(struct)中有效的变体,在枚举(enum)中也是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h4><p>Rust 有两种不同类型的常量,可以在任何作用域(包括全局)中声明。两种常量都需要显式的类型注解:</p><ol><li><code>const</code>: 不可变的值(最常见的情况)。</li><li><code>static</code>: 可能是可变的变量,拥有 <code>&#39;static</code> 生命周期。<code>&#39;static</code> 生命周期是被推断出来的,不需要显式指定。访问或修改可变的 <code>static</code> 变量是不安全的</li></ol><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="强大的包管理系统"><a href="#强大的包管理系统" class="headerlink" title="强大的包管理系统"></a>强大的包管理系统</h4><p>一个rust项目可能是lib也可以是main,分别代表生成库和可执行程序. 注意可以既存在main.rs和lib.rs.</p><ul><li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li><li><strong>Crates:</strong> A tree of modules that produces a library or executable</li><li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and privacy of paths</li><li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li></ul><p>crate根文件是Rust编译器启动的源文件,它构成了crate的根模块</p><p>包(Packages)是提供一组功能的一个或多个crate的集合。一个包包含一个Cargo.toml。描述如何构建这些crate的Toml文件。Cargo实际上是一个包，其中包含用于构建代码的命令行工具的二进制crate。Cargo包还包含一个二进制包所依赖的库包。其他项目可以依赖Cargo库crate来使用Cargo命令行工具使用的相同逻辑。</p><p>crate有两种形式:二进制(binary)crate或库(library )crate。二进制crate是可以编译为可运行的可执行文件的程序，例如命令行程序或服务器。每个程序都必须有一个名为main的函数，用于定义可执行程序运行时发生的情况。</p><p>library crate<strong>没有main函数</strong>，也不能编译成可执行文件。相反，它们定义了旨在与多个项目共享的功能。</p><h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><ol><li><p>从crate根目录开始:当编译一个crate时，编译器<strong>首先查找crate根文件</strong>(通常是src/lib.rs,为库crate或src/main.rs表示二进制文件)用于编译代码。</p></li><li><p>声明模块:在crate根文件中，你可以声明新的模块;假设你用mod garden;声明了一个“花园”模块。编译器将在这些地方查找模块的代码：</p><p> 内联下载mod garden之后</p><p> 在src/garden.rs文件中</p><p>在src/garden/mod.rs文件中   查找模块的规律就是同级目录同名文件或者同名子目录中的<code>mod.rs</code>文件</p></li><li><p>声明子模块:在crate根目录之外的任何文件中(除了<code>src/main/lib.rs</code>的文件中)，都可以声明子模块。例如，你可以声明mod vegetables;在<code>src/garden.rs</code>。编译器将在以下地方以父模块命名的目录中查找子模块的代码:</p><p>内联，直接跟在mod vegetables后面</p><p>在src/garden/vegetables.rs文件中</p><p>在src/garden/vegetables/mod.rs文件中     查找子模块的规律就是与文件同名子目录中的同名模块文件或者同名模块目录中的<code>mod.rs</code>文件</p></li><li><p>模块中的代码路径:一旦模块成为crate的一部分,只要隐私规则允许,就可以使用代码路径从同一crate中的任何其他地方引用该模块中的代码。例如，garden vegetables模块中的Asparagus类型可以在crate::garden::vegetables::Asparagus中找到。</p></li><li><p>私有vs.公共:默认情况下，模块内的代码对其父模块是私有的。要使一个模块为公共，请使用pub mod而不是mod声明它。要使公共模块中的项也为公共，请在声明它们之前使用pub。</p></li><li><p>use关键字:在作用域中，use关键字创建项的快捷方式，以减少长路径的重复。在任何可以引用crate::garden::vegetables::Asparagus的作用域中，你可以使用crate::garden::vegetables::Asparagus创建一个快捷方式;从那时起，你只需要编写Asparagus就可以在作用域中使用该类型。</p><p>​     注意,<code>use</code>是用于减少名称重复的,<code>pub mod</code>才是用于引入的.</p><p>使用<code>mod</code>组织代码结构,提到src/main.rs和src/lib.rs被称为crate roots.命名的原因是这两个文件的内容在crate的模块结构(称为模块树)的根位置形成了一个名为crate的模块</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">serve_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 模块树,注意</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">crate</span></span><br><span class="line"><span class="string"> └── front_of_house</span></span><br><span class="line"><span class="string">     ├── hosting</span></span><br><span class="line"><span class="string">     │   ├── add_to_waitlist</span></span><br><span class="line"><span class="string">     │   └── seat_at_table</span></span><br><span class="line"><span class="string">     └── serving</span></span><br><span class="line"><span class="string">         ├── take_order</span></span><br><span class="line"><span class="string">         ├── serve_order</span></span><br><span class="line"><span class="string">         └── take_payment</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Path</strong></p><p>在模块树中如何找到一个item</p><p><strong>绝对路径</strong>是从crate根目录开始的完整路径;对于来自外部crate的代码，绝对路径以crate名称开头，而对于来自当前crate的代码，它以文字crate开头。</p><p>相对路径从当前模块开始，使用当前模块中的self、super或标识符。</p></li></ol><p>父模块中的项不能使用子模块中的私有项，但子模块中的项可以使用其祖先模块中的项。这是因为子模块封装并隐藏了它们的实现细节，但是子模块可以看到它们被定义的上下文。</p><p>sibling之间可以调用模块,比如同在crate下的函数和模块,这个函数可以直接调用模块而不使用pub.</p><p><strong>相对路径</strong></p><p>使用super,self等引入.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">deliver_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fix_incorrect_order</span></span>() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::deliver_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cook_order</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意使得模块中的enum,structs,函数等pub才能访问.</p><blockquote><p>一个包可以同时包含src/main。Rs二进制crate根以及src/lib。默认情况下，两个crate都有包名。通常，具有这种既包含库又包含二进制crate模式的包在二进制crate中会有足够的代码来启动调用库crate中的代码的可执行文件。这使得其他项目可以从包提供的大部分功能中受益，因为库crate的代码可以共享</p></blockquote><p>使用<code>use</code>将paths引入作用域,要使用的话就要在同一mod作用域中.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用use将函数的父模块带入作用域意味着我们必须在调用函数时指定父模块。在调用函数时指定父模块可以清楚地表明该函数不是本地定义的，同时仍然可以最大限度地减少完整路径的重复。此外在使用struct、enum和其他项时，习惯上指定完整路径。</p><p>对于将两个具有相同名称的类型带入相同作用域的问题,除了引入父模块，还有另一种解决方案:在路径之后，可以为类型指定as和一个新的本地名称或别名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用use关键字将名称引入作用域时，在新作用域中可用的名称是private。为了使调用代码的代码能够引用该名称，就好像它是在该代码的作用域中定义的一样，可以组合pub和use。这种技术被称为再导出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// restaurant  src/lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更改之前，外部代码必须通过restaurant::front_of_house::hosting::add_to_waitlist()来调用add_to_waitlist函数，这也需要将front_of_house模块标记为pub.现在外部代码可以使用restaurant::hosting::add_to_waitlist()代替。</p><p>标准std库也是一个包外部的crate。因为标准库是随Rust语言一起提供的，所以不需要更改Cargo.toml。但是需要用use来引用它，以便将其中的项引入包的作用域。</p><p>推荐模块命名不要为<code>mod.rs</code>,使用名为<code>mod.rs</code>文件的风格的主要缺点是项目最终可能会有许多名为mod.rs的文件,当同时在编辑器中打开它们时,这可能会令人困惑。</p><h3 id="使用Cargo构建大项目"><a href="#使用Cargo构建大项目" class="headerlink" title="使用Cargo构建大项目"></a>使用Cargo构建大项目</h3><h4 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h4><p>在debug和release构建时可以使用不同的选项,在<code>Cargo.toml</code>中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Cargo有两个主要配置profiles:运行Cargo构建时使用的开发配置文件和运行Cargo构建—发布时使用的发布配置文件。运行<code>cargo build --release</code>使用<code>release</code> profile.</p><p>当没有显式地添加任何profiles时，Cargo对应用的每个profiles都有默认设置。通过添加[profile.]*]部分，自定义的任何配置文件,覆盖任何子集的默认设置。</p><p>option-level设置控制Rust将应用于代码的优化数量，范围为0到3。应用更多的优化会延长编译时间，因此，如果您正在开发并经常编译代码，那么您可能希望通过更少的优化来加快编译速度，即使结果代码运行得更慢。</p><p>因此dev的默认选项级别为0。准备发布代码时，最好花更多的时间进行编译。将只在发布模式下编译一次，但是将多次运行编译后的程序，因此发布模式以较长的编译时间换取运行速度更快的代码</p><p>使用<code>cargo publish</code>进行发布,注意需要注册crates.io账号,如果需要更新版本更改<code>version</code>再推送即可</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p>使用<code>cargo yank --vers [versionNumber]</code>可以阻止使用这个项目的某个版本的依赖.</p><p>yank一个版本可以防止新项目依赖于该版本，同时允许所有依赖于该版本的现有项目继续进行。</p><h4 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h4><p>工作区是一组共享Cargo.lock,和输出目录的packages. 常见工作流是一个可执行文件的packages和多个生成库的packages.</p><p>在根目录下创建<code>Cargo.toml</code>,其中添加packages名字,假设根目录名字add</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"></span><br><span class="line">members = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new adder</span><br></pre></td></tr></table></figure><p>目录结构如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Cargo</span>.</span></span>lock</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Cargo</span>.</span></span>toml</span><br><span class="line">├── adder</span><br><span class="line">│   ├── <span class="module-access"><span class="module"><span class="identifier">Cargo</span>.</span></span>toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>工作区在顶层有一个目标目录，编译后的工件将被放置到该目录中;adder包没有自己的目标目录。即使要从adder目录中运行cargo构建，编译后的工件仍然会在add/target而不是add/adder/target中结束。Cargo在工作区的目标目录中采用这样的结构，因为工作区的crate是相互依赖的。</p><blockquote><p>如果每个crate都有自己的目标目录，那么每个crate都必须重新编译工作空间中的其他crate，以便将工件放置在自己的目标目录中。通过共享一个目标目录，crate可以避免不必要的重新构建。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new add_one --lib</span><br></pre></td></tr></table></figure><p>继续添加crate,加入workspace中.</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;add_one&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加本地项目中的依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adder/Cargo.toml</span></span><br><span class="line">[dependencies]</span><br><span class="line">add_one = &#123; path = <span class="string">&quot;../add_one&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>在顶层目录运行<code>cargo build</code>,然后指定<code>-p</code>运行指定可执行程序<code>cargo run -p adder</code></p><p>如果要使workspace下两个crate使用同一版本同一个依赖,可以使得其中一个crate依赖另一个依赖,build之后在顶层cargo.lock中会有相关依赖信息.</p><blockquote><p>Cargo将确保工作空间中使用rand包的每个包中的每个crate都使用相同的版本，只要它们指定rand的兼容版本，就可以节省空间并确保工作空间中的crate彼此兼容</p></blockquote><p>workspace中的项目测试,在顶层目录中<code>cargo test</code>运行每个crate中的测试,使用<code>cargo test -p</code>指定,发布项目同理,<code>cargo publish -p</code>.</p><p><code>cargo install</code>命令在本地安装和使用二进制crate.</p><p>所有使用cargo install安装的二进制文件都存储在安装根目录的bin文件夹中。如果没有任何自定义配置，这个目录将是<code>$HOME/.cargo/bin</code></p><p>如果<code>$PATH</code>中的二进制文件名为<code>cargo-something</code>，则可以通过运行Cargo something来将其作为Cargo子命令运行。在运行cargo——list时会列出这样的自定义命令。</p><h4 id="cargo-fmt-clippy"><a href="#cargo-fmt-clippy" class="headerlink" title="cargo fmt/clippy"></a>cargo fmt/clippy</h4><p>分别用于格式化和语法提示</p><h4 id="cargo-doc"><a href="#cargo-doc" class="headerlink" title="cargo doc"></a>cargo doc</h4><p>非常方便的生成文档的工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc --no-deps --open</span><br></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>单元测试 集成测试 benchmarks</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test&#123;</span><br><span class="line"><span class="keyword">use</span> super::*;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外也有doc-test,用于测试文档中的代码.尝试使用<code>criterion</code><a href="https://bheisler.github.io/criterion.rs/book/index.html">Criterion.rs - Criterion.rs Documentation (bheisler.github.io)</a>进行benchmark测试.</p><h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> log::&#123;error,warn,info,debug,trace&#125;;</span><br><span class="line">error!();</span><br><span class="line">warn!();</span><br><span class="line">info!();</span><br><span class="line">debug!();</span><br><span class="line">trace!();</span><br></pre></td></tr></table></figure><h3 id="dyn"><a href="#dyn" class="headerlink" title="dyn"></a>dyn</h3><p>Rust 编译器需要知道每个函数的返回类型需要多少空间。这意味着所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 <code>Animal</code> 那样的的 trait，则不能编写返回 <code>Animal</code> 的函数，因为其不同的实现将需要不同的内存量。</p><p>但是，<strong>有一个简单的解决方法。相比于直接返回一个 trait 对象，我们的函数返回一个包含一些 <code>Animal</code> 的 <code>Box</code></strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">walk</span></span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> walk <span class="keyword">for</span> a &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> walk <span class="keyword">for</span> b &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">xx</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">let</span> t = <span class="built_in">vec!</span>[<span class="built_in">Box</span>::new(a&#123;]&#125;),<span class="built_in">Box</span>::new(b&#123;&#125;)]; <span class="comment">// Box&lt;dyn walk&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>box</code> 只是对堆中某些内存的引用。因为引用的大小是静态已知的，并且编译器可以保证引用指向已分配的堆 <code>Animal</code>，所以可以从函数中返回 trait.</p><p>每当在堆上分配内存时，Rust 都会尝试尽可能明确。因此，如果<strong>函数以这种方式返回指向堆的 trait 指针，则需要使用 <code>dyn</code> 关键字编写返回类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sheep</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Animal</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例方法签名</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">noise</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `Sheep` 的 `Animal` trait。</span></span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Sheep &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">noise</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;baaaaah!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `Cow` 的 `Animal` trait。</span></span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Cow &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">noise</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;moooooo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">random_animal</span></span>(random_number: <span class="built_in">f64</span>) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> random_number &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        <span class="built_in">Box</span>::new(Sheep &#123;&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Box</span>::new(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> random_number = <span class="number">0.234</span>;</span><br><span class="line">    <span class="keyword">let</span> animal = random_animal(random_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;</span>, animal.noise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>与C++类似,rust也使用了一套机制保证内存安全. 智能指针相比于借用(引用)来说,其在大多数情况下拥有所有权.</p><p>常用智能指针类型如下</p><ul><li><code>Box&lt;T&gt;</code> for allocating values on the heap</li><li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li><li><p><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</p></li><li><p><strong>RefCell</strong>：智能指针，允许运行时动态获取可变引用，跟踪借用以保证安全性</p></li><li><strong>Arc</strong>:线程安全的reference counting type</li></ul><p>此外,有<strong>Ref</strong>:用于在不可变借用的情况下安全地访问数据和<strong>Cell</strong>分别用来安全访问数据.</p><h4 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h4><p>你必须通过使用Rust类型Rc\<T>显式地启用多重所有权，Rc\<T>是引用计数的缩写。Rc\<T>类型跟踪对一个值的引用次数，以确定该值是否仍在使用。如果对一个值的引用为零，则可以清除该值，而不会导致任何引用无效。</p><p>当<strong>想要在堆上分配一些数据供程序的多个部分读取,并且在编译时无法确定哪个部分将最后使用该数据时</strong>,使用Rc\<T>类型。<strong>如果知道哪一部分将最后完成,就可以将该部分设置为数据的所有者,并且在编译时强制执行的正常所有权规则将生效。</strong></p><p>注意，<strong>Rc\<T>仅用于单线程场景</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust中，<code>Cell</code> 是标准库中的一个类型，它提供了一种在可变引用的限制下安全地更新数据的方法。<code>Cell</code> 是一个非线程安全的类型，主要用于单线程环境下的可变状态管理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Cell</span></span><br><span class="line">    <span class="keyword">let</span> count = Cell::new(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 get() 获取值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Initial value: &#123;&#125;&quot;</span>, count.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 set() 修改值</span></span><br><span class="line">    count.set(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New value: &#123;&#125;&quot;</span>, count.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Rc\<T>不同，RefCell\<T>类型表示它所持有的数据的单一所有权.</p><p>通过引用和Box\<T>，借用规则的不变量在编译时强制执行。使用RefCell\<T>，这些<strong>不变量在运行时强制执行</strong>。对于引用，如果违反了这些规则，就会出现编译器错误。对于RefCell\<T>，如果你违反了这些规则，你的程序就会panic并退出。</p><blockquote><p>在编译时检查借用规则的优点是，在开发过程中可以更快地捕获错误，并且不会对运行时性能产生影响，因为所有的分析都是事先完成的。由于这些原因，在大多数情况下，在编译时检查借用规则是最好的选择，这就是为什么这是Rust的默认值。</p><p>在运行时检查借阅规则的优点是，在编译时检查不允许的情况下，允许某些内存安全的场景。静态分析和Rust编译器一样，本质上是保守的。代码的一些属性是不可能通过分析代码来检测的</p></blockquote><p>与Rc\<T>类似，RefCell\<T>仅用于单线程场景，如果您尝试在多线程上下文中使用它，则会给您一个编译时错误。(尝试使用Mutex以及Arc)</p><h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h4><p>同c++中的weak_ptr,避免循环引用.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h4><p>Rc\<T>允许同一数据的多个所有者;Box\<T>和RefCell\<T>具有单个所有者。</p><p>Box\<T>允许在编译时检查不可变或可变借用(意味着只有单一读取和修改者,同时也是owner);Rc\<T>只允许在编译时不可变借用(相当于可以有多个可读,不能更改值,可以考虑搭配RefCell修改);</p><p>RefCell\<T>允许在运行时检查不可变或可变的借用。因为RefCell\<T>允许在运行时检查可变借用，所以即使RefCell\<T>是不可变的，你也可以改变RefCell\<T>中的值。</p><blockquote><p>内部可变性是Rust中的一种设计模式，它允许你改变数据，即使数据有不可变的引用;</p><p>这就是使用RefCell的目的.</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;<span class="symbol">&#x27;a</span> T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用RefCell\<T>的常见方法是与Rc\<T>结合使用。回想一下，Rc\<T>允许您拥有某些数据的多个所有者，但它只提供对该数据的不可变访问。如果你有一个Rc\<T>持有一个RefCell\<T>，可以得到一个值，可以有多个所有者，你可以改变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在有多个owner情况下修改数据 使用Rc和RefCell</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">3</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">4</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;a:?&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;b:?&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;c:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下,没有特别情况可以使用Box,类似于c++中unique_ptr,Rc类似于shared_ptr.</p><p>Arc和Mutex用于多线程情况. RefCell本身是运行时改变借用可变性,在一些情况下可以使用.</p><h4 id="Trait-对比Concept-in-C-20"><a href="#Trait-对比Concept-in-C-20" class="headerlink" title="Trait 对比Concept in C++20"></a>Trait 对比Concept in C++20</h4><p>Rust中trait与泛型结合很好,同时由于Rust没有类的继承,可以考虑使用泛型继承和组合实现类似效果. 可以<strong>使用<code>:</code>以及where和<code>+</code>搭配可以对trait的继承以及对泛型的限制进行描述</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> train walk &#123;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">xxx</span></span>();</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">yy</span></span>()&#123;<span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">zzz</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">run</span></span>:walk &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">ttt</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(s:<span class="keyword">dyn</span> run)&#123;&#125;</span><br><span class="line"><span class="comment">// 限制结构的泛型</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Hi</span></span>&lt;T:run&gt; &#123;</span><br><span class="line">  T:value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现结构的trait</span></span><br><span class="line"><span class="keyword">impl</span> walk <span class="keyword">for</span> Hi&lt;T&gt; <span class="keyword">where</span> T:walk &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外trait也可以写泛型(这在c++中往往是常见行为). trait在继承时使用<code>:</code>和<code>+</code>,在泛型使用时使用<code>:</code>或<code>where</code>,<code>+</code>.</p><p>在c++中concept更偏向于限制泛型,而rust中trait还有接口的含义(通过实现接口而不是继承满足要求).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = std::is_integral&lt;T&gt;::value;</span><br></pre></td></tr></table></figure><p>声明concept如上,此外可以使用<code>&amp;&amp;</code>搭配,还可以使用requires</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123; a + b; &#125;;  <span class="comment">// a + b 可通过编译即可</span></span><br></pre></td></tr></table></figure><ol><li><code>requires &#123; requirement-seq &#125;</code></li><li><code>requires ( parameter-list(optional) ) &#123; requirement-seq &#125;</code></li></ol><p><code>requirements-seq</code> 可以是：简单要求、类型要求、复合要求、嵌套要求.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">concept</span> Check = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123;</span><br><span class="line">    &#123; a.<span class="built_in">clear</span>() &#125; <span class="keyword">noexcept</span>;  <span class="comment">// 支持clear,且不抛异常</span></span><br><span class="line">    &#123; a + b &#125; <span class="keyword">noexcept</span>-&gt;std::same_as&lt;<span class="keyword">int</span>&gt;;  <span class="comment">// std::same_as&lt;decltype((a + b)), int&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C =</span><br><span class="line">    <span class="built_in"><span class="keyword">requires</span></span>(T x) &#123;</span><br><span class="line">    &#123;*x&#125;;                                 <span class="comment">// *x有意义</span></span><br><span class="line">    &#123; x + <span class="number">1</span> &#125; -&gt; std::same_as&lt;<span class="keyword">int</span>&gt;;       <span class="comment">// x + 1有意义且std::same_as&lt;decltype((x + 1)), int&gt;，即x+1是int类型</span></span><br><span class="line">    &#123; x * <span class="number">1</span> &#125; -&gt; std::convertible_to&lt;T&gt;;  <span class="comment">// x * 1 有意义且std::convertible_to&lt; decltype((x *1),T&gt;，即x*1可转变为T类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">concept</span> Check = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123;</span><br><span class="line">    <span class="keyword">requires</span> std::same_as&lt;<span class="keyword">decltype</span>((a + b)), <span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">concept</span> Check = <span class="built_in"><span class="keyword">requires</span></span>(T a, T b) &#123;</span><br><span class="line">    &#123; a + b &#125; -&gt; std::same_as&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而使用concept如下,使用和定义concept时都可以使用requires和&amp;&amp;.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> integral&lt;T&gt; </span></span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">// 个人推荐</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T a)</span> <span class="keyword">requires</span> integral&lt;T&gt; </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span> &lt;integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T&amp; a)</span> </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">//</span></span><br><span class="line"><span class="function">integral <span class="keyword">auto</span> <span class="title">inc</span><span class="params">(integral <span class="keyword">auto</span> a)</span> </span>&#123; <span class="keyword">return</span> ++a; &#125; <span class="comment">// 泛型函数 使用concept限制</span></span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>作为偏底层的编程语言,c/c++,rust,zig等目前都还在发展,即使c++已过五十年,但C++2a中Concepts,Modules,Coroutines(协程)等新特性都不断出现(虽然在其他语言中早就有了),所以还是地位仍在的.而后两者在前端工具构建上均大显身手,期待后续发展.</p><p>我也很喜欢使用C/C++,Go,Rust等写一些小程序demo.</p><h3 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h3><p>一些语言高级特性</p><ol><li><a href="https://draveness.me/metaprogramming/">谈元编程与表达能力 - 面向信仰编程 (draveness.me)</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/tuna/tunight/2020-04-25-generics-and-metaprogramming/slides.pdf">从泛型 (Generics) 到元编程 (Metaprogramming) (tsinghua.edu.cn)</a></li></ol><p><img data-src="https://s2.loli.net/2024/06/29/5tfZJquDxgvKros.png" alt="image-20240629202803323"></p><p><img data-src="https://s2.loli.net/2024/06/29/gZaJPSIc5sdzM91.png" alt="image-20240629202943879"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust官方推荐的三个资料,分别是The Rust programming language,Rust by examples以及ruslings,已经相当充足了.包括相对全面的书,代码例子以及方便的互动式exercises.个人觉得,the book相当于字典,虽然其实还有内容更多的reference,而examples更加易懂上手,rustlings相当于刷题,把关键东西了解一遍.&lt;/p&gt;
&lt;p&gt;所以从这三个东西入手开始Rust学习之旅,一些地方会跟c++对比.&lt;br&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://www.sekyoro.top/tags/Rust/"/>
    
  </entry>
  
</feed>

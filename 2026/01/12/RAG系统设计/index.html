<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=目前LLM应用集中在开发所谓AI智能体,理想中的AI智能体能够自主感知环境并作出决策,与环境的变化不断反馈,同时具备记忆,反思和工具能力.而目前的AI应用中,效果最好,成本也低的还是RAG. name=description><meta content=article property=og:type><meta content=RAG系统设计 property=og:title><meta content=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=目前LLM应用集中在开发所谓AI智能体,理想中的AI智能体能够自主感知环境并作出决策,与环境的变化不断反馈,同时具备记忆,反思和工具能力.而目前的AI应用中,效果最好,成本也低的还是RAG. property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2026/01/13/8gjtfrQ3vART42E.png property=og:image><meta content=https://s2.loli.net/2026/01/13/bSG4or8AcmnNkxP.png property=og:image><meta content=https://s2.loli.net/2026/01/13/OxiwCam8R5HzroU.png property=og:image><meta content=https://s2.loli.net/2026/01/13/HQyj94GeUDbJXvL.png property=og:image><meta content=https://s2.loli.net/2026/01/13/LJ5gIYocRW1OMhs.png property=og:image><meta content=https://s2.loli.net/2026/01/13/a93OWviDeEuVHtS.png property=og:image><meta content=https://s2.loli.net/2026/01/13/HtOu2piYNzmc5oT.png property=og:image><meta content=https://s2.loli.net/2026/01/13/jnPqIHEdLuV2g8l.png property=og:image><meta content=https://s2.loli.net/2026/01/13/FmMrCP7X6E3NsRV.png property=og:image><meta content=https://s2.loli.net/2026/01/13/uWSVRKQ13fZlOde.png property=og:image><meta content=https://s2.loli.net/2026/01/13/oMWHlgAt4XJy5VC.png property=og:image><meta content=https://s2.loli.net/2026/01/13/9QqxH8JkfObdPpe.png property=og:image><meta content=https://s2.loli.net/2026/01/13/3zsZUHCwk5QOaGl.png property=og:image><meta content=https://s2.loli.net/2026/01/13/1MGJDKWENkfjeS4.png property=og:image><meta content=https://s2.loli.net/2026/01/13/GyxSOqhop9erDBA.png property=og:image><meta content=https://s2.loli.net/2026/01/13/BmrKg4o7uCNx3fZ.png property=og:image><meta content=2026-01-12T15:50:19.000Z property=article:published_time><meta content=2026-01-13T15:47:59.136Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content="个人博客 技术学习 计算机 互联网 人工智能" property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2026/01/13/8gjtfrQ3vART42E.png name=twitter:image><link href=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>RAG系统设计 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>RAG系统设计</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2026-01-12 23:50:19" datetime=2026-01-12T23:50:19+08:00>2026-01-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2026-01-13 23:47:59" datetime=2026-01-13T23:47:59+08:00 itemprop=dateModified>2026-01-13</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>22k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>20 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>目前LLM应用集中在开发所谓AI智能体,理想中的AI智能体能够自主感知环境并作出决策,与环境的变化不断反馈,同时具备记忆,反思和工具能力.而目前的AI应用中,效果最好,成本也低的还是RAG.<br><span id=more></span><h2 id=RAG应用场景><a class=headerlink href=#RAG应用场景 title=RAG应用场景></a>RAG应用场景</h2><p>RAG全称是“Retrieval-Augmented Generation”，即“检索增强的生成”。当设计一个LLM问答应用，模型<strong>需要处理用户的领域问题时</strong>，尽管大模型通常表现出色，但有时提供的答案并不准确，甚至可能出现错误。<strong>当用户需要获取实时信息时，模型无法及时提供最新的答案</strong>。这种现象在LLM应用中较为常见。<p>这些模型仍然存在一些无法忽视的局限性。其中，<strong>领域知识缺乏</strong>是最明显的问题。大模型的知识来源于训练数据，这些数据主要来自公开的互联网和开源数据集，无法覆盖特定领域或高度专业化的内部知识。<p><strong>信息过时</strong>则指模型难以处理实时信息，因为训练过程耗时且成本高昂，模型一旦训练完成，就难以获取和处理新信息。<p>此外，<strong>幻觉问题</strong>是另一个显著的局限，模型基于概率生成文本，有时会输出看似合理但实际错误的答案。最后，<strong>数据安全性</strong>在企业应用中尤为重要，如何在确保数据安全的前提下，使大模型有效利用私有数据进行推理和生成，是一个具有挑战性的问题。<p><img alt=image-20260113140539536 data-src=https://s2.loli.net/2026/01/13/8gjtfrQ3vART42E.png><p>RAG系统的应用场景主要集中在专业领域和企业场景,<p>RAG的核心思想是<strong>利用外部知识库或数据集来辅助模型的生成过程</strong>。具体来说，RAG通常包含以下关键步骤。<ol><li>检索阶段：首先，模型会根据输入的查询或问题，从预先构建的索引中检索出最相关的数据、文档或文本片段。<li>生成阶段：随后，模型会使用这个综合的表示来生成答案或输出文本。在问答任务中，这通常意味着生成一个对原始查询的直接回答。</ol><p>选择RAG而不是直接将所有知识库数据交给大模型处理，主要是<strong>因为模型能够处理的token数有限，输入过多token会增加成本。更重要的是，提供少量相关的关键信息能够带来更优质的回答</strong>。<p><strong>RAG模型的核心思想在于通过检索与生成的有机结合，弥补大模型在处理领域问题和实时任务时的不足。</strong>传统的生成模型在面对复杂问题时，往往由于知识储备不足，生成出错误或无关的回答。而RAG通过检索模块获取相关的背景信息，使生成模块能够参考这些信息，从而生成更具可信度和准确性的答案。这种方法不仅增强了生成内容的准确性，还提高了模型在应对特定领域知识和动态信息时的适应能力。<p><img alt=image-20260113141707928 data-src=https://s2.loli.net/2026/01/13/bSG4or8AcmnNkxP.png style=zoom:67%;><p>RAG标准流程由<strong>索引</strong>（Indexing）、<strong>检索</strong>（Retriever）和<strong>生成</strong>（Generation）三个核心阶段组成。<ol><li>索引阶段，通过<strong>处理多种来源多种格式的文档提取其中文本，将其切分为标准长度的文本块</strong>（chunk），并进行<strong>嵌入向量化（embedding），向量存储在向量数据库</strong>（vector database）中。<li>检索阶段，用户输入的查询（query）被转化为向量表示，通过相似度匹配从向量数据库中检索出最相关的文本块。<li>最后生成阶段，检索到的相关文本与原始查询共同构成提示词（Prompt），输入大语言模型（LLM），生成精确且具备上下文关联的回答。</ol><p><strong>索引是RAG系统的基础环节</strong>，包含四个关键步骤。<ol><li>首先，将各类数据源及其格式（如书籍、教材、领域数据、企业文档等，txt、markdown、doc、ppt、excel、pdf、html、json等格式）统一解析为纯文本格式。<li>接着，根据文本的语义或文档结构，将文档分割为小而语义完整的文本块（chunks），确保系统能够高效检索和利用这些块中包含的信息。<li>然后，使用文本嵌入模型（embedding model），将这些文本块向量化，生成高维稠密向量，转换为计算机可理解的语义表示。<li>最后，将这些向量存储在向量数据库(vector database)中，并构建索引，完成知识库的构建。这一流程成功将外部文档转化为可检索的向量，支撑后续的检索和生成环节。</ol><p><strong>检索是连接用户查询与知识库的核心环节。</strong>首先，用户输入的问题通过同样的文本嵌入模型转换为向量表示，将查询映射到与知识库内容相同的向量空间中。通过相似度度量方法，检索模块从向量数据库中筛选出与查询最相关的前K个文本块，这些文本块将作为生成阶段输入的一部分。通过相似性搜索，检索模块有效获取了与用户查询切实相关的外部知识，为生成阶段提供了精确且有意义的上下文支持。<p><strong>生成是RAG流程中的最终环节</strong>，将检索到的相关文本块与用户的原始查询整合为增强提示词（Prompt），并输入到大语言模型（LLM）中。LLM基于这些输入生成最终的回答，确保生成内容既符合用户的查询意图，又充分利用了检索到的上下文信息，使得回答更加准确和相关，充分使用到知识库中的知识。通过这一过程，RAG实现了具备领域知识和私有信息的精确内容生成。<h2 id=Fine-tuning-vs-RAG><a title="Fine-tuning vs RAG" class=headerlink href=#Fine-tuning-vs-RAG></a>Fine-tuning vs RAG</h2><p>Fine-tuning 作为一种直接针对预训练语言模型进行额外训练的方法，能够让模型更好地适应特定领域或任务。这种方法的核心优势在于，<strong>能够显著提升模型在目标任务上的表现</strong>。通过使用领域特定的数据集，Fine-tuning 可以让模型学习到行业术语、专业知识结构和特定的表达方式。这使得Fine-tuned模型在处理专业领域的问题时，能够提供更加准确、相关的回答。例如，在极客时间，我们把作者的实战经验从文章中提取出来，然后基于开源模型进行微调，让 LLM 可以输出生产环境直接可用的技术方案，而不是一些通用解决方案。<p><strong>微调更适合需求稳定、领域知识固定且不需要频繁更新知识库的场景</strong>。通过使用特定领域的数据对模型进行深度优化，微调可以提升模型在特定任务或领域中的推理能力，确保输出内容的专业性和一致性。因此，当任务侧重于某一特定领域，并且对实时信息的依赖较低时，微调更能满足这些需求<p>此外，Fine-tuning 后的模型响应速度快，无需在运行时检索外部知识库，这使得它特别适合需要实时响应的场景，比如在线客户服务或实时决策支持系统。举个例子，在我们的用户对话功能中，有时候人工客服可能不在线，用户提问如果能快速得到响应，及时解答用户问题，可以大大提高用户的信任感。<p>当然，使用 Fine-tuning 也要付出一些额外的成本。它需要大量的标注数据和较高的计算资源，这对许多企业来说可能是一个门槛。而且，一旦模型经过 Fine-tuning，要更新其知识就需要重新训练，如果是经常变化的知识，可能成本就非常高了。<p>相比之下，RAG 技术提供了一种更为灵活的解决方案，可以更好地处理 “经常变化” 的知识。RAG 通过将大语言模型与外部知识库结合，在生成回答时实时检索相关信息。这种方法非常灵活，由于是自己设计的知识库，可以做各种优化操作，保证把最准确的知识呈现给用户。企业可以随时更新知识库中的信息。<p>RAG 的另一个重要优势是其<strong>可解释性</strong>。由于每个回答都可以追溯到具体的知识来源，这大大增强了AI系统的可信度和透明度。在需要严格监管或高度问责的行业，如金融服务或政府部门，这一特性尤为重要。然而，RAG也有其局限性。由于需要实时检索知识库，RAG系统的响应速度可能不如 Fine-tuned 模型快。此外，RAG的效果高度依赖于<strong>知识库的质量</strong>和<strong>检索算法的效率</strong>，这要求我们投入大量资源来维护和优化知识库。<p>在实际应用中，我们可以将 Fine-tuning 和 RAG 结合使用，以充分发挥两种方法的优势。这种混合方法可以应对更复杂的场景和挑战。例如，要做一个极客时间客服系统，我们可以使用 Fine-tuned 模型来处理常见的、结构化的查询，比如一些通识或者固定不变的知识，保证快速、准确的响应。同时，对于涉及最新产品信息或政策变更的问题，系统可以切换到 RAG 模式，利用实时更新的知识库来提供最新、最相关的信息。在产品研发过程中，可以使用企业内固定的技术相关文档进行 Fine-tuning，让 LLM 回答的内容都是符合企业开发技术范围，再配合上 RAG 把一些外部的技术文档作为补充知识库，两者结合，在内部就可以很好地辅助产研人员工作。<h3 id=未来方向><a class=headerlink href=#未来方向 title=未来方向></a>未来方向</h3><p><strong>第一个方向是动态知识图谱的集成。</strong>传统的RAG系统通常使用静态的知识库，而动态知识图谱将为RAG带来更智能、更灵活的知识管理能力。这种系统不仅能够实时更新知识，还能自动建立知识之间的关联。<p>在前面课程中提到的 Mem0 记忆框架，最近更新了一个特性，就是 graph memory。它把用户的记忆拆分成记忆节点和关系，通过使用图数据库，保存下这些关系和节点，在使用记忆的时候，会通过图检索技术找到记忆之间的关联，从而找到关键的记忆点，然后结合当时的详细记忆，最终给出回答。这种技术可以让用户在海量记忆中去查询问题的答案，相比传统的 RAG，极大程度地提高了记忆的相关性和连续性。<p>还有就是最近大火的<a href=https://microsoft.github.io/graphrag/ rel=noopener target=_blank>GraphRAG</a>。GraphRAG 本身是一个理论，这个项目是由微软开源的，它包括从原始文本中提取知识图，构建社区层次结构，为这些社区生成摘要，然后在执行基于 RAG 的任务时利用这些结构等等功能。<p><strong>第二个方向是个性化</strong> <strong>RAG。</strong>未来的RAG系统将能够根据用户的背景、偏好和使用历史来动态调整其检索和生成策略。<p>例如，一个个性化的 RAG 系统可以根据用户的知识水平、学习风格和关注点来推荐内容和解答用户问题。这种个性化不仅限于内容的选择，还包括表达方式的调整，使得AI助手能够以最适合每个用户的方式进行交流，可以根据不同用户的喜好风格，调整 AI 小助手的说话方式。这将大大提高用户体验，使AI系统更加贴近人类的交互需求，带给用户更多的亲切感。<p><strong>第三个方向是多模态 RAG。</strong>上述的讨论都建立在文本模型上，如果再加上视觉模型，让大模型能像人眼一样观察世界，再把看到的东西内化到知识库中，这将会大大拓宽 RAG 的应用范围，让更多的业务能够用上大模型技术。<p>比如，在医疗领域，使用多模态 RAG 系统可能会同时分析病人的症状描述（文本）、X光片（图像）、心电图（时序数据）和医生的口头诊断（音频）。系统不仅能够理解每种模态的信息，还能够在这些不同模态之间建立联系，提供更加全面和准确的诊断建议。相对于只有文本内容，这种方式能够得出更加准确和有深度的诊断，也更加符合医生的诊断习惯。通过与多模态结合，将会让大模型在更多领域发挥价值，甚至会产生新的产品形态或者服务方式。企业在这个方向上进行探索，会带来创新性的收获。<h2 id=统一多源文档格式><a class=headerlink href=#统一多源文档格式 title=统一多源文档格式></a>统一多源文档格式</h2><p>票据,扫描件,手写,文件里的嵌入表格和数学公式<p><strong>Word文件</strong><p>文档格式.doc,docx,是Word文档的OPen XML格式.<p>块的分布 块与块之间的关系<p><img alt=image-20260113144028000 data-src=https://s2.loli.net/2026/01/13/OxiwCam8R5HzroU.png style=zoom:67%;><p><strong>文档解析工具</strong><p>python-docx,langchain document loader,springlangchain4j,spring ai<p><strong>文档解析逻辑</strong><p>文字通过库直接解析,图片使用路径表示<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>def</span> <span class=title>parse_docx</span>(<span class=params>self, docx_path</span>):</span></span><br><span class=line>       doc = DocxDocument(docx_path)</span><br><span class=line></span><br><span class=line>       content = []</span><br><span class=line></span><br><span class=line>       image_map = self._extract_images_from_docx(doc)</span><br><span class=line></span><br><span class=line>       <span class=function><span class=keyword>def</span> <span class=title>parse_paragraph</span>(<span class=params>paragraph</span>):</span></span><br><span class=line>           <span class=function><span class=keyword>def</span> <span class=title>append_image_link</span>(<span class=params>image_id, has_drawing, target_buffer</span>):</span></span><br><span class=line>               <span class=string>"""Helper to append image link from image_map based on relationship type."""</span></span><br><span class=line>               rel = doc.part.rels[image_id]</span><br><span class=line>               <span class=keyword>if</span> rel.is_external:</span><br><span class=line>                   <span class=keyword>if</span> image_id <span class=keyword>in</span> image_map <span class=keyword>and</span> <span class=keyword>not</span> has_drawing:</span><br><span class=line>                       target_buffer.append(image_map[image_id])</span><br><span class=line>               <span class=keyword>else</span>:</span><br><span class=line>                   image_part = rel.target_part</span><br><span class=line>                   <span class=keyword>if</span> image_part <span class=keyword>in</span> image_map <span class=keyword>and</span> <span class=keyword>not</span> has_drawing:</span><br><span class=line>                       target_buffer.append(image_map[image_part])</span><br><span class=line></span><br><span class=line>           <span class=function><span class=keyword>def</span> <span class=title>process_run</span>(<span class=params>run, target_buffer</span>):</span></span><br><span class=line>               <span class=comment># Helper to extract text and embedded images from a run element and append them to target_buffer</span></span><br><span class=line>               <span class=keyword>if</span> <span class=built_in>hasattr</span>(run.element, <span class=string>"tag"</span>) <span class=keyword>and</span> <span class=built_in>isinstance</span>(run.element.tag, <span class=built_in>str</span>) <span class=keyword>and</span> run.element.tag.endswith(<span class=string>"r"</span>):</span><br><span class=line>                   <span class=comment># Process drawing type images</span></span><br><span class=line>                   drawing_elements = run.element.findall(</span><br><span class=line>                       <span class=string>".//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}drawing"</span></span><br><span class=line>                   )</span><br><span class=line>                   has_drawing = <span class=literal>False</span></span><br><span class=line>                   <span class=keyword>for</span> drawing <span class=keyword>in</span> drawing_elements:</span><br><span class=line>                       blip_elements = drawing.findall(</span><br><span class=line>                           <span class=string>".//{http://schemas.openxmlformats.org/drawingml/2006/main}blip"</span></span><br><span class=line>                       )</span><br><span class=line>                       <span class=keyword>for</span> blip <span class=keyword>in</span> blip_elements:</span><br><span class=line>                           embed_id = blip.get(</span><br><span class=line>                               <span class=string>"{http://schemas.openxmlformats.org/officeDocument/2006/relationships}embed"</span></span><br><span class=line>                           )</span><br><span class=line>                           <span class=keyword>if</span> embed_id:</span><br><span class=line>                               rel = doc.part.rels.get(embed_id)</span><br><span class=line>                               <span class=keyword>if</span> rel <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span> <span class=keyword>and</span> rel.is_external:</span><br><span class=line>                                   <span class=comment># External image: use embed_id as key</span></span><br><span class=line>                                   <span class=keyword>if</span> embed_id <span class=keyword>in</span> image_map:</span><br><span class=line>                                       has_drawing = <span class=literal>True</span></span><br><span class=line>                                       target_buffer.append(image_map[embed_id])</span><br><span class=line>                               <span class=keyword>else</span>:</span><br><span class=line>                                   <span class=comment># Internal image: use target_part as key</span></span><br><span class=line>                                   image_part = doc.part.related_parts.get(embed_id)</span><br><span class=line>                                   <span class=keyword>if</span> image_part <span class=keyword>in</span> image_map:</span><br><span class=line>                                       has_drawing = <span class=literal>True</span></span><br><span class=line>                                       target_buffer.append(image_map[image_part])</span><br><span class=line>                   <span class=comment># Process pict type images</span></span><br><span class=line>                   shape_elements = run.element.findall(</span><br><span class=line>                       <span class=string>".//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}pict"</span></span><br><span class=line>                   )</span><br><span class=line>                   <span class=keyword>for</span> shape <span class=keyword>in</span> shape_elements:</span><br><span class=line>                       <span class=comment># Find image data in VML</span></span><br><span class=line>                       shape_image = shape.find(</span><br><span class=line>                           <span class=string>".//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}binData"</span></span><br><span class=line>                       )</span><br><span class=line>                       <span class=keyword>if</span> shape_image <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span> <span class=keyword>and</span> shape_image.text:</span><br><span class=line>                           image_id = shape_image.get(</span><br><span class=line>                               <span class=string>"{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id"</span></span><br><span class=line>                           )</span><br><span class=line>                           <span class=keyword>if</span> image_id <span class=keyword>and</span> image_id <span class=keyword>in</span> doc.part.rels:</span><br><span class=line>                               append_image_link(image_id, has_drawing, target_buffer)</span><br><span class=line>                       <span class=comment># Find imagedata element in VML</span></span><br><span class=line>                       image_data = shape.find(<span class=string>".//{urn:schemas-microsoft-com:vml}imagedata"</span>)</span><br><span class=line>                       <span class=keyword>if</span> image_data <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span>:</span><br><span class=line>                           image_id = image_data.get(<span class=string>"id"</span>) <span class=keyword>or</span> image_data.get(</span><br><span class=line>                               <span class=string>"{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id"</span></span><br><span class=line>                           )</span><br><span class=line>                           <span class=keyword>if</span> image_id <span class=keyword>and</span> image_id <span class=keyword>in</span> doc.part.rels:</span><br><span class=line>                               append_image_link(image_id, has_drawing, target_buffer)</span><br><span class=line>               <span class=keyword>if</span> run.text.strip():</span><br><span class=line>                   target_buffer.append(run.text.strip())</span><br></pre></table></figure><p>dify中word提取逻辑,Word 文档（<code>.docx</code>）本质上是一个压缩的 XML 文件。D通过解析这些底层的 XML 标签来重构表格和布局。<ol><li>图片转存逻辑</ol><ul><li><strong>处理位置</strong>：<code>_extract_images_from_docx(self, doc)</code> 方法。<li><strong>具体细节</strong>：<ul><li>它遍历 <code>doc.part.rels</code>（文档关系表）。<li>如果是<strong>内部图片</strong>，直接读取 <code>rel.target_part.blob</code>。<li>如果是<strong>外部图片 URL</strong>，使用 <code>ssrf_proxy.get(url)</code> 下载（<strong>重点：通过代理下载以防止 SSRF 攻击</strong>）。<li><strong>存储与映射</strong>：调用 <code>storage.save()</code> 将图片存入系统，并向数据库 <code>UploadFile</code> 表写入记录。最后返回 <code>image_map</code>，其 Key 是图片在 XML 中的 ID，Value 是 Markdown 格式的链接：<code>![image](预览地址)</code>。</ul></ul><ol><li>表格转 Markdown 逻辑</ol><ul><li><strong>处理位置</strong>：<code>_table_to_markdown(self, table, image_map)</code> 及其调用的 <code>_parse_row</code> 和 <code>_parse_cell</code>。<li><strong>具体细节</strong>：<ul><li><strong>对齐处理</strong>：计算表格的最大列数 <code>total_cols</code>。<li><strong>格式构造</strong>：手动拼接 Markdown 的分隔符 <code>| --- |</code>。<li><strong>单元格合并处理</strong>：在 <code>_parse_row</code> 中，通过 <code>cell.grid_span</code> 获取单元格跨越的列数，确保合并单元格在 Markdown 转换后不会导致列偏移，保持数据结构的对齐。</ul></ul><ol><li>复杂文本与链接提取</ol><ul><li><strong>处理位置</strong>：<code>parse_paragraph</code>（在 <code>parse_docx</code> 内部定义的函数）。<li><strong>具体细节</strong>：<ul><li><strong>普通文本</strong>：遍历 <code>run.text</code>。<li><strong>现代超链接</strong>：处理 <code>w:hyperlink</code> 标签。<li><strong>旧式超链接 (Field)</strong>：这是最难处理的部分，代码通过正则匹配 <code>HYPERLINK "url"</code> 并结合 <code>w:fldChar</code>（字段开始/分隔/结束状态机）来提取那些隐藏在 Word 指令字段中的链接。</ul></ul><p>直接提取纯文本会丢失表格的行级/列级对应关系。转换为 Markdown 后，大模型能够通过分隔符明确识别表格数据的关联性，减少幻觉。<p>实际研发场景中，使用 Document Loader 文档加载器模块时，需要根据具体的业务需求编写自定义的文档后处理逻辑。针对业务需求，开发者可以自行编写和实现对不同文档内容的解析，例如对标题、段落、表格、图片等元素的特殊处理。<h3 id=PDF解析><a class=headerlink href=#PDF解析 title=PDF解析></a>PDF解析</h3><p>尽管PDF文件的内容在表达图像、文字和表格信息，但其<strong>本质上是一系列显示和打印指令的集合</strong>。，即使是一个仅包含 “Hello World” 文字的简单PDF，其文件内容也是一长串的打印指令。<p><img alt=image-20260113151406760 data-src=https://s2.loli.net/2026/01/13/HQyj94GeUDbJXvL.png style=zoom:67%;><p>PDF文件的<strong>显示效果不受设备、软件或系统的影响，但对计算机而言，它是一种非数据结构化的格式，</strong>储存的信息无法直接被理解。此外，大模型的训练数据中不包含直接的PDF文件，无法直接理解。<p>PDF解析，对于纯文本格式可以转换为文本字符串，而对于包含多种元素的复杂格式，选择 <strong>MarkDown 文件</strong>作为统一的输出格式最为合适。这是因为MarkDown文件关注内容本身，而非打印格式，能够表示多种文档元素内容。MarkDown格式被广泛接受于互联网世界，其信息能够被大模型理解。<p><strong>PDF文件分为电子版和扫描版。</strong>PDF电子版可以<strong>通过规则解析</strong>，提取出文本、表格等文档元素。目前，有许多开源库可以支持，例如 <strong>pyPDF2、PyMuPDF、pdfminer、pdfplumber和papermage</strong> 等。这些库在 langchain_community.document_loaders 中基本都有对应的加载器，方便在不同场景下切换使用。<p><strong>在基于规则的开源库中，pdfplumber对中文支持较好，且在表格解析方面表现优秀，但对双栏文本的解析能力较差；pdfminer和PyMuPDF对中文支持良好，但表格解析效果较弱；pyPDF2对英文支持较好，但中文支持较差；papermage集成了pdfminer和其他工具，特别适合处理论文场景。</strong>开发者可以根据实际业务场景的测试结果选择合适的工具，pdfplumber或pdfminer都是当前不错的选择。<p><strong>扫描版PDF</strong><p>PDF扫描版<strong>需要经过文本识别和表格识别PDF扫描图像</strong>，才能提取出文档中的各类元素。同时要真正实现文档解析的目标，<strong>无论扫描版还是电子版均需进行版面分析和阅读顺序的还原，将内容解析为一个包含所有文档元素并且具有正确阅读顺序的MarkDown文件</strong>。单纯依赖规则解析是无法实现这一目标的.<p>目前支持这些功能的多为<strong>基于深度学习的开源库，如 Layout-parser、PP-StructureV2、PDF-Extract-Kit、pix2text、MinerU、marker等</strong>。<p>由于PDF文档解析整体流程用到了多个深度学习模型组合，真正在生产场景中会遇到效率问题。<strong>商业闭源库</strong>由于其部署的云端集群可以做并行处理和工程效率优化，所以在精度和效率上都能做到生产中的级别，比如TextIn.com、Doc2x、mathpix、庖丁PDFlux、腾讯云文档识别等，当然商业库会存在成本问题，你可以按需选择。<p>PDF内容提取逻辑,参考<a href=https://github.com/langgenius/dify/blob/main/api/core/rag/extractor/pdf_extractor.py rel=noopener target=_blank>dify</a><ol><li>图片格式识别（Magic Bytes）</ol><ul><li><strong>实现位置</strong>：类属性 <code>IMAGE_FORMATS</code> 和 <code>_extract_images</code> 内部。<li><strong>逻辑</strong>：代码通过检查文件头的“魔数”（Magic Bytes）来精准识别图片格式（如 JPEG 的 <code>\xff\xd8\xff</code>，PNG 的 <code>\x89PNG</code>），而不是简单依赖文件后缀。这保证了即使 PDF 内部图像流没有明确标签，也能正确保存为 <code>.jpg</code> 或 <code>.png</code>。</ul><ol><li>图像转存与持久化</ol><ul><li><strong>处理位置</strong>：<code>_extract_images(self, page)</code>。<li><strong>具体细节</strong>：<ul><li><strong>对象过滤</strong>：使用 <code>filter=(pdfium_c.FPDF_PAGEOBJ_IMAGE,)</code> 仅提取页面中的图像对象。<li><strong>二进制提取</strong>：调用 <code>obj.extract()</code>。注意其中的 <code>fb_format="png"</code>，这意味着对于非 JPEG 格式的图像，代码会自动将其回退（Fallback）并渲染为 PNG 格式以保证兼容性。<li><strong>存储与数据库</strong>：图片字节流被存入 <code>storage</code>，同时向 <code>UploadFile</code> 数据库表写入元数据。返回的 Markdown 链接允许前端或大模型直接通过 URL 预览提取到的图片。</ul></ul><ol><li>内存与资源管理</ol><ul><li><strong>处理位置</strong>：<code>parse</code> 方法中的 <code>finally</code> 块及 <code>autoclose=True</code>。<li><strong>逻辑</strong>：代码显式调用 <code>text_page.close()</code>、<code>page.close()</code> 和 <code>pdf_reader.close()</code>。在处理包含数千张图片的 PDF 时，及时释放 C 级底层的 PDF 句柄是防止内存泄漏的关键。</ul><h4 id=优化解析逻辑><a class=headerlink href=#优化解析逻辑 title=优化解析逻辑></a>优化解析逻辑</h4><p><strong>布局恢复</strong>：目前提取的是“平铺”文本，PDF 中的<strong>多栏布局或页眉页脚</strong>可能会混入正文。可以考虑引入 <code>pypdfium2</code> 的坐标分析功能来过滤页眉页脚,或者使用OCR提取布局信息。<p><strong>表格识别</strong>: pdf底层存储的是字符及其坐标,需要通过定位页面中的表格区域。尝试理解表格的行列逻辑，并将其转换为标准的 <strong>Markdown 表格格式</strong>（<code>|---|</code>）。结合布局分析和表格重建 <a href=https://github.com/infiniflow/ragflow rel=noopener target=_blank>infiniflow/ragflow</a><p><strong>OCR 介入</strong>：如果 PDF 是扫描件（图片生成的 PDF），<code>get_text_range()</code> 将返回空。此时应触发 OCR 流程对提取出的图片进行二次文字识别。<p><strong>表格识别</strong>:引入OCR<p>采取 <strong>“混合解析策略”</strong>：<ol><li><strong>预判断</strong>：先尝试用 <code>pypdfium2</code> 读取文本，如果返回字符数极少，判定为扫描件，触发 OCR。<li><strong>工具选型</strong>：<ul><li><strong>追求开源/本地部署</strong>：集成 <code>Marker</code> 或 <code>Unstructured</code> 库。<li><strong>追求极致效果</strong>：使用多模态 API（如 GPT-4o-mini）专门处理表格页。</ul><li><strong>标准化输出</strong>：无论后端用什么工具，统一输出为 <strong>Markdown</strong>，因为这能最大程度保留表格的语义逻辑供大模型检索。</ol><p><strong>推荐工具对比：</strong><div class=table-container><table><thead><tr><th><strong>需求场景</strong><th><strong>推荐工具</strong><th><strong>集成难度</strong><tbody><tr><td><strong>追求极致速度</strong><td>维持现状 (<code>pypdfium2</code>)<td>-<tr><td><strong>精准处理多栏/论文</strong><td>集成 <code>Marker</code><td>中（需要额外 Python 依赖）<tr><td><strong>完美还原复杂表格</strong><td><code>Unstructured</code> + <code>PaddleOCR</code><td>高（环境配置较复杂）<tr><td><strong>万能适配</strong><td>多模态 LLM 视觉解析<td>低（仅需 API 调用）</table></div><p>在Marker中,使用深度学习模型和启发式算法来解析PDF中的多栏布局和表格。多栏文本通过<code>TextProcessor</code>检测和合并，表格通过<code>TableProcessor</code>进行结构化提取，并可选择性使用LLM增强准确性<p>开源系统不支持的文件类型<p><img alt=image-20260113162924676 data-src=https://s2.loli.net/2026/01/13/LJ5gIYocRW1OMhs.png style=zoom:50%;><p><img alt=image-20260113164413896 data-src=https://s2.loli.net/2026/01/13/a93OWviDeEuVHtS.png style=zoom:50%;><h3 id=难点><a class=headerlink href=#难点 title=难点></a>难点</h3><h4 id=跨页表格怎么自动对齐><a class=headerlink href=#跨页表格怎么自动对齐 title=跨页表格怎么自动对齐></a>跨页表格怎么自动对齐</h4><p>在处理 PDF 解析时，<strong>跨页表格（Multi-page Tables）</strong>是最具挑战性的场景之一。由于 PDF 在分页处会强制打断表格结构，并可能插入页眉、页脚或重复表头，简单的流式提取会导致表格断裂或数据错位。<p><strong>关键技术方案</strong><p>表头一致性,判断是否为同一张表的重复表头<p>表格位置分析,判断相邻页中的表格是否在文档布局中连续<p>自动拼接与去重,对于相同表头的多个分页表格,按行拼接,并去除重复的表头行<ol><li>布局检测</ol><p>mineru<ol><li>文档格式检测<li>文档格式识别<li>OCR处理<li>表格预测</ol><h2 id=数据预处理><a class=headerlink href=#数据预处理 title=数据预处理></a>数据预处理</h2><p><img alt=image-20260113172147249 data-src=https://s2.loli.net/2026/01/13/HtOu2piYNzmc5oT.png><p>构建领域术语词库,识别输入中领域术语,替换<p>术语混淆直接影响信息检索的精确度与生成内容质量.<h3 id=术语词库构建与维护><a class=headerlink href=#术语词库构建与维护 title=术语词库构建与维护></a>术语词库构建与维护</h3><p><strong>产生术语混淆</strong><p>术语多义性,同义词,领域差异以及企业专属术语<p><strong>术语词库构建流程</strong><ol><li>收集术语来源<li>标准化术语<li>建立别名映射关系<li>添加上下文信息<li>构建术语索引</ol><p><img alt=image-20260113192853262 data-src=https://s2.loli.net/2026/01/13/jnPqIHEdLuV2g8l.png><p><strong>术语词库与RAG集成</strong><p>方式1:预处理阶段替换术语<p>方式2:检索增强<p>方式3:重排序<p>方式4:后处理解释<p><strong>维护术语词库</strong><h2 id=分块策略与Embedding技术><a class=headerlink href=#分块策略与Embedding技术 title=分块策略与Embedding技术></a>分块策略与Embedding技术</h2><p><img alt=image-20260113172431541 data-src=https://s2.loli.net/2026/01/13/FmMrCP7X6E3NsRV.png><p><strong>数据分块（Chunking/切片）</strong> 的质量直接决定了检索的精准度。如果<strong>切片太小，会丢失上下文</strong>；如果<strong>切片太大，会引入噪声并稀释语义。</strong><p>Token-based chunking TokenTextSplitter 严格限制模型窗口时物理边界控制精准<p>SentenceSplitter 通用文本文档语义保真度高，配置简单 目标是在保持语义完整性的前提下，尽可能按句子边界切分。<p><strong>工作原理</strong>：它会尝试按照段落 (<code>\n\n</code>)、换行 (<code>\n</code>)、句子、单词的优先级递归切分。<p><strong>核心作用</strong>：它能确保切片<strong>不会在句子中间断开</strong>。<p><strong>关键参数</strong>：<code>chunk_size</code>（块大小）和 <code>chunk_overlap</code>（重叠大小）。<p>窗口切分, SentenceWindowNodeParser<div class=table-container><table><thead><tr><th><strong>文档类型</strong><th><strong>推荐切片类 (LlamaIndex)</strong><th><strong>选择理由</strong><tbody><tr><td><strong>标准说明书/公文</strong><td><code>SentenceSplitter</code><td>段落结构清晰，按句子切分能最大程度保留语义。<tr><td><strong>README/技术手册</strong><td><code>MarkdownNodeParser</code><td><strong>强推。</strong> 必须按 <code>H1-H3</code> 标题切分，否则正文会脱离标题，导致检索到正文却不知道在说哪个产品。<tr><td><strong>代码库 (Python/JS)</strong><td><code>CodeSplitter</code><td>依据语法树（AST）切分，保证一个函数或一个类在一个 Chunk 里。<tr><td><strong>扫描件/复杂 PDF</strong><td><code>SemanticSplitter</code><td><strong>慎用。</strong> 建议先用 <code>Marker</code> 转为 Markdown，再用 <code>MarkdownNodeParser</code> 处理。</table></div><p><strong>“全家桶”组合</strong> 通常是：<ol><li><strong>MarkdownNodeParser</strong>（用于格式化内容）<li><ul><li><strong>SentenceSplitter</strong>（作为 fallback 处理长段落）</ul><li><ul><li><strong>MetadataExtractor</strong>（注入标题和上下文）</ul><li><ul><li><strong>RedisCache</strong>（放在 IngestionPipeline 里加速重复解析</ul></ol><p>滑动窗口切分=sentenceSplitter+SentenceWindowSplitter<h4 id=滑动窗口><a class=headerlink href=#滑动窗口 title=滑动窗口></a>滑动窗口</h4><p>滑动窗口结合关键词<ol><li>初步切片,使用滑动窗口对文档进行基础分段<li>关键词检测,分析每个切片的边界,识别是否存在关键词或语义单元的中断<li>动态调整,根据关键词位置和上下文语境,微调切片边界,确保语义完整</ol><p><strong>语义切分</strong><p><img alt=image-20260113214337874 data-src=https://s2.loli.net/2026/01/13/uWSVRKQ13fZlOde.png><p>SemanticSplitter 的工作逻辑可以分为以下四个步骤：<ol><li><strong>句子分割</strong>：首先将原始文档拆分成一个个基础的句子。<li><strong>向量化（Embedding）</strong>：利用 Embedding 模型将每个句子（或句组）转化为高维向量。<li><strong>计算相似度</strong>：计算相邻句子之间的<strong>余弦相似度（Cosine Similarity）</strong>。<li><strong>设定阈值（Threshold）</strong>：<ul><li>如果<strong>相邻两句的意思非常接近，它们会被合并在同一个块（Chunk）里</strong>。<li>如果相似度突然下降，超过了设定的阈值，系统就认为“话题发生了转换”，并在此处建立切片断点。</ul></ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> llama_index.core.node_parser <span class=keyword>import</span> SemanticSplitterNodeParser</span><br><span class=line><span class=keyword>from</span> llama_index.embeddings.openai <span class=keyword>import</span> OpenAIEmbedding</span><br><span class=line></span><br><span class=line><span class=comment># 1. 定义 Embedding 模型（用于计算句子间的相似度）</span></span><br><span class=line>embed_model = OpenAIEmbedding()</span><br><span class=line></span><br><span class=line><span class=comment># 2. 初始化语义切片器</span></span><br><span class=line><span class=comment># buffer_size: 计算相似度时考虑的窗口大小</span></span><br><span class=line><span class=comment># breakpoint_percentile_threshold: 相似度下降到多少百分位时进行切割</span></span><br><span class=line>splitter = SemanticSplitterNodeParser(</span><br><span class=line>    buffer_size=<span class=number>1</span>, </span><br><span class=line>    breakpoint_percentile_threshold=<span class=number>95</span>, </span><br><span class=line>    embed_model=embed_model</span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=comment># 3. 对文档进行切片</span></span><br><span class=line>nodes = splitter.get_nodes_from_documents(documents)</span><br></pre></table></figure><h2 id=动态切片策略与重叠机制><a class=headerlink href=#动态切片策略与重叠机制 title=动态切片策略与重叠机制></a>动态切片策略与重叠机制</h2><p><strong>RecursiveTextSplitter</strong>（递归字符切片器）是 RAG 开发中最常用、也是性价比最高的文本切片工具。它被广泛集成在 LangChain 等框架中，旨在解决简单字符切片容易“切断语义”的问题。<p>它的核心理念是：<strong>尽可能保持段落、句子和词语的完整性。</strong><p><code>RecursiveTextSplitter</code> 维护了一个<strong>分隔符列表</strong>（默认通常是 <code>["\n\n", "\n", " ", ""]</code>）。其工作流程如下：<ol><li><strong>段落切分</strong>：首先尝试用双换行符 <code>\n\n</code>（段落边界）来切分文档。<li><strong>检查大小</strong>：如果切出来的块小于设定的 <code>chunk_size</code>，则保留。<li><strong>降级递归</strong>：如果某个块仍然超过了 <code>chunk_size</code>，它会针对这个超长的块，换用下一个分隔符（如单换行符 <code>\n</code>）继续尝试切分。<li><strong>最小单位</strong>：如果连换行符切完都太大，它会寻找空格 <code>" "</code>（单词边界）。如果连空格都解决不了（比如一个极长的化学单词），最后才会按字符 <code>""</code> 强制切断。</ol><p><strong>结构化文档失效</strong>：如果你处理的是 Markdown（带有很多 <code>#</code> 标题）或代码，普通的递归切片可能会切断标题和正文的联系。此时应该使用专用的 <code>MarkdownHeaderTextSplitter</code> 或 <code>CodeSplitter</code>。<p><strong>不识别语义转折</strong>：它只看物理符号（如换行符），不看意思。如果一个段落里讨论了两个完全不同的主题，它还是会把它们放在一起。这种情况需要 <code>SemanticSplitter</code>。<p><strong>TopicNodeParser</strong><p>命题化检索<p><code>TopicNodeParser</code> 通常利用 LLM 或高精度的 Embedding 模型来识别文档中的“话题转换点”（Topic Drift）。<p>其工作流程通常如下：<ol><li><strong>初始分割</strong>：将文档初步拆分为较小的单元（如句子或短段落）。<li><strong>主题建模/识别</strong>：<ul><li><strong>方法 A（LLM 驱动）</strong>：让 LLM 扫描文本块，判断：“这里是否开启了一个新话题？”<li><strong>方法 B（语义聚类）</strong>：计算连续块之间的相似度，当相似度曲线出现“断崖式”下跌时，判定为主题切换。</ul><li><strong>节点构建</strong>：将属于同一个主题的所有文本块合并为一个 <code>Node</code>，并自动为该 Node 提取一个<strong>主题标签（Topic Label）</strong>作为元数据。</ol><p><strong>上下文割裂</strong>：一个关于“安装步骤”的描述可能被切成了两半，检索时只搜到后半部分，导致步骤缺失。<p><strong>语义混杂</strong>：一个 1024 Token 的块里，前一半在说“硬件规格”，后一半在说“软件配置”，这会导致该块的向量表征变得“平庸”，检索相关度下降。<p><img alt=image-20260113221722324 data-src=https://s2.loli.net/2026/01/13/oMWHlgAt4XJy5VC.png><h4 id=Dify中的父子模式><a class=headerlink href=#Dify中的父子模式 title=Dify中的父子模式></a>Dify中的父子模式</h4><p>在普通的切片模式下，开发者常面临一个<strong>“鱼与熊掌不可兼得”</strong>的困局：<ul><li><strong>分段太小</strong>：检索非常精准（向量表征集中），但由于上下文（Context）太少，LLM 回答时容易断章取义。<li><strong>分段太大</strong>：包含了足够的背景，但一个段落里讲了三个主题，导致向量表征模糊，搜索时很难排在前面。</ul><p><strong>父子模式的对策</strong>：将原本的大段落（父）进一步拆解为多个小片段（子）。<ol><li><p>工作原理</p><li><p><strong>存储阶段</strong>：</p> <ul><li><strong>父分段 (Parent)</strong>：通常是较长的文本块（如 1000 Tokens），保留了完整的逻辑和上下文。<li><strong>子分段 (Child)</strong>：将父分段进一步切碎（如 200 Tokens）。<li><strong>数据库关联</strong>：系统在向量数据库中索引“子分段”，但每一个子分段都关联着其对应的“父分段” ID。</ul><li><strong>检索阶段</strong>：<ul><li>用户提问后，系统去匹配<strong>最相关的子分段</strong>。</ul><li><strong>还原阶段（关键步）</strong>：<ul><li>一旦命中了某个子分段，Dify 不会将子分段的内容发给 LLM，而是自动根据关联 ID，<strong>找回它所属的父分段内容</strong>。</ul><li><strong>生成阶段</strong>：<ul><li>LLM 接收到的是语义丰富的父分段，从而能根据完整的背景生成高质量答案</ul></ol><p>开启“父子模式”通常需要调整以下参数：<ul><li><strong>父分段规则</strong>：设定父块的大小（建议 800-1000 字符）。<li><strong>子分段规则</strong>：设定子块的大小（建议 200-300 字符）。<li><strong>检索策略</strong>：<ul><li>通常配合<strong>混合检索（Hybrid Search）</strong>使用，即：子分段的向量检索 + 全文检索。</ul></ul><p><strong>适用文档</strong>：逻辑严密但篇幅较长的文档，如<strong>法律条文、技术规范、深度行业报告</strong>。<p><strong>配合 Rerank</strong>：在父子模式下，强烈建议开启 <strong>Rerank（重排序）</strong>。因为子块召回可能较多，通过 Rerank 选出最准确的子块对应的父块，能显著降低 Token 消耗并提升准确度。<p><img alt=image-20260113222328479 data-src=https://s2.loli.net/2026/01/13/9QqxH8JkfObdPpe.png><p>传统的 RAG 工具（如 LangChain 或 Dify 默认模式）往往采用“一刀切”的规则来切片，而 RAGFlow 的模板化逻辑是：<strong>先看文档长什么样，再决定怎么拆。</strong><p>不同的文档有完全不同的逻辑结构。如果用同一种算法去切，会发生以下惨剧：<ul><li><strong>财务报表</strong>：表格被拆散成一堆毫无意义的数字。<li><strong>科研论文</strong>：双栏排版的文字被横向读取，左右两栏混在一起。<li><strong>调查问卷</strong>：问题和选项被强行切断。</ul><p><strong>RAGFlow 的模板化方案</strong>：预设了多种针对特定场景的解析逻辑，确保数据从 PDF/Word 转化为数据库向量时，逻辑依然是完整的。<p>RAGFlow 提供了多种内置模板，每种模板背后都有一套专门的布局识别（Layout Analysis）算法<p>切片的核心作用:为后续混合检索,重排,查询转换等提供高质量数据<p>最后也需要构建评估体系,持续验证与迭代优化<h2 id=检索增强阶段><a class=headerlink href=#检索增强阶段 title=检索增强阶段></a>检索增强阶段</h2><p>在初步召回的基础上,进一步优化检索结果的广度与精度.<p><img alt=image-20260113174601655 data-src=https://s2.loli.net/2026/01/13/3zsZUHCwk5QOaGl.png><p><strong>查询扩展与重写</strong><p>生成 3 到 5 个不同表述但语义相同的查询变体。这些变体应从不同的侧重点出发，帮助从向量数据库中找回最相关的文档。其核心依据是<strong>语义向量空间的不确定性</strong>。<p>利用大语言模型（LLM）将用户的一个问题转化为多个语义相似但措辞不同的问题，然后分别进行检索。<p>传统的向量检索（Vector Search）高度依赖用户输入的<strong>措辞</strong>。<ul><li><strong>痛点</strong>：如果用户的问题和文档中的词汇不匹配，或者提问比较模糊，向量空间中的距离可能较远，导致检索不到核心内容。<li><strong>例子</strong>：用户问“如何对齐 PDF 表格？”，文档里写的可能是“PDF 表格解析与重组方案”。两者字面上不完全一致。</ul><ol><li><strong>查询生成</strong>：LLM 接收原始问题，生成 3-5 个不同角度的变体（例如：“PDF 表格错位怎么处理？”、“PDF 跨页表格对齐技术”等）。<li><strong>并行检索</strong>：将这多个问题同时发给向量数据库，每个问题都会召回一批文档。<li><strong>取并集（Union）</strong>：将所有问题召回的文档汇总在一起。<li><strong>去重与排序</strong>：剔除重复文档，最后将这组更全面的文档交给 LLM 生成答<strong>案</strong></ol><p><strong>假设性文档HyDE</strong><p>核心思想是与其直接用“问题”去搜答案，不如先让 AI 编一个“假答案”，然后用这个“假答案”去搜“真文档”。<p>在传统的向量检索中，我们计算的是 <strong>问题（Query）</strong> 和 <strong>文档（Document）</strong> 之间的相似度。<ul><li><strong>痛点</strong>：问题通常很短（如“HyDE 是什么？”），而文档通常很长且充满细节。在向量空间里，短问题和长文档的特征向量往往<strong>不对称</strong>，导致检索不到最相关的片段。<li><strong>HyDE 的逻辑</strong>：文档和文档之间是最像的。</ul><ol><li><strong>生成假设文档</strong>：接收用户的问题，让 LLM（如 GPT-4）在不看任何外部资料的情况下，凭直觉写一篇“伪文档”或“假设性回答”。<li><strong>向量化（Embedding）</strong>：将这篇逻辑通顺但内容可能不准确的<strong>假设文档</strong>转化成向量。<li><strong>检索真文档</strong>：用这个“伪向量”去数据库里匹配物理特征最接近的<strong>真实文档</strong>。<li><strong>生成最终答案</strong>：把检索到的真文档喂给 AI，生成正式的回复。</ol><h2 id=OCR文件错漏><a class=headerlink href=#OCR文件错漏 title=OCR文件错漏></a>OCR文件错漏</h2><p>OCR识别错误可以分为:<p>字符识别错误,文字遗漏,多字重复,格式混乱<p>在OCR之前可以及逆行文本图像校正,纠正图像中文档扭曲,倾斜,透视变形等问题,另外进行版面区域检测,对文档图像进行内容解析和区域划分<p>识别后的内容可以通过LLM修正<h2 id=生成控制与验证阶段><a class=headerlink href=#生成控制与验证阶段 title=生成控制与验证阶段></a>生成控制与验证阶段</h2><p><img alt=image-20260113191853638 data-src=https://s2.loli.net/2026/01/13/1MGJDKWENkfjeS4.png><h2 id=向量检索引擎><a class=headerlink href=#向量检索引擎 title=向量检索引擎></a>向量检索引擎</h2><p><img alt=image-20260113233157267 data-src=https://s2.loli.net/2026/01/13/GyxSOqhop9erDBA.png><p>BM25是改进的TF-IDF排序,通过词频,文档长度归一化以及逆文档频率加权.<h3 id=设计混合检索架构提高多阶段召回率><a class=headerlink href=#设计混合检索架构提高多阶段召回率 title=设计混合检索架构提高多阶段召回率></a>设计混合检索架构提高多阶段召回率</h3><h2 id=让AI返回结构化数据><a class=headerlink href=#让AI返回结构化数据 title=让AI返回结构化数据></a>让AI返回结构化数据</h2><p>Structured Generation with LLM，是指<strong>让LLM按照预先定义的schema，输出符合schema的结构化结果</strong>。<p>常见的应用场景有：<ol><li><strong>数据处理</strong>。主要功能为a -> b，即从源文本中<strong>抽取/</strong>生成符合schema的结果，例如给定新闻，进行分类、抽取关键词、生成总结等；<li><strong>Agent</strong>。主要功能是Tool Calling，即根据用户query，选择适当的tool和入参</ol><p>如何从模型输出中准确提取自己所需的信息。例如，当我们希望模型输出 JSON 格式的数据时，由于模型生成的内容并不总是稳定，可能需要额外编写大量的正则表达式来匹配并提取其中的有效信息。然而，由于 LLM 的能力，导致其输出结构并不永远可靠。<p>现阶段， 让LLM按要求生成特定格式文本的主要方法有几种种：<ul><li>微调：使模型的输出遵循特定格式<li><strong>OpenAI Json-mode/function-calling/Structured Outputs:</strong> 这些功能允许模型生成更严格、结构化的输出，但受限于openAI平台。<li><strong>格式约束</strong>：在decoding阶段进行约束，限制模型的输出，<li><strong>Prompt Engineering</strong>： 最简单的办法，但不稳定。<li>多阶段prompting： 通过多个步骤的提示逐步引导模型生成所需的格式</ul><ol><li>提示词工程（Prompt Engineering）</ol><p>这是最基础的方式，通过在 System Prompt 中明确要求 AI 返回特定的格式。<ul><li><strong>实现方式</strong>：在提示词末尾加上 <code>“请以 JSON 格式返回结果，不要包含任何多余的解释文字”</code>，并给出示例。<li><strong>优点</strong>：<ul><li><strong>低成本</strong>：不需要额外的 API 参数或编程逻辑。<li><strong>灵活性高</strong>：可以随时调整字段定义。</ul><li><strong>缺点</strong>：<ul><li><strong>不稳定</strong>：AI 可能会在 JSON 前后加上“好的，这是你要的结果”等废话（俗称 Chatty AI）。<li><strong>解析失败</strong>：长文本下可能会出现 JSON 语法错误（如少个括号、引号未转义）。</ul></ul><p><strong>Kor技术</strong><p>使用<a href=https://eyurtsev.github.io/kor/ rel=noopener target=_blank>Kor </a>进行structured generation的流程如下：<ol><li>定义schema，包括结构、注释还有例子；<li>Kor<strong>用特定的<em>prompt template</em>，将用户提供的schema和待处理的raw text</strong>，组装成prompt；<li>将prompt发送给LLM，借助其通用的In Context Learning能力，尽量生成符合schema的内容；<li><p>Kor对LLM的输出进行parse，返回符合schema的结构化结果，但也有概率没有返回（当LLM的输出不符合schema时）。</p><li><p>JSON Mode（JSON 模式）</p></ol><p>主流模型（如 GPT-4、Gemini 1.5、Claude 3）都提供了专门的开关。<ul><li><strong>实现方式</strong>：在调用 API 时设置 <code>response_format: { "type": "json_object" }</code>。<li><strong>优点</strong>：<ul><li><strong>格式强制</strong>：模型会确保输出是一个合法的 JSON，极大地减少了解析错误。</ul><li><strong>缺点</strong>：<ul><li><strong>不保证内容 Schema</strong>：虽然它是 JSON，但字段名可能会随机变化（比如这次叫 <code>name</code>，下次叫 <code>user_name</code>）。<li><strong>仍需引导</strong>：通常还是需要在 Prompt 中提示它是 JSON，否则模型可能不知道该写什么。</ul></ul><p>仅特定模型和平台支持,需要在prompt中要求输出json格式,不能保证完全按要求的格式结构输出,Json-Mode 更多是对于输出json的格式进行检查.JSON Mode 的实现原理是受限解码,核心不是让模型“学会”写 JSON，而是在它每产生一个 Token 时，通过一个<strong>外部过滤器（Filter）</strong>强行剔除掉会导致语法错误的选项。<ol><li>函数调用 / 工具调用（Function Calling / Tool Use）</ol><p>这是目前<strong>最推荐</strong>、生产环境最常用的方式。<ul><li><strong>实现方式</strong>：预先定义一个函数的参数结构（通常使用 JSON Schema），AI 不直接回答问题，而是通过“调用函数”来填充这些参数。<li><strong>优点</strong>：<ul><li><strong>强类型约束</strong>：严格遵循你定义的字段名和数据类型。<li><strong>逻辑解耦</strong>：AI 负责提取信息，你的代码负责处理提取后的数据。</ul><li><strong>缺点</strong>：<ul><li><strong>延迟略高</strong>：模型需要额外的思考步骤来决定调用哪个函数。<li><strong>成本</strong>：复杂的函数定义会占用更多的输入 Token。</ul></ul><p>Function Calling是构建agent的基石，也是各大LLM厂商的标配功能。要做到好的FC，LLM要能做到：<ol><li>理解任务与function/tool的关系，知道是否要调用、需调用哪些function/tool、是否缺必要参数；<li>返回结构化内容，包括function name、arguments（json格式）</ol><div class=table-container><table><thead><tr><th><strong>特性</strong><th><strong>普通 Prompt</strong><th><strong>JSON Mode</strong><th><strong>Function Calling</strong><tbody><tr><td><strong>约束目标</strong><td>语义理解（靠 AI 配合）<td>语法合规（保证是 JSON）<td><strong>Schema 合规（保证字段对齐）</strong><tr><td><strong>字段准确度</strong><td>差，经常乱起名<td>中，字段可能多写或漏写<td><strong>极高，严格遵循定义</strong><tr><td><strong>复杂结构</strong><td>难以处理深层嵌套<td>较好<td><strong>完美，支持复杂递归嵌套</strong><tr><td><strong>稳定性</strong><td>易受 Prompt 干扰<td>较稳<td><strong>工业级稳定</strong></table></div><p>Mistral模型的开源FC实现<p>mistral-nemo这样实现FC：<ol><li>将tools按照特定的template，组装到prompt中去；<li>LLM输出时，也遵循特定的template，call tool时加入特殊标记（TOOL_CALLS），并返回name和arguments。</ol><p>mistral-nemo在fine-tuning时，按照这样的格式进行训练，FC的“要求”已经被encode到模型的参数中去了；<ol><li>结构化输出（Structured Outputs）</ol><blockquote><p>很多开发者会用 <strong>Function Calling 来实现结构化输出</strong>（即使他们并不打算真的调用函数）。<ul><li><strong>原因</strong>：早期的模型不支持独立的 Structured Output 模式，但 Function Calling 训练得非常成熟，能极稳地吐出 JSON 参数包。<li><strong>现状</strong>：现在像 OpenAI 的 <strong>Structured Outputs</strong> 已经是这两者的结合体——它既可以用在普通的回复里，也可以用在函数调用的参数提取里，保证 100% 的字段匹配。</ul></blockquote><p>这是 OpenAI 等厂商近期推出的最高级别约束方案。<ul><li><strong>实现方式</strong>：在 API 请求中提供具体的 <code>json_schema</code>，并开启 <code>strict: true</code> 模式。<li><strong>优点</strong>：<ul><li><strong>100% 可靠</strong>：通过受限解码技术（Constrained Decoding），模型输出的每一个字符都受到 Schema 约束，完全不会偏离。<li><strong>零冗余</strong>：不会有任何解释性文字。</ul><li><strong>缺点</strong>：<ul><li><strong>模型限制</strong>：目前仅支持部分最新型号（如 GPT-4o 系列）。<li><strong>Schema 校验严格</strong>：如果 Schema 写的有问题，请求会直接失败。</ul></ul><ol><li>编程框架封装（Pydantic / LangChain / Instructor）</ol><p>利用开源库在代码层面进行封装和后处理。<ul><li><strong>实现方式</strong>：使用 Python 的 <code>Pydantic</code> 定义类，通过 <code>Instructor</code> 库调用 AI，自动完成“请求 -> 提取 -> 验证 -> 重试”的闭环。<li><strong>优点</strong>：<ul><li><strong>开发体验极佳</strong>：像调用普通函数一样获取 AI 结果。<li><strong>自动重试</strong>：如果 AI 第一次返回的 JSON 缺字段，框架会自动反馈错误并让 AI 重写。</ul><li><strong>缺点</strong>：<ul><li><strong>依赖性</strong>：增加了项目的库依赖。</ul></ul><div class=table-container><table><thead><tr><th><strong>需求场景</strong><th><strong>推荐方式</strong><th><strong>稳定等级</strong><tbody><tr><td><strong>快速原型、简单测试</strong><td>提示词工程<td>⭐⭐<tr><td><strong>需要合法 JSON 但字段多变</strong><td>JSON Mode<td>⭐⭐⭐<tr><td><strong>生产环境、复杂业务逻辑</strong><td><strong>Function Calling</strong><td>⭐⭐⭐⭐<tr><td><strong>高严苛金融/政务系统</strong><td><strong>Structured Outputs (Strict)</strong><td>⭐⭐⭐⭐⭐</table></div><h3 id=开源实现><a class=headerlink href=#开源实现 title=开源实现></a>开源实现</h3><p><strong>Outlines</strong><p><strong>对于json schema，outlines首先将其转为正则表达式，然后再转为token-level的Finite State Machine</strong><p>随后，模型的生成过程就变成在state之间的跳转：首先从初始state出发，随后在有限的输出路径中选一条，到达下一个state，直到到达最后一个state，完成生成。<p>其中”有限的输出路径“就是前文所提到的tokens输出范围。<p><code>Outlines</code> 的精髓在于它不直接处理 JSON，而是处理 <strong>FSM（有限状态机）</strong>。<ol><li><strong>解析 Schema</strong>：当你传入一个 Pydantic 模型或正则表达式时，<code>Outlines</code> 会解析其结构。<li><strong>构建 FSM</strong>：它利用 <code>interegular</code> 等库，将复杂的规则（如 JSON 语法或正则）转换成一个高度优化的<strong>有限状态机</strong>。<li><strong>状态映射</strong>：在这个状态机中，每个状态都代表了当前已经生成的字符串序列。状态机明确知道：在当前状态下，下一个字符可以是哪些，不可以是哪些。<li>FSM的缺点是无法准确表示复杂的schema。</ol><p><strong>guidance</strong><p>Guidance 的本质是将 <strong>确定性的程序逻辑</strong> 与 <strong>不确定性的 AI 生成</strong> 缝合在一起。<p>在生成过程中，Guidance 采取“接力赛”模式：<ul><li><strong>程序控制阶段</strong>：框架直接向模型注入确定的字符串（如 JSON 的键名 <code>{"name":</code>）。这部分不消耗模型的推理计算，是直接“贴”上去的。<li><strong>模型生成阶段</strong>：框架将控制权交给 AI，但限制 AI 只能在指定的“坑”里填空。填完后，框架立刻收回控制权，跳过冗余字符，直接进入下一个字段。</ul><p><strong>Instructor</strong><p>主要依赖于 <strong>Pydantic</strong>、<strong>Python 动态类型</strong>以及底层模型的 <strong>Function Calling</strong> 协议<p><strong>① 模式转换 (Model to Schema)</strong><p>当你定义一个 <code>Pydantic</code> 模型并传给 Instructor 时，它会利用 Pydantic 内置的 <code>model_json_schema()</code> 方法，自动将这个 Python 类转换成标准的 <strong>JSON Schema</strong>。<p><strong>② 协议适配 (Protocol Adaptation)</strong><p>Instructor 会根据你使用的模型，将 Schema 包装进正确的 API 参数中：<ul><li><strong>对于 OpenAI</strong>：它会将 Schema 放入 <code>tools</code> 或新的 <code>response_format</code>（Structured Outputs）中。<li><strong>对于 Anthropic/Gemini</strong>：它会调整为对应的 <code>Tool Use</code> 或 <code>JSON Mode</code> 格式。</ul><p><strong>③ 采样约束与解析 (Sampling & Parsing)</strong><p>模型返回 JSON 字符串后，Instructor 会立即进行 <strong>反序列化</strong>。<ul><li>它尝试用你定义的 Pydantic 模型去实例化这个 JSON。<li><strong>关键点</strong>：如果 JSON 缺少字段或类型不对，Pydantic 会抛出验证错误（ValidationError）。</ul><p><strong>④ 自动重试机制 (Self-Correction/Retries)</strong><p>这是 Instructor 最强大的功能。如果解析失败，它不会直接报错，而是：<ol><li>把 Pydantic 抛出的<strong>具体错误信息</strong>（例如：<code>age 字段缺失</code>）作为新的 User Message 发回给 AI。<li>告诉 AI：“你刚才的输出不对，报错如下，请修正后重新生成。”<li>这个过程会重复 N 次，直到获取合规数据。</ol><h3 id=生产实现><a class=headerlink href=#生产实现 title=生产实现></a>生产实现</h3><p>在 Java 生态中，尤其是 <strong>LangChain4j</strong> 和 <strong>Spring AI</strong> 实现结构化输出的底层逻辑，其实是把“复杂的协议通信”封装成了开发者熟悉的“对象映射”。<p>实现方式主要分为两类：<strong>基于 API 协议的强约束</strong>（类似 OpenAI 官方方案）和 <strong>基于 Prompt 的后置解析</strong>。<ol><li>强约束方案：<strong>基于 Function Calling</strong> (推荐)</ol><p>这是 LangChain4j 等库默认的首选方式。它<strong>利用了模型厂商提供的专用接口</strong>。<ul><li><strong>实现步骤</strong>：<ol><li><strong>内省 (Introspection)</strong>：当你定义一个 Java <code>Record</code> 或 <code>POJO</code> 时，框架会利用 Java 的<strong>反射机制</strong>读取字段名、类型和 <code>@Description</code> 注解。<li><strong>Schema 转换</strong>：框架将这些 Java 信息翻译成 <strong>JSON Schema</strong>。<li><strong>协议请求</strong>：在调用模型 API 时，框架不会把 Schema 塞进 Prompt，而是塞进参数里的 <code>tools</code> 或 <code>response_format</code> 字段。<li><strong>模型输出</strong>：由于模型底层开启了“受限采样”，它会直接吐出一个干净的 JSON 字符串。<li><strong>反序列化</strong>：框架内部使用 <strong>Jackson</strong> 或 <strong>Gson</strong> 将 JSON 字符串瞬间转回 Java 对象。</ol></ul><ol><li>弱约束方案：基于指令与 Parser (Spring AI 常用)</ol><p>如果模型<strong>不支持强约束接口（如某些早期的开源模型），Java 框架会回退到这种模式</strong>。<ul><li><strong>实现步骤</strong>：<ol><li><strong>注入指令</strong>：<code>BeanOutputParser</code> 会生成一段非常长且严厉的 Prompt 片段，告诉 AI：“你必须只返回 JSON，字段必须叫 XXX，类型必须是 int…”。<li><strong>后置处理</strong>：AI 返回一段包含 JSON 的文本。<li><strong>正则提取</strong>：Java 框架会用正则表达式从一堆废话中捞出 <code>{ ... }</code> 这一部分。<li><strong>验证与纠错</strong>：如果 Jackson 转换失败，部分框架（如 LangChain4j）会把错误日志发回给 AI，说“你刚才生成的 JSON 少了个逗号，请重写”，这就是自动修复机制。</ol></ul><h2 id=有效评估与改进RAG应用><a class=headerlink href=#有效评估与改进RAG应用 title=有效评估与改进RAG应用></a>有效评估与改进RAG应用</h2><p>首先我们要明确业务目标，然后根据业务目标制定指标，再根据实际的指标值改进检索技术。这种方法一步到位，<p><strong>RAGAS</strong><ol><li>与竞品相比，文档相对较完备。<li>专业度比较高，专注于做RAG评测。<li>支持与LLamaIndex、LangChain等11种RAG框架集成。</ol><p>Ragas目前实现了十项评估指标，我们挨个来看看。<p><strong>忠实度（Faithfulness）</strong>指标用于衡量生成答案与给定上下文的事实一致性。如果生成答案中的所有声明都可以从给定的上下文中推断出来，则认为该答案是忠实的。<p><strong>答案相关性（Answer Relevance）</strong>侧重于评估生成答案与给定提示的相关性。对于不完整或包含冗余信息的答案，会给出较低的分数，而较高的分数表示更好的相关性。这个指标是通过问题、上下文和答案来计算的。答案相关性定义为原始问题与基于答案生成（逆向工程）的若干人工问题之间的平均余弦相似度。<p><strong>上下文查准率（Context Precision）</strong>用于判断上下文中存在的所有真实相关项，是否都排在了较高的位置。理想情况下，所有相关的信息块都应该出现在顶部排名。这个指标是通过问题、真实答案和上下文来计算的，其值范围在0到1之间，分数越高表示查准率越高。<p><strong>上下文利用率</strong>（Context utilization）：上下文利用就像是上下文查准率指标的无参考版本。也就是关注是否利用了所有可用的信息块，而忽略掉它们的顺序如何。<p><strong>上下文查全率（Context Recall）</strong>，它衡量的是检索到的上下文与作为真实答案的标注答案的一致程度。该指标是通过问题、真实答案和检索到的上下文来计算的，其值范围在0到1之间，数值越高表示性能越好。为了从真实答案中估计上下文召回率，会分析真实答案中的每个声明，以确定它是否可以归因于检索到的上下文。在理想情况下，真实答案中的所有声明都应该可以归因于检索到的上下文。<p><strong>上下文实体查全率（Context entities Recall）</strong>，衡量从真实答案中召回的实体比例的一个指标。具体就是根据真实答案和上下文中存在的实体数量相对于单独在真实答案中存在的实体数量，来衡量检索到的上下文的召回率。<p>这个指标在有事实依据的用例中很有用，比如旅游咨询台、历史问答等。这个指标可以帮助评估基于与真实答案中实体的比较的实体检索机制，因为在实体重要的情况下，我们需要覆盖这些实体的上下文。<p><strong>答案语义相似度（Answer semantic similarity）</strong>，用于评估生成答案与真实答案之间的语义相似度。这个评估是基于真实答案和答案进行的，其值在0到1的范围内。分数越高，表示生成的答案与真实答案间的一致性越好。<p><strong>答案正确度（Answer Correctness）</strong>，用衡量生成的答案与真实答案相比的准确性。这个评估依赖于真实答案和答案，分数范围从0到1。分数越高表示生成的答案与真实答案之间的一致性越好，意味着正确度更高。<p>答案正确度包括两个关键方面：生成答案与真实答案之间的语义相似度以及事实相似度。这些方面通过加权方案结合起来，形成答案正确性分数。用户还可以选择使用一个“阈值”值将结果分数四舍五入为二进制（如果需要）。<p><strong>特定领域评估（Domain Specific Evaluation）</strong>，特定领域评估指标用于评估模型在特定领域的性能。评分标准包含了每个分数的描述，通常范围在从1到5分。<p><strong>摘要分数（Summarization Score）</strong>，这个指标衡量摘要在捕捉上下文重要信息方面的表现如何。这个指标背后的直觉是，一个好的摘要应该包含上下文所有重要信息。我们首先从上下文中提取一组重要的关键词。然后使用这些关键词生成一组问题。接着我们向摘要提出这些问题，并计算摘要得分为正确回答的问题数与问题总数的比率。<p>现如果你想直接把刚刚这些Ragas指标用到我们前面实战案例的评估，就会发现门槛还是有点高，难度比较大。为什么呢？因为我们没有评估所需要的基础数据，所以我们需要先采集相关数据。<p>那如何采集评估所需要的基础数据呢？一种方法是让数据标注员人工提问和标注，这种方法成本很高。目前最常见，也是最容易的方法是让用户直接提供反馈，然后收集这些结果，再让数据标注员分析和标注。<h2 id=其他RAG技术><a class=headerlink href=#其他RAG技术 title=其他RAG技术></a>其他RAG技术</h2><p><strong>GraphRAG</strong><p>GraphRAG是一种结合了知识图谱的检索增强生成技术，旨在通过构建知识图谱和社区检测算法，提升大模型在理解和生成复杂信息方面的能力。它通过<strong>图结构信息</strong>，能够更精确地检索和生成与上下文相关的回答，从而在处理大规模数据集时展现出显著的性能提升<h2 id=规范化RAG应用><a class=headerlink href=#规范化RAG应用 title=规范化RAG应用></a>规范化RAG应用</h2><h3 id=RAG链路级优化><a class=headerlink href=#RAG链路级优化 title=RAG链路级优化></a>RAG链路级优化</h3><p><img alt=image-20260113192018389 data-src=https://s2.loli.net/2026/01/13/BmrKg4o7uCNx3fZ.png><p>从知识入库处理到最终生成评估.</p><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/ title=RAG系统设计>https://www.sekyoro.top/2026/01/12/RAG系统设计/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/2026/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/ rel=prev title=从零开始大数据> <i class="fa fa-chevron-left"></i> 从零开始大数据 </a></div><div class=post-nav-item><a href=/2026/01/16/%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93/ rel=next title=智力题总结> 智力题总结 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#RAG%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>1.</span> <span class=nav-text>RAG应用场景</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Fine-tuning-vs-RAG><span class=nav-number>2.</span> <span class=nav-text>Fine-tuning vs RAG</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91><span class=nav-number>2.1.</span> <span class=nav-text>未来方向</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BB%9F%E4%B8%80%E5%A4%9A%E6%BA%90%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F><span class=nav-number>3.</span> <span class=nav-text>统一多源文档格式</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#PDF%E8%A7%A3%E6%9E%90><span class=nav-number>3.1.</span> <span class=nav-text>PDF解析</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E5%8C%96%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91><span class=nav-number>3.1.1.</span> <span class=nav-text>优化解析逻辑</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%BE%E7%82%B9><span class=nav-number>3.2.</span> <span class=nav-text>难点</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B7%A8%E9%A1%B5%E8%A1%A8%E6%A0%BC%E6%80%8E%E4%B9%88%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90><span class=nav-number>3.2.1.</span> <span class=nav-text>跨页表格怎么自动对齐</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86><span class=nav-number>4.</span> <span class=nav-text>数据预处理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9C%AF%E8%AF%AD%E8%AF%8D%E5%BA%93%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4><span class=nav-number>4.1.</span> <span class=nav-text>术语词库构建与维护</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%9D%97%E7%AD%96%E7%95%A5%E4%B8%8EEmbedding%E6%8A%80%E6%9C%AF><span class=nav-number>5.</span> <span class=nav-text>分块策略与Embedding技术</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3><span class=nav-number>5.0.1.</span> <span class=nav-text>滑动窗口</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E5%88%87%E7%89%87%E7%AD%96%E7%95%A5%E4%B8%8E%E9%87%8D%E5%8F%A0%E6%9C%BA%E5%88%B6><span class=nav-number>6.</span> <span class=nav-text>动态切片策略与重叠机制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Dify%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E6%A8%A1%E5%BC%8F><span class=nav-number>6.0.1.</span> <span class=nav-text>Dify中的父子模式</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E9%98%B6%E6%AE%B5><span class=nav-number>7.</span> <span class=nav-text>检索增强阶段</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#OCR%E6%96%87%E4%BB%B6%E9%94%99%E6%BC%8F><span class=nav-number>8.</span> <span class=nav-text>OCR文件错漏</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5><span class=nav-number>9.</span> <span class=nav-text>生成控制与验证阶段</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E><span class=nav-number>10.</span> <span class=nav-text>向量检索引擎</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E8%AE%A1%E6%B7%B7%E5%90%88%E6%A3%80%E7%B4%A2%E6%9E%B6%E6%9E%84%E6%8F%90%E9%AB%98%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%8F%AC%E5%9B%9E%E7%8E%87><span class=nav-number>10.1.</span> <span class=nav-text>设计混合检索架构提高多阶段召回率</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%A9AI%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE><span class=nav-number>11.</span> <span class=nav-text>让AI返回结构化数据</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0><span class=nav-number>11.1.</span> <span class=nav-text>开源实现</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E4%BA%A7%E5%AE%9E%E7%8E%B0><span class=nav-number>11.2.</span> <span class=nav-text>生产实现</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%89%E6%95%88%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%94%B9%E8%BF%9BRAG%E5%BA%94%E7%94%A8><span class=nav-number>12.</span> <span class=nav-text>有效评估与改进RAG应用</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B6%E4%BB%96RAG%E6%8A%80%E6%9C%AF><span class=nav-number>13.</span> <span class=nav-text>其他RAG技术</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%84%E8%8C%83%E5%8C%96RAG%E5%BA%94%E7%94%A8><span class=nav-number>14.</span> <span class=nav-text>规范化RAG应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#RAG%E9%93%BE%E8%B7%AF%E7%BA%A7%E4%BC%98%E5%8C%96><span class=nav-number>14.1.</span> <span class=nav-text>RAG链路级优化</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>259</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>220</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>此文章目前无词云</h3></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2026</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>4.3m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>64:40</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>document.addEventListener("DOMContentLoaded", function() {
    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
        var pvContainer = document.getElementById("busuanzi_container_site_pv");
        if (pvContainer && pvContainer.style.display !== "none") {
            var pvElement = document.getElementById("busuanzi_value_site_pv");
            if (pvElement) {
                pvElement.innerHTML = parseInt(pvElement.innerHTML) + countOffset;
                clearInterval(int);
            }
        }
        
        var uvContainer = document.getElementById("busuanzi_container_site_uv");
        if (uvContainer && window.getComputedStyle(uvContainer).display !== "none")
        {
            var uvElement = document.getElementById("busuanzi_value_site_uv");
            if (uvElement) {
                uvElement.innerHTML = parseInt(uvElement.innerHTML) + countOffset; // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    }
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	 '.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
  
  // Reinitialize TagCanvas for tag cloud
  if (typeof TagCanvas !== 'undefined' && document.getElementById('resCanvas')) {
    try {
      TagCanvas.textFont = 'Trebuchet MS, Helvetica';
      TagCanvas.textColour = '#333';
      TagCanvas.textHeight = 20;
      TagCanvas.outlineColour = '#E2E1D1';
      TagCanvas.maxSpeed = 0.3;
      TagCanvas.freezeActive = true;
      TagCanvas.outlineMethod = 'block';
      TagCanvas.minBrightness = 0.2;
      TagCanvas.depth = 0.92;
      TagCanvas.pulsateTo = 0.6;
      TagCanvas.initial = [0.1,-0.1];
      TagCanvas.decel = 0.98;
      TagCanvas.reverse = true;
      TagCanvas.hideTags = false;
      TagCanvas.shadow = '#ccf';
      TagCanvas.shadowBlur = 3;
      TagCanvas.weight = false;
      TagCanvas.imageScale = null;
      TagCanvas.fadeIn = 1000;
      TagCanvas.clickToFront = 600;
      TagCanvas.lock = false;
      TagCanvas.Start('resCanvas');
      TagCanvas.tc['resCanvas'].Wheel(true);
    } catch(e) {
      console.log('TagCanvas initialization failed:', e);
    }
  }
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
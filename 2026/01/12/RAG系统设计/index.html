<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=目前LLM应用集中在开发所谓AI智能体,理想中的AI智能体能够自主感知环境并作出决策,与环境的变化不断反馈,同时具备记忆,反思和工具能力.而目前的AI应用中,效果最好,成本也低的还是RAG. name=description><meta content=article property=og:type><meta content=RAG系统设计 property=og:title><meta content=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=目前LLM应用集中在开发所谓AI智能体,理想中的AI智能体能够自主感知环境并作出决策,与环境的变化不断反馈,同时具备记忆,反思和工具能力.而目前的AI应用中,效果最好,成本也低的还是RAG. property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2026/01/13/8gjtfrQ3vART42E.png property=og:image><meta content=https://s2.loli.net/2026/01/13/bSG4or8AcmnNkxP.png property=og:image><meta content=https://s2.loli.net/2026/01/13/OxiwCam8R5HzroU.png property=og:image><meta content=https://s2.loli.net/2026/01/13/HQyj94GeUDbJXvL.png property=og:image><meta content=https://s2.loli.net/2026/01/13/LJ5gIYocRW1OMhs.png property=og:image><meta content=https://s2.loli.net/2026/01/13/a93OWviDeEuVHtS.png property=og:image><meta content=https://s2.loli.net/2026/01/13/HtOu2piYNzmc5oT.png property=og:image><meta content=https://s2.loli.net/2026/01/13/jnPqIHEdLuV2g8l.png property=og:image><meta content=https://s2.loli.net/2026/01/13/FmMrCP7X6E3NsRV.png property=og:image><meta content=https://s2.loli.net/2026/01/13/uWSVRKQ13fZlOde.png property=og:image><meta content=https://s2.loli.net/2026/01/13/oMWHlgAt4XJy5VC.png property=og:image><meta content=https://s2.loli.net/2026/01/13/9QqxH8JkfObdPpe.png property=og:image><meta content=https://s2.loli.net/2026/01/13/3zsZUHCwk5QOaGl.png property=og:image><meta content=https://s2.loli.net/2026/01/13/1MGJDKWENkfjeS4.png property=og:image><meta content=https://s2.loli.net/2026/01/13/GyxSOqhop9erDBA.png property=og:image><meta content=https://s2.loli.net/2026/01/13/BmrKg4o7uCNx3fZ.png property=og:image><meta content=https://www.runoob.com/wp-content/uploads/2026/02/runoob-funcall-runoob-scaled.png property=og:image><meta content=2026-01-12T15:50:19.000Z property=article:published_time><meta content=2026-02-28T12:09:20.000Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content="个人博客 技术学习 计算机 互联网 人工智能" property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2026/01/13/8gjtfrQ3vART42E.png name=twitter:image><link href=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>RAG系统设计 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>RAG系统设计</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2026-01-12 23:50:19" datetime=2026-01-12T23:50:19+08:00>2026-01-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2026-02-28 20:09:20" datetime=2026-02-28T20:09:20+08:00 itemprop=dateModified>2026-02-28</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>57k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>52 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>目前LLM应用集中在开发所谓AI智能体,理想中的AI智能体能够自主感知环境并作出决策,与环境的变化不断反馈,同时具备记忆,反思和工具能力.而目前的AI应用中,效果最好,成本也低的还是RAG.<br><span id=more></span><h2 id=RAG应用场景><a class=headerlink href=#RAG应用场景 title=RAG应用场景></a>RAG应用场景</h2><p>RAG全称是“Retrieval-Augmented Generation”，即“检索增强的生成”。当设计一个LLM问答应用，模型<strong>需要处理用户的领域问题时</strong>，尽管大模型通常表现出色，但有时提供的答案并不准确，甚至可能出现错误。<strong>当用户需要获取实时信息时，模型无法及时提供最新的答案</strong>。这种现象在LLM应用中较为常见。<p>这些模型仍然存在一些无法忽视的局限性。其中，<strong>领域知识缺乏</strong>是最明显的问题。大模型的知识来源于训练数据，这些数据主要来自公开的互联网和开源数据集，无法覆盖特定领域或高度专业化的内部知识。<p><strong>信息过时</strong>则指模型难以处理实时信息，因为训练过程耗时且成本高昂，模型一旦训练完成，就难以获取和处理新信息。<p>此外，<strong>幻觉问题</strong>是另一个显著的局限，模型基于概率生成文本，有时会输出看似合理但实际错误的答案。最后，<strong>数据安全性</strong>在企业应用中尤为重要，如何在确保数据安全的前提下，使大模型有效利用私有数据进行推理和生成，是一个具有挑战性的问题。<p><img alt=image-20260113140539536 data-src=https://s2.loli.net/2026/01/13/8gjtfrQ3vART42E.png><p>RAG系统的应用场景主要集中在专业领域和企业场景,<p>RAG的核心思想是<strong>利用外部知识库或数据集来辅助模型的生成过程</strong>。具体来说，RAG通常包含以下关键步骤。<ol><li>检索阶段：首先，模型会根据输入的查询或问题，从预先构建的索引中检索出最相关的数据、文档或文本片段。<li>生成阶段：随后，模型会使用这个综合的表示来生成答案或输出文本。在问答任务中，这通常意味着生成一个对原始查询的直接回答。</ol><p>选择RAG而不是直接将所有知识库数据交给大模型处理，主要是<strong>因为模型能够处理的token数有限，输入过多token会增加成本。更重要的是，提供少量相关的关键信息能够带来更优质的回答</strong>。<p><strong>RAG模型的核心思想在于通过检索与生成的有机结合，弥补大模型在处理领域问题和实时任务时的不足。</strong>传统的生成模型在面对复杂问题时，往往由于知识储备不足，生成出错误或无关的回答。而RAG通过检索模块获取相关的背景信息，使生成模块能够参考这些信息，从而生成更具可信度和准确性的答案。这种方法不仅增强了生成内容的准确性，还提高了模型在应对特定领域知识和动态信息时的适应能力。<p><img alt=image-20260113141707928 data-src=https://s2.loli.net/2026/01/13/bSG4or8AcmnNkxP.png style=zoom:67%;><p>RAG标准流程由<strong>索引</strong>（Indexing）、<strong>检索</strong>（Retriever）和<strong>生成</strong>（Generation）三个核心阶段组成。<ol><li>索引阶段，通过<strong>处理多种来源多种格式的文档提取其中文本，将其切分为标准长度的文本块</strong>（chunk），并进行<strong>嵌入向量化（embedding），向量存储在向量数据库</strong>（vector database）中。<li>检索阶段，用户输入的查询（query）被转化为向量表示，通过相似度匹配从向量数据库中检索出最相关的文本块。<li>最后生成阶段，检索到的相关文本与原始查询共同构成提示词（Prompt），输入大语言模型（LLM），生成精确且具备上下文关联的回答。</ol><p><strong>索引是RAG系统的基础环节</strong>，包含四个关键步骤。<ol><li>首先，将各类数据源及其格式（如书籍、教材、领域数据、企业文档等，txt、markdown、doc、ppt、excel、pdf、html、json等格式）统一解析为纯文本格式。<li>接着，根据文本的语义或文档结构，将文档分割为小而语义完整的文本块（chunks），确保系统能够高效检索和利用这些块中包含的信息。<li>然后，使用文本嵌入模型（embedding model），将这些文本块向量化，生成高维稠密向量，转换为计算机可理解的语义表示。<li>最后，将这些向量存储在向量数据库(vector database)中，并构建索引，完成知识库的构建。这一流程成功将外部文档转化为可检索的向量，支撑后续的检索和生成环节。</ol><p><strong>检索是连接用户查询与知识库的核心环节。</strong>首先，用户输入的问题通过同样的文本嵌入模型转换为向量表示，将查询映射到与知识库内容相同的向量空间中。通过相似度度量方法，检索模块从向量数据库中筛选出与查询最相关的前K个文本块，这些文本块将作为生成阶段输入的一部分。通过相似性搜索，检索模块有效获取了与用户查询切实相关的外部知识，为生成阶段提供了精确且有意义的上下文支持。<p><strong>生成是RAG流程中的最终环节</strong>，将检索到的相关文本块与用户的原始查询整合为增强提示词（Prompt），并输入到大语言模型（LLM）中。LLM基于这些输入生成最终的回答，确保生成内容既符合用户的查询意图，又充分利用了检索到的上下文信息，使得回答更加准确和相关，充分使用到知识库中的知识。通过这一过程，RAG实现了具备领域知识和私有信息的精确内容生成。<h2 id=Fine-tuning-vs-RAG><a title="Fine-tuning vs RAG" class=headerlink href=#Fine-tuning-vs-RAG></a>Fine-tuning vs RAG</h2><p>Fine-tuning 作为一种直接针对预训练语言模型进行额外训练的方法，能够让模型更好地适应特定领域或任务。这种方法的核心优势在于，<strong>能够显著提升模型在目标任务上的表现</strong>。通过使用领域特定的数据集，Fine-tuning 可以让模型学习到行业术语、专业知识结构和特定的表达方式。这使得Fine-tuned模型在处理专业领域的问题时，能够提供更加准确、相关的回答。例如，在极客时间，我们把作者的实战经验从文章中提取出来，然后基于开源模型进行微调，让 LLM 可以输出生产环境直接可用的技术方案，而不是一些通用解决方案。<p><strong>微调更适合需求稳定、领域知识固定且不需要频繁更新知识库的场景</strong>。通过使用特定领域的数据对模型进行深度优化，微调可以提升模型在特定任务或领域中的推理能力，确保输出内容的专业性和一致性。因此，当任务侧重于某一特定领域，并且对实时信息的依赖较低时，微调更能满足这些需求<p>此外，Fine-tuning 后的模型响应速度快，无需在运行时检索外部知识库，这使得它特别适合需要实时响应的场景，比如在线客户服务或实时决策支持系统。举个例子，在我们的用户对话功能中，有时候人工客服可能不在线，用户提问如果能快速得到响应，及时解答用户问题，可以大大提高用户的信任感。<p>当然，使用 Fine-tuning 也要付出一些额外的成本。它需要大量的标注数据和较高的计算资源，这对许多企业来说可能是一个门槛。而且，一旦模型经过 Fine-tuning，要更新其知识就需要重新训练，如果是经常变化的知识，可能成本就非常高了。<p>相比之下，RAG 技术提供了一种更为灵活的解决方案，可以更好地处理 “经常变化” 的知识。RAG 通过将大语言模型与外部知识库结合，在生成回答时实时检索相关信息。这种方法非常灵活，由于是自己设计的知识库，可以做各种优化操作，保证把最准确的知识呈现给用户。企业可以随时更新知识库中的信息。<p>RAG 的另一个重要优势是其<strong>可解释性</strong>。由于每个回答都可以追溯到具体的知识来源，这大大增强了AI系统的可信度和透明度。在需要严格监管或高度问责的行业，如金融服务或政府部门，这一特性尤为重要。然而，RAG也有其局限性。由于需要实时检索知识库，RAG系统的响应速度可能不如 Fine-tuned 模型快。此外，RAG的效果高度依赖于<strong>知识库的质量</strong>和<strong>检索算法的效率</strong>，这要求我们投入大量资源来维护和优化知识库。<p>在实际应用中，我们可以将 Fine-tuning 和 RAG 结合使用，以充分发挥两种方法的优势。这种混合方法可以应对更复杂的场景和挑战。例如，要做一个极客时间客服系统，我们可以使用 Fine-tuned 模型来处理常见的、结构化的查询，比如一些通识或者固定不变的知识，保证快速、准确的响应。同时，对于涉及最新产品信息或政策变更的问题，系统可以切换到 RAG 模式，利用实时更新的知识库来提供最新、最相关的信息。在产品研发过程中，可以使用企业内固定的技术相关文档进行 Fine-tuning，让 LLM 回答的内容都是符合企业开发技术范围，再配合上 RAG 把一些外部的技术文档作为补充知识库，两者结合，在内部就可以很好地辅助产研人员工作。<h3 id=未来方向><a class=headerlink href=#未来方向 title=未来方向></a>未来方向</h3><p><strong>第一个方向是动态知识图谱的集成。</strong>传统的RAG系统通常使用静态的知识库，而动态知识图谱将为RAG带来更智能、更灵活的知识管理能力。这种系统不仅能够实时更新知识，还能自动建立知识之间的关联。<p>在前面课程中提到的 Mem0 记忆框架，最近更新了一个特性，就是 graph memory。它把用户的记忆拆分成记忆节点和关系，通过使用图数据库，保存下这些关系和节点，在使用记忆的时候，会通过图检索技术找到记忆之间的关联，从而找到关键的记忆点，然后结合当时的详细记忆，最终给出回答。这种技术可以让用户在海量记忆中去查询问题的答案，相比传统的 RAG，极大程度地提高了记忆的相关性和连续性。<p>还有就是最近大火的<a href=https://microsoft.github.io/graphrag/ rel=noopener target=_blank>GraphRAG</a>。GraphRAG 本身是一个理论，这个项目是由微软开源的，它包括从原始文本中提取知识图，构建社区层次结构，为这些社区生成摘要，然后在执行基于 RAG 的任务时利用这些结构等等功能。<p><strong>第二个方向是个性化</strong> <strong>RAG。</strong>未来的RAG系统将能够根据用户的背景、偏好和使用历史来动态调整其检索和生成策略。<p>例如，一个个性化的 RAG 系统可以根据用户的知识水平、学习风格和关注点来推荐内容和解答用户问题。这种个性化不仅限于内容的选择，还包括表达方式的调整，使得AI助手能够以最适合每个用户的方式进行交流，可以根据不同用户的喜好风格，调整 AI 小助手的说话方式。这将大大提高用户体验，使AI系统更加贴近人类的交互需求，带给用户更多的亲切感。<p><strong>第三个方向是多模态 RAG。</strong>上述的讨论都建立在文本模型上，如果再加上视觉模型，让大模型能像人眼一样观察世界，再把看到的东西内化到知识库中，这将会大大拓宽 RAG 的应用范围，让更多的业务能够用上大模型技术。<p>比如，在医疗领域，使用多模态 RAG 系统可能会同时分析病人的症状描述（文本）、X光片（图像）、心电图（时序数据）和医生的口头诊断（音频）。系统不仅能够理解每种模态的信息，还能够在这些不同模态之间建立联系，提供更加全面和准确的诊断建议。相对于只有文本内容，这种方式能够得出更加准确和有深度的诊断，也更加符合医生的诊断习惯。通过与多模态结合，将会让大模型在更多领域发挥价值，甚至会产生新的产品形态或者服务方式。企业在这个方向上进行探索，会带来创新性的收获。<h1 id=IM系统><a class=headerlink href=#IM系统 title=IM系统></a>IM系统</h1><p>基于 Netty ⾃定义 WebSocket 协议实现⾼性能即时通讯服务；利⽤ Redisson 缓存会话列表与⽤⼾路由以优 化加载性能同时维护集群环境下的⽤⼾状态。此外，通过设计离线消息增量拉取逻辑，确保⽤⼾重连后消息有 序不丢失。<p>是基于 Netty 搭建高性能 WebSocket 即时通讯服务，解决三个核心问题：<p>①单节点高性能通讯 ②集群下用户状态同步 ③用户重连后离线消息不丢失且加载高效。整体架构上，用 Netty 做底层通讯层，Redisson（Redis）做分布式缓存 / 消息广播层，再通过离线消息增量拉取的业务逻辑保证消息一致性。<h4 id=Netty-自定义-WebSocket-实现高性能即时通讯><a title="Netty + 自定义 WebSocket 实现高性能即时通讯" class=headerlink href=#Netty-自定义-WebSocket-实现高性能即时通讯></a>Netty + 自定义 WebSocket 实现高性能即时通讯</h4><blockquote><p>Netty 是一个<strong>异步事件驱动</strong>的网络应用框架，用于快速开发高性能、高可靠性的网络服务器和客户端<p><strong>异步非阻塞</strong>：基于 NIO，支持高并发<p><strong>高性能</strong>：零拷贝、内存池、对象池<p><strong>高可靠性</strong>：完善的异常处理、断连重连<p><strong>高度可定制</strong>：灵活的线程模型、编解码</blockquote><p>首先是底层通讯层的设计，选择 Netty 是因为它的 NIO 非阻塞 Reactor 模型天生适配高并发的长连接场景，比传统 BIO 的 Tomcat WebSocket 性能提升显著：<ul><li>协议层处理：在 Netty 的 ChannelPipeline 中做了分层 Handler 设计：<ul><li>先通过<code>HttpServerCodec</code>+<code>HttpObjectAggregator</code>处理 HTTP 协议（因为 WebSocket 握手基于 HTTP），保证 HTTP 请求的完整性；<li>再通过<code>WebSocketServerProtocolHandler</code>将 HTTP 协议升级为 WebSocket，支持全双工长连接，同时配置帧大小、握手超时等参数避免异常连接；<li>核心的心跳保活：加入<code>IdleStateHandler</code>设置 60 秒读超时（用户端 60 秒没发心跳则判定连接失效），配合自定义的<code>HandlerHeartBeat</code>处理器，监听到读超时事件后主动关闭无效连接，避免资源泄漏；写超时暂时设为 0（心跳由客户端主动发，服务端仅被动检测），如果检测到写超时也会主动推送心跳包维持连接。</ul><li><strong>高性能优化</strong>：拆分 Boss/Worker 线程组（Boss 组仅处理连接建立，Worker 组处理消息读写），避免连接和消息处理互相阻塞；给业务 Handler 加<code>@Sharable</code>注解复用实例，减少对象创建开销；容器销毁时通过<code>@PreDestroy</code>优雅关闭 EventLoopGroup，防止端口占用 / 线程泄漏。</ul><h4 id=Redisson-缓存会话-amp-用户路由（解决集群状态同步）><a title="Redisson 缓存会话 & 用户路由（解决集群状态同步）" class=headerlink href=#Redisson-缓存会话-amp-用户路由（解决集群状态同步）></a>Redisson 缓存会话 & 用户路由（解决集群状态同步）</h4><p>单节点下可以用本地 ConcurrentMap 维护用户 ID 和 Netty Channel 的映射，但集群环境下节点间隔离，必须用分布式缓存 / 广播：<ul><li><p>缓存设计：会话列表缓存：把用户的聊天会话（ChatSessionUser）缓存到 Redis，用户上线时直接从 Redis 拉取，比每次查数据库减少 80% 以上的加载耗时；</p> <p>用户路由：用 Redis 维护「用户 ID - 节点标识 - Channel」的映射，同时基于 Redisson 的<code>RTopic</code>实现集群消息广播 —— 比如 A 节点的用户给 B 节点的用户发消息，先通过 RTopic 把消息广播到所有节点，节点收到后查本地 ChannelMap，找到目标用户则推送消息，解决集群下消息路由问题；</p> <p>状态维护：用户上线 / 下线 / 心跳都会更新 Redis 中的状态（比如<code>saveUserHeartBeat</code>记录心跳时间，<code>removeUserHeartBeat</code>清理离线状态），集群节点可通过 Redis 感知用户在线状态，避免给离线用户推送无效消息。</p><li><p><strong>选型思考</strong>：选 Redisson 而非原生 Redis 客户端，是因为它封装了分布式锁、ChannelGroup、Topic 等适配 Netty 的特性，且支持 Redis 集群模式，能直接对接生产环境的 Redis 集群。</p></ul><h4 id=离线消息增量拉取（保证消息有序不丢失）><a class=headerlink href=#离线消息增量拉取（保证消息有序不丢失） title=离线消息增量拉取（保证消息有序不丢失）></a>离线消息增量拉取（保证消息有序不丢失）</h4><p>用户重连后如果全量拉取所有消息，不仅性能差，还会导致用户体验下降，所以设计了增量拉取逻辑：<ul><li><strong>核心锚点</strong>：在用户表（UserInfo）中记录<code>lastOffTime</code>（最后离线时间戳），用户重连时以此为基准拉取增量数据；<li><strong>增量范围控制</strong>：考虑到用户离线过久（比如超过 3 天）会产生大量消息，限制仅拉取最近 3 天的增量，平衡性能和用户体验；<li>增量维度：<ul><li>会话列表：按<code>last_receive_time > lastOffTime</code>筛选离线期间有新消息的会话，保证会话最新；<li>聊天消息：按联系人维度（用户 / 群聊）筛选离线期间新增的消息，且按接收时间降序排序，确保消息有序；<li>好友申请：筛选离线期间新增的未处理申请，统计数量并推送给用户；</ul><li><strong>实现细节</strong>：将这些增量数据封装成<code>WsInitData</code>对象，在用户握手成功后一次性推送，既保证消息不丢失，又避免全量加载的性能问题。</ul><h4 id=IM系统保证消息的可靠（有序、不丢失、不重复）><a class=headerlink href=#IM系统保证消息的可靠（有序、不丢失、不重复） title=IM系统保证消息的可靠（有序、不丢失、不重复）></a>IM系统保证消息的可靠（有序、不丢失、不重复）</h4><p>客户端 A 向 B 发送消息要实现<strong>绝对可靠</strong>（不丢、不重、有序、可达），需要覆盖「发送端→服务端→接收端」全链路的确认机制、异常兜底和存储保障。结合你现有 Netty+Redisson/Redis 的技术栈，以下是可落地的核心方案（补充现有离线增量拉取、集群广播之外的可靠性保障）：<p>消息可靠的本质是「全链路确认 + 多层兜底」：<ul><li>不丢：每一步操作都有「确认回执」+「持久化兜底」；<li>不重：全局唯一 ID + 幂等校验；<li>有序：基于时序 / 唯一 ID 的排序机制；<li>可达：离线兜底 + 重试机制。</ul><p>发送端（A）：避免「发出去就丢」<p>客户端本地缓存 + 重试机制<ul><li><strong>问题</strong>：A 发送消息时网络闪断 / 服务端暂不可达，消息直接丢失。<li>实现：A 发送消息前，先将消息（带<strong>全局唯一 msgId</strong>，雪花算法生成）缓存到本地（移动端用 SP/MMKV，PC 端用本地 DB），标记状态为「待发送」；<ul><li>监听 Netty writeAndFlush的 Future 回调：<ul><li>成功（收到服务端「接收 ACK」）：更新本地状态为「已发送」；<li>失败 / 超时：触发<strong>指数退避重试</strong>（1s→3s→5s，最多 5 次），重试失败则标记「发送失败」，给用户弹窗提示手动重发。</ul></ul></ul><h5 id=服务端「接收确认」（第一层兜底）><a class=headerlink href=#服务端「接收确认」（第一层兜底） title=服务端「接收确认」（第一层兜底）></a>服务端「接收确认」（第一层兜底）</h5><p><strong>问题</strong>：服务端收到 A 的消息但未处理就宕机，消息丢失。<p>只有DB 写入成功，才给 A 返回 ACK；否则告知 A 发送失败，触发客户端重试。<h4 id=服务端转发阶段：避免「服务端收到但-B-收不到」><a title="服务端转发阶段：避免「服务端收到但 B 收不到」" class=headerlink href=#服务端转发阶段：避免「服务端收到但-B-收不到」></a>服务端转发阶段：避免「服务端收到但 B 收不到」</h4><h5 id=消息持久化-投递状态跟踪><a title="消息持久化 + 投递状态跟踪" class=headerlink href=#消息持久化-投递状态跟踪></a>消息持久化 + 投递状态跟踪</h5><ul><li><strong>问题</strong>：服务端已接收消息，但 B 离线 / Channel 断开，消息无法投递。<li>实现：消息落地到<code>chat_message</code>表时，增加<code>message_status</code>字段（<code>TO_DELIVER</code>待投递 /<code>DELIVERED</code>已投递 /<code>READ</code>已读）；</ul><h5 id=集群环境：可靠广播替代普通-Topic><a title="集群环境：可靠广播替代普通 Topic" class=headerlink href=#集群环境：可靠广播替代普通-Topic></a>集群环境：可靠广播替代普通 Topic</h5><ul><li><strong>问题</strong>：现有<code>RTopic</code>是普通广播，若消费节点宕机，消息直接丢失。<li>实现：用 Redisson <code>ReliableTopic</code>（可靠 Topic）替代普通<code>RTopic</code></ul><h4 id=接收端（B）：避免「收到但没确认」><a class=headerlink href=#接收端（B）：避免「收到但没确认」 title=接收端（B）：避免「收到但没确认」></a>接收端（B）：避免「收到但没确认」</h4><h5 id=（1）接收-已读确认机制（回执）><a title="（1）接收 / 已读确认机制（回执）" class=headerlink href=#（1）接收-已读确认机制（回执）></a>（1）接收 / 已读确认机制（回执）</h5><ul><li><strong>问题</strong>：B 收到消息但服务端不知情，A 误以为消息丢失，重复发送。<li>实现：<ul><li>B 收到消息后，立即给服务端返回「已接收 ACK」（携带 msgId）；<li>服务端收到 ACK 后，更新 DB/Redis 中消息状态为「DELIVERED」，并推送给 A「B 已收到」的回执；<li>B 进入聊天窗口阅读消息后，再返回「已读 ACK」，服务端更新状态为「READ」，同步给 A（已读回执）</ul></ul><h5 id=（2）幂等去重：避免重复消息><a class=headerlink href=#（2）幂等去重：避免重复消息 title=（2）幂等去重：避免重复消息></a>（2）幂等去重：避免重复消息</h5><ul><li><strong>问题</strong>：网络重试 / 集群广播导致 B 收到重复消息。<li>实现：全局唯一 msgId：所有消息用雪花算法生成唯一 ID（包含用户 ID、时间戳、序列号）；<ul><li>客户端 B：本地维护「已接收 msgId 列表」（内存 + 本地缓存），收到消息先校验 msgId 是否存在，存在则丢弃；<li>服务端：Redis 中维护<code>msg_delivered_set:{userId}</code>（已投递 msgId 集合），推送前先校验，避免重复推送。</ul></ul><p>极端场景：兜底保障<h5 id=（1）死信队列（DLQ）：处理多次重试失败的消息><a class=headerlink href=#（1）死信队列（DLQ）：处理多次重试失败的消息 title=（1）死信队列（DLQ）：处理多次重试失败的消息></a>（1）死信队列（DLQ）：处理多次重试失败的消息</h5><ul><li><strong>问题</strong>：B 长期离线 / 账号异常，消息重试 N 次仍无法投递，导致消息积压 / 丢失。<li>实现：<ul><li>消息重试≥5 次仍失败，转入死信队列<code>DLQ_QUEUE</code>；<li>后台定时任务扫描死信队列，做兜底处理：<ul><li>给 A 推送「消息投递失败」提示；<li>若 B 是离线状态，保留消息到 DB，待 B 上线后强制触发增量拉取；<li>死信消息保留 7 天，避免永久丢失。</ul></ul></ul><h5 id=（2）分布式事务：保障「存储-投递」原子性><a title="（2）分布式事务：保障「存储 + 投递」原子性" class=headerlink href=#（2）分布式事务：保障「存储-投递」原子性></a>（2）分布式事务：保障「存储 + 投递」原子性</h5><ul><li><p><strong>问题</strong>：服务端将消息存入 DB，但推送时失败，导致「存了但没发」。</p><li><p>实现：基于「本地消息表 + 定时任务」实现最终一致性：</p> <ol><li><p>服务端接收 A 的消息时，同时写入「本地消息表」（标记「待投递」）；</p><li><p>定时任务扫描本地消息表，重推「待投递」且超过阈值（比如 10s）的消息；</p><li><p>推送成功后更新状态为「已投递」，避免重复扫描。</p></ol></ul><h4 id=心跳机制为什么设-60-秒读超时？写超时为什么设-0？><a title="心跳机制为什么设 60 秒读超时？写超时为什么设 0？" class=headerlink href=#心跳机制为什么设-60-秒读超时？写超时为什么设-0？></a>心跳机制为什么设 60 秒读超时？写超时为什么设 0？</h4><p>答：读超时设 60 秒是结合业务场景（即时通讯不需要超高频心跳），平衡「连接保活」和「资源占用」—— 太短会增加客户端心跳开销，太长会导致无效连接占用端口 / 线程；写超时设 0 是因为我们设计的是「客户端主动发心跳，服务端被动检测」，如果服务端主动推心跳（写超时触发），会增加服务端开销，且客户端如果在线，自然会主动发心跳，无需服务端额外推送。<h4 id=集群下怎么保证消息不推错、不重复？><a class=headerlink href=#集群下怎么保证消息不推错、不重复？ title=集群下怎么保证消息不推错、不重复？></a>集群下怎么保证消息不推错、不重复？</h4><p>方法一：首先通过 Redisson RTopic 广播消息时，会携带「目标用户 ID」，每个节点收到广播后，先查本地的 USER_CONTEXT_MAP（ConcurrentMap），只有本地有该用户的 Channel 才会推送，避免推错；其次消息推送前会结合 Redis 的用户在线状态做校验（比如用户已离线则不推送），且聊天消息入库时会加唯一 ID，客户端收到后去重，避免重复推送。<h4 id=离线消息增量拉取怎么保证有序？><a class=headerlink href=#离线消息增量拉取怎么保证有序？ title=离线消息增量拉取怎么保证有序？></a>离线消息增量拉取怎么保证有序？</h4><p>数据库层面给<code>chat_message</code>表的<code>last_receive_time</code>字段加了索引，查询时按<code>last_receive_time desc</code>排序，拉取后推送给客户端时也是按这个顺序；另外会话列表也按最后接收消息时间降序排列，保证用户重连后看到的消息 / 会话和离线前的顺序一致，符合用户的使用习惯。<h1 id=文件分片上传、断点续传><a class=headerlink href=#文件分片上传、断点续传 title=文件分片上传、断点续传></a>文件分片上传、断点续传</h1><p>可靠性、有序性、不重复<h1 id=RAG检索流水线><a class=headerlink href=#RAG检索流水线 title=RAG检索流水线></a>RAG检索流水线</h1><p>按 “数据侧 + 查询侧” 梳理<p>核心流程分两大环节：<ol><li>离线数据预处理（语料入库）： - 垂直领域语料清洗（去重/降噪/结构化）→ 拆分chunk（按语义/固定长度，比如512token）； - 双路编码：① 用领域微调的Bi-Encoder（如BERT-base）将chunk转为768维向量；② 对chunk做中文分词（IK分词器），提取关键词/实体； - ES索引构建：创建混合索引（text类型存文本+dense_vector类型存向量），同时优化BM25参数、向量索引类型。 2. 在线检索（问答推理）：<li>用户问题输入 → 同样做Bi-Encoder向量化+关键词提取； - 多路召回：① KNN向量检索（top100）+ ② BM25关键词检索（top100）； - 结果去重/合并（保留top100）→ Cross-Encoder重排（对“问题+候选chunk”打分）→ 取top10作为检索结果； - 把top10 chunk拼接为prompt，送入大模型生成回答 → 返回最终结果。</ol><h1 id=文件解析与切片、向量入库><a class=headerlink href=#文件解析与切片、向量入库 title=文件解析与切片、向量入库></a>文件解析与切片、向量入库</h1><h2 id=文档预处理（统一格式-噪声清洗）><a title="文档预处理（统一格式 + 噪声清洗）" class=headerlink href=#文档预处理（统一格式-噪声清洗）></a>文档预处理（统一格式 + 噪声清洗）</h2><p>先将不同格式（PDF/Word/Markdown/TXT）的文档标准化，同时过滤无意义内容，避免干扰分片逻辑：<h3 id=多格式文本提取><a class=headerlink href=#多格式文本提取 title=多格式文本提取></a>多格式文本提取</h3><div class=table-container><table><thead><tr><th style=text-align:center>文档格式<th style=text-align:center>提取方式（核心工具 / 逻辑）<tbody><tr><td style=text-align:center>Word（DOCX/DOC）<td style=text-align:center>解析 XML 结构，提取「样式层级（标题 1/2/3）、正文段落、文本块」（工具：POI）；<tr><td style=text-align:center>PDF<td style=text-align:center>文本型 PDF：Apache PDFBox/IText 提取文本块，按字体大小 / 行距 / 缩进识别标题；图片型 PDF：先 OCR（Tesseract）转文本，再按文本块拆分；<tr><td style=text-align:center>Markdown<td style=text-align:center>解析<code>#/##/###</code>标题标识、空行、列表符，识别章节 / 段落边界；<tr><td style=text-align:center>TXT<td style=text-align:center>按换行符、特殊分隔符（如<code>====</code>/<code>----</code>）识别章节，保留原始文本结构；</table></div><p>实现基于⽂档层级树的分层索引⽅案，通过“章-段-句”组织结构并以句⼦为最小向量单元，解决常规硬切⽚ 导致的语义链断裂问题。同时集成⽗⼦索引策略实现“细粒度检索、宽粒度召回”，以解决⻓⽂档问答中的信 息碎⽚化问题。<h3 id=2-噪声清洗><a title="2. 噪声清洗" class=headerlink href=#2-噪声清洗></a>2. 噪声清洗</h3><ul><li>正则过滤：移除页眉页脚（如 “XX 白皮书 第 X 页”）、水印、重复空行、无意义符号（如<code>★/■</code>）；<li>特殊文本处理：表格 / 公式 / 代码块标记为 “特殊单元”，暂不拆分（后续单独处理）。</ul><h2 id=层级树构建核心步骤（从顶层到叶子节点）><a class=headerlink href=#层级树构建核心步骤（从顶层到叶子节点） title=层级树构建核心步骤（从顶层到叶子节点）></a>层级树构建核心步骤（从顶层到叶子节点）</h2><h3 id=步骤-1：章节级分片（树的「分支节点」）><a title="步骤 1：章节级分片（树的「分支节点」）" class=headerlink href=#步骤-1：章节级分片（树的「分支节点」）></a>步骤 1：章节级分片（树的「分支节点」）</h3><p>目标：识别 “章 / 节” 边界，构建层级树顶层，核心是 “标题规则 + 主题连续性”。<h4 id=1-章节边界判定规则（优先级从高到低）><a title="1. 章节边界判定规则（优先级从高到低）" class=headerlink href=#1-章节边界判定规则（优先级从高到低）></a>1. 章节边界判定规则（优先级从高到低）</h4><div class=table-container><table><thead><tr><th style=text-align:center>规则类型<th style=text-align:center>具体逻辑<tbody><tr><td style=text-align:center>格式规则<td style=text-align:center>- 一级标题：Word “标题 1”、Markdown<code>#</code>、PDF 字体≥16 号且加粗、TXT “第 X 章”；- 二级 / 三级节：Word“标题 2/3”、Markdown<code>##/###</code>、PDF 字体≥14 号；<tr><td style=text-align:center>主题规则<td style=text-align:center>无格式标题时，用 NLP 主题模型（如 LDA）分析文本主题，<strong>主题突变处判定为新章节</strong>；<tr><td style=text-align:center>兜底规则<td style=text-align:center>超长无标题文档：按 “每 5000 字（可配置）” 拆分虚拟章节（标记为 “未命名章节 X”）；</table></div><h4 id=章节节点生成><a title=". 章节节点生成" class=headerlink href=#章节节点生成></a>. 章节节点生成</h4><p>遍历预处理后的文本，生成章节节点，结构示例：<p>java<p>运行<figure class="highlight haxe"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 章节节点核心结构</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>ChapterNode</span> </span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> chapterId;       <span class=comment>// 唯一ID（如doc_1_chapter_1）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> parentChapterId; <span class=comment>// 父章节ID（顶级章为null）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> title;           <span class=comment>// 章节标题（如“1.1 人工智能发展历程”）</span></span><br><span class=line>    <span class=keyword>private</span> Long startPos;          <span class=comment>// 文本起始位置（用于溯源）</span></span><br><span class=line>    <span class=keyword>private</span> Long endPos;            <span class=comment>// 文本结束位置</span></span><br><span class=line>    <span class=keyword>private</span> List<<span class=keyword>String</span>> paragraphIds; <span class=comment>// 子段落ID列表（初始为空）</span></span><br><span class=line>}</span><br></pre></table></figure><ul><li>关联逻辑：将 “标题后→下一个标题前” 的所有正文，绑定为该章节的 “待分片段落内容”。</ul><h3 id=步骤-2：段落级分片（树的「中间节点」）><a title="步骤 2：段落级分片（树的「中间节点」）" class=headerlink href=#步骤-2：段落级分片（树的「中间节点」）></a>步骤 2：段落级分片（树的「中间节点」）</h3><p>目标：拆分章节下的正文为段落，核心是 “格式边界 + 语义边界” 双判定。<h4 id=1-段落边界判定规则><a title="1. 段落边界判定规则" class=headerlink href=#1-段落边界判定规则></a>1. 段落边界判定规则</h4><p>表格<div class=table-container><table><thead><tr><th style=text-align:center>规则类型<th style=text-align:center>具体逻辑<tbody><tr><td style=text-align:center>格式边界（优先）<td style=text-align:center>Word 段落标记、PDF 文本块分隔、Markdown/TXT 空行（连续≥1 个换行）；<tr><td style=text-align:center>语义边界（补充）<td style=text-align:center>无格式分隔时，按 “连续文本 + 换行 + 非缩进文本” 判定段落结束；用 HanLP/LTP 的「分词 + 依存句法分析」，确保段落语义完整；</table></div><h4 id=2-段落节点生成><a title="2. 段落节点生成" class=headerlink href=#2-段落节点生成></a>2. 段落节点生成</h4><p>遍历章节下的正文，拆分段落并关联到父章节，结构示例：<figure class="highlight arduino"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 段落节点核心结构</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>ParagraphNode</span> {</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> paragraphId;    <span class=comment>// 唯一ID（如doc_1_chapter_1_para_1）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> chapterId;      <span class=comment>// 父章节ID（关联顶层）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> text;           <span class=comment>// 段落文本</span></span><br><span class=line>    <span class=keyword>private</span> List<<span class=keyword>String</span>> sentenceIds; <span class=comment>// 子句子ID列表（初始为空）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> prevParaId;     <span class=comment>// 前一段落ID（上下文回溯）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> nextParaId;     <span class=comment>// 后一段落ID</span></span><br><span class=line>}</span><br></pre></table></figure><h3 id=步骤-3：句子级分片（树的「叶子节点」，最小向量单元）><a title="步骤 3：句子级分片（树的「叶子节点」，最小向量单元）" class=headerlink href=#步骤-3：句子级分片（树的「叶子节点」，最小向量单元）></a>步骤 3：句子级分片（树的「叶子节点」，最小向量单元）</h3><p>目标：拆分段落为句子（最小语义单元），核心是 “句终结符 + 语义完整性校正”。<h4 id=1-句子边界判定规则（避免语义割裂）><a title="1. 句子边界判定规则（避免语义割裂）" class=headerlink href=#1-句子边界判定规则（避免语义割裂）></a>1. 句子边界判定规则（避免语义割裂）</h4><div class=table-container><table><thead><tr><th style=text-align:center>基础规则<th style=text-align:center>具体逻辑<tbody><tr><td style=text-align:center>句终结符<td style=text-align:center>中文：<code>。！？；</code>；英文：<code>. ! ?</code>；特殊处理：省略号<code>……</code>、引号内句子不拆分；<tr><td style=text-align:center>语义校正规则<td style=text-align:center>- 用 HanLP 的「句法分析」检查：如 “因为 A，所以 B。” 不能拆分为 “因为 A，” 和 “所以 B。”；- 过滤无意义短句（如仅 “注：”“补充：”）；- 对话拆分：“小明：你好！小红：再见！”→拆为 2 个句子；</table></div><h4 id=2-句子节点生成（最小向量单元）><a title="2. 句子节点生成（最小向量单元）" class=headerlink href=#2-句子节点生成（最小向量单元）></a>2. 句子节点生成（最小向量单元）</h4><p>遍历段落文本，拆分句子并关联到父段落，结构示例：<figure class="highlight arduino"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment>// 句子节点核心结构（最小向量单元）</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>SentenceNode</span> {</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> sentenceId;     <span class=comment>// 唯一ID（如doc_1_chapter_1_para_1_sent_1）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> paragraphId;    <span class=comment>// 父段落ID（关联中间层）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> chapterId;      <span class=comment>// 父章节ID（跨层关联）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> text;           <span class=comment>// 句子文本（完整语义）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>float</span>[] vector;        <span class=comment>// 句子向量（后续嵌入生成）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> prevSentId;     <span class=comment>// 前一句子ID（上下文回溯）</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>String</span> nextSentId;     <span class=comment>// 后一句子ID</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=难点-1：常规硬切片导致的语义链断裂><a title="难点 1：常规硬切片导致的语义链断裂" class=headerlink href=#难点-1：常规硬切片导致的语义链断裂></a>难点 1：常规硬切片导致的语义链断裂</h4><ul><li>核心痛点：传统硬切片（按固定字符数 / 行数切分）会割裂完整语义单元，比如一个因果句 “因为 A 技术高并发，所以 B 场景选 A” 被拆成两段，检索 “B 场景选 A 的原因” 时，仅能匹配到后半段，丢失 “高并发” 核心语义，导致问答结果缺失关键信息。<li>解决方案：<ol><li>层级化语义拆分：放弃无意义硬切片，基于文档原生结构（章标题、段分隔符、句终结符「。！？」）构建 “章 - 段 - 句” 层级树，确保每个层级都贴合自然语义边界；<li>最小语义单元锁定：以 “句子” 为最小向量单元生成嵌入向量，保证单个向量承载完整语义（如上述因果句作为一个向量单元），从底层避免语义链断裂；<li>上下文关联存储：每个句子向量额外存储「父节点（段落 ID / 章节 ID）+ 前后句 ID」元数据，即使检索到单个句子，也能快速回溯到所属段落 / 章节，补充完整语义链。</ol></ul><h4 id=长文档问答的信息碎片化><a class=headerlink href=#长文档问答的信息碎片化 title=长文档问答的信息碎片化></a>长文档问答的信息碎片化</h4><ul><li><p>核心痛点：长文档按句子级细粒度检索时，能精准匹配到相关句子，但结果是孤立的 “信息碎片”，无法整合出有逻辑的完整答案；若按章节级粗粒度检索，召回范围过宽，精准度极低。</p><li><p>解决方案（父子索引策略）：</p> <ol><li><p>索引分层设计：</p> <ul><li>子索引（细粒度）：存储句子级向量 + 语义元数据，负责 “细粒度检索”—— 精准定位用户问题对应的核心句子；<li>父索引（宽粒度）：对段落 / 章节内所有句子向量做均值 / 加权聚合，生成段落 / 章节级聚合向量，负责 “宽粒度召回”—— 召回核心句子所属的完整段落 / 章节；</ul><li><p>检索协作流程</p> <p>：① 用户提问→子索引检索 Top-N 相似句子→获取句子所属段落 / 章节 ID；</p> <p>② 基于章节 ID 在父索引中召回完整段落 / 章节内容（宽粒度）；</p> <p>③ 以宽粒度内容为上下文，整合细粒度句子，生成完整问答答案，解决信息碎片化；</p><li><p>权重调优：父索引召回时，基于子索引匹配句子的相似度权重对父节点排序，优先召回核心句子所属的父节点，保证宽粒度内容与问题强相关。</p></ol></ul><h4 id=多格式文档的层级树构建精准性><a class=headerlink href=#多格式文档的层级树构建精准性 title=多格式文档的层级树构建精准性></a>多格式文档的层级树构建精准性</h4><ul><li><p>核心痛点：PDF（无显性段落标记）、Word（样式层级）、Markdown（# 标识）等不同格式文档的 “章 - 段 - 句” 边界差异大，导致层级拆分不精准；长文档层级树节点过多，索引构建 / 检索效率低。</p><li><p>解决方案</p> <ol><li><p>多格式结构化解析</p> <p>：PDF：通过文本块 + 行距分析识别段落，结合 OCR 处理图片文本后再拆分句子；</p> <ul><li>Word：解析样式层级（标题 1→章、标题 2→节、正文→段），按样式拆分层级；<li>Markdown：通过 #/##/### 识别章节，按换行符拆分段落；<li>引入 NLP 工具（HanLP/Jieba）做句法分析，校正拆分错误（如省略号误判为句终结符）；</ul><li><p>层级树轻量化</p> <p>：过滤页眉页脚、免责声明等无意义节点，对超长章节（万字以上）在 “段” 层级做二次语义拆分（保证段落语义完整），减少节点数量；</p><li><p>增量索引更新</p> <p>：记录各层级节点的修改时间戳，仅对更新的章 / 段 / 句重新生成向量并更新索引，而非全量重建。</p></ol></ul><h4 id=细粒度检索-宽粒度召回的效率平衡><a title="细粒度检索 + 宽粒度召回的效率平衡" class=headerlink href=#细粒度检索-宽粒度召回的效率平衡></a>细粒度检索 + 宽粒度召回的效率平衡</h4><ul><li><p>核心痛点：句子级检索需遍历大量向量，章节级召回需关联父节点，双重检索导致延迟升高；向量数据库性能随数据量增长下降。</p><li><p>解决方案：</p> <ol><li><p>预关联映射表：</p> <p>提前构建「句子 ID→段落 ID→章节 ID」映射表，存储在向量数据库元数据中，检索时无需额外查询，直接关联父节点；</p><li><p>向量数据库分层优化：</p> <ul><li>选型：用 Milvus（支持分区）按章节分区存储父 / 子索引；<li>索引类型：子索引用 IVF_FLAT（保证精度），父索引用 HNSW（提升速度）；</ul><li><p>结果截断与缓存</p> <p>：细粒度检索仅返回 Top-10 相似句子，减少关联父节点的开销；对高频查询的章节向量做缓存，降低重复检索成本。</p></ol></ul><h1 id=知识库检索><a class=headerlink href=#知识库检索 title=知识库检索></a>知识库检索</h1><p>构建基于 Elasticsearch 的 RAG 检索流⽔线，通过集成 KNN 向量检索与 BM25 关键词匹配实现多路召回， 并引⼊ Cross-Encoder 重排模型以优化语义对⻬精度，在平衡系统响应性能的同时将垂直领域问答准确率提 升25% 以上。<h4 id=什么选择-KNN-BM25-多路召回，而非单一检索方式？><a title="什么选择 KNN+BM25 多路召回，而非单一检索方式？" class=headerlink href=#什么选择-KNN-BM25-多路召回，而非单一检索方式？></a>什么选择 KNN+BM25 多路召回，而非单一检索方式？</h4><p><strong>回答思路</strong>（对比单一方式的痛点，突出互补性）：<p>垂直领域（比如金融/医疗）的问答有两个核心诉求：精准匹配专业术语 + 语义理解上下文，单一方式无法兼顾：<ul><li>仅用BM25：依赖关键词匹配，容易出现“词不达意”（比如用户问“糖尿病血糖控制”，BM25可能漏检含“降糖”但无“血糖控制”的语料），语义召回率低；<li>仅用KNN向量检索：对专业术语的精准匹配弱（比如“重疾险”和“重大疾病保险”向量相似但关键词完全不同时，可能漏检），且向量检索性能成本更高；<li>多路召回：BM25保证“关键词精准性”，KNN保证“语义相关性”，两者互补覆盖更多候选结果，为后续重排提供足够的优质样本。</ul><h4 id=Cross-Encoder-重排的作用是什么？和-Bi-Encoder-的区别？为什么选它？><a title="Cross-Encoder 重排的作用是什么？和 Bi-Encoder 的区别？为什么选它？" class=headerlink href=#Cross-Encoder-重排的作用是什么？和-Bi-Encoder-的区别？为什么选它？></a>Cross-Encoder 重排的作用是什么？和 Bi-Encoder 的区别？为什么选它？</h4><p>作用：解决多路召回结果中“语义匹配精度低”的问题——<strong>召回阶段为了兼顾召回率会返回较多候选，但部分候选和问题的语义匹配度低，Cross-Encoder通过“问题+候选文本”的成对打分</strong>，精准排序出最相关的结果。<p>与Bi-Encoder的区别： - Bi-Encoder：单文本编码（问题/候选分别编码），速度快但精度低（编码时无交互），适合召回阶段； - Cross-Encoder：成对编码（问题和候选拼接后编码），精度高但速度慢（无法预编码），适合重排阶段； 3. 选择原因：垂直领域对问答准确率要求高，且召回后候选集已压缩到100条内，Cross-Encoder的性能损耗可控，能显著提升语义对齐精度。<h4 id=在-ES-中是如何实现-KNN-向量检索的？用到了哪些-ES-特性？><a title="在 ES 中是如何实现 KNN 向量检索的？用到了哪些 ES 特性？" class=headerlink href=#在-ES-中是如何实现-KNN-向量检索的？用到了哪些-ES-特性？></a>在 ES 中是如何实现 KNN 向量检索的？用到了哪些 ES 特性？</h4><p><strong>回答思路</strong>（结合 ES 版本 / 索引类型 / 参数，体现实操）：<p>我们用的是ES 8.x版本（原生支持dense_vector和KNN），核心实现细节：<ol><li>向量字段定义：创建索引时指定dense_vector类型，参数设置：<br>“vector”: {<br> “type”: “dense_vector”,<br> “dims”: 768, // 与Bi-Encoder输出维度一致<br> “index”: true,<br> “similarity”: “cosine” // 垂直领域语义匹配用余弦相似度更合适<br>}<li>向量索引类型：选择HNSW（Hierarchical Navigable Small Worlds），相比brute-force暴力检索，HNSW在召回率（>95%）和性能（QPS提升3倍）间更平衡，关键参数调优：<ul><li>m: 16（邻接节点数，平衡召回率/内存）；<li>ef_construction: 100（构建索引时的探索深度）；<li>ef_search: 50（检索时的探索深度）；</ul><li>检索语法：用ES的knn查询子句，指定字段、查询向量、k值（top100），和BM25查询通过bool should子句实现多路召回。</ol><h4 id=多路召回的结果是如何合并-去重的？有没有做权重调整？><a title="多路召回的结果是如何合并 / 去重的？有没有做权重调整？" class=headerlink href=#多路召回的结果是如何合并-去重的？有没有做权重调整？></a>多路召回的结果是如何合并 / 去重的？有没有做权重调整？</h4><p>合并逻辑分三步： 1. 去重：基于chunk的唯一ID去重（离线处理时为每个chunk生成唯一ID），避免同一语料被BM25和KNN同时召回； 2. 初步排序：给两路召回结果赋初始权重（BM25得分<em>0.4 + KNN相似度</em>0.6），先做一次粗排（<strong>垂直领域语义更重要，所以KNN权重更高</strong>）； 3. 截断：保留top100候选（既保证召回率，又控制后续Cross-Encoder的计算成本）； 补充：权重比例是通过离线实验调优的——测试了0.3:0.7、0.4:0.6、0.5:0.5三组比例，最终0.4:0.6在召回率（>90%）和准确率上最优。<h4 id=Cross-Encoder-重排是如何集成到流程中的？如何平衡性能？><a title="Cross-Encoder 重排是如何集成到流程中的？如何平衡性能？" class=headerlink href=#Cross-Encoder-重排是如何集成到流程中的？如何平衡性能？></a>Cross-Encoder 重排是如何集成到流程中的？如何平衡性能？</h4><p>集成方式（微服务架构）： - 检索层（ES）返回top100候选后，调用“重排服务”（基于FastAPI封装Cross-Encoder）； - 重排服务输入：用户问题 + 100条候选chunk；输出：按Cross-Encoder打分降序的top10 chunk； - 重排服务做了模型量化（INT8），部署在GPU上（batch推理），单条推理耗时从20ms降到5ms；<p>2性能平衡的关键优化： - 候选集截断：仅对召回的top100做重排，而非全量； - 模型轻量化：选用轻量版Cross-Encoder（如cross-encoder/ms-marco-MiniLM-L-6-v2），而非大模型； - 缓存：对高频问题（比如Top1000常见问题）的检索+重排结果做缓存（Redis），命中率约30%，整体响应时间从500ms降到200ms内。<h4 id=准确率提升-25-”-是如何量化的？对比的基线是什么？><a title="准确率提升 25%” 是如何量化的？对比的基线是什么？" class=headerlink href=#准确率提升-25-”-是如何量化的？对比的基线是什么？></a>准确率提升 25%” 是如何量化的？对比的基线是什么？</h4><p>1.评测数据集：构建了垂直领域（比如医疗）的评测集，包含1000个真实用户问题 + 人工标注的“标准答案chunk”（每个问题对应3-5个核心chunk）；<ol><li>核心指标： - 检索准确率（Recall@10）：检索结果中包含至少1个标准答案chunk的比例（核心指标，因为RAG的关键是召回正确语料）； - 问答准确率：人工评估大模型生成回答与标准答案的匹配度（分为精准/部分/错误三档）；<li><ol><li>对比基线：仅用BM25检索的RAG流程； 4. 结果： - 基线：检索Recall@10=60%，问答准确率=65%； - 优化后：检索Recall@10=82%，问答准确率=81%（提升24.6%，约25%）； - 同时，通过缓存/模型量化，系统响应时间控制在200ms内（满足线上要求的300ms阈值）。</ol></ol><h4 id=KNN-向量检索的性能瓶颈是什么？你是如何优化的？><a title="KNN 向量检索的性能瓶颈是什么？你是如何优化的？" class=headerlink href=#KNN-向量检索的性能瓶颈是什么？你是如何优化的？></a>KNN 向量检索的性能瓶颈是什么？你是如何优化的？</h4><p>落地初期的瓶颈： 1. 向量索引构建耗时久（百万级chunk构建需数小时）；<ol><li><p>在线检索QPS低（单节点QPS仅50），延迟高（平均300ms）； 优化手段： 1. 索引层面： - 向量维度优化：从1024维降到768维（通过领域微调验证，召回率仅下降1%，检索速度提升20%）；</p><li><p>ES集群调优：增加分片数（按数据量设8分片），副本数1（兼顾高可用和检索性能），关闭刷新间隔（离线构建索引时）；</p> <p>工程层面： - 批量编码：离线语料向量化时用batch_size=64批量处理，提升编码效率； - 预热：上线前预热ES索引（提前查询），避免冷启动时的磁盘IO瓶颈； 最终：索引构建时间降到1小时内，在线检索QPS提升到200+，延迟降到80ms内。</p></ol><h4 id=落地过程中最大的挑战是什么？如何解决的？><a class=headerlink href=#落地过程中最大的挑战是什么？如何解决的？ title=落地过程中最大的挑战是什么？如何解决的？></a>落地过程中最大的挑战是什么？如何解决的？</h4><p>最大挑战：Cross-Encoder重排后准确率提升，但系统响应时间从150ms涨到500ms，超出线上300ms的阈值。 分析过程：<p>拆解耗时：ES检索80ms + Cross-Encoder重排350ms + 大模型推理70ms → 重排是核心瓶颈； - 根因：用了全量Cross-Encoder（bert-base），单条推理20ms，100条候选就是2000ms（批量后仍350ms）；<p>解决措施： 1. 模型轻量化：替换为MiniLM-L6版Cross-Encoder，推理耗时从20ms/条降到5ms/条；<ol><li>候选集再压缩：基于“BM25+KNN”的粗排得分，将候选集从100条降到50条（验证召回率仅下降2%）；<li>缓存高频问题：对Top1000高频问题的检索+重排结果缓存，命中率30%； 最终结果：重排耗时降到80ms，整体响应时间控制在200ms内，同时问答准确率仍保持提升25%的效果。</ol><h4 id=向量检索和-BM25-的结果冲突时（比如-KNN-认为相关，BM25-认为不相关），如何处理？><a title="向量检索和 BM25 的结果冲突时（比如 KNN 认为相关，BM25 认为不相关），如何处理？" class=headerlink href=#向量检索和-BM25-的结果冲突时（比如-KNN-认为相关，BM25-认为不相关），如何处理？></a>向量检索和 BM25 的结果冲突时（比如 KNN 认为相关，BM25 认为不相关），如何处理？</h4><p>做了“场景化权重调整+人工规则兜底”：<ol><li>基础规则：对含专业术语的问题（通过实体识别判断），提升BM25权重（比如0.5:0.5），保证术语精准匹配；对泛语义问题（比如“如何缓解高血压头晕”），提升KNN权重（0.3:0.7）；<li>冲突过滤：如果某条候选在KNN中排前20，但BM25得分是0（完全无关键词匹配），或反之，会标记为“冲突候选”，仅保留前50%的冲突候选，避免低质量结果进入重排；<li>离线验证：定期分析冲突案例，迭代调整权重和规则（比如新增“实体匹配加分”规则），逐步降低冲突率（从15%降到5%）。</ol><h1 id=聊天助手Agent><a class=headerlink href=#聊天助手Agent title=聊天助手Agent></a>聊天助手Agent</h1><p>构建基于 Elasticsearch 的 RAG 检索流⽔线，通过集成 KNN 向量检索与 BM25 关键词匹配实现多路召回， 并引⼊ Cross-Encoder 重排模型以优化语义对⻬精度，在平衡系统响应性能的同时将垂直领域问答准确率提 升25% 以上。<p>设计基于 LLM 的⾃适应检索模块，通过指代消解与语义扩展优化⾸轮意图识别；针对重排分数低于阈值的场 景，触发查询重写与回退机制，提升检索召回质量。同时集成⻆⾊与组织标签实现精细化权限管控，确保数据 隔离安全。<h4 id=你设计的基于-LLM-的自适应检索模块整体架构是怎样的？核心流程是什么？><a title="你设计的基于 LLM 的自适应检索模块整体架构是怎样的？核心流程是什么？" class=headerlink href=#你设计的基于-LLM-的自适应检索模块整体架构是怎样的？核心流程是什么？></a>你设计的基于 LLM 的自适应检索模块整体架构是怎样的？核心流程是什么？</h4><p><strong>核心回答</strong>：<p>整体架构采用「<strong>意图理解层→检索召回层→重排过滤层→自适应优化层→权限管控层</strong>」的分层设计，核心流程如下：<ol><li><strong>首轮输入处理</strong>：用户查询进入后，先通过 LLM 完成「指代消解 + 语义扩展」，解决 “他 / 这个功能 / 上周的报表” 等指代模糊问题，同时扩展核心语义（如 “查销售数据” 扩展为 “查询 2024 年 Q2 华东区销售业绩报表 + 销售额 + 环比数据”）；<li><strong>基础检索</strong>：将优化后的查询送入向量库 + 关键词检索引擎，获取初始召回结果；<li><strong>重排评分</strong>：通过 Cross-BERT 等模型对召回结果重排，输出重排分数；<li><strong>自适应决策</strong>：若重排分数≥阈值，直接返回结果 + 权限过滤；若＜阈值，触发「LLM 查询重写」生成 2~3 个改写查询，并行召回后再重排，若仍不达标则触发回退机制（降级为基础关键词检索 + 人工标注结果兜底）；<li><strong>权限管控</strong>：全流程嵌入角色 / 组织标签过滤，检索前过滤用户无权限的数据源，检索后过滤结果中敏感数据，最终返回符合权限的结果。</ol><p><strong>补充细节</strong>：模块采用 “LLM + 传统检索” 混合架构，既利用 LLM 的语义理解能力，又保留传统检索的高效性，同时通过「规则 + LLM」双校验保证意图识别的稳定性。<h4 id=问题-2：指代消解和语义扩展具体是怎么做的？如何落地到首轮意图识别中？><a title="问题 2：指代消解和语义扩展具体是怎么做的？如何落地到首轮意图识别中？" class=headerlink href=#问题-2：指代消解和语义扩展具体是怎么做的？如何落地到首轮意图识别中？></a>问题 2：指代消解和语义扩展具体是怎么做的？如何落地到首轮意图识别中？</h4><p><strong>核心回答</strong>：<h5 id=（1）指代消解（解决首轮查询的模糊指代问题）><a class=headerlink href=#（1）指代消解（解决首轮查询的模糊指代问题） title=（1）指代消解（解决首轮查询的模糊指代问题）></a>（1）指代消解（解决首轮查询的模糊指代问题）</h5><ul><li><p>技术方案：采用「规则兜底 + LLM 精准消解」的混合策略：</p> <ul><li><p>规则层：基于依存句法分析（如 HanLP/LTP）识别代词（他 / 它 / 该 / 此）、省略成分，匹配上下文 / 领域词典（如 “报表” 关联 “销售报表 / 财务报表”）；</p><li><p>LLM 层：设计专属 prompt，输入 “用户查询 + 对话上下文（若有）+ 领域实体库”，指令 LLM 输出 “消解后的完整查询 + 指代映射关系”，示例 prompt：</p> <figure class="highlight armasm"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>任务：消解查询中的指代成分，输出完整无歧义的查询。</span><br><span class=line>输入：用户查询=“把它发给我”，上下文=“用户此前询问<span class=number>2024</span>年<span class=built_in>Q2</span>销售报表”，领域实体库=[销售报表、财务报表、华东区业绩]</span><br><span class=line>输出要求：完整查询+指代映射（如：完整查询=把<span class=number>2024</span>年<span class=built_in>Q2</span>销售报表发给我；指代映射=它→<span class=number>2024</span>年<span class=built_in>Q2</span>销售报表）</span><br></pre></table></figure></ul><li><p>落地：首轮查询先过规则消解，若消解置信度＜0.8，触发 LLM 消解，确保意图无歧义。</p></ul><h5 id=（2）语义扩展（解决首轮查询语义单薄问题）><a class=headerlink href=#（2）语义扩展（解决首轮查询语义单薄问题） title=（2）语义扩展（解决首轮查询语义单薄问题）></a>（2）语义扩展（解决首轮查询语义单薄问题）</h5><ul><li><p>技术方案：「静态扩展 + LLM 动态扩展」结合：</p> <ul><li><p>静态扩展：基于行业词库（如同义词林、上下位词库）扩展核心词（如 “查数据”→“查询 / 统计 / 导出 数据 / 报表 / 明细”）；</p><li><p>LLM 动态扩展：输入消解后的查询，指令 LLM 生成 “用户可能想表达的 3 个相关查询”（避免过度扩展），示例：</p> <figure class="highlight armasm"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>输入：查询=“查询<span class=number>2024</span>年<span class=built_in>Q2</span>华东区销售数据”</span><br><span class=line>输出：</span><br><span class=line><span class=number>1</span>. 查询<span class=number>2024</span>年<span class=built_in>Q2</span>华东区销售额及环比增长率</span><br><span class=line><span class=number>2</span>. 导出<span class=number>2024</span>年<span class=built_in>Q2</span>华东区各省份销售明细报表</span><br><span class=line><span class=number>3</span>. 统计<span class=number>2024</span>年<span class=built_in>Q2</span>华东区销售数据与<span class=built_in>Q1</span>的对比</span><br></pre></table></figure></ul></ul><ul><li>落地：将扩展后的语义融入检索查询向量，提升首轮召回的覆盖率。</ul><h4 id=问题-3：重排分数低于阈值时的查询重写和回退机制具体如何设计？><a title="问题 3：重排分数低于阈值时的查询重写和回退机制具体如何设计？" class=headerlink href=#问题-3：重排分数低于阈值时的查询重写和回退机制具体如何设计？></a>问题 3：重排分数低于阈值时的查询重写和回退机制具体如何设计？</h4><p><strong>核心回答</strong>：<h5 id=（1）查询重写机制（核心是-“精准改写-多策略备选”）><a title="（1）查询重写机制（核心是 “精准改写 + 多策略备选”）" class=headerlink href=#（1）查询重写机制（核心是-“精准改写-多策略备选”）></a>（1）查询重写机制（核心是 “精准改写 + 多策略备选”）</h5><ul><li><p>触发条件：重排分数＜预设阈值（如 0.7，基于业务场景离线标定）；</p><li><p>改写策略：</p> <p>① 历史对话融合：LLM 结合多轮对话上下文，补充查询中缺失的上下文信息（如用户仅说 “再查一次”，改写为 “查询 2024 年 Q2 华东区销售数据并导出 Excel”）；</p> <p>② 关键词强化：提取原查询核心词，LLM 补充领域限定词（如 “查报表”→“查询 2024 年 Q2 华东区销售业绩报表”）；</p> <p>③ 句式转换：将口语化查询转为检索友好型（如 “为啥销售数据低”→“查询 2024 年 Q2 华东区销售数据偏低的原因”）；</p><li><p>执行逻辑：LLM 生成 2~3 个改写查询，并行送入检索引擎，取各改写查询召回结果的并集，再统一重排。</p></ul><h5 id=（2）回退机制（保证服务兜底能力）><a class=headerlink href=#（2）回退机制（保证服务兜底能力） title=（2）回退机制（保证服务兜底能力）></a>（2）回退机制（保证服务兜底能力）</h5><ul><li><p>触发条件：查询重写后的重排分数仍＜阈值；</p><li><p>回退策略：</p> <p>① 降级为 “关键词精准检索”：仅保留原查询核心词（去除扩展词），避免过度泛化；</p> <p>② 兜底到人工标注结果：调取该类查询的人工标注高频结果，补充到召回列表；</p> <p>③ 反馈提示：返回结果时附带 “是否想查询 XXX？” 的引导式提示，引导用户明确意图。</p></ul><h4 id=问题-4：LLM-改写引入的耗时增加，你是怎么优化的？><a title="问题 4：LLM 改写引入的耗时增加，你是怎么优化的？" class=headerlink href=#问题-4：LLM-改写引入的耗时增加，你是怎么优化的？></a>问题 4：LLM 改写引入的耗时增加，你是怎么优化的？</h4><p><strong>核心回答</strong>：<p>针对 LLM 改写带来的耗时（单轮 LLM 调用约 200~500ms），从「<strong>链路优化、资源优化、策略优化</strong>」三个维度解决：<ol><li><p><strong>链路优化：异步 + 缓存 + 并行</strong></p> <ul><li>异步处理：将 LLM 改写与基础检索并行执行（基础检索约 50ms），若基础检索重排分数达标，直接终止 LLM 改写流程；<li>缓存策略：对高频查询 / 改写结果做两级缓存（本地缓存 + Redis），缓存 Key 为 “用户查询 + 角色标签”，缓存有效期 1 小时（按业务更新频率调整），命中率可达 60%+，直接跳过 LLM 改写；<li>批量改写：将多个低分数查询打包，一次性发送给 LLM，减少调用次数（如每 100ms 批量一次，耗时摊薄至单查询 50ms 内）。</ul><li><p><strong>资源优化：LLM 轻量化 + 部署优化</strong></p> <ul><li>模型选型：首轮意图识别 / 指代消解用轻量开源模型（如 ChatGLM-6B、Qwen-7B），部署为量化版（4bit/8bit），推理耗时从 500ms 降至 150ms；<li>部署架构：LLM 服务采用 “主从架构”，主模型处理复杂改写，从模型处理简单指代消解，负载均衡分流。</ul><li><p><strong>策略优化：动态阈值 + 分级改写</strong></p> <ul><li>动态阈值：基于用户场景（如普通用户阈值 0.7，管理员阈值 0.6）、查询类型（如简单查询阈值 0.8，复杂查询阈值 0.6）动态调整，减少不必要的改写触发；<li>分级改写：简单查询用规则改写（耗时＜10ms），仅复杂查询触发 LLM 改写，降低 LLM 调用占比。</ul></ol><p><strong>效果</strong>：优化后整体检索链路耗时从平均 800ms 降至 200ms 内，满足线上服务 P99＜500ms 的要求。<h4 id=问题-5：角色与组织标签如何集成到检索模块，实现精细化权限管控和数据隔离？><a title="问题 5：角色与组织标签如何集成到检索模块，实现精细化权限管控和数据隔离？" class=headerlink href=#问题-5：角色与组织标签如何集成到检索模块，实现精细化权限管控和数据隔离？></a>问题 5：角色与组织标签如何集成到检索模块，实现精细化权限管控和数据隔离？</h4><p><strong>核心回答</strong>：<p>采用「<strong>标签打标 + 全流程过滤</strong>」的方案，确保 “数据能检索到的前提是用户有权限”，核心流程：<ol><li><p><strong>标签体系设计</strong>：</p> <ul><li>维度：角色标签（普通用户 / 管理员 / 财务）+ 组织标签（华东区 / 华北区 / 总部）+ 数据标签（公开 / 部门级 / 公司级）；<li>打标方式：数据源入库时，通过 LLM + 规则自动打标（如 “华东区销售数据” 打标：组织 = 华东区、数据级别 = 部门级），人工审核兜底。</ul><li><p><strong>全流程权限过滤</strong>：</p> <ul><li>检索前过滤：用户发起查询时，先解析用户的角色 / 组织标签，生成 “权限过滤条件”（如华东区普通用户→仅能检索 “组织 = 华东区 + 数据级别≤部门级” 的数据源），过滤掉无权限的数据源，减少检索范围；<li>检索后过滤：对召回结果做二次校验，LLM 识别结果中的敏感数据（如跨组织数据），自动屏蔽 / 脱敏；<li>权限缓存：将用户权限标签缓存至本地，避免每次检索都查询权限系统，提升效率。</ul><li><p><strong>安全兜底</strong>：</p> <ul><li>审计日志：记录用户检索的数据源、结果、权限匹配情况，便于追溯；<li>熔断机制：若权限服务异常，直接返回 “权限验证失败”，避免数据泄露。</ul></ol><h4 id=问题-6：自适应检索模块如何支撑多轮对话场景？><a title="问题 6：自适应检索模块如何支撑多轮对话场景？" class=headerlink href=#问题-6：自适应检索模块如何支撑多轮对话场景？></a>问题 6：自适应检索模块如何支撑多轮对话场景？</h4><p><strong>核心回答</strong>：<p>多轮对话的核心是 “上下文有效融合 + 意图漂移修正”，模块通过 3 个关键点支撑：<ol><li><strong>上下文管理</strong>：维护「用户会话上下文窗口」（最多保留最近 5 轮对话），并通过 LLM 做上下文摘要（避免窗口过长），摘要内容包含 “核心意图 + 已获取信息 + 待解决问题”；<li><strong>多轮指代消解</strong>：首轮消解的基础上，每轮对话都将 “当前查询 + 上下文摘要” 送入 LLM，消解跨轮指代（如用户第 3 轮说 “它的环比呢？”，消解为 “2024 年 Q2 华东区销售数据的环比增长率呢？”）；<li><strong>意图漂移修正</strong>：若 LLM 检测到用户意图漂移（如从 “查销售数据” 变为 “查成本数据”），则重置检索策略（重新语义扩展 + 检索）；若意图未漂移（仅补充信息），则复用历史检索结果，仅做局部改写。</ol><h4 id=问题-7：怎么衡量这个模块的优化效果？有哪些核心指标？><a title="问题 7：怎么衡量这个模块的优化效果？有哪些核心指标？" class=headerlink href=#问题-7：怎么衡量这个模块的优化效果？有哪些核心指标？></a>问题 7：怎么衡量这个模块的优化效果？有哪些核心指标？</h4><p><strong>核心回答</strong>：<p>从「效果 + 性能 + 体验」三个维度设计指标，核心指标及优化效果如下：<div class=table-container><table><thead><tr><th style=text-align:center>维度<th style=text-align:center>核心指标<th style=text-align:center>优化前<th style=text-align:center>优化后<tbody><tr><td style=text-align:center>效果<td style=text-align:center>首轮意图识别准确率<td style=text-align:center>75%<td style=text-align:center>92%<tr><td style=text-align:center><td style=text-align:center>检索召回率（Top20）<td style=text-align:center>68%<td style=text-align:center>85%<tr><td style=text-align:center><td style=text-align:center>重排分数达标率<td style=text-align:center>70%<td style=text-align:center>88%<tr><td style=text-align:center>性能<td style=text-align:center>检索链路平均耗时<td style=text-align:center>800ms<td style=text-align:center>200ms<tr><td style=text-align:center><td style=text-align:center>LLM 调用占比<td style=text-align:center>100%<td style=text-align:center>40%<tr><td style=text-align:center>体验<td style=text-align:center>用户二次提问率<td style=text-align:center>35%<td style=text-align:center>12%<tr><td style=text-align:center><td style=text-align:center>权限违规访问拦截率<td style=text-align:center>90%<td style=text-align:center>100%</table></div><p><strong>补充</strong>：通过 A/B 测试验证效果，实验组为 “自适应检索模块”，对照组为 “传统检索”，持续监控指标并迭代阈值 / 改写策略。<h3 id=二、核心难点及解决方案><a class=headerlink href=#二、核心难点及解决方案 title=二、核心难点及解决方案></a>二、核心难点及解决方案</h3><div class=table-container><table><thead><tr><th style=text-align:center>核心难点<th style=text-align:center>具体解决方案<tbody><tr><td style=text-align:center>1. 首轮意图识别的准确性（指代消解歧义、语义扩展过度 / 不足）<td style=text-align:center>① 规则 + LLM 双校验指代消解，设置消解置信度阈值；② 语义扩展限制数量（3 个以内），结合领域词库避免过度扩展；③ 离线标注意图样本，微调 LLM 提升行业适配性<tr><td style=text-align:center>2. LLM 改写的耗时与召回质量平衡<td style=text-align:center>① 异步并行执行 LLM 改写与基础检索；② 高频查询缓存改写结果；③ 轻量 LLM 模型 + 批量调用降低耗时；④ 动态阈值减少不必要改写<tr><td style=text-align:center>3. 多轮对话上下文融合（意图漂移、上下文冗余）<td style=text-align:center>① 上下文摘要压缩窗口长度；② LLM 检测意图漂移并重置检索策略；③ 跨轮指代消解结合上下文摘要，保证意图连贯<tr><td style=text-align:center>4. 细粒度权限管控与检索性能的平衡<td style=text-align:center>① 检索前过滤无权限数据源，减少检索范围；② 缓存用户权限标签，避免重复查询；③ 规则 + 轻量化 LLM 做检索后过滤，替代全量 LLM 校验<tr><td style=text-align:center>5. LLM 服务抖动 / 失败对检索链路的稳定性影响<td style=text-align:center>① 设计降级策略：LLM 服务异常时，自动切换为 “规则改写 + 传统检索”；② 多 LLM 实例容灾，主实例故障自动切从实例；③ 超时控制（LLM 调用超时 100ms 则终止）<tr><td style=text-align:center>6. 查询重写的有效性（改写后召回结果仍不达标的情况）<td style=text-align:center>① 离线构建改写模板库，LLM 基于模板生成改写查询；② 对改写结果做 “有效性预校验”（匹配核心词 / 领域词），无效则重新改写；③ 回退机制兜底，保证基础召回能力</table></div><h3><a title=" " class=headerlink href=#></a></h3><h2 id=统一多源文档格式><a class=headerlink href=#统一多源文档格式 title=统一多源文档格式></a>统一多源文档格式</h2><p>票据,扫描件,手写,文件里的嵌入表格和数学公式<p><strong>Word文件</strong><p>文档格式.doc,docx,是Word文档的OPen XML格式.<p>块的分布 块与块之间的关系<p><img alt=image-20260113144028000 data-src=https://s2.loli.net/2026/01/13/OxiwCam8R5HzroU.png style=zoom:67%;><p><strong>文档解析工具</strong><p>python-docx,langchain document loader,springlangchain4j,spring ai<p><strong>文档解析逻辑</strong><p>文字通过库直接解析,图片使用路径表示<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>def</span> <span class=title>parse_docx</span>(<span class=params>self, docx_path</span>):</span></span><br><span class=line>       doc = DocxDocument(docx_path)</span><br><span class=line></span><br><span class=line>       content = []</span><br><span class=line></span><br><span class=line>       image_map = self._extract_images_from_docx(doc)</span><br><span class=line></span><br><span class=line>       <span class=function><span class=keyword>def</span> <span class=title>parse_paragraph</span>(<span class=params>paragraph</span>):</span></span><br><span class=line>           <span class=function><span class=keyword>def</span> <span class=title>append_image_link</span>(<span class=params>image_id, has_drawing, target_buffer</span>):</span></span><br><span class=line>               <span class=string>"""Helper to append image link from image_map based on relationship type."""</span></span><br><span class=line>               rel = doc.part.rels[image_id]</span><br><span class=line>               <span class=keyword>if</span> rel.is_external:</span><br><span class=line>                   <span class=keyword>if</span> image_id <span class=keyword>in</span> image_map <span class=keyword>and</span> <span class=keyword>not</span> has_drawing:</span><br><span class=line>                       target_buffer.append(image_map[image_id])</span><br><span class=line>               <span class=keyword>else</span>:</span><br><span class=line>                   image_part = rel.target_part</span><br><span class=line>                   <span class=keyword>if</span> image_part <span class=keyword>in</span> image_map <span class=keyword>and</span> <span class=keyword>not</span> has_drawing:</span><br><span class=line>                       target_buffer.append(image_map[image_part])</span><br><span class=line></span><br><span class=line>           <span class=function><span class=keyword>def</span> <span class=title>process_run</span>(<span class=params>run, target_buffer</span>):</span></span><br><span class=line>               <span class=comment># Helper to extract text and embedded images from a run element and append them to target_buffer</span></span><br><span class=line>               <span class=keyword>if</span> <span class=built_in>hasattr</span>(run.element, <span class=string>"tag"</span>) <span class=keyword>and</span> <span class=built_in>isinstance</span>(run.element.tag, <span class=built_in>str</span>) <span class=keyword>and</span> run.element.tag.endswith(<span class=string>"r"</span>):</span><br><span class=line>                   <span class=comment># Process drawing type images</span></span><br><span class=line>                   drawing_elements = run.element.findall(</span><br><span class=line>                       <span class=string>".//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}drawing"</span></span><br><span class=line>                   )</span><br><span class=line>                   has_drawing = <span class=literal>False</span></span><br><span class=line>                   <span class=keyword>for</span> drawing <span class=keyword>in</span> drawing_elements:</span><br><span class=line>                       blip_elements = drawing.findall(</span><br><span class=line>                           <span class=string>".//{http://schemas.openxmlformats.org/drawingml/2006/main}blip"</span></span><br><span class=line>                       )</span><br><span class=line>                       <span class=keyword>for</span> blip <span class=keyword>in</span> blip_elements:</span><br><span class=line>                           embed_id = blip.get(</span><br><span class=line>                               <span class=string>"{http://schemas.openxmlformats.org/officeDocument/2006/relationships}embed"</span></span><br><span class=line>                           )</span><br><span class=line>                           <span class=keyword>if</span> embed_id:</span><br><span class=line>                               rel = doc.part.rels.get(embed_id)</span><br><span class=line>                               <span class=keyword>if</span> rel <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span> <span class=keyword>and</span> rel.is_external:</span><br><span class=line>                                   <span class=comment># External image: use embed_id as key</span></span><br><span class=line>                                   <span class=keyword>if</span> embed_id <span class=keyword>in</span> image_map:</span><br><span class=line>                                       has_drawing = <span class=literal>True</span></span><br><span class=line>                                       target_buffer.append(image_map[embed_id])</span><br><span class=line>                               <span class=keyword>else</span>:</span><br><span class=line>                                   <span class=comment># Internal image: use target_part as key</span></span><br><span class=line>                                   image_part = doc.part.related_parts.get(embed_id)</span><br><span class=line>                                   <span class=keyword>if</span> image_part <span class=keyword>in</span> image_map:</span><br><span class=line>                                       has_drawing = <span class=literal>True</span></span><br><span class=line>                                       target_buffer.append(image_map[image_part])</span><br><span class=line>                   <span class=comment># Process pict type images</span></span><br><span class=line>                   shape_elements = run.element.findall(</span><br><span class=line>                       <span class=string>".//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}pict"</span></span><br><span class=line>                   )</span><br><span class=line>                   <span class=keyword>for</span> shape <span class=keyword>in</span> shape_elements:</span><br><span class=line>                       <span class=comment># Find image data in VML</span></span><br><span class=line>                       shape_image = shape.find(</span><br><span class=line>                           <span class=string>".//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}binData"</span></span><br><span class=line>                       )</span><br><span class=line>                       <span class=keyword>if</span> shape_image <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span> <span class=keyword>and</span> shape_image.text:</span><br><span class=line>                           image_id = shape_image.get(</span><br><span class=line>                               <span class=string>"{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id"</span></span><br><span class=line>                           )</span><br><span class=line>                           <span class=keyword>if</span> image_id <span class=keyword>and</span> image_id <span class=keyword>in</span> doc.part.rels:</span><br><span class=line>                               append_image_link(image_id, has_drawing, target_buffer)</span><br><span class=line>                       <span class=comment># Find imagedata element in VML</span></span><br><span class=line>                       image_data = shape.find(<span class=string>".//{urn:schemas-microsoft-com:vml}imagedata"</span>)</span><br><span class=line>                       <span class=keyword>if</span> image_data <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span>:</span><br><span class=line>                           image_id = image_data.get(<span class=string>"id"</span>) <span class=keyword>or</span> image_data.get(</span><br><span class=line>                               <span class=string>"{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id"</span></span><br><span class=line>                           )</span><br><span class=line>                           <span class=keyword>if</span> image_id <span class=keyword>and</span> image_id <span class=keyword>in</span> doc.part.rels:</span><br><span class=line>                               append_image_link(image_id, has_drawing, target_buffer)</span><br><span class=line>               <span class=keyword>if</span> run.text.strip():</span><br><span class=line>                   target_buffer.append(run.text.strip())</span><br></pre></table></figure><p>dify中word提取逻辑,Word 文档（<code>.docx</code>）本质上是一个压缩的 XML 文件。D通过解析这些底层的 XML 标签来重构表格和布局。<ol><li>图片转存逻辑</ol><ul><li><strong>处理位置</strong>：<code>_extract_images_from_docx(self, doc)</code> 方法。<li><strong>具体细节</strong>：<ul><li>它遍历 <code>doc.part.rels</code>（文档关系表）。<li>如果是<strong>内部图片</strong>，直接读取 <code>rel.target_part.blob</code>。<li>如果是<strong>外部图片 URL</strong>，使用 <code>ssrf_proxy.get(url)</code> 下载（<strong>重点：通过代理下载以防止 SSRF 攻击</strong>）。<li><strong>存储与映射</strong>：调用 <code>storage.save()</code> 将图片存入系统，并向数据库 <code>UploadFile</code> 表写入记录。最后返回 <code>image_map</code>，其 Key 是图片在 XML 中的 ID，Value 是 Markdown 格式的链接：<code>![image](预览地址)</code>。</ul></ul><ol><li>表格转 Markdown 逻辑</ol><ul><li><strong>处理位置</strong>：<code>_table_to_markdown(self, table, image_map)</code> 及其调用的 <code>_parse_row</code> 和 <code>_parse_cell</code>。<li><strong>具体细节</strong>：<ul><li><strong>对齐处理</strong>：计算表格的最大列数 <code>total_cols</code>。<li><strong>格式构造</strong>：手动拼接 Markdown 的分隔符 <code>| --- |</code>。<li><strong>单元格合并处理</strong>：在 <code>_parse_row</code> 中，通过 <code>cell.grid_span</code> 获取单元格跨越的列数，确保合并单元格在 Markdown 转换后不会导致列偏移，保持数据结构的对齐。</ul></ul><ol><li>复杂文本与链接提取</ol><ul><li><strong>处理位置</strong>：<code>parse_paragraph</code>（在 <code>parse_docx</code> 内部定义的函数）。<li><strong>具体细节</strong>：<ul><li><strong>普通文本</strong>：遍历 <code>run.text</code>。<li><strong>现代超链接</strong>：处理 <code>w:hyperlink</code> 标签。<li><strong>旧式超链接 (Field)</strong>：这是最难处理的部分，代码通过正则匹配 <code>HYPERLINK "url"</code> 并结合 <code>w:fldChar</code>（字段开始/分隔/结束状态机）来提取那些隐藏在 Word 指令字段中的链接。</ul></ul><p>直接提取纯文本会丢失表格的行级/列级对应关系。转换为 Markdown 后，大模型能够通过分隔符明确识别表格数据的关联性，减少幻觉。<p>实际研发场景中，使用 Document Loader 文档加载器模块时，需要根据具体的业务需求编写自定义的文档后处理逻辑。针对业务需求，开发者可以自行编写和实现对不同文档内容的解析，例如对标题、段落、表格、图片等元素的特殊处理。<h3 id=PDF解析><a class=headerlink href=#PDF解析 title=PDF解析></a>PDF解析</h3><p>尽管PDF文件的内容在表达图像、文字和表格信息，但其<strong>本质上是一系列显示和打印指令的集合</strong>。，即使是一个仅包含 “Hello World” 文字的简单PDF，其文件内容也是一长串的打印指令。<p><img alt=image-20260113151406760 data-src=https://s2.loli.net/2026/01/13/HQyj94GeUDbJXvL.png style=zoom:67%;><p>PDF文件的<strong>显示效果不受设备、软件或系统的影响，但对计算机而言，它是一种非数据结构化的格式，</strong>储存的信息无法直接被理解。此外，大模型的训练数据中不包含直接的PDF文件，无法直接理解。<p>PDF解析，对于纯文本格式可以转换为文本字符串，而对于包含多种元素的复杂格式，选择 <strong>MarkDown 文件</strong>作为统一的输出格式最为合适。这是因为MarkDown文件关注内容本身，而非打印格式，能够表示多种文档元素内容。MarkDown格式被广泛接受于互联网世界，其信息能够被大模型理解。<p><strong>PDF文件分为电子版和扫描版。</strong>PDF电子版可以<strong>通过规则解析</strong>，提取出文本、表格等文档元素。目前，有许多开源库可以支持，例如 <strong>pyPDF2、PyMuPDF、pdfminer、pdfplumber和papermage</strong> 等。这些库在 langchain_community.document_loaders 中基本都有对应的加载器，方便在不同场景下切换使用。<p><strong>在基于规则的开源库中，pdfplumber对中文支持较好，且在表格解析方面表现优秀，但对双栏文本的解析能力较差；pdfminer和PyMuPDF对中文支持良好，但表格解析效果较弱；pyPDF2对英文支持较好，但中文支持较差；papermage集成了pdfminer和其他工具，特别适合处理论文场景。</strong>开发者可以根据实际业务场景的测试结果选择合适的工具，pdfplumber或pdfminer都是当前不错的选择。<p><strong>扫描版PDF</strong><p>PDF扫描版<strong>需要经过文本识别和表格识别PDF扫描图像</strong>，才能提取出文档中的各类元素。同时要真正实现文档解析的目标，<strong>无论扫描版还是电子版均需进行版面分析和阅读顺序的还原，将内容解析为一个包含所有文档元素并且具有正确阅读顺序的MarkDown文件</strong>。单纯依赖规则解析是无法实现这一目标的.<p>目前支持这些功能的多为<strong>基于深度学习的开源库，如 Layout-parser、PP-StructureV2、PDF-Extract-Kit、pix2text、MinerU、marker等</strong>。<p>由于PDF文档解析整体流程用到了多个深度学习模型组合，真正在生产场景中会遇到效率问题。<strong>商业闭源库</strong>由于其部署的云端集群可以做并行处理和工程效率优化，所以在精度和效率上都能做到生产中的级别，比如TextIn.com、Doc2x、mathpix、庖丁PDFlux、腾讯云文档识别等，当然商业库会存在成本问题，你可以按需选择。<p>PDF内容提取逻辑,参考<a href=https://github.com/langgenius/dify/blob/main/api/core/rag/extractor/pdf_extractor.py rel=noopener target=_blank>dify</a><ol><li>图片格式识别（Magic Bytes）</ol><ul><li><strong>实现位置</strong>：类属性 <code>IMAGE_FORMATS</code> 和 <code>_extract_images</code> 内部。<li><strong>逻辑</strong>：代码通过检查文件头的“魔数”（Magic Bytes）来精准识别图片格式（如 JPEG 的 <code>\xff\xd8\xff</code>，PNG 的 <code>\x89PNG</code>），而不是简单依赖文件后缀。这保证了即使 PDF 内部图像流没有明确标签，也能正确保存为 <code>.jpg</code> 或 <code>.png</code>。</ul><ol><li>图像转存与持久化</ol><ul><li><strong>处理位置</strong>：<code>_extract_images(self, page)</code>。<li><strong>具体细节</strong>：<ul><li><strong>对象过滤</strong>：使用 <code>filter=(pdfium_c.FPDF_PAGEOBJ_IMAGE,)</code> 仅提取页面中的图像对象。<li><strong>二进制提取</strong>：调用 <code>obj.extract()</code>。注意其中的 <code>fb_format="png"</code>，这意味着对于非 JPEG 格式的图像，代码会自动将其回退（Fallback）并渲染为 PNG 格式以保证兼容性。<li><strong>存储与数据库</strong>：图片字节流被存入 <code>storage</code>，同时向 <code>UploadFile</code> 数据库表写入元数据。返回的 Markdown 链接允许前端或大模型直接通过 URL 预览提取到的图片。</ul></ul><ol><li>内存与资源管理</ol><ul><li><strong>处理位置</strong>：<code>parse</code> 方法中的 <code>finally</code> 块及 <code>autoclose=True</code>。<li><strong>逻辑</strong>：代码显式调用 <code>text_page.close()</code>、<code>page.close()</code> 和 <code>pdf_reader.close()</code>。在处理包含数千张图片的 PDF 时，及时释放 C 级底层的 PDF 句柄是防止内存泄漏的关键。</ul><h4 id=优化解析逻辑><a class=headerlink href=#优化解析逻辑 title=优化解析逻辑></a>优化解析逻辑</h4><p><strong>布局恢复</strong>：目前提取的是“平铺”文本，PDF 中的<strong>多栏布局或页眉页脚</strong>可能会混入正文。可以考虑引入 <code>pypdfium2</code> 的坐标分析功能来过滤页眉页脚,或者使用OCR提取布局信息。<p><strong>表格识别</strong>: pdf底层存储的是字符及其坐标,需要通过定位页面中的表格区域。尝试理解表格的行列逻辑，并将其转换为标准的 <strong>Markdown 表格格式</strong>（<code>|---|</code>）。结合布局分析和表格重建 <a href=https://github.com/infiniflow/ragflow rel=noopener target=_blank>infiniflow/ragflow</a><p><strong>OCR 介入</strong>：如果 PDF 是扫描件（图片生成的 PDF），<code>get_text_range()</code> 将返回空。此时应触发 OCR 流程对提取出的图片进行二次文字识别。<p><strong>表格识别</strong>:引入OCR<p>采取 <strong>“混合解析策略”</strong>：<ol><li><strong>预判断</strong>：先尝试用 <code>pypdfium2</code> 读取文本，如果返回字符数极少，判定为扫描件，触发 OCR。<li><strong>工具选型</strong>：<ul><li><strong>追求开源/本地部署</strong>：集成 <code>Marker</code> 或 <code>Unstructured</code> 库。<li><strong>追求极致效果</strong>：使用多模态 API（如 GPT-4o-mini）专门处理表格页。</ul><li><strong>标准化输出</strong>：无论后端用什么工具，统一输出为 <strong>Markdown</strong>，因为这能最大程度保留表格的语义逻辑供大模型检索。</ol><p><strong>推荐工具对比：</strong><div class=table-container><table><thead><tr><th><strong>需求场景</strong><th><strong>推荐工具</strong><th><strong>集成难度</strong><tbody><tr><td><strong>追求极致速度</strong><td>维持现状 (<code>pypdfium2</code>)<td>-<tr><td><strong>精准处理多栏/论文</strong><td>集成 <code>Marker</code><td>中（需要额外 Python 依赖）<tr><td><strong>完美还原复杂表格</strong><td><code>Unstructured</code> + <code>PaddleOCR</code><td>高（环境配置较复杂）<tr><td><strong>万能适配</strong><td>多模态 LLM 视觉解析<td>低（仅需 API 调用）</table></div><p>在Marker中,使用深度学习模型和启发式算法来解析PDF中的多栏布局和表格。多栏文本通过<code>TextProcessor</code>检测和合并，表格通过<code>TableProcessor</code>进行结构化提取，并可选择性使用LLM增强准确性<p>开源系统不支持的文件类型<p><img alt=image-20260113162924676 data-src=https://s2.loli.net/2026/01/13/LJ5gIYocRW1OMhs.png style=zoom:50%;><p><img alt=image-20260113164413896 data-src=https://s2.loli.net/2026/01/13/a93OWviDeEuVHtS.png style=zoom:50%;><h3 id=难点><a class=headerlink href=#难点 title=难点></a>难点</h3><h4 id=跨页表格怎么自动对齐><a class=headerlink href=#跨页表格怎么自动对齐 title=跨页表格怎么自动对齐></a>跨页表格怎么自动对齐</h4><p>在处理 PDF 解析时，<strong>跨页表格（Multi-page Tables）</strong>是最具挑战性的场景之一。由于 PDF 在分页处会强制打断表格结构，并可能插入页眉、页脚或重复表头，简单的流式提取会导致表格断裂或数据错位。<p><strong>关键技术方案</strong><p>表头一致性,判断是否为同一张表的重复表头<p>表格位置分析,判断相邻页中的表格是否在文档布局中连续<p>自动拼接与去重,对于相同表头的多个分页表格,按行拼接,并去除重复的表头行<ol><li>布局检测</ol><p>mineru<ol><li>文档格式检测<li>文档格式识别<li>OCR处理<li>表格预测</ol><h2 id=数据预处理><a class=headerlink href=#数据预处理 title=数据预处理></a>数据预处理</h2><p><img alt=image-20260113172147249 data-src=https://s2.loli.net/2026/01/13/HtOu2piYNzmc5oT.png><p>构建领域术语词库,识别输入中领域术语,替换<p>术语混淆直接影响信息检索的精确度与生成内容质量.<h3 id=术语词库构建与维护><a class=headerlink href=#术语词库构建与维护 title=术语词库构建与维护></a>术语词库构建与维护</h3><p><strong>产生术语混淆</strong><p>术语多义性,同义词,领域差异以及企业专属术语<p><strong>术语词库构建流程</strong><ol><li>收集术语来源<li>标准化术语<li>建立别名映射关系<li>添加上下文信息<li>构建术语索引</ol><p><img alt=image-20260113192853262 data-src=https://s2.loli.net/2026/01/13/jnPqIHEdLuV2g8l.png><p><strong>术语词库与RAG集成</strong><p>方式1:预处理阶段替换术语<p>方式2:检索增强<p>方式3:重排序<p>方式4:后处理解释<p><strong>维护术语词库</strong><h2 id=分块策略与Embedding技术><a class=headerlink href=#分块策略与Embedding技术 title=分块策略与Embedding技术></a>分块策略与Embedding技术</h2><p><img alt=image-20260113172431541 data-src=https://s2.loli.net/2026/01/13/FmMrCP7X6E3NsRV.png><p><strong>数据分块（Chunking/切片）</strong> 的质量直接决定了检索的精准度。如果<strong>切片太小，会丢失上下文</strong>；如果<strong>切片太大，会引入噪声并稀释语义。</strong><p>Token-based chunking TokenTextSplitter 严格限制模型窗口时物理边界控制精准<p>SentenceSplitter 通用文本文档语义保真度高，配置简单 目标是在保持语义完整性的前提下，尽可能按句子边界切分。<p><strong>工作原理</strong>：它会尝试按照段落 (<code>\n\n</code>)、换行 (<code>\n</code>)、句子、单词的优先级递归切分。<p><strong>核心作用</strong>：它能确保切片<strong>不会在句子中间断开</strong>。<p><strong>关键参数</strong>：<code>chunk_size</code>（块大小）和 <code>chunk_overlap</code>（重叠大小）。<p>窗口切分, SentenceWindowNodeParser<div class=table-container><table><thead><tr><th><strong>文档类型</strong><th><strong>推荐切片类 (LlamaIndex)</strong><th><strong>选择理由</strong><tbody><tr><td><strong>标准说明书/公文</strong><td><code>SentenceSplitter</code><td>段落结构清晰，按句子切分能最大程度保留语义。<tr><td><strong>README/技术手册</strong><td><code>MarkdownNodeParser</code><td><strong>强推。</strong> 必须按 <code>H1-H3</code> 标题切分，否则正文会脱离标题，导致检索到正文却不知道在说哪个产品。<tr><td><strong>代码库 (Python/JS)</strong><td><code>CodeSplitter</code><td>依据语法树（AST）切分，保证一个函数或一个类在一个 Chunk 里。<tr><td><strong>扫描件/复杂 PDF</strong><td><code>SemanticSplitter</code><td><strong>慎用。</strong> 建议先用 <code>Marker</code> 转为 Markdown，再用 <code>MarkdownNodeParser</code> 处理。</table></div><p><strong>“全家桶”组合</strong> 通常是：<ol><li><strong>MarkdownNodeParser</strong>（用于格式化内容）<li><ul><li><strong>SentenceSplitter</strong>（作为 fallback 处理长段落）</ul><li><ul><li><strong>MetadataExtractor</strong>（注入标题和上下文）</ul><li><ul><li><strong>RedisCache</strong>（放在 IngestionPipeline 里加速重复解析</ul></ol><p>滑动窗口切分=sentenceSplitter+SentenceWindowSplitter<h4 id=滑动窗口><a class=headerlink href=#滑动窗口 title=滑动窗口></a>滑动窗口</h4><p>滑动窗口结合关键词<ol><li>初步切片,使用滑动窗口对文档进行基础分段<li>关键词检测,分析每个切片的边界,识别是否存在关键词或语义单元的中断<li>动态调整,根据关键词位置和上下文语境,微调切片边界,确保语义完整</ol><p><strong>语义切分</strong><p><img alt=image-20260113214337874 data-src=https://s2.loli.net/2026/01/13/uWSVRKQ13fZlOde.png><p>SemanticSplitter 的工作逻辑可以分为以下四个步骤：<ol><li><strong>句子分割</strong>：首先将原始文档拆分成一个个基础的句子。<li><strong>向量化（Embedding）</strong>：利用 Embedding 模型将每个句子（或句组）转化为高维向量。<li><strong>计算相似度</strong>：计算相邻句子之间的<strong>余弦相似度（Cosine Similarity）</strong>。<li><strong>设定阈值（Threshold）</strong>：<ul><li>如果<strong>相邻两句的意思非常接近，它们会被合并在同一个块（Chunk）里</strong>。<li>如果相似度突然下降，超过了设定的阈值，系统就认为“话题发生了转换”，并在此处建立切片断点。</ul></ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> llama_index.core.node_parser <span class=keyword>import</span> SemanticSplitterNodeParser</span><br><span class=line><span class=keyword>from</span> llama_index.embeddings.openai <span class=keyword>import</span> OpenAIEmbedding</span><br><span class=line></span><br><span class=line><span class=comment># 1. 定义 Embedding 模型（用于计算句子间的相似度）</span></span><br><span class=line>embed_model = OpenAIEmbedding()</span><br><span class=line></span><br><span class=line><span class=comment># 2. 初始化语义切片器</span></span><br><span class=line><span class=comment># buffer_size: 计算相似度时考虑的窗口大小</span></span><br><span class=line><span class=comment># breakpoint_percentile_threshold: 相似度下降到多少百分位时进行切割</span></span><br><span class=line>splitter = SemanticSplitterNodeParser(</span><br><span class=line>    buffer_size=<span class=number>1</span>, </span><br><span class=line>    breakpoint_percentile_threshold=<span class=number>95</span>, </span><br><span class=line>    embed_model=embed_model</span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=comment># 3. 对文档进行切片</span></span><br><span class=line>nodes = splitter.get_nodes_from_documents(documents)</span><br></pre></table></figure><h2 id=动态切片策略与重叠机制><a class=headerlink href=#动态切片策略与重叠机制 title=动态切片策略与重叠机制></a>动态切片策略与重叠机制</h2><p><strong>RecursiveTextSplitter</strong>（递归字符切片器）是 RAG 开发中最常用、也是性价比最高的文本切片工具。它被广泛集成在 LangChain 等框架中，旨在解决简单字符切片容易“切断语义”的问题。<p>它的核心理念是：<strong>尽可能保持段落、句子和词语的完整性。</strong><p><code>RecursiveTextSplitter</code> 维护了一个<strong>分隔符列表</strong>（默认通常是 <code>["\n\n", "\n", " ", ""]</code>）。其工作流程如下：<ol><li><strong>段落切分</strong>：首先尝试用双换行符 <code>\n\n</code>（段落边界）来切分文档。<li><strong>检查大小</strong>：如果切出来的块小于设定的 <code>chunk_size</code>，则保留。<li><strong>降级递归</strong>：如果某个块仍然超过了 <code>chunk_size</code>，它会针对这个超长的块，换用下一个分隔符（如单换行符 <code>\n</code>）继续尝试切分。<li><strong>最小单位</strong>：如果连换行符切完都太大，它会寻找空格 <code>" "</code>（单词边界）。如果连空格都解决不了（比如一个极长的化学单词），最后才会按字符 <code>""</code> 强制切断。</ol><p><strong>结构化文档失效</strong>：如果你处理的是 Markdown（带有很多 <code>#</code> 标题）或代码，普通的递归切片可能会切断标题和正文的联系。此时应该使用专用的 <code>MarkdownHeaderTextSplitter</code> 或 <code>CodeSplitter</code>。<p><strong>不识别语义转折</strong>：它只看物理符号（如换行符），不看意思。如果一个段落里讨论了两个完全不同的主题，它还是会把它们放在一起。这种情况需要 <code>SemanticSplitter</code>。<p><strong>TopicNodeParser</strong><p>命题化检索<p><code>TopicNodeParser</code> 通常利用 LLM 或高精度的 Embedding 模型来识别文档中的“话题转换点”（Topic Drift）。<p>其工作流程通常如下：<ol><li><strong>初始分割</strong>：将文档初步拆分为较小的单元（如句子或短段落）。<li><strong>主题建模/识别</strong>：<ul><li><strong>方法 A（LLM 驱动）</strong>：让 LLM 扫描文本块，判断：“这里是否开启了一个新话题？”<li><strong>方法 B（语义聚类）</strong>：计算连续块之间的相似度，当相似度曲线出现“断崖式”下跌时，判定为主题切换。</ul><li><strong>节点构建</strong>：将属于同一个主题的所有文本块合并为一个 <code>Node</code>，并自动为该 Node 提取一个<strong>主题标签（Topic Label）</strong>作为元数据。</ol><p><strong>上下文割裂</strong>：一个关于“安装步骤”的描述可能被切成了两半，检索时只搜到后半部分，导致步骤缺失。<p><strong>语义混杂</strong>：一个 1024 Token 的块里，前一半在说“硬件规格”，后一半在说“软件配置”，这会导致该块的向量表征变得“平庸”，检索相关度下降。<p><img alt=image-20260113221722324 data-src=https://s2.loli.net/2026/01/13/oMWHlgAt4XJy5VC.png><h4 id=Dify中的父子模式><a class=headerlink href=#Dify中的父子模式 title=Dify中的父子模式></a>Dify中的父子模式</h4><p>在普通的切片模式下，开发者常面临一个<strong>“鱼与熊掌不可兼得”</strong>的困局：<ul><li><strong>分段太小</strong>：检索非常精准（向量表征集中），但由于上下文（Context）太少，LLM 回答时容易断章取义。<li><strong>分段太大</strong>：包含了足够的背景，但一个段落里讲了三个主题，导致向量表征模糊，搜索时很难排在前面。</ul><p><strong>父子模式的对策</strong>：将原本的大段落（父）进一步拆解为多个小片段（子）。<ol><li><p>工作原理</p><li><p><strong>存储阶段</strong>：</p> <ul><li><strong>父分段 (Parent)</strong>：通常是较长的文本块（如 1000 Tokens），保留了完整的逻辑和上下文。<li><strong>子分段 (Child)</strong>：将父分段进一步切碎（如 200 Tokens）。<li><strong>数据库关联</strong>：系统在向量数据库中索引“子分段”，但每一个子分段都关联着其对应的“父分段” ID。</ul><li><strong>检索阶段</strong>：<ul><li>用户提问后，系统去匹配<strong>最相关的子分段</strong>。</ul><li><strong>还原阶段（关键步）</strong>：<ul><li>一旦命中了某个子分段，Dify 不会将子分段的内容发给 LLM，而是自动根据关联 ID，<strong>找回它所属的父分段内容</strong>。</ul><li><strong>生成阶段</strong>：<ul><li>LLM 接收到的是语义丰富的父分段，从而能根据完整的背景生成高质量答案</ul></ol><p>开启“父子模式”通常需要调整以下参数：<ul><li><strong>父分段规则</strong>：设定父块的大小（建议 800-1000 字符）。<li><strong>子分段规则</strong>：设定子块的大小（建议 200-300 字符）。<li><strong>检索策略</strong>：<ul><li>通常配合<strong>混合检索（Hybrid Search）</strong>使用，即：子分段的向量检索 + 全文检索。</ul></ul><p><strong>适用文档</strong>：逻辑严密但篇幅较长的文档，如<strong>法律条文、技术规范、深度行业报告</strong>。<p><strong>配合 Rerank</strong>：在父子模式下，强烈建议开启 <strong>Rerank（重排序）</strong>。因为子块召回可能较多，通过 Rerank 选出最准确的子块对应的父块，能显著降低 Token 消耗并提升准确度。<p><img alt=image-20260113222328479 data-src=https://s2.loli.net/2026/01/13/9QqxH8JkfObdPpe.png><p>传统的 RAG 工具（如 LangChain 或 Dify 默认模式）往往采用“一刀切”的规则来切片，而 RAGFlow 的模板化逻辑是：<strong>先看文档长什么样，再决定怎么拆。</strong><p>不同的文档有完全不同的逻辑结构。如果用同一种算法去切，会发生以下惨剧：<ul><li><strong>财务报表</strong>：表格被拆散成一堆毫无意义的数字。<li><strong>科研论文</strong>：双栏排版的文字被横向读取，左右两栏混在一起。<li><strong>调查问卷</strong>：问题和选项被强行切断。</ul><p><strong>RAGFlow 的模板化方案</strong>：预设了多种针对特定场景的解析逻辑，确保数据从 PDF/Word 转化为数据库向量时，逻辑依然是完整的。<p>RAGFlow 提供了多种内置模板，每种模板背后都有一套专门的布局识别（Layout Analysis）算法<p>切片的核心作用:为后续混合检索,重排,查询转换等提供高质量数据<p>最后也需要构建评估体系,持续验证与迭代优化<h2 id=检索增强阶段><a class=headerlink href=#检索增强阶段 title=检索增强阶段></a>检索增强阶段</h2><p>在初步召回的基础上,进一步优化检索结果的广度与精度.<p><img alt=image-20260113174601655 data-src=https://s2.loli.net/2026/01/13/3zsZUHCwk5QOaGl.png><p><strong>查询扩展与重写</strong><p>生成 3 到 5 个不同表述但语义相同的查询变体。这些变体应从不同的侧重点出发，帮助从向量数据库中找回最相关的文档。其核心依据是<strong>语义向量空间的不确定性</strong>。<p>利用大语言模型（LLM）将用户的一个问题转化为多个语义相似但措辞不同的问题，然后分别进行检索。<p>传统的向量检索（Vector Search）高度依赖用户输入的<strong>措辞</strong>。<ul><li><strong>痛点</strong>：如果用户的问题和文档中的词汇不匹配，或者提问比较模糊，向量空间中的距离可能较远，导致检索不到核心内容。<li><strong>例子</strong>：用户问“如何对齐 PDF 表格？”，文档里写的可能是“PDF 表格解析与重组方案”。两者字面上不完全一致。</ul><ol><li><strong>查询生成</strong>：LLM 接收原始问题，生成 3-5 个不同角度的变体（例如：“PDF 表格错位怎么处理？”、“PDF 跨页表格对齐技术”等）。<li><strong>并行检索</strong>：将这多个问题同时发给向量数据库，每个问题都会召回一批文档。<li><strong>取并集（Union）</strong>：将所有问题召回的文档汇总在一起。<li><strong>去重与排序</strong>：剔除重复文档，最后将这组更全面的文档交给 LLM 生成答<strong>案</strong></ol><p><strong>假设性文档HyDE</strong><p>核心思想是与其直接用“问题”去搜答案，不如先让 AI 编一个“假答案”，然后用这个“假答案”去搜“真文档”。<p>在传统的向量检索中，我们计算的是 <strong>问题（Query）</strong> 和 <strong>文档（Document）</strong> 之间的相似度。<ul><li><strong>痛点</strong>：问题通常很短（如“HyDE 是什么？”），而文档通常很长且充满细节。在向量空间里，短问题和长文档的特征向量往往<strong>不对称</strong>，导致检索不到最相关的片段。<li><strong>HyDE 的逻辑</strong>：文档和文档之间是最像的。</ul><ol><li><strong>生成假设文档</strong>：接收用户的问题，让 LLM（如 GPT-4）在不看任何外部资料的情况下，凭直觉写一篇“伪文档”或“假设性回答”。<li><strong>向量化（Embedding）</strong>：将这篇逻辑通顺但内容可能不准确的<strong>假设文档</strong>转化成向量。<li><strong>检索真文档</strong>：用这个“伪向量”去数据库里匹配物理特征最接近的<strong>真实文档</strong>。<li><strong>生成最终答案</strong>：把检索到的真文档喂给 AI，生成正式的回复。</ol><h2 id=OCR文件错漏><a class=headerlink href=#OCR文件错漏 title=OCR文件错漏></a>OCR文件错漏</h2><p>OCR识别错误可以分为:<p>字符识别错误,文字遗漏,多字重复,格式混乱<p>在OCR之前可以及逆行文本图像校正,纠正图像中文档扭曲,倾斜,透视变形等问题,另外进行版面区域检测,对文档图像进行内容解析和区域划分<p>识别后的内容可以通过LLM修正<h2 id=生成控制与验证阶段><a class=headerlink href=#生成控制与验证阶段 title=生成控制与验证阶段></a>生成控制与验证阶段</h2><p><img alt=image-20260113191853638 data-src=https://s2.loli.net/2026/01/13/1MGJDKWENkfjeS4.png><h2 id=向量检索引擎><a class=headerlink href=#向量检索引擎 title=向量检索引擎></a>向量检索引擎</h2><p><img alt=image-20260113233157267 data-src=https://s2.loli.net/2026/01/13/GyxSOqhop9erDBA.png><p>BM25是改进的TF-IDF排序,通过词频,文档长度归一化以及逆文档频率加权.<h3 id=设计混合检索架构提高多阶段召回率><a class=headerlink href=#设计混合检索架构提高多阶段召回率 title=设计混合检索架构提高多阶段召回率></a>设计混合检索架构提高多阶段召回率</h3><h2 id=让AI返回结构化数据><a class=headerlink href=#让AI返回结构化数据 title=让AI返回结构化数据></a>让AI返回结构化数据</h2><p>Structured Generation with LLM，是指<strong>让LLM按照预先定义的schema，输出符合schema的结构化结果</strong>。<p>常见的应用场景有：<ol><li><strong>数据处理</strong>。主要功能为a -> b，即从源文本中<strong>抽取/</strong>生成符合schema的结果，例如给定新闻，进行分类、抽取关键词、生成总结等；<li><strong>Agent</strong>。主要功能是Tool Calling，即根据用户query，选择适当的tool和入参</ol><p>如何从模型输出中准确提取自己所需的信息。例如，当我们希望模型输出 JSON 格式的数据时，由于模型生成的内容并不总是稳定，可能需要额外编写大量的正则表达式来匹配并提取其中的有效信息。然而，由于 LLM 的能力，导致其输出结构并不永远可靠。<p>现阶段， 让LLM按要求生成特定格式文本的主要方法有几种种：<ul><li>微调：使模型的输出遵循特定格式<li><strong>OpenAI Json-mode/function-calling/Structured Outputs:</strong> 这些功能允许模型生成更严格、结构化的输出，但受限于openAI平台。<li><strong>格式约束</strong>：在decoding阶段进行约束，限制模型的输出，<li><strong>Prompt Engineering</strong>： 最简单的办法，但不稳定。<li>多阶段prompting： 通过多个步骤的提示逐步引导模型生成所需的格式</ul><ol><li>提示词工程（Prompt Engineering）</ol><p>这是最基础的方式，通过在 System Prompt 中明确要求 AI 返回特定的格式。<ul><li><strong>实现方式</strong>：在提示词末尾加上 <code>“请以 JSON 格式返回结果，不要包含任何多余的解释文字”</code>，并给出示例。<li><strong>优点</strong>：<ul><li><strong>低成本</strong>：不需要额外的 API 参数或编程逻辑。<li><strong>灵活性高</strong>：可以随时调整字段定义。</ul><li><strong>缺点</strong>：<ul><li><strong>不稳定</strong>：AI 可能会在 JSON 前后加上“好的，这是你要的结果”等废话（俗称 Chatty AI）。<li><strong>解析失败</strong>：长文本下可能会出现 JSON 语法错误（如少个括号、引号未转义）。</ul></ul><p><strong>Kor技术</strong><p>使用<a href=https://eyurtsev.github.io/kor/ rel=noopener target=_blank>Kor </a>进行structured generation的流程如下：<ol><li>定义schema，包括结构、注释还有例子；<li>Kor<strong>用特定的<em>prompt template</em>，将用户提供的schema和待处理的raw text</strong>，组装成prompt；<li>将prompt发送给LLM，借助其通用的In Context Learning能力，尽量生成符合schema的内容；<li><p>Kor对LLM的输出进行parse，返回符合schema的结构化结果，但也有概率没有返回（当LLM的输出不符合schema时）。</p><li><p>JSON Mode（JSON 模式）</p></ol><p>主流模型（如 GPT-4、Gemini 1.5、Claude 3）都提供了专门的开关。<ul><li><strong>实现方式</strong>：在调用 API 时设置 <code>response_format: { "type": "json_object" }</code>。<li><strong>优点</strong>：<ul><li><strong>格式强制</strong>：模型会确保输出是一个合法的 JSON，极大地减少了解析错误。</ul><li><strong>缺点</strong>：<ul><li><strong>不保证内容 Schema</strong>：虽然它是 JSON，但字段名可能会随机变化（比如这次叫 <code>name</code>，下次叫 <code>user_name</code>）。<li><strong>仍需引导</strong>：通常还是需要在 Prompt 中提示它是 JSON，否则模型可能不知道该写什么。</ul></ul><p>仅特定模型和平台支持,需要在prompt中要求输出json格式,不能保证完全按要求的格式结构输出,Json-Mode 更多是对于输出json的格式进行检查.JSON Mode 的实现原理是受限解码,核心不是让模型“学会”写 JSON，而是在它每产生一个 Token 时，通过一个<strong>外部过滤器（Filter）</strong>强行剔除掉会导致语法错误的选项。<ol><li>函数调用 / 工具调用（Function Calling / Tool Use）</ol><p>这是目前<strong>最推荐</strong>、生产环境最常用的方式。<ul><li><strong>实现方式</strong>：预先定义一个函数的参数结构（通常使用 JSON Schema），AI 不直接回答问题，而是通过“调用函数”来填充这些参数。<li><strong>优点</strong>：<ul><li><strong>强类型约束</strong>：严格遵循你定义的字段名和数据类型。<li><strong>逻辑解耦</strong>：AI 负责提取信息，你的代码负责处理提取后的数据。</ul><li><strong>缺点</strong>：<ul><li><strong>延迟略高</strong>：模型需要额外的思考步骤来决定调用哪个函数。<li><strong>成本</strong>：复杂的函数定义会占用更多的输入 Token。</ul></ul><p>Function Calling是构建agent的基石，也是各大LLM厂商的标配功能。要做到好的FC，LLM要能做到：<ol><li>理解任务与function/tool的关系，知道是否要调用、需调用哪些function/tool、是否缺必要参数；<li>返回结构化内容，包括function name、arguments（json格式）</ol><div class=table-container><table><thead><tr><th><strong>特性</strong><th><strong>普通 Prompt</strong><th><strong>JSON Mode</strong><th><strong>Function Calling</strong><tbody><tr><td><strong>约束目标</strong><td>语义理解（靠 AI 配合）<td>语法合规（保证是 JSON）<td><strong>Schema 合规（保证字段对齐）</strong><tr><td><strong>字段准确度</strong><td>差，经常乱起名<td>中，字段可能多写或漏写<td><strong>极高，严格遵循定义</strong><tr><td><strong>复杂结构</strong><td>难以处理深层嵌套<td>较好<td><strong>完美，支持复杂递归嵌套</strong><tr><td><strong>稳定性</strong><td>易受 Prompt 干扰<td>较稳<td><strong>工业级稳定</strong></table></div><p>Mistral模型的开源FC实现<p>mistral-nemo这样实现FC：<ol><li>将tools按照特定的template，组装到prompt中去；<li>LLM输出时，也遵循特定的template，call tool时加入特殊标记（TOOL_CALLS），并返回name和arguments。</ol><p>mistral-nemo在fine-tuning时，按照这样的格式进行训练，FC的“要求”已经被encode到模型的参数中去了；<ol><li>结构化输出（Structured Outputs）</ol><blockquote><p>很多开发者会用 <strong>Function Calling 来实现结构化输出</strong>（即使他们并不打算真的调用函数）。<ul><li><strong>原因</strong>：早期的模型不支持独立的 Structured Output 模式，但 Function Calling 训练得非常成熟，能极稳地吐出 JSON 参数包。<li><strong>现状</strong>：现在像 OpenAI 的 <strong>Structured Outputs</strong> 已经是这两者的结合体——它既可以用在普通的回复里，也可以用在函数调用的参数提取里，保证 100% 的字段匹配。</ul></blockquote><p>这是 OpenAI 等厂商近期推出的最高级别约束方案。<ul><li><strong>实现方式</strong>：在 API 请求中提供具体的 <code>json_schema</code>，并开启 <code>strict: true</code> 模式。<li><strong>优点</strong>：<ul><li><strong>100% 可靠</strong>：通过受限解码技术（Constrained Decoding），模型输出的每一个字符都受到 Schema 约束，完全不会偏离。<li><strong>零冗余</strong>：不会有任何解释性文字。</ul><li><strong>缺点</strong>：<ul><li><strong>模型限制</strong>：目前仅支持部分最新型号（如 GPT-4o 系列）。<li><strong>Schema 校验严格</strong>：如果 Schema 写的有问题，请求会直接失败。</ul></ul><ol><li>编程框架封装（Pydantic / LangChain / Instructor）</ol><p>利用开源库在代码层面进行封装和后处理。<ul><li><strong>实现方式</strong>：使用 Python 的 <code>Pydantic</code> 定义类，通过 <code>Instructor</code> 库调用 AI，自动完成“请求 -> 提取 -> 验证 -> 重试”的闭环。<li><strong>优点</strong>：<ul><li><strong>开发体验极佳</strong>：像调用普通函数一样获取 AI 结果。<li><strong>自动重试</strong>：如果 AI 第一次返回的 JSON 缺字段，框架会自动反馈错误并让 AI 重写。</ul><li><strong>缺点</strong>：<ul><li><strong>依赖性</strong>：增加了项目的库依赖。</ul></ul><div class=table-container><table><thead><tr><th><strong>需求场景</strong><th><strong>推荐方式</strong><th><strong>稳定等级</strong><tbody><tr><td><strong>快速原型、简单测试</strong><td>提示词工程<td>⭐⭐<tr><td><strong>需要合法 JSON 但字段多变</strong><td>JSON Mode<td>⭐⭐⭐<tr><td><strong>生产环境、复杂业务逻辑</strong><td><strong>Function Calling</strong><td>⭐⭐⭐⭐<tr><td><strong>高严苛金融/政务系统</strong><td><strong>Structured Outputs (Strict)</strong><td>⭐⭐⭐⭐⭐</table></div><h3 id=开源实现><a class=headerlink href=#开源实现 title=开源实现></a>开源实现</h3><p><strong>Outlines</strong><p><strong>对于json schema，outlines首先将其转为正则表达式，然后再转为token-level的Finite State Machine</strong><p>随后，模型的生成过程就变成在state之间的跳转：首先从初始state出发，随后在有限的输出路径中选一条，到达下一个state，直到到达最后一个state，完成生成。<p>其中”有限的输出路径“就是前文所提到的tokens输出范围。<p><code>Outlines</code> 的精髓在于它不直接处理 JSON，而是处理 <strong>FSM（有限状态机）</strong>。<ol><li><strong>解析 Schema</strong>：当你传入一个 Pydantic 模型或正则表达式时，<code>Outlines</code> 会解析其结构。<li><strong>构建 FSM</strong>：它利用 <code>interegular</code> 等库，将复杂的规则（如 JSON 语法或正则）转换成一个高度优化的<strong>有限状态机</strong>。<li><strong>状态映射</strong>：在这个状态机中，每个状态都代表了当前已经生成的字符串序列。状态机明确知道：在当前状态下，下一个字符可以是哪些，不可以是哪些。<li>FSM的缺点是无法准确表示复杂的schema。</ol><p><strong>guidance</strong><p>Guidance 的本质是将 <strong>确定性的程序逻辑</strong> 与 <strong>不确定性的 AI 生成</strong> 缝合在一起。<p>在生成过程中，Guidance 采取“接力赛”模式：<ul><li><strong>程序控制阶段</strong>：框架直接向模型注入确定的字符串（如 JSON 的键名 <code>{"name":</code>）。这部分不消耗模型的推理计算，是直接“贴”上去的。<li><strong>模型生成阶段</strong>：框架将控制权交给 AI，但限制 AI 只能在指定的“坑”里填空。填完后，框架立刻收回控制权，跳过冗余字符，直接进入下一个字段。</ul><p><strong>Instructor</strong><p>主要依赖于 <strong>Pydantic</strong>、<strong>Python 动态类型</strong>以及底层模型的 <strong>Function Calling</strong> 协议<p><strong>① 模式转换 (Model to Schema)</strong><p>当你定义一个 <code>Pydantic</code> 模型并传给 Instructor 时，它会利用 Pydantic 内置的 <code>model_json_schema()</code> 方法，自动将这个 Python 类转换成标准的 <strong>JSON Schema</strong>。<p><strong>② 协议适配 (Protocol Adaptation)</strong><p>Instructor 会根据你使用的模型，将 Schema 包装进正确的 API 参数中：<ul><li><strong>对于 OpenAI</strong>：它会将 Schema 放入 <code>tools</code> 或新的 <code>response_format</code>（Structured Outputs）中。<li><strong>对于 Anthropic/Gemini</strong>：它会调整为对应的 <code>Tool Use</code> 或 <code>JSON Mode</code> 格式。</ul><p><strong>③ 采样约束与解析 (Sampling & Parsing)</strong><p>模型返回 JSON 字符串后，Instructor 会立即进行 <strong>反序列化</strong>。<ul><li>它尝试用你定义的 Pydantic 模型去实例化这个 JSON。<li><strong>关键点</strong>：如果 JSON 缺少字段或类型不对，Pydantic 会抛出验证错误（ValidationError）。</ul><p><strong>④ 自动重试机制 (Self-Correction/Retries)</strong><p>这是 Instructor 最强大的功能。如果解析失败，它不会直接报错，而是：<ol><li>把 Pydantic 抛出的<strong>具体错误信息</strong>（例如：<code>age 字段缺失</code>）作为新的 User Message 发回给 AI。<li>告诉 AI：“你刚才的输出不对，报错如下，请修正后重新生成。”<li>这个过程会重复 N 次，直到获取合规数据。</ol><h3 id=生产实现><a class=headerlink href=#生产实现 title=生产实现></a>生产实现</h3><p>在 Java 生态中，尤其是 <strong>LangChain4j</strong> 和 <strong>Spring AI</strong> 实现结构化输出的底层逻辑，其实是把“复杂的协议通信”封装成了开发者熟悉的“对象映射”。<p>实现方式主要分为两类：<strong>基于 API 协议的强约束</strong>（类似 OpenAI 官方方案）和 <strong>基于 Prompt 的后置解析</strong>。<ol><li>强约束方案：<strong>基于 Function Calling</strong> (推荐)</ol><p>这是 LangChain4j 等库默认的首选方式。它<strong>利用了模型厂商提供的专用接口</strong>。<ul><li><strong>实现步骤</strong>：<ol><li><strong>内省 (Introspection)</strong>：当你定义一个 Java <code>Record</code> 或 <code>POJO</code> 时，框架会利用 Java 的<strong>反射机制</strong>读取字段名、类型和 <code>@Description</code> 注解。<li><strong>Schema 转换</strong>：框架将这些 Java 信息翻译成 <strong>JSON Schema</strong>。<li><strong>协议请求</strong>：在调用模型 API 时，框架不会把 Schema 塞进 Prompt，而是塞进参数里的 <code>tools</code> 或 <code>response_format</code> 字段。<li><strong>模型输出</strong>：由于模型底层开启了“受限采样”，它会直接吐出一个干净的 JSON 字符串。<li><strong>反序列化</strong>：框架内部使用 <strong>Jackson</strong> 或 <strong>Gson</strong> 将 JSON 字符串瞬间转回 Java 对象。</ol></ul><ol><li>弱约束方案：基于指令与 Parser (Spring AI 常用)</ol><p>如果模型<strong>不支持强约束接口（如某些早期的开源模型），Java 框架会回退到这种模式</strong>。<ul><li><strong>实现步骤</strong>：<ol><li><strong>注入指令</strong>：<code>BeanOutputParser</code> 会生成一段非常长且严厉的 Prompt 片段，告诉 AI：“你必须只返回 JSON，字段必须叫 XXX，类型必须是 int…”。<li><strong>后置处理</strong>：AI 返回一段包含 JSON 的文本。<li><strong>正则提取</strong>：Java 框架会用正则表达式从一堆废话中捞出 <code>{ ... }</code> 这一部分。<li><strong>验证与纠错</strong>：如果 Jackson 转换失败，部分框架（如 LangChain4j）会把错误日志发回给 AI，说“你刚才生成的 JSON 少了个逗号，请重写”，这就是自动修复机制。</ol></ul><h2 id=有效评估与改进RAG应用><a class=headerlink href=#有效评估与改进RAG应用 title=有效评估与改进RAG应用></a>有效评估与改进RAG应用</h2><p>首先我们要明确业务目标，然后根据业务目标制定指标，再根据实际的指标值改进检索技术。这种方法一步到位，<p><strong>RAGAS</strong><ol><li>与竞品相比，文档相对较完备。<li>专业度比较高，专注于做RAG评测。<li>支持与LLamaIndex、LangChain等11种RAG框架集成。</ol><p>Ragas目前实现了十项评估指标，我们挨个来看看。<p><strong>忠实度（Faithfulness）</strong>指标用于衡量生成答案与给定上下文的事实一致性。如果生成答案中的所有声明都可以从给定的上下文中推断出来，则认为该答案是忠实的。<p><strong>答案相关性（Answer Relevance）</strong>侧重于评估生成答案与给定提示的相关性。对于不完整或包含冗余信息的答案，会给出较低的分数，而较高的分数表示更好的相关性。这个指标是通过问题、上下文和答案来计算的。答案相关性定义为原始问题与基于答案生成（逆向工程）的若干人工问题之间的平均余弦相似度。<p><strong>上下文查准率（Context Precision）</strong>用于判断上下文中存在的所有真实相关项，是否都排在了较高的位置。理想情况下，所有相关的信息块都应该出现在顶部排名。这个指标是通过问题、真实答案和上下文来计算的，其值范围在0到1之间，分数越高表示查准率越高。<p><strong>上下文利用率</strong>（Context utilization）：上下文利用就像是上下文查准率指标的无参考版本。也就是关注是否利用了所有可用的信息块，而忽略掉它们的顺序如何。<p><strong>上下文查全率（Context Recall）</strong>，它衡量的是检索到的上下文与作为真实答案的标注答案的一致程度。该指标是通过问题、真实答案和检索到的上下文来计算的，其值范围在0到1之间，数值越高表示性能越好。为了从真实答案中估计上下文召回率，会分析真实答案中的每个声明，以确定它是否可以归因于检索到的上下文。在理想情况下，真实答案中的所有声明都应该可以归因于检索到的上下文。<p><strong>上下文实体查全率（Context entities Recall）</strong>，衡量从真实答案中召回的实体比例的一个指标。具体就是根据真实答案和上下文中存在的实体数量相对于单独在真实答案中存在的实体数量，来衡量检索到的上下文的召回率。<p>这个指标在有事实依据的用例中很有用，比如旅游咨询台、历史问答等。这个指标可以帮助评估基于与真实答案中实体的比较的实体检索机制，因为在实体重要的情况下，我们需要覆盖这些实体的上下文。<p><strong>答案语义相似度（Answer semantic similarity）</strong>，用于评估生成答案与真实答案之间的语义相似度。这个评估是基于真实答案和答案进行的，其值在0到1的范围内。分数越高，表示生成的答案与真实答案间的一致性越好。<p><strong>答案正确度（Answer Correctness）</strong>，用衡量生成的答案与真实答案相比的准确性。这个评估依赖于真实答案和答案，分数范围从0到1。分数越高表示生成的答案与真实答案之间的一致性越好，意味着正确度更高。<p>答案正确度包括两个关键方面：生成答案与真实答案之间的语义相似度以及事实相似度。这些方面通过加权方案结合起来，形成答案正确性分数。用户还可以选择使用一个“阈值”值将结果分数四舍五入为二进制（如果需要）。<p><strong>特定领域评估（Domain Specific Evaluation）</strong>，特定领域评估指标用于评估模型在特定领域的性能。评分标准包含了每个分数的描述，通常范围在从1到5分。<p><strong>摘要分数（Summarization Score）</strong>，这个指标衡量摘要在捕捉上下文重要信息方面的表现如何。这个指标背后的直觉是，一个好的摘要应该包含上下文所有重要信息。我们首先从上下文中提取一组重要的关键词。然后使用这些关键词生成一组问题。接着我们向摘要提出这些问题，并计算摘要得分为正确回答的问题数与问题总数的比率。<p>现如果你想直接把刚刚这些Ragas指标用到我们前面实战案例的评估，就会发现门槛还是有点高，难度比较大。为什么呢？因为我们没有评估所需要的基础数据，所以我们需要先采集相关数据。<p>那如何采集评估所需要的基础数据呢？一种方法是让数据标注员人工提问和标注，这种方法成本很高。目前最常见，也是最容易的方法是让用户直接提供反馈，然后收集这些结果，再让数据标注员分析和标注。<p>Precision、Recall、F1、MRR<p>这三个指标通常用于评估二分类模型或非排序的检索结果。<ul><li><p><strong>Precision (精确率/查准率)</strong>：</p> <p>衡量“检索出的结果中，有多少是真正相关的”。</p> <script type="math/tex; mode=display">Precision = \frac{TP}{TP + FP}</script><li><p><strong>Recall (召回率/查全率)</strong>：</p> <p>衡量“所有真正相关的结果中，有多少被成功找回了”。</p> <script type="math/tex; mode=display">Recall = \frac{TP}{TP + FN}</script><li><p><strong>F1-Score</strong>：</p> <p>精确率和召回率的调和平均数。当两者出现冲突时（例如一个高一个低），$F1$ 提供了一个平衡的评估标准。</p> <script type="math/tex; mode=display">F1 = 2 \cdot \frac{Precision \cdot Recall}{Precision + Recall}</script></ul><p>在搜索和推荐场景中，相关条目的<strong>排名越靠前</strong>，用户体验越好。<ul><li><p><strong>MRR (Mean Reciprocal Rank, 平均倒数排名)</strong>：</p> <p>它只关注<strong>第一个</strong>相关结果出现的位置。</p> <ul><li><p><strong>计算逻辑</strong>：对于一个查询，如果第一个相关结果排在第 $n$ 位，其倒数排名就是 $1/n$。将所有查询的倒数排名取平均值即为 MRR。</p><li><p><strong>公式</strong>：</p> <script type="math/tex; mode=display">MRR = \frac{1}{|Q|} \sum_{i=1}^{|Q|} \frac{1}{rank_i}</script><li><p><strong>特点</strong>：MRR 越高，说明系统能越快地让用户找到想要的第一个信息。</p></ul></ul><p>RRF 倒数排名<p><strong>RRF (Reciprocal Rank Fusion, 倒数排名融合)</strong> 严格来说不是一种单纯的“评估指标”，而是一种将<strong>多个排序列表融合为一个</strong>的算法。它在混合搜索（Hybrid Search，如：关键词检索 + 向量检索）中非常流行。<ul><li><p><strong>原理</strong>：它不依赖各个检索系统给出的具体分数（因为不同系统的分数尺度不同，无法直接相加），而是只依赖它们的<strong>排名</strong>。</p><li><p><strong>核心公式</strong>：</p> <p>对于文档 $d$，其在所有排名列表 $R$ 中的总分为：</p> <script type="math/tex; mode=display">RRFscore(d) = \sum_{r \in R} \frac{1}{k + r(d)}</script><ul><li>$r(d)$：文档 $d$ 在列表 $r$ 中的排名位置。<li>$k$：一个常数（平滑因子），通常取 <strong>60</strong>。</ul></ul><blockquote><p><strong>为什么有用？</strong><p>RRF 具有“二八定律”的特性：排在前面的文档权重会迅速衰减，而多个列表共同排在前面的文档会获得极高的总分。它能非常简单且有效地结合语义搜索和传统搜索的优点。</blockquote><h2 id=其他RAG技术><a class=headerlink href=#其他RAG技术 title=其他RAG技术></a>其他RAG技术</h2><p><strong>GraphRAG</strong><p>GraphRAG是一种结合了知识图谱的检索增强生成技术，旨在通过构建知识图谱和社区检测算法，提升大模型在理解和生成复杂信息方面的能力。它通过<strong>图结构信息</strong>，能够更精确地检索和生成与上下文相关的回答，从而在处理大规模数据集时展现出显著的性能提升<h2 id=规范化RAG应用><a class=headerlink href=#规范化RAG应用 title=规范化RAG应用></a>规范化RAG应用</h2><h3 id=RAG链路级优化><a class=headerlink href=#RAG链路级优化 title=RAG链路级优化></a>RAG链路级优化</h3><p><img alt=image-20260113192018389 data-src=https://s2.loli.net/2026/01/13/BmrKg4o7uCNx3fZ.png><p>从知识入库处理到最终生成评估.<h1 id=SpringAI智能面试平台-RAG><a class=headerlink href=#SpringAI智能面试平台-RAG title=SpringAI智能面试平台+RAG></a>SpringAI智能面试平台+RAG</h1><h2 id=基于Tika实现多格式内容提取与解析><a class=headerlink href=#基于Tika实现多格式内容提取与解析 title=基于Tika实现多格式内容提取与解析></a>基于Tika实现多格式内容提取与解析</h2><h2 id=工具调用><a class=headerlink href=#工具调用 title=工具调用></a>工具调用</h2><p>Function Calling（函数调用）是让 LLM 能够使用外部工具的核心机制。Function Calling允许模型决定<strong>何时调用工具</strong>、<strong>调用哪个工具</strong>，以及<strong>传递什么参数</strong>。<p><img alt=img data-src=https://www.runoob.com/wp-content/uploads/2026/02/runoob-funcall-runoob-scaled.png style=zoom:50%;>核心概念<ul><li><strong>工具定义</strong>：描述一个工具的功能、参数和返回值<li><strong>工具选择</strong>：LLM 根据用户问题选择合适的工具<li><strong>参数提取</strong>：LLM 从问题中提取工具所需的参数<li><strong>结果处理</strong>：将工具执行结果整合到最终回答中</ul><p>假设我们有一个查询天气的工具，当用户问<strong>北京今天天气如何？</strong>时：<ol><li>LLM 识别出需要调用天气查询工具<li>从问题中提取参数：<code>city="北京"</code>, <code>date="今天"</code><li>调用天气 API 获取数据<li>将天气数据整合成友好的回答返回给用户</ol><p>要让 LLM 正确使用工具，首先需要清晰地定义工具，好的工具定义应该像一份清晰的说明书，让 LLM 明白：<ul><li>这个工具是做什么的？<li>什么时候使用它？<li>需要什么参数？<li>参数是什么格式？</ul><p>工具定义的结构<p>一个完整的工具定义通常包含以下部分：<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment># 工具定义示例结构</span></span><br><span class=line>weather_tool = {</span><br><span class=line>  <span class=string>"name"</span>: <span class=string>"get_weather"</span>, <span class=comment># 工具名称</span></span><br><span class=line>  <span class=string>"description"</span>: <span class=string>"获取指定城市的天气信息"</span>, <span class=comment># 工具描述</span></span><br><span class=line>  <span class=string>"parameters"</span>: { <span class=comment># 参数定义</span></span><br><span class=line>    <span class=string>"type"</span>: <span class=string>"object"</span>,</span><br><span class=line>    <span class=string>"properties"</span>: {</span><br><span class=line>      <span class=string>"city"</span>: {</span><br><span class=line>        <span class=string>"type"</span>: <span class=string>"string"</span>,</span><br><span class=line>        <span class=string>"description"</span>: <span class=string>"城市名称，如'北京'、'上海'"</span></span><br><span class=line>      },</span><br><span class=line>      <span class=string>"date"</span>: {</span><br><span class=line>        <span class=string>"type"</span>: <span class=string>"string"</span>,</span><br><span class=line>        <span class=string>"description"</span>: <span class=string>"日期，格式'YYYY-MM-DD'，或'今天'、'明天'"</span>,</span><br><span class=line>        <span class=string>"enum"</span>: [<span class=string>"今天"</span>, <span class=string>"明天"</span>, <span class=string>"后天"</span>]</span><br><span class=line>      }</span><br><span class=line>    },</span><br><span class=line>    <span class=string>"required"</span>: [<span class=string>"city"</span>] <span class=comment># 必填参数</span></span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=难点-1：参数提取不准确（最常见）><a title="难点 1：参数提取不准确（最常见）" class=headerlink href=#难点-1：参数提取不准确（最常见）></a>难点 1：参数提取不准确（最常见）</h4><ul><li>问题表现：模型漏提参数、提错参数类型（比如把 “北京” 识别成数字）、参数值不符合规则（比如城市名写成 “北京市市”）。<li><p>典型场景：用户说 “查下上海明天的空气质量”，模型可能漏提 “明天” 这个时间参数，只调用 <code>get_air_quality(city="上海")</code>，导致返回今天的数据。</p> <p>解决 “参数提取不准确”：结构化提示 + 参数校验</p><li><p>核心思路：</p> <ol><li>在提示词中明确参数的<strong>名称、类型、约束条件</strong>（比如城市名只能是中文，时间格式为 YYYY-MM-DD）；<li>调用工具前加一层<strong>参数校验逻辑</strong>，不符合规则就让模型重新提取。</ol><li><p>示例提示词：</p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>你需要调用工具解决用户问题，规则如下：</span><br><span class=line><span class=number>1.</span> 工具：get<span class=constructor>_weather(<span class=params>city</span>: <span class=params>str</span>, <span class=params>date</span>: <span class=params>str</span>)</span></span><br><span class=line><span class=number>2.</span> 参数约束：</span><br><span class=line>   - city：必须是中国城市的中文全称，如“北京”“上海”，不能加“市”；</span><br><span class=line>   - date：可选，格式为YYYY-MM-DD，默认是当天。</span><br><span class=line><span class=number>3.</span> 若参数缺失或不符合规则，必须重新追问用户或修正。</span><br></pre></table></figure></ul><p><strong>参数校验逻辑</strong><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>def</span> <span class=title>validate_parameters</span>(<span class=params>func_name, params</span>):</span></span><br><span class=line>    <span class=string>"""校验函数参数"""</span></span><br><span class=line>    <span class=comment># 定义各函数的参数规则</span></span><br><span class=line>    func_rules = {</span><br><span class=line>        <span class=string>"get_weather"</span>: {</span><br><span class=line>            <span class=string>"city"</span>: {<span class=string>"type"</span>: <span class=built_in>str</span>, <span class=string>"required"</span>: <span class=literal>True</span>, <span class=string>"pattern"</span>: <span class=string>r"^[\u4e00-\u9fa5]{2,4}$"</span>},</span><br><span class=line>            <span class=string>"date"</span>: {<span class=string>"type"</span>: <span class=built_in>str</span>, <span class=string>"required"</span>: <span class=literal>False</span>, <span class=string>"pattern"</span>: <span class=string>r"^\d{4}-\d{2}-\d{2}$"</span>}</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>if</span> func_name <span class=keyword>not</span> <span class=keyword>in</span> func_rules:</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>False</span>, <span class=string>"工具不存在"</span></span><br><span class=line>    </span><br><span class=line>    rules = func_rules[func_name]</span><br><span class=line>    <span class=keyword>for</span> param, rule <span class=keyword>in</span> rules.items():</span><br><span class=line>        <span class=comment># 检查必填参数</span></span><br><span class=line>        <span class=keyword>if</span> rule[<span class=string>"required"</span>] <span class=keyword>and</span> param <span class=keyword>not</span> <span class=keyword>in</span> params:</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>False</span>, <span class=string>f"缺失必填参数：<span class=subst>{param}</span>"</span></span><br><span class=line>        <span class=comment># 检查参数类型</span></span><br><span class=line>        <span class=keyword>if</span> param <span class=keyword>in</span> params <span class=keyword>and</span> <span class=keyword>not</span> <span class=built_in>isinstance</span>(params[param], rule[<span class=string>"type"</span>]):</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>False</span>, <span class=string>f"<span class=subst>{param}</span>类型错误，需为<span class=subst>{rule[<span class=string>'type'</span>].__name__}</span>"</span></span><br><span class=line>        <span class=comment># 检查参数格式（如正则）</span></span><br><span class=line>        <span class=keyword>if</span> param <span class=keyword>in</span> params <span class=keyword>and</span> rule.get(<span class=string>"pattern"</span>) <span class=keyword>and</span> <span class=keyword>not</span> re.match(rule[<span class=string>"pattern"</span>], params[param]):</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>False</span>, <span class=string>f"<span class=subst>{param}</span>格式错误，需符合规则：<span class=subst>{rule[<span class=string>'pattern'</span>]}</span>"</span></span><br><span class=line>    </span><br><span class=line>    <span class=keyword>return</span> <span class=literal>True</span>, <span class=string>"参数校验通过"</span></span><br></pre></table></figure><h4 id=2-难点-2：输出格式不规范><a title="2. 难点 2：输出格式不规范" class=headerlink href=#2-难点-2：输出格式不规范></a>2. 难点 2：输出格式不规范</h4><ul><li>问题表现：模型输出的调用指令不符合程序解析要求（比如 JSON 格式缺引号、多逗号、字段名写错），导致代码解析失败。<li>典型场景：要求输出 <code>{"name":"get_weather","parameters":{"city":"北京"}}</code>，模型却输出 <code>{name:get_weather, parameters:{city:北京}}</code>（缺引号），程序直接报错。</ul><p>解决 “输出格式不规范”：强制格式约束 + JSON 模式<p>核心思路：<ol><li>用<strong>JSON Schema</strong> 定义输出格式（明确字段名、类型），让模型严格遵循；<li>主流大模型（GPT-3.5/4、Claude、文心一言）都支持 “强制 JSON 输出”，直接指定格式即可。</ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> openai <span class=keyword>import</span> OpenAI</span><br><span class=line>client = OpenAI()</span><br><span class=line></span><br><span class=line><span class=comment># 定义工具描述（含JSON Schema）</span></span><br><span class=line>tools = [</span><br><span class=line>    {</span><br><span class=line>        <span class=string>"type"</span>: <span class=string>"function"</span>,</span><br><span class=line>        <span class=string>"function"</span>: {</span><br><span class=line>            <span class=string>"name"</span>: <span class=string>"get_weather"</span>,</span><br><span class=line>            <span class=string>"description"</span>: <span class=string>"获取指定城市指定日期的气温"</span>,</span><br><span class=line>            <span class=string>"parameters"</span>: {</span><br><span class=line>                <span class=string>"type"</span>: <span class=string>"object"</span>,</span><br><span class=line>                <span class=string>"properties"</span>: {</span><br><span class=line>                    <span class=string>"city"</span>: {</span><br><span class=line>                        <span class=string>"type"</span>: <span class=string>"string"</span>,</span><br><span class=line>                        <span class=string>"description"</span>: <span class=string>"中国城市中文全称，如北京、上海"</span></span><br><span class=line>                    },</span><br><span class=line>                    <span class=string>"date"</span>: {</span><br><span class=line>                        <span class=string>"type"</span>: <span class=string>"string"</span>,</span><br><span class=line>                        <span class=string>"description"</span>: <span class=string>"日期，格式为YYYY-MM-DD，可选，默认当天"</span></span><br><span class=line>                    }</span><br><span class=line>                },</span><br><span class=line>                <span class=string>"required"</span>: [<span class=string>"city"</span>]  <span class=comment># 明确必填参数</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>]</span><br><span class=line></span><br><span class=line><span class=comment># 调用API，强制JSON输出</span></span><br><span class=line>response = client.chat.completions.create(</span><br><span class=line>    model=<span class=string>"gpt-3.5-turbo"</span>,</span><br><span class=line>    messages=[{<span class=string>"role"</span>: <span class=string>"user"</span>, <span class=string>"content"</span>: <span class=string>"查下北京明天的气温"</span>}],</span><br><span class=line>    tools=tools,</span><br><span class=line>    tool_choice=<span class=string>"auto"</span>,  <span class=comment># 让模型自动选择是否调用工具</span></span><br><span class=line>    response_format={<span class=string>"type"</span>: <span class=string>"json_object"</span>}  <span class=comment># 强制JSON格式</span></span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=comment># 解析调用结果</span></span><br><span class=line>tool_call = response.choices[<span class=number>0</span>].message.tool_calls[<span class=number>0</span>]</span><br><span class=line>func_name = tool_call.function.name</span><br><span class=line>func_params = json.loads(tool_call.function.arguments)</span><br><span class=line><span class=built_in>print</span>(<span class=string>f"调用工具：<span class=subst>{func_name}</span>，参数：<span class=subst>{func_params}</span>"</span>)</span><br><span class=line><span class=comment># 输出：调用工具：get_weather，参数：{"city":"北京","date":"2026-02-23"}</span></span><br></pre></table></figure><p>大模型的 “强制 JSON 输出” 不是单一技术，而是<strong>训练阶段的格式对齐 + 推理阶段的约束机制</strong> 共同作用的结果，<h2 id=训练阶段：给模型-“植入”-JSON-语法认知><a title="训练阶段：给模型 “植入” JSON 语法认知" class=headerlink href=#训练阶段：给模型-“植入”-JSON-语法认知></a>训练阶段：给模型 “植入” JSON 语法认知</h2><p>这是所有模型能输出合法 JSON 的基础，也是 “强制输出” 的底层前提。<p>数据层面：大规模 JSON 格式数据注入<ul><li><p>做法</p> <p>：在模型预训练 / 微调阶段，加入海量的 “自然语言 ↔ JSON” 配对数据，比如：</p> <ul><li>输入：“提取北京明天的气温” → 输出：<code>{"city":"北京","date":"明天","action":"查气温"}</code>；<li>输入：“计算 1+2” → 输出：<code>{"operation":"add","num1":1,"num2":2,"result":3}</code>；</ul><li><p><strong>目的</strong>：让模型学习 “自然语言需求” 和 “合法 JSON 结构” 的强映射关系，理解 JSON 的语法规则（双引号、键值对、无多余逗号等）。</p><li><p>关键细节：</p> <ul><li>数据中会包含大量 “错误 JSON 案例 + 修正结果”（比如缺少双引号的 JSON → 模型输出修正后的合法 JSON）；<li>对 GPT-4 这类原生支持 JSON 的模型，还会单独构建 “JSON 语法专项数据集”（包含 JSON Schema 约束、嵌套 JSON、数组等复杂场景）。</ul></ul><p>模型架构层面：针对性的格式约束模块（GPT 专属）<p>OpenAI 为 GPT-3.5-turbo-1106/4 新增了<strong>格式约束头（Format Constraint Head）</strong>，这是其 “原生强制 JSON” 的核心：<ul><li><strong>位置</strong>：在模型的 decoder 层最后，加一个独立的 “语法校验模块”；<li>作用：<ol><li>接收上层输出的 token 序列（比如 <code>{"city":"北京"</code>）；<li>实时校验是否符合 JSON 语法规则（比如是否漏双引号、是否有多余逗号）；<li>对违规的 token 进行 “抑制”（比如模型想输出单引号 <code>'北京'</code>，该模块会降低单引号 token 的概率，提升双引号 <code>"</code> 的概率）；</ol><li><strong>对比</strong>：Claude / 文心一言暂未在模型架构层加这类硬件模块，而是靠后续推理阶段的规则弥补。</ul><p>微调阶段：指令调优（RLHF）强化 JSON 格式<ul><li><p>做法</p> <p>：在人类反馈强化学习（RLHF）阶段，加入 “JSON 格式正确性” 的奖励机制：</p> <ul><li>如果模型输出合法 JSON → 给予高奖励（提升该输出路径的概率）；<li>如果输出非法 JSON（比如缺引号、多逗号）→ 给予惩罚（降低该路径概率）；</ul><li><p><strong>GPT 额外操作</strong>：对 “response_format=json_object” 这类参数，单独做了 “指令调优”，让模型识别到该参数后，直接激活 “JSON 约束模式”。</p></ul><p>推理阶段：实时约束输出，确保 JSON 合法<p>训练阶段是 “让模型会写 JSON”，推理阶段是 “强制模型必须写合法 JSON”，这是 “强制输出” 的核心执行层。<ol><li>GPT 系列：原生语法锁（硬限制）</ol><p>当调用 <code>response_format={"type":"json_object"}</code> 时，模型推理过程会触发以下底层逻辑：模型无法输出任何非 JSON 内容（比如 “以下是结果：” 这类文字），因为格式约束头会直接过滤掉这类 token；<p>如果模型无法生成合法 JSON（比如需求矛盾），会直接终止推理并返回 API 错误，而非输出错误 JSON；<p>生成过程中会自动补全 JSON 缺失部分（比如模型生成 <code>{"city":"北京"</code>，会自动补全 <code>}</code><p>2.Claude 系列：提示词引导 + 生成后校验（软限制）<p>Claude 没有模型层的 “JSON 语法锁”，其 “强制输出” 靠两步实现：<ol><li>推理初期：提示词解析为格式规则<ul><li>模型先解析用户提示词中的 JSON 要求（比如 “仅输出 JSON”“字段名双引号”），将其转化为内部的 “生成规则”；<li>生成时，模型会优先选择符合 JSON 语法的 token（基于训练阶段的认知）。</ul><li>推理后期：生成后语法校验<ul><li>Claude 生成完文本后，会有一个轻量级的 “JSON 校验模块”（属于推理框架，非模型层）；<li>如果检测到 JSON 非法（比如缺逗号），会自动修正后输出；如果无法修正，会重新生成。</ul></ol><ul><li><strong>特点</strong>：依赖提示词的清晰度，没有 GPT 那样的 “硬锁”，但通过训练数据的强引导，成功率接近 100%。</ul><p>不管是哪种模型，“强制 JSON 输出” 最终都会落到 “token 生成的概率控制” 上（这是模型推理的最底层）：<ol><li>Token 概率重加权</ol><ul><li><p>做法</p> <p>：在生成每个 token 时，调整不同 token 的概率：</p> <ul><li>提升 JSON 合规 token 的概率（比如 <code>"</code>、<code>{</code>、<code>}</code>、<code>,</code>）；<li>降低违规 token 的概率（比如 <code>'</code>、<code>：</code>、中文逗号 <code>，</code>、多余的空格）；</ul></ul><ol><li>上下文窗口的格式记忆</ol><ul><li>模型会在推理的上下文窗口中，“记住” 当前的 JSON 结构状态：<ul><li>比如已经生成了 <code>{</code>，模型会记住 “需要闭合 <code>}</code>”；<li>生成了 <code>"city":"北京"</code>，会记住 “下一个可能是 <code>,</code> 或 <code>}</code>”；</ul><li>GPT 的格式约束头会专门维护这个 “JSON 状态机”，而 Claude 靠训练数据的记忆实现。</ul><ol><li>难点 3：工具匹配错误</ol><ul><li>问题表现：模型选错工具（比如用户要算加法，却调用了乘法工具），或没必要调用工具时强行调用（比如用户问 “1+1 等于几”，本可直接回答，却调用计算器工具）。</ul><p>核心思路：<ol><li>给每个工具写<strong>精准、唯一的描述</strong>（避免模糊，比如 “get_weather” 描述为 “仅用于获取城市气温，不包含空气质量、风力”）；<li><p>对高风险调用（比如涉及付费 API），增加 “模型自我确认” 步骤，让模型先判断 “是否需要调用工具”“是否选对工具”。</p><li><p>难点 4：上下文丢失</p></ol><ul><li>问题表现：多轮对话中，模型忘记上一轮的参数（比如用户先问 “北京气温”，接着说 “空气质量呢”，模型没识别出 “北京” 这个上下文参数）。</ul><p>核心思路：<ol><li>把多轮对话中的参数缓存到上下文（比如用户先提 “北京”，后续对话自动带上<code>city="北京"</code>）；<li>若参数缺失，让模型主动追问用户（比如用户说 “查气温”，模型回复 “请问你想查哪个城市的气温？”）</ol><h2 id=记忆系统><a class=headerlink href=#记忆系统 title=记忆系统></a>记忆系统</h2><p>人类的记忆分为短期记忆和长期记忆，AI Agent 的记忆系统也采用了类似的设计。<p>理解这两种记忆的区别和用途，是构建智能 Agent 的基础。<p>短期记忆：Agent 的工作记忆<p>短期记忆就像是 Agent 的工作台，存储当前对话的上下文和临时信息。<p><strong>特点</strong>：<ul><li><strong>容量有限</strong>：通常只能保存最近的几次对话（如最近的 10-20 轮对话）<li><strong>快速访问</strong>：读取和写入速度很快<li><strong>临时性</strong>：对话结束后通常会被清除或压缩<li><strong>上下文相关</strong>：直接影响当前的响应生成</ul><p>长期记忆：Agent 的知识库<p>长期记忆就像是 Agent 的档案室，存储重要的、需要长期保留的信息。<p><strong>特点</strong>：<ul><li><strong>容量大</strong>：可以存储大量信息<li><strong>持久化</strong>：信息会长期保存，不会自动清除<li><strong>检索式访问</strong>：通过查询检索相关信息，而非顺序读取<li><strong>结构化存储</strong>：信息通常以结构化方式存储，便于检索</ul><p><strong>主要用途</strong>：<ul><li>存储用户的个人信息和偏好<li>积累知识和经验<li>记住重要的对话内容<li>保存任务执行结果</ul><h3 id=对话历史管理><a class=headerlink href=#对话历史管理 title=对话历史管理></a>对话历史管理</h3><h3 id=基本的对话历史管理><a class=headerlink href=#基本的对话历史管理 title=基本的对话历史管理></a>基本的对话历史管理</h3><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>ConversationManager</span>:</span></span><br><span class=line>    <span class=string>"""对话管理器"""</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, max_context_length=<span class=number>4000</span></span>):</span></span><br><span class=line>        self.max_context_length = max_context_length  <span class=comment># 最大token数</span></span><br><span class=line>        self.history = []  <span class=comment># 完整的对话历史</span></span><br><span class=line>        self.active_context = []  <span class=comment># 当前活跃的上下文</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>add_exchange</span>(<span class=params>self, user_input, assistant_response</span>):</span></span><br><span class=line>        <span class=string>"""添加一轮对话"""</span></span><br><span class=line>        self.history.append({</span><br><span class=line>            <span class=string>"user"</span>: user_input,</span><br><span class=line>            <span class=string>"assistant"</span>: assistant_response,</span><br><span class=line>            <span class=string>"timestamp"</span>: time.time()</span><br><span class=line>        })</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>build_context</span>(<span class=params>self, current_query, include_history=<span class=literal>True</span></span>):</span></span><br><span class=line>        <span class=string>"""构建当前查询的上下文"""</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> <span class=keyword>not</span> include_history <span class=keyword>or</span> <span class=keyword>not</span> self.history:</span><br><span class=line>            <span class=comment># 没有历史或不需要历史，只返回当前查询</span></span><br><span class=line>            <span class=keyword>return</span> [{<span class=string>"role"</span>: <span class=string>"user"</span>, <span class=string>"content"</span>: current_query}]</span><br><span class=line></span><br><span class=line>        <span class=comment># 从最近的对话开始，逐步添加历史，直到达到长度限制</span></span><br><span class=line>        context = []</span><br><span class=line>        context_length = self.estimate_tokens(current_query)</span><br><span class=line></span><br><span class=line>        <span class=comment># 添加当前查询</span></span><br><span class=line>        context.insert(<span class=number>0</span>, {<span class=string>"role"</span>: <span class=string>"user"</span>, <span class=string>"content"</span>: current_query})</span><br><span class=line></span><br><span class=line>        <span class=comment># 从最近到最远添加历史</span></span><br><span class=line>        <span class=keyword>for</span> exchange <span class=keyword>in</span> <span class=built_in>reversed</span>(self.history):</span><br><span class=line>            user_tokens = self.estimate_tokens(exchange[<span class=string>"user"</span>])</span><br><span class=line>            assistant_tokens = self.estimate_tokens(exchange[<span class=string>"assistant"</span>])</span><br><span class=line></span><br><span class=line>            <span class=comment># 检查是否会超出限制</span></span><br><span class=line>            <span class=keyword>if</span> context_length + user_tokens + assistant_tokens > self.max_context_length:</span><br><span class=line>                <span class=keyword>break</span></span><br><span class=line></span><br><span class=line>            <span class=comment># 添加助理回复（在用户输入之前）</span></span><br><span class=line>            context.insert(<span class=number>0</span>, {<span class=string>"role"</span>: <span class=string>"assistant"</span>, <span class=string>"content"</span>: exchange[<span class=string>"assistant"</span>]})</span><br><span class=line>            context.insert(<span class=number>0</span>, {<span class=string>"role"</span>: <span class=string>"user"</span>, <span class=string>"content"</span>: exchange[<span class=string>"user"</span>]})</span><br><span class=line></span><br><span class=line>            context_length += user_tokens + assistant_tokens</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> context</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>estimate_tokens</span>(<span class=params>self, text</span>):</span></span><br><span class=line>        <span class=string>"""粗略估计文本的token数量（实际应用中应使用准确的tokenizer）"""</span></span><br><span class=line>        <span class=comment># 简单估算：英文约0.75单词/token，中文约1-2字符/token</span></span><br><span class=line>        <span class=keyword>if</span> self.is_chinese(text):</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>len</span>(text) // <span class=number>2</span>  <span class=comment># 中文每2字符约1个token</span></span><br><span class=line>        <span class=keyword>else</span>:</span><br><span class=line>            words = <span class=built_in>len</span>(text.split())</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>int</span>(words * <span class=number>1.3</span>)  <span class=comment># 英文每单词约1.3个token</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>is_chinese</span>(<span class=params>self, text</span>):</span></span><br><span class=line>        <span class=string>"""判断文本是否主要为中文"""</span></span><br><span class=line>        chinese_chars = <span class=built_in>sum</span>(<span class=number>1</span> <span class=keyword>for</span> c <span class=keyword>in</span> text <span class=keyword>if</span> <span class=string>'\u4e00'</span> <= c <= <span class=string>'\u9fff'</span>)</span><br><span class=line>        <span class=keyword>return</span> chinese_chars / <span class=built_in>max</span>(<span class=built_in>len</span>(text), <span class=number>1</span>) > <span class=number>0.3</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>clear_history</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=string>"""清空对话历史"""</span></span><br><span class=line>        self.history.clear()</span><br><span class=line>        self.active_context.clear()</span><br></pre></table></figure><h3 id=智能历史选择策略><a class=headerlink href=#智能历史选择策略 title=智能历史选择策略></a>智能历史选择策略</h3><p>不是所有历史对话都同样重要。智能的历史选择可以提高上下文的使用效率：<h4 id=1-基于时间的衰减><a title="1. 基于时间的衰减" class=headerlink href=#1-基于时间的衰减></a>1. 基于时间的衰减</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>def</span> <span class=title>time_based_selection</span>(<span class=params>history, current_time, max_items=<span class=number>10</span></span>):</span></span><br><span class=line>    <span class=string>"""基于时间的选择：越近的对话权重越高"""</span></span><br><span class=line>    scored_items = []</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> item <span class=keyword>in</span> history:</span><br><span class=line>        <span class=comment># 计算时间衰减分数（越近分数越高）</span></span><br><span class=line>        time_diff = current_time - item[<span class=string>"timestamp"</span>]</span><br><span class=line>        time_score = <span class=built_in>max</span>(<span class=number>0</span>, <span class=number>1</span> - time_diff / <span class=number>3600</span>)  <span class=comment># 1小时内完全保留，之后衰减</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 结合其他因素（如对话长度、重要性标记等）</span></span><br><span class=line>        total_score = time_score</span><br><span class=line></span><br><span class=line>        scored_items.append((total_score, item))</span><br><span class=line></span><br><span class=line>    <span class=comment># 按分数排序，选择分数最高的</span></span><br><span class=line>    scored_items.sort(key=<span class=keyword>lambda</span> x: x[<span class=number>0</span>], reverse=<span class=literal>True</span>)</span><br><span class=line>    <span class=keyword>return</span> [item <span class=keyword>for</span> score, item <span class=keyword>in</span> scored_items[:max_items]]</span><br></pre></table></figure><h4 id=2-基于相关性的选择><a title="2. 基于相关性的选择" class=headerlink href=#2-基于相关性的选择></a>2. 基于相关性的选择</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>def</span> <span class=title>relevance_based_selection</span>(<span class=params>history, current_query, embedding_model, max_items=<span class=number>5</span></span>):</span></span><br><span class=line>    <span class=string>"""基于与当前查询相关性的选择"""</span></span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> history:</span><br><span class=line>        <span class=keyword>return</span> []</span><br><span class=line></span><br><span class=line>    <span class=comment># 计算当前查询的向量</span></span><br><span class=line>    query_embedding = embedding_model.encode(current_query)</span><br><span class=line></span><br><span class=line>    scored_items = []</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> item <span class=keyword>in</span> history:</span><br><span class=line>        <span class=comment># 将历史对话内容转换为向量</span></span><br><span class=line>        content = item[<span class=string>"user"</span>] + <span class=string>" "</span> + item[<span class=string>"assistant"</span>]</span><br><span class=line>        content_embedding = embedding_model.encode(content)</span><br><span class=line></span><br><span class=line>        <span class=comment># 计算余弦相似度</span></span><br><span class=line>        similarity = cosine_similarity([query_embedding], [content_embedding])[<span class=number>0</span>][<span class=number>0</span>]</span><br><span class=line></span><br><span class=line>        scored_items.append((similarity, item))</span><br><span class=line></span><br><span class=line>    <span class=comment># 按相似度排序，选择最相关的</span></span><br><span class=line>    scored_items.sort(key=<span class=keyword>lambda</span> x: x[<span class=number>0</span>], reverse=<span class=literal>True</span>)</span><br><span class=line>    <span class=keyword>return</span> [item <span class=keyword>for</span> similarity, item <span class=keyword>in</span> scored_items[:max_items]]</span><br></pre></table></figure><h4 id=3-混合选择策略><a title="3. 混合选择策略" class=headerlink href=#3-混合选择策略></a>3. 混合选择策略</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>SmartHistorySelector</span>:</span></span><br><span class=line>    <span class=string>"""智能历史选择器"""</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, embedding_model=<span class=literal>None</span></span>):</span></span><br><span class=line>        self.embedding_model = embedding_model</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>select_history</span>(<span class=params>self, history, current_query, max_context_length=<span class=number>3000</span></span>):</span></span><br><span class=line>        <span class=string>"""智能选择历史对话"""</span></span><br><span class=line></span><br><span class=line>        selected = []</span><br><span class=line>        current_length = <span class=number>0</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 策略1：总是包含最近的一轮对话</span></span><br><span class=line>        <span class=keyword>if</span> history:</span><br><span class=line>            recent = history[-<span class=number>1</span>]</span><br><span class=line>            recent_length = self.estimate_length(recent)</span><br><span class=line>            <span class=keyword>if</span> recent_length <= max_context_length:</span><br><span class=line>                selected.append(recent)</span><br><span class=line>                current_length += recent_length</span><br><span class=line></span><br><span class=line>        <span class=comment># 策略2：基于相关性的选择</span></span><br><span class=line>        <span class=keyword>if</span> self.embedding_model <span class=keyword>and</span> <span class=built_in>len</span>(history) > <span class=number>1</span>:</span><br><span class=line>            relevant = self.select_by_relevance(history[:-<span class=number>1</span>], current_query, <span class=number>3</span>)</span><br><span class=line>            <span class=keyword>for</span> item <span class=keyword>in</span> relevant:</span><br><span class=line>                item_length = self.estimate_length(item)</span><br><span class=line>                <span class=keyword>if</span> current_length + item_length <= max_context_length:</span><br><span class=line>                    selected.append(item)</span><br><span class=line>                    current_length += item_length</span><br><span class=line></span><br><span class=line>        <span class=comment># 策略3：如果还有空间，按时间顺序添加</span></span><br><span class=line>        remaining_space = max_context_length - current_length</span><br><span class=line>        <span class=keyword>if</span> remaining_space > <span class=number>100</span>:  <span class=comment># 至少100token的空间</span></span><br><span class=line>            <span class=keyword>for</span> item <span class=keyword>in</span> history:</span><br><span class=line>                <span class=keyword>if</span> item <span class=keyword>not</span> <span class=keyword>in</span> selected:</span><br><span class=line>                    item_length = self.estimate_length(item)</span><br><span class=line>                    <span class=keyword>if</span> item_length <= remaining_space:</span><br><span class=line>                        selected.append(item)</span><br><span class=line>                        remaining_space -= item_length</span><br><span class=line></span><br><span class=line>        <span class=comment># 按时间顺序排序</span></span><br><span class=line>        selected.sort(key=<span class=keyword>lambda</span> x: x[<span class=string>"timestamp"</span>])</span><br><span class=line>        <span class=keyword>return</span> selected</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>select_by_relevance</span>(<span class=params>self, history, query, max_items</span>):</span></span><br><span class=line>        <span class=string>"""基于相关性选择"""</span></span><br><span class=line>        <span class=comment># 简化实现，实际应使用向量相似度</span></span><br><span class=line>        query_lower = query.lower()</span><br><span class=line>        scored = []</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> item <span class=keyword>in</span> history:</span><br><span class=line>            content = (item[<span class=string>"user"</span>] + <span class=string>" "</span> + item[<span class=string>"assistant"</span>]).lower()</span><br><span class=line>            <span class=comment># 简单关键词匹配</span></span><br><span class=line>            score = <span class=built_in>sum</span>(<span class=number>1</span> <span class=keyword>for</span> word <span class=keyword>in</span> query_lower.split() <span class=keyword>if</span> word <span class=keyword>in</span> content)</span><br><span class=line>            scored.append((score, item))</span><br><span class=line></span><br><span class=line>        scored.sort(key=<span class=keyword>lambda</span> x: x[<span class=number>0</span>], reverse=<span class=literal>True</span>)</span><br><span class=line>        <span class=keyword>return</span> [item <span class=keyword>for</span> score, item <span class=keyword>in</span> scored[:max_items]]</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>estimate_length</span>(<span class=params>self, exchange</span>):</span></span><br><span class=line>        <span class=string>"""估计对话长度"""</span></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>len</span>(exchange[<span class=string>"user"</span>]) + <span class=built_in>len</span>(exchange[<span class=string>"assistant"</span>])</span><br></pre></table></figure><h3 id=记忆压缩与总结策略><a class=headerlink href=#记忆压缩与总结策略 title=记忆压缩与总结策略></a>记忆压缩与总结策略</h3><p>随着对话的进行，记忆会不断累积。为了避免信息过载和减少资源消耗，需要定期对记忆进行压缩和总结。<h3 id=记忆压缩策略><a class=headerlink href=#记忆压缩策略 title=记忆压缩策略></a>记忆压缩策略</h3><h4 id=1-基于重要性的压缩><a title="1. 基于重要性的压缩" class=headerlink href=#1-基于重要性的压缩></a>1. 基于重要性的压缩</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>ImportanceBasedCompressor</span>:</span></span><br><span class=line>    <span class=string>"""基于重要性的记忆压缩器"""</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, llm_client</span>):</span></span><br><span class=line>        self.llm = llm_client</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>compress_memories</span>(<span class=params>self, memories, target_ratio=<span class=number>0.5</span></span>):</span></span><br><span class=line>        <span class=string>"""压缩记忆，保留重要内容"""</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> <span class=built_in>len</span>(memories) <= <span class=number>1</span>:</span><br><span class=line>            <span class=keyword>return</span> memories  <span class=comment># 记忆太少，不需要压缩</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 评估每个记忆的重要性</span></span><br><span class=line>        scored_memories = []</span><br><span class=line>        <span class=keyword>for</span> memory <span class=keyword>in</span> memories:</span><br><span class=line>            importance = self.evaluate_importance(memory)</span><br><span class=line>            scored_memories.append((importance, memory))</span><br><span class=line></span><br><span class=line>        <span class=comment># 按重要性排序</span></span><br><span class=line>        scored_memories.sort(key=<span class=keyword>lambda</span> x: x[<span class=number>0</span>], reverse=<span class=literal>True</span>)</span><br><span class=line></span><br><span class=line>        <span class=comment># 保留最重要的部分</span></span><br><span class=line>        keep_count = <span class=built_in>max</span>(<span class=number>1</span>, <span class=built_in>int</span>(<span class=built_in>len</span>(memories) * target_ratio))</span><br><span class=line>        compressed_memories = [memory <span class=keyword>for</span> _, memory <span class=keyword>in</span> scored_memories[:keep_count]]</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> compressed_memories</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>evaluate_importance</span>(<span class=params>self, memory</span>):</span></span><br><span class=line>        <span class=string>"""评估记忆的重要性"""</span></span><br><span class=line>        content = memory[<span class=string>"content"</span>]</span><br><span class=line>        metadata = memory.get(<span class=string>"metadata"</span>, {})</span><br><span class=line></span><br><span class=line>        <span class=comment># 基于规则的重要性评估</span></span><br><span class=line>        importance_score = <span class=number>0.0</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 1. 基于类型</span></span><br><span class=line>        memory_type = metadata.get(<span class=string>"type"</span>, <span class=string>""</span>)</span><br><span class=line>        <span class=keyword>if</span> memory_type == <span class=string>"personal_info"</span>:</span><br><span class=line>            importance_score += <span class=number>0.8</span></span><br><span class=line>        <span class=keyword>elif</span> memory_type == <span class=string>"preference"</span>:</span><br><span class=line>            importance_score += <span class=number>0.7</span></span><br><span class=line>        <span class=keyword>elif</span> memory_type == <span class=string>"fact"</span>:</span><br><span class=line>            importance_score += <span class=number>0.5</span></span><br><span class=line>        <span class=keyword>elif</span> memory_type == <span class=string>"conversation"</span>:</span><br><span class=line>            importance_score += <span class=number>0.3</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 2. 基于长度（适中的长度可能更重要）</span></span><br><span class=line>        content_length = <span class=built_in>len</span>(content)</span><br><span class=line>        <span class=keyword>if</span> <span class=number>50</span> <= content_length <= <span class=number>500</span>:</span><br><span class=line>            importance_score += <span class=number>0.2</span></span><br><span class=line>        <span class=keyword>elif</span> content_length > <span class=number>500</span>:</span><br><span class=line>            importance_score += <span class=number>0.1</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 3. 基于时间衰减（越新的记忆越重要）</span></span><br><span class=line>        timestamp = metadata.get(<span class=string>"timestamp"</span>, <span class=number>0</span>)</span><br><span class=line>        <span class=keyword>if</span> timestamp > <span class=number>0</span>:</span><br><span class=line>            age_days = (time.time() - timestamp) / (<span class=number>24</span> * <span class=number>3600</span>)</span><br><span class=line>            recency_score = <span class=built_in>max</span>(<span class=number>0</span>, <span class=number>1</span> - age_days / <span class=number>30</span>)  <span class=comment># 30天内线性衰减</span></span><br><span class=line>            importance_score += recency_score * <span class=number>0.5</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 4. 基于显式重要性标记</span></span><br><span class=line>        explicit_importance = metadata.get(<span class=string>"importance"</span>, <span class=number>0.5</span>)</span><br><span class=line>        importance_score += explicit_importance * <span class=number>0.5</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>min</span>(importance_score, <span class=number>1.0</span>)  <span class=comment># 归一化到0-1</span></span><br></pre></table></figure><h4 id=2-基于聚类的压缩><a title="2. 基于聚类的压缩" class=headerlink href=#2-基于聚类的压缩></a>2. 基于聚类的压缩</h4><p>将相似记忆聚类，然后总结每个聚类：<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> sklearn.cluster <span class=keyword>import</span> KMeans</span><br><span class=line><span class=keyword>import</span> numpy <span class=keyword>as</span> np</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>ClusterBasedCompressor</span>:</span></span><br><span class=line>    <span class=string>"""基于聚类的记忆压缩器"""</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, embedding_model</span>):</span></span><br><span class=line>        self.embedding_model = embedding_model</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>compress_by_clustering</span>(<span class=params>self, memories, n_clusters=<span class=literal>None</span></span>):</span></span><br><span class=line>        <span class=string>"""通过聚类压缩记忆"""</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> <span class=built_in>len</span>(memories) <= <span class=number>3</span>:</span><br><span class=line>            <span class=keyword>return</span> memories  <span class=comment># 记忆太少，不需要聚类</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 确定聚类数量</span></span><br><span class=line>        <span class=keyword>if</span> n_clusters <span class=keyword>is</span> <span class=literal>None</span>:</span><br><span class=line>            n_clusters = <span class=built_in>min</span>(<span class=number>3</span>, <span class=built_in>len</span>(memories) // <span class=number>2</span>)</span><br><span class=line></span><br><span class=line>        <span class=comment># 获取所有记忆的embedding</span></span><br><span class=line>        embeddings = []</span><br><span class=line>        <span class=keyword>for</span> memory <span class=keyword>in</span> memories:</span><br><span class=line>            embedding = self.embedding_model.encode(memory[<span class=string>"content"</span>])</span><br><span class=line>            embeddings.append(embedding)</span><br><span class=line></span><br><span class=line>        embeddings = np.array(embeddings)</span><br><span class=line></span><br><span class=line>        <span class=comment># 执行K-means聚类</span></span><br><span class=line>        kmeans = KMeans(n_clusters=n_clusters, random_state=<span class=number>42</span>, n_init=<span class=number>10</span>)</span><br><span class=line>        labels = kmeans.fit_predict(embeddings)</span><br><span class=line></span><br><span class=line>        <span class=comment># 对每个聚类进行总结</span></span><br><span class=line>        compressed_memories = []</span><br><span class=line>        <span class=keyword>for</span> cluster_id <span class=keyword>in</span> <span class=built_in>range</span>(n_clusters):</span><br><span class=line>            <span class=comment># 获取该聚类的所有记忆</span></span><br><span class=line>            cluster_memories = [</span><br><span class=line>                memories[i] <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=built_in>len</span>(memories)) <span class=keyword>if</span> labels[i] == cluster_id</span><br><span class=line>            ]</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> cluster_memories:</span><br><span class=line>                <span class=comment># 总结该聚类的记忆</span></span><br><span class=line>                summary = self.summarize_cluster(cluster_memories)</span><br><span class=line>                compressed_memories.append(summary)</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> compressed_memories</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>summarize_cluster</span>(<span class=params>self, cluster_memories</span>):</span></span><br><span class=line>        <span class=string>"""总结一个聚类的记忆"""</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> <span class=built_in>len</span>(cluster_memories) == <span class=number>1</span>:</span><br><span class=line>            <span class=comment># 只有一个记忆，直接返回</span></span><br><span class=line>            <span class=keyword>return</span> cluster_memories[<span class=number>0</span>]</span><br><span class=line></span><br><span class=line>        <span class=comment># 合并所有记忆内容</span></span><br><span class=line>        all_content = <span class=string>"\n"</span>.join([m[<span class=string>"content"</span>] <span class=keyword>for</span> m <span class=keyword>in</span> cluster_memories])</span><br><span class=line></span><br><span class=line>        <span class=comment># 使用LLM生成总结（这里简化实现）</span></span><br><span class=line>        <span class=comment># 实际应调用LLM生成高质量的总结</span></span><br><span class=line>        summary_content = <span class=string>f"相关主题的<span class=subst>{<span class=built_in>len</span>(cluster_memories)}</span>条记忆摘要：<span class=subst>{all_content[:<span class=number>500</span>]}</span>..."</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 合并元数据</span></span><br><span class=line>        merged_metadata = {</span><br><span class=line>            <span class=string>"type"</span>: <span class=string>"cluster_summary"</span>,</span><br><span class=line>            <span class=string>"original_count"</span>: <span class=built_in>len</span>(cluster_memories),</span><br><span class=line>            <span class=string>"compressed"</span>: <span class=literal>True</span>,</span><br><span class=line>            <span class=string>"timestamp"</span>: time.time()</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> {</span><br><span class=line>            <span class=string>"content"</span>: summary_content,</span><br><span class=line>            <span class=string>"metadata"</span>: merged_metadata</span><br><span class=line>        }</span><br></pre></table></figure><h4 id=3-增量总结策略><a title="3. 增量总结策略" class=headerlink href=#3-增量总结策略></a>3. 增量总结策略</h4><p>在对话过程中逐步总结，而不是一次性处理所有历史：<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>IncrementalSummarizer</span>:</span></span><br><span class=line>    <span class=string>"""增量总结器"""</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>__init__</span>(<span class=params>self, llm_client, summary_interval=<span class=number>5</span></span>):</span></span><br><span class=line>        self.llm = llm_client</span><br><span class=line>        self.summary_interval = summary_interval  <span class=comment># 每多少轮对话总结一次</span></span><br><span class=line>        self.conversation_buffer = []</span><br><span class=line>        self.summaries = []</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>add_conversation</span>(<span class=params>self, user_input, assistant_response</span>):</span></span><br><span class=line>        <span class=string>"""添加对话到缓冲区"""</span></span><br><span class=line></span><br><span class=line>        self.conversation_buffer.append({</span><br><span class=line>            <span class=string>"user"</span>: user_input,</span><br><span class=line>            <span class=string>"assistant"</span>: assistant_response,</span><br><span class=line>            <span class=string>"timestamp"</span>: time.time()</span><br><span class=line>        })</span><br><span class=line></span><br><span class=line>        <span class=comment># 检查是否需要总结</span></span><br><span class=line>        <span class=keyword>if</span> <span class=built_in>len</span>(self.conversation_buffer) >= self.summary_interval:</span><br><span class=line>            self.create_summary()</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>create_summary</span>(<span class=params>self</span>):</span></span><br><span class=line>        <span class=string>"""创建总结"""</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> <span class=keyword>not</span> self.conversation_buffer:</span><br><span class=line>            <span class=keyword>return</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 将对话缓冲区的所有内容总结为一段文字</span></span><br><span class=line>        conversation_text = <span class=string>""</span></span><br><span class=line>        <span class=keyword>for</span> exchange <span class=keyword>in</span> self.conversation_buffer:</span><br><span class=line>            conversation_text += <span class=string>f"用户: <span class=subst>{exchange[<span class=string>'user'</span>]}</span>\n"</span></span><br><span class=line>            conversation_text += <span class=string>f"助理: <span class=subst>{exchange[<span class=string>'assistant'</span>]}</span>\n\n"</span></span><br><span class=line></span><br><span class=line>        <span class=comment># 使用LLM生成总结</span></span><br><span class=line>        prompt = <span class=string>f"""</span></span><br><span class=line><span class=string>请将以下对话内容总结为一个简短的段落，保留核心信息和重要细节：</span></span><br><span class=line><span class=string></span></span><br><span class=line><span class=string>对话内容：</span></span><br><span class=line><span class=string><span class=subst>{conversation_text}</span></span></span><br><span class=line><span class=string></span></span><br><span class=line><span class=string>总结要求：</span></span><br><span class=line><span class=string>1. 不超过200字</span></span><br><span class=line><span class=string>2. 保留用户的主要需求和助理的关键回答</span></span><br><span class=line><span class=string>3. 忽略问候语、重复内容和无关细节</span></span><br><span class=line><span class=string></span></span><br><span class=line><span class=string>总结：</span></span><br><span class=line><span class=string>"""</span></span><br><span class=line></span><br><span class=line>        summary = self.llm.generate(prompt, max_tokens=<span class=number>200</span>)</span><br><span class=line></span><br><span class=line>        <span class=comment># 保存总结</span></span><br><span class=line>        self.summaries.append({</span><br><span class=line>            <span class=string>"content"</span>: summary,</span><br><span class=line>            <span class=string>"timestamp"</span>: time.time(),</span><br><span class=line>            <span class=string>"original_count"</span>: <span class=built_in>len</span>(self.conversation_buffer)</span><br><span class=line>        })</span><br><span class=line></span><br><span class=line>        <span class=comment># 清空缓冲区</span></span><br><span class=line>        self.conversation_buffer.clear()</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>def</span> <span class=title>get_context</span>(<span class=params>self, include_recent=<span class=literal>True</span>, include_summaries=<span class=literal>True</span></span>):</span></span><br><span class=line>        <span class=string>"""获取上下文"""</span></span><br><span class=line></span><br><span class=line>        context_parts = []</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> include_summaries <span class=keyword>and</span> self.summaries:</span><br><span class=line>            <span class=comment># 添加所有总结</span></span><br><span class=line>            <span class=keyword>for</span> i, summary <span class=keyword>in</span> <span class=built_in>enumerate</span>(self.summaries[-<span class=number>3</span>:]):  <span class=comment># 最多3个总结</span></span><br><span class=line>                context_parts.append(<span class=string>f"[对话总结 <span class=subst>{i+<span class=number>1</span>}</span>]\n<span class=subst>{summary[<span class=string>'content'</span>]}</span>"</span>)</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> include_recent <span class=keyword>and</span> self.conversation_buffer:</span><br><span class=line>            <span class=comment># 添加最近的对话</span></span><br><span class=line>            <span class=keyword>for</span> exchange <span class=keyword>in</span> self.conversation_buffer[-<span class=number>3</span>:]:  <span class=comment># 最多3轮最近对话</span></span><br><span class=line>                context_parts.append(<span class=string>f"用户: <span class=subst>{exchange[<span class=string>'user'</span>]}</span>"</span>)</span><br><span class=line>                context_parts.append(<span class=string>f"助理: <span class=subst>{exchange[<span class=string>'assistant'</span>]}</span>"</span>)</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> <span class=string>"\n\n"</span>.join(context_parts)</span><br></pre></table></figure><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2026/01/12/RAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/ title=RAG系统设计>https://www.sekyoro.top/2026/01/12/RAG系统设计/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/2026/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/ rel=prev title=从零开始大数据> <i class="fa fa-chevron-left"></i> 从零开始大数据 </a></div><div class=post-nav-item><a href=/2026/01/16/%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93/ rel=next title=智力题总结> 智力题总结 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#RAG%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>1.</span> <span class=nav-text>RAG应用场景</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Fine-tuning-vs-RAG><span class=nav-number>2.</span> <span class=nav-text>Fine-tuning vs RAG</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91><span class=nav-number>2.1.</span> <span class=nav-text>未来方向</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#IM%E7%B3%BB%E7%BB%9F><span class=nav-number></span> <span class=nav-text>IM系统</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Netty-%E8%87%AA%E5%AE%9A%E4%B9%89-WebSocket-%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF><span class=nav-number>0.0.1.</span> <span class=nav-text>Netty + 自定义 WebSocket 实现高性能即时通讯</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Redisson-%E7%BC%93%E5%AD%98%E4%BC%9A%E8%AF%9D-amp-%E7%94%A8%E6%88%B7%E8%B7%AF%E7%94%B1%EF%BC%88%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%EF%BC%89><span class=nav-number>0.0.2.</span> <span class=nav-text>Redisson 缓存会话 & 用户路由（解决集群状态同步）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%A6%BB%E7%BA%BF%E6%B6%88%E6%81%AF%E5%A2%9E%E9%87%8F%E6%8B%89%E5%8F%96%EF%BC%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%89><span class=nav-number>0.0.3.</span> <span class=nav-text>离线消息增量拉取（保证消息有序不丢失）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#IM%E7%B3%BB%E7%BB%9F%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%EF%BC%88%E6%9C%89%E5%BA%8F%E3%80%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E3%80%81%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%89><span class=nav-number>0.0.4.</span> <span class=nav-text>IM系统保证消息的可靠（有序、不丢失、不重复）</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%8C%E6%8E%A5%E6%94%B6%E7%A1%AE%E8%AE%A4%E3%80%8D%EF%BC%88%E7%AC%AC%E4%B8%80%E5%B1%82%E5%85%9C%E5%BA%95%EF%BC%89><span class=nav-number>0.0.4.1.</span> <span class=nav-text>服务端「接收确认」（第一层兜底）</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BD%AC%E5%8F%91%E9%98%B6%E6%AE%B5%EF%BC%9A%E9%81%BF%E5%85%8D%E3%80%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%88%B0%E4%BD%86-B-%E6%94%B6%E4%B8%8D%E5%88%B0%E3%80%8D><span class=nav-number>0.0.5.</span> <span class=nav-text>服务端转发阶段：避免「服务端收到但 B 收不到」</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E6%8A%95%E9%80%92%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA><span class=nav-number>0.0.5.1.</span> <span class=nav-text>消息持久化 + 投递状态跟踪</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%EF%BC%9A%E5%8F%AF%E9%9D%A0%E5%B9%BF%E6%92%AD%E6%9B%BF%E4%BB%A3%E6%99%AE%E9%80%9A-Topic><span class=nav-number>0.0.5.2.</span> <span class=nav-text>集群环境：可靠广播替代普通 Topic</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8E%A5%E6%94%B6%E7%AB%AF%EF%BC%88B%EF%BC%89%EF%BC%9A%E9%81%BF%E5%85%8D%E3%80%8C%E6%94%B6%E5%88%B0%E4%BD%86%E6%B2%A1%E7%A1%AE%E8%AE%A4%E3%80%8D><span class=nav-number>0.0.6.</span> <span class=nav-text>接收端（B）：避免「收到但没确认」</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%881%EF%BC%89%E6%8E%A5%E6%94%B6-%E5%B7%B2%E8%AF%BB%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9B%9E%E6%89%A7%EF%BC%89><span class=nav-number>0.0.6.1.</span> <span class=nav-text>（1）接收 / 已读确认机制（回执）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%882%EF%BC%89%E5%B9%82%E7%AD%89%E5%8E%BB%E9%87%8D%EF%BC%9A%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF><span class=nav-number>0.0.6.2.</span> <span class=nav-text>（2）幂等去重：避免重复消息</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%881%EF%BC%89%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%88DLQ%EF%BC%89%EF%BC%9A%E5%A4%84%E7%90%86%E5%A4%9A%E6%AC%A1%E9%87%8D%E8%AF%95%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B6%88%E6%81%AF><span class=nav-number>0.0.6.3.</span> <span class=nav-text>（1）死信队列（DLQ）：处理多次重试失败的消息</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%882%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9A%E4%BF%9D%E9%9A%9C%E3%80%8C%E5%AD%98%E5%82%A8-%E6%8A%95%E9%80%92%E3%80%8D%E5%8E%9F%E5%AD%90%E6%80%A7><span class=nav-number>0.0.6.4.</span> <span class=nav-text>（2）分布式事务：保障「存储 + 投递」原子性</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE-60-%E7%A7%92%E8%AF%BB%E8%B6%85%E6%97%B6%EF%BC%9F%E5%86%99%E8%B6%85%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE-0%EF%BC%9F><span class=nav-number>0.0.7.</span> <span class=nav-text>心跳机制为什么设 60 秒读超时？写超时为什么设 0？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%9B%86%E7%BE%A4%E4%B8%8B%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E6%8E%A8%E9%94%99%E3%80%81%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%9F><span class=nav-number>0.0.8.</span> <span class=nav-text>集群下怎么保证消息不推错、不重复？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%A6%BB%E7%BA%BF%E6%B6%88%E6%81%AF%E5%A2%9E%E9%87%8F%E6%8B%89%E5%8F%96%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%EF%BC%9F><span class=nav-number>0.0.9.</span> <span class=nav-text>离线消息增量拉取怎么保证有序？</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0><span class=nav-number></span> <span class=nav-text>文件分片上传、断点续传</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#RAG%E6%A3%80%E7%B4%A2%E6%B5%81%E6%B0%B4%E7%BA%BF><span class=nav-number></span> <span class=nav-text>RAG检索流水线</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%87%E7%89%87%E3%80%81%E5%90%91%E9%87%8F%E5%85%A5%E5%BA%93><span class=nav-number></span> <span class=nav-text>文件解析与切片、向量入库</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%96%87%E6%A1%A3%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F-%E5%99%AA%E5%A3%B0%E6%B8%85%E6%B4%97%EF%BC%89><span class=nav-number>1.</span> <span class=nav-text>文档预处理（统一格式 + 噪声清洗）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%9A%E6%A0%BC%E5%BC%8F%E6%96%87%E6%9C%AC%E6%8F%90%E5%8F%96><span class=nav-number>1.1.</span> <span class=nav-text>多格式文本提取</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-%E5%99%AA%E5%A3%B0%E6%B8%85%E6%B4%97><span class=nav-number>1.2.</span> <span class=nav-text>2. 噪声清洗</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B1%82%E7%BA%A7%E6%A0%91%E6%9E%84%E5%BB%BA%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4%EF%BC%88%E4%BB%8E%E9%A1%B6%E5%B1%82%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89><span class=nav-number>2.</span> <span class=nav-text>层级树构建核心步骤（从顶层到叶子节点）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E7%AB%A0%E8%8A%82%E7%BA%A7%E5%88%86%E7%89%87%EF%BC%88%E6%A0%91%E7%9A%84%E3%80%8C%E5%88%86%E6%94%AF%E8%8A%82%E7%82%B9%E3%80%8D%EF%BC%89><span class=nav-number>2.1.</span> <span class=nav-text>步骤 1：章节级分片（树的「分支节点」）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E7%AB%A0%E8%8A%82%E8%BE%B9%E7%95%8C%E5%88%A4%E5%AE%9A%E8%A7%84%E5%88%99%EF%BC%88%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%8E%E9%AB%98%E5%88%B0%E4%BD%8E%EF%BC%89><span class=nav-number>2.1.1.</span> <span class=nav-text>1. 章节边界判定规则（优先级从高到低）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AB%A0%E8%8A%82%E8%8A%82%E7%82%B9%E7%94%9F%E6%88%90><span class=nav-number>2.1.2.</span> <span class=nav-text>. 章节节点生成</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E6%AE%B5%E8%90%BD%E7%BA%A7%E5%88%86%E7%89%87%EF%BC%88%E6%A0%91%E7%9A%84%E3%80%8C%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9%E3%80%8D%EF%BC%89><span class=nav-number>2.2.</span> <span class=nav-text>步骤 2：段落级分片（树的「中间节点」）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E6%AE%B5%E8%90%BD%E8%BE%B9%E7%95%8C%E5%88%A4%E5%AE%9A%E8%A7%84%E5%88%99><span class=nav-number>2.2.1.</span> <span class=nav-text>1. 段落边界判定规则</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E6%AE%B5%E8%90%BD%E8%8A%82%E7%82%B9%E7%94%9F%E6%88%90><span class=nav-number>2.2.2.</span> <span class=nav-text>2. 段落节点生成</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E5%8F%A5%E5%AD%90%E7%BA%A7%E5%88%86%E7%89%87%EF%BC%88%E6%A0%91%E7%9A%84%E3%80%8C%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E3%80%8D%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%90%91%E9%87%8F%E5%8D%95%E5%85%83%EF%BC%89><span class=nav-number>2.3.</span> <span class=nav-text>步骤 3：句子级分片（树的「叶子节点」，最小向量单元）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%8F%A5%E5%AD%90%E8%BE%B9%E7%95%8C%E5%88%A4%E5%AE%9A%E8%A7%84%E5%88%99%EF%BC%88%E9%81%BF%E5%85%8D%E8%AF%AD%E4%B9%89%E5%89%B2%E8%A3%82%EF%BC%89><span class=nav-number>2.3.1.</span> <span class=nav-text>1. 句子边界判定规则（避免语义割裂）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E5%8F%A5%E5%AD%90%E8%8A%82%E7%82%B9%E7%94%9F%E6%88%90%EF%BC%88%E6%9C%80%E5%B0%8F%E5%90%91%E9%87%8F%E5%8D%95%E5%85%83%EF%BC%89><span class=nav-number>2.3.2.</span> <span class=nav-text>2. 句子节点生成（最小向量单元）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%9A%BE%E7%82%B9-1%EF%BC%9A%E5%B8%B8%E8%A7%84%E7%A1%AC%E5%88%87%E7%89%87%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%AD%E4%B9%89%E9%93%BE%E6%96%AD%E8%A3%82><span class=nav-number>2.3.3.</span> <span class=nav-text>难点 1：常规硬切片导致的语义链断裂</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%95%BF%E6%96%87%E6%A1%A3%E9%97%AE%E7%AD%94%E7%9A%84%E4%BF%A1%E6%81%AF%E7%A2%8E%E7%89%87%E5%8C%96><span class=nav-number>2.3.4.</span> <span class=nav-text>长文档问答的信息碎片化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%A4%9A%E6%A0%BC%E5%BC%8F%E6%96%87%E6%A1%A3%E7%9A%84%E5%B1%82%E7%BA%A7%E6%A0%91%E6%9E%84%E5%BB%BA%E7%B2%BE%E5%87%86%E6%80%A7><span class=nav-number>2.3.5.</span> <span class=nav-text>多格式文档的层级树构建精准性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BB%86%E7%B2%92%E5%BA%A6%E6%A3%80%E7%B4%A2-%E5%AE%BD%E7%B2%92%E5%BA%A6%E5%8F%AC%E5%9B%9E%E7%9A%84%E6%95%88%E7%8E%87%E5%B9%B3%E8%A1%A1><span class=nav-number>2.3.6.</span> <span class=nav-text>细粒度检索 + 宽粒度召回的效率平衡</span></a></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%9F%A5%E8%AF%86%E5%BA%93%E6%A3%80%E7%B4%A2><span class=nav-number></span> <span class=nav-text>知识库检索</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-KNN-BM25-%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E%EF%BC%8C%E8%80%8C%E9%9D%9E%E5%8D%95%E4%B8%80%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%EF%BC%9F><span class=nav-number>0.0.1.</span> <span class=nav-text>什么选择 KNN+BM25 多路召回，而非单一检索方式？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Cross-Encoder-%E9%87%8D%E6%8E%92%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%92%8C-Bi-Encoder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E5%AE%83%EF%BC%9F><span class=nav-number>0.0.2.</span> <span class=nav-text>Cross-Encoder 重排的作用是什么？和 Bi-Encoder 的区别？为什么选它？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9C%A8-ES-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-KNN-%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E7%9A%84%EF%BC%9F%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B-ES-%E7%89%B9%E6%80%A7%EF%BC%9F><span class=nav-number>0.0.3.</span> <span class=nav-text>在 ES 中是如何实现 KNN 向量检索的？用到了哪些 ES 特性？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6-%E5%8E%BB%E9%87%8D%E7%9A%84%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E6%9D%83%E9%87%8D%E8%B0%83%E6%95%B4%EF%BC%9F><span class=nav-number>0.0.4.</span> <span class=nav-text>多路召回的结果是如何合并 / 去重的？有没有做权重调整？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Cross-Encoder-%E9%87%8D%E6%8E%92%E6%98%AF%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B9%B3%E8%A1%A1%E6%80%A7%E8%83%BD%EF%BC%9F><span class=nav-number>0.0.5.</span> <span class=nav-text>Cross-Encoder 重排是如何集成到流程中的？如何平衡性能？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%87%86%E7%A1%AE%E7%8E%87%E6%8F%90%E5%8D%87-25-%E2%80%9D-%E6%98%AF%E5%A6%82%E4%BD%95%E9%87%8F%E5%8C%96%E7%9A%84%EF%BC%9F%E5%AF%B9%E6%AF%94%E7%9A%84%E5%9F%BA%E7%BA%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=nav-number>0.0.6.</span> <span class=nav-text>准确率提升 25%” 是如何量化的？对比的基线是什么？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#KNN-%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F><span class=nav-number>0.0.7.</span> <span class=nav-text>KNN 向量检索的性能瓶颈是什么？你是如何优化的？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%90%BD%E5%9C%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%8C%91%E6%88%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F><span class=nav-number>0.0.8.</span> <span class=nav-text>落地过程中最大的挑战是什么？如何解决的？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%92%8C-BM25-%E7%9A%84%E7%BB%93%E6%9E%9C%E5%86%B2%E7%AA%81%E6%97%B6%EF%BC%88%E6%AF%94%E5%A6%82-KNN-%E8%AE%A4%E4%B8%BA%E7%9B%B8%E5%85%B3%EF%BC%8CBM25-%E8%AE%A4%E4%B8%BA%E4%B8%8D%E7%9B%B8%E5%85%B3%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F><span class=nav-number>0.0.9.</span> <span class=nav-text>向量检索和 BM25 的结果冲突时（比如 KNN 认为相关，BM25 认为不相关），如何处理？</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%81%8A%E5%A4%A9%E5%8A%A9%E6%89%8BAgent><span class=nav-number></span> <span class=nav-text>聊天助手Agent</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%A0%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E4%BA%8E-LLM-%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F><span class=nav-number>0.0.1.</span> <span class=nav-text>你设计的基于 LLM 的自适应检索模块整体架构是怎样的？核心流程是什么？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%AE%E9%A2%98-2%EF%BC%9A%E6%8C%87%E4%BB%A3%E6%B6%88%E8%A7%A3%E5%92%8C%E8%AF%AD%E4%B9%89%E6%89%A9%E5%B1%95%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E5%88%B0%E9%A6%96%E8%BD%AE%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB%E4%B8%AD%EF%BC%9F><span class=nav-number>0.0.2.</span> <span class=nav-text>问题 2：指代消解和语义扩展具体是怎么做的？如何落地到首轮意图识别中？</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%881%EF%BC%89%E6%8C%87%E4%BB%A3%E6%B6%88%E8%A7%A3%EF%BC%88%E8%A7%A3%E5%86%B3%E9%A6%96%E8%BD%AE%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%8C%87%E4%BB%A3%E9%97%AE%E9%A2%98%EF%BC%89><span class=nav-number>0.0.2.1.</span> <span class=nav-text>（1）指代消解（解决首轮查询的模糊指代问题）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%882%EF%BC%89%E8%AF%AD%E4%B9%89%E6%89%A9%E5%B1%95%EF%BC%88%E8%A7%A3%E5%86%B3%E9%A6%96%E8%BD%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E4%B9%89%E5%8D%95%E8%96%84%E9%97%AE%E9%A2%98%EF%BC%89><span class=nav-number>0.0.2.2.</span> <span class=nav-text>（2）语义扩展（解决首轮查询语义单薄问题）</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%AE%E9%A2%98-3%EF%BC%9A%E9%87%8D%E6%8E%92%E5%88%86%E6%95%B0%E4%BD%8E%E4%BA%8E%E9%98%88%E5%80%BC%E6%97%B6%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99%E5%92%8C%E5%9B%9E%E9%80%80%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F><span class=nav-number>0.0.3.</span> <span class=nav-text>问题 3：重排分数低于阈值时的查询重写和回退机制具体如何设计？</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%881%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6%EF%BC%88%E6%A0%B8%E5%BF%83%E6%98%AF-%E2%80%9C%E7%B2%BE%E5%87%86%E6%94%B9%E5%86%99-%E5%A4%9A%E7%AD%96%E7%95%A5%E5%A4%87%E9%80%89%E2%80%9D%EF%BC%89><span class=nav-number>0.0.3.1.</span> <span class=nav-text>（1）查询重写机制（核心是 “精准改写 + 多策略备选”）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%EF%BC%882%EF%BC%89%E5%9B%9E%E9%80%80%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%85%9C%E5%BA%95%E8%83%BD%E5%8A%9B%EF%BC%89><span class=nav-number>0.0.3.2.</span> <span class=nav-text>（2）回退机制（保证服务兜底能力）</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%AE%E9%A2%98-4%EF%BC%9ALLM-%E6%94%B9%E5%86%99%E5%BC%95%E5%85%A5%E7%9A%84%E8%80%97%E6%97%B6%E5%A2%9E%E5%8A%A0%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F><span class=nav-number>0.0.4.</span> <span class=nav-text>问题 4：LLM 改写引入的耗时增加，你是怎么优化的？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%AE%E9%A2%98-5%EF%BC%9A%E8%A7%92%E8%89%B2%E4%B8%8E%E7%BB%84%E7%BB%87%E6%A0%87%E7%AD%BE%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%BB%86%E5%8C%96%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%EF%BC%9F><span class=nav-number>0.0.5.</span> <span class=nav-text>问题 5：角色与组织标签如何集成到检索模块，实现精细化权限管控和数据隔离？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%AE%E9%A2%98-6%EF%BC%9A%E8%87%AA%E9%80%82%E5%BA%94%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E5%9C%BA%E6%99%AF%EF%BC%9F><span class=nav-number>0.0.6.</span> <span class=nav-text>问题 6：自适应检索模块如何支撑多轮对话场景？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%97%AE%E9%A2%98-7%EF%BC%9A%E6%80%8E%E4%B9%88%E8%A1%A1%E9%87%8F%E8%BF%99%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%8C%87%E6%A0%87%EF%BC%9F><span class=nav-number>0.0.7.</span> <span class=nav-text>问题 7：怎么衡量这个模块的优化效果？有哪些核心指标？</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E9%9A%BE%E7%82%B9%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88><span class=nav-number>0.1.</span> <span class=nav-text>二、核心难点及解决方案</span></a><li class="nav-item nav-level-3"><a class=nav-link><span class=nav-number>0.2.</span> <span class=nav-text> </span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BB%9F%E4%B8%80%E5%A4%9A%E6%BA%90%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F><span class=nav-number>1.</span> <span class=nav-text>统一多源文档格式</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#PDF%E8%A7%A3%E6%9E%90><span class=nav-number>1.1.</span> <span class=nav-text>PDF解析</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E5%8C%96%E8%A7%A3%E6%9E%90%E9%80%BB%E8%BE%91><span class=nav-number>1.1.1.</span> <span class=nav-text>优化解析逻辑</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%BE%E7%82%B9><span class=nav-number>1.2.</span> <span class=nav-text>难点</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B7%A8%E9%A1%B5%E8%A1%A8%E6%A0%BC%E6%80%8E%E4%B9%88%E8%87%AA%E5%8A%A8%E5%AF%B9%E9%BD%90><span class=nav-number>1.2.1.</span> <span class=nav-text>跨页表格怎么自动对齐</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86><span class=nav-number>2.</span> <span class=nav-text>数据预处理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9C%AF%E8%AF%AD%E8%AF%8D%E5%BA%93%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4><span class=nav-number>2.1.</span> <span class=nav-text>术语词库构建与维护</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%9D%97%E7%AD%96%E7%95%A5%E4%B8%8EEmbedding%E6%8A%80%E6%9C%AF><span class=nav-number>3.</span> <span class=nav-text>分块策略与Embedding技术</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3><span class=nav-number>3.0.1.</span> <span class=nav-text>滑动窗口</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E5%88%87%E7%89%87%E7%AD%96%E7%95%A5%E4%B8%8E%E9%87%8D%E5%8F%A0%E6%9C%BA%E5%88%B6><span class=nav-number>4.</span> <span class=nav-text>动态切片策略与重叠机制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Dify%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E6%A8%A1%E5%BC%8F><span class=nav-number>4.0.1.</span> <span class=nav-text>Dify中的父子模式</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E9%98%B6%E6%AE%B5><span class=nav-number>5.</span> <span class=nav-text>检索增强阶段</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#OCR%E6%96%87%E4%BB%B6%E9%94%99%E6%BC%8F><span class=nav-number>6.</span> <span class=nav-text>OCR文件错漏</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%94%9F%E6%88%90%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5><span class=nav-number>7.</span> <span class=nav-text>生成控制与验证阶段</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E><span class=nav-number>8.</span> <span class=nav-text>向量检索引擎</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E8%AE%A1%E6%B7%B7%E5%90%88%E6%A3%80%E7%B4%A2%E6%9E%B6%E6%9E%84%E6%8F%90%E9%AB%98%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%8F%AC%E5%9B%9E%E7%8E%87><span class=nav-number>8.1.</span> <span class=nav-text>设计混合检索架构提高多阶段召回率</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%A9AI%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE><span class=nav-number>9.</span> <span class=nav-text>让AI返回结构化数据</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0><span class=nav-number>9.1.</span> <span class=nav-text>开源实现</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E4%BA%A7%E5%AE%9E%E7%8E%B0><span class=nav-number>9.2.</span> <span class=nav-text>生产实现</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%89%E6%95%88%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%94%B9%E8%BF%9BRAG%E5%BA%94%E7%94%A8><span class=nav-number>10.</span> <span class=nav-text>有效评估与改进RAG应用</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B6%E4%BB%96RAG%E6%8A%80%E6%9C%AF><span class=nav-number>11.</span> <span class=nav-text>其他RAG技术</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%84%E8%8C%83%E5%8C%96RAG%E5%BA%94%E7%94%A8><span class=nav-number>12.</span> <span class=nav-text>规范化RAG应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#RAG%E9%93%BE%E8%B7%AF%E7%BA%A7%E4%BC%98%E5%8C%96><span class=nav-number>12.1.</span> <span class=nav-text>RAG链路级优化</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#SpringAI%E6%99%BA%E8%83%BD%E9%9D%A2%E8%AF%95%E5%B9%B3%E5%8F%B0-RAG><span class=nav-number></span> <span class=nav-text>SpringAI智能面试平台+RAG</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9F%BA%E4%BA%8ETika%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%A0%BC%E5%BC%8F%E5%86%85%E5%AE%B9%E6%8F%90%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90><span class=nav-number>1.</span> <span class=nav-text>基于Tika实现多格式内容提取与解析</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8><span class=nav-number>2.</span> <span class=nav-text>工具调用</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%9A%BE%E7%82%B9-1%EF%BC%9A%E5%8F%82%E6%95%B0%E6%8F%90%E5%8F%96%E4%B8%8D%E5%87%86%E7%A1%AE%EF%BC%88%E6%9C%80%E5%B8%B8%E8%A7%81%EF%BC%89><span class=nav-number>2.0.1.</span> <span class=nav-text>难点 1：参数提取不准确（最常见）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E9%9A%BE%E7%82%B9-2%EF%BC%9A%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E4%B8%8D%E8%A7%84%E8%8C%83><span class=nav-number>2.0.2.</span> <span class=nav-text>2. 难点 2：输出格式不规范</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%AD%E7%BB%83%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%99%E6%A8%A1%E5%9E%8B-%E2%80%9C%E6%A4%8D%E5%85%A5%E2%80%9D-JSON-%E8%AF%AD%E6%B3%95%E8%AE%A4%E7%9F%A5><span class=nav-number>3.</span> <span class=nav-text>训练阶段：给模型 “植入” JSON 语法认知</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%B0%E5%BF%86%E7%B3%BB%E7%BB%9F><span class=nav-number>4.</span> <span class=nav-text>记忆系统</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2%E7%AE%A1%E7%90%86><span class=nav-number>4.1.</span> <span class=nav-text>对话历史管理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2%E7%AE%A1%E7%90%86><span class=nav-number>4.2.</span> <span class=nav-text>基本的对话历史管理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%99%BA%E8%83%BD%E5%8E%86%E5%8F%B2%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5><span class=nav-number>4.3.</span> <span class=nav-text>智能历史选择策略</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%B0%E5%87%8F><span class=nav-number>4.3.1.</span> <span class=nav-text>1. 基于时间的衰减</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E5%9F%BA%E4%BA%8E%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9A%84%E9%80%89%E6%8B%A9><span class=nav-number>4.3.2.</span> <span class=nav-text>2. 基于相关性的选择</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E6%B7%B7%E5%90%88%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5><span class=nav-number>4.3.3.</span> <span class=nav-text>3. 混合选择策略</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%B0%E5%BF%86%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%80%BB%E7%BB%93%E7%AD%96%E7%95%A5><span class=nav-number>4.4.</span> <span class=nav-text>记忆压缩与总结策略</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%B0%E5%BF%86%E5%8E%8B%E7%BC%A9%E7%AD%96%E7%95%A5><span class=nav-number>4.5.</span> <span class=nav-text>记忆压缩策略</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%9F%BA%E4%BA%8E%E9%87%8D%E8%A6%81%E6%80%A7%E7%9A%84%E5%8E%8B%E7%BC%A9><span class=nav-number>4.5.1.</span> <span class=nav-text>1. 基于重要性的压缩</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E5%9F%BA%E4%BA%8E%E8%81%9A%E7%B1%BB%E7%9A%84%E5%8E%8B%E7%BC%A9><span class=nav-number>4.5.2.</span> <span class=nav-text>2. 基于聚类的压缩</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%A2%9E%E9%87%8F%E6%80%BB%E7%BB%93%E7%AD%96%E7%95%A5><span class=nav-number>4.5.3.</span> <span class=nav-text>3. 增量总结策略</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>267</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>229</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>此文章目前无词云</h3></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2026</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>4.7m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>71:48</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>document.addEventListener("DOMContentLoaded", function() {
    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
        var pvContainer = document.getElementById("busuanzi_container_site_pv");
        if (pvContainer && pvContainer.style.display !== "none") {
            var pvElement = document.getElementById("busuanzi_value_site_pv");
            if (pvElement) {
                pvElement.innerHTML = parseInt(pvElement.innerHTML) + countOffset;
                clearInterval(int);
            }
        }
        
        var uvContainer = document.getElementById("busuanzi_container_site_uv");
        if (uvContainer && window.getComputedStyle(uvContainer).display !== "none")
        {
            var uvElement = document.getElementById("busuanzi_value_site_uv");
            if (uvElement) {
                uvElement.innerHTML = parseInt(uvElement.innerHTML) + countOffset; // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    }
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	 '.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
  
  // Reinitialize TagCanvas for tag cloud
  if (typeof TagCanvas !== 'undefined' && document.getElementById('resCanvas')) {
    try {
      TagCanvas.textFont = 'Trebuchet MS, Helvetica';
      TagCanvas.textColour = '#333';
      TagCanvas.textHeight = 20;
      TagCanvas.outlineColour = '#E2E1D1';
      TagCanvas.maxSpeed = 0.3;
      TagCanvas.freezeActive = true;
      TagCanvas.outlineMethod = 'block';
      TagCanvas.minBrightness = 0.2;
      TagCanvas.depth = 0.92;
      TagCanvas.pulsateTo = 0.6;
      TagCanvas.initial = [0.1,-0.1];
      TagCanvas.decel = 0.98;
      TagCanvas.reverse = true;
      TagCanvas.hideTags = false;
      TagCanvas.shadow = '#ccf';
      TagCanvas.shadowBlur = 3;
      TagCanvas.weight = false;
      TagCanvas.imageScale = null;
      TagCanvas.fadeIn = 1000;
      TagCanvas.clickToFront = 600;
      TagCanvas.lock = false;
      TagCanvas.Start('resCanvas');
      TagCanvas.tc['resCanvas'].Wheel(true);
    } catch(e) {
      console.log('TagCanvas initialization failed:', e);
    }
  }
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>
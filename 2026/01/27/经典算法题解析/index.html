<!doctypehtml><html lang=zh-CN><script defer src=/live2d-widget/autoload.js></script><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 5.4.0" name=generator><link href=/images/blog_32px.png rel=apple-touch-icon sizes=180x180><link href=/images/blog_32px.png rel=icon sizes=32x32 type=image/png><link href=/images/blog_16px.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><meta content=EPrJAp11bJwHULpQUaSNSZ8_3RcvTsPDAEGOME4pl1w name=google-site-verification><!-- Google tag (gtag.js) --><!-- 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB21D8MKKW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VB21D8MKKW');
</script> --><!-- google adsense in head.swig --><script async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4034523802263123></script><meta content=7226864CE87CE9DE8C008385273846FF name=msvalidate.01><meta content=code-fjFXVtiL7j name=baidu-site-verification><link href=/css/main.css rel=stylesheet><link as=style href=https://fonts.googleapis.com/css?family=Roboto%20Mono,Roboto:300,300italic,400,400italic,700,700italic|Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext onload=this.rel='stylesheet' rel=preload><link as=style href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css onload=this.rel='stylesheet' rel=preload><link href=https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap rel=stylesheet><link href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/pace-js@1/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sekyoro.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"0F9LEEVW82","apiKey":"78839e9f9be09d081c5c4da81975cd19","indexName":"sekyoblog_sec","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><link href=//cdn.bootcss.com/animate.css/3.5.0/animate.min.css rel=stylesheet><meta content=再次总结经典算法题目。 name=description><meta content=article property=og:type><meta content=经典算法题解析 property=og:title><meta content=https://www.sekyoro.top/2026/01/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/index.html property=og:url><meta content=Sekyoro的博客小屋 property=og:site_name><meta content=再次总结经典算法题目。 property=og:description><meta content=zh_CN property=og:locale><meta content=https://s2.loli.net/2026/01/27/ZOiU1tYajTzcCMf.png property=og:image><meta content=https://s2.loli.net/2026/02/02/bcyS78esmrTuiHl.png property=og:image><meta content=https://s2.loli.net/2026/02/03/bhlRSygsmIWnpoV.png property=og:image><meta content=https://img.proanimer.com/imgs/image-20260210124408364.png property=og:image><meta content=https://files.seeusercontent.com/2026/02/18/jy3S/image-20260218195651652.png property=og:image><meta content=https://files.seeusercontent.com/2026/02/19/oZg6/image-20260219112111053.png property=og:image><meta content=https://files.seeusercontent.com/2026/02/23/8Lrb/image-20260223131535419.png property=og:image><meta content=https://cdn.sekyoro.top/imgs/image-20260211173106800.png property=og:image><meta content=https://files.seeusercontent.com/2026/02/22/9fuG/image-20260222222516630.png property=og:image><meta content=https://files.seeusercontent.com/2026/02/21/Sr6n/image-20260221213221536.png property=og:image><meta content=2026-01-27T02:34:25.000Z property=article:published_time><meta content=2026-02-28T12:09:16.000Z property=article:modified_time><meta content=Sekyoro property=article:author><meta content=算法 property=article:tag><meta content=summary name=twitter:card><meta content=https://s2.loli.net/2026/01/27/ZOiU1tYajTzcCMf.png name=twitter:image><link href=https://www.sekyoro.top/2026/01/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>经典算法题解析 | Sekyoro的博客小屋</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><link href=/atom.xml rel=alternate title=Sekyoro的博客小屋 type=application/atom+xml><body itemscope itemtype=http://schema.org/WebPage><canvas style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" class=fireworks></canvas><script defer src=https://cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script defer src=/js/src/fireworks.js></script><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Sekyoro的博客小屋</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-bangumis"><a href=/bangumis/ rel=section><i class="fa fa-film fa-fw"></i>追番</a><li class="menu-item menu-item-resume"><a href=/resume/ rel=section><i class="fa fa-file-pdf fa-fw"></i>简历</a><li class="menu-item menu-item-materials"><a href=/materials/ rel=section><i class="fa fa-book fa-fw"></i>学习资料</a><li class="menu-item menu-item-sitemap"><a href=/sitemap.xml rel=section><i class="fa fa-sitemap fa-fw"></i>站点地图</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div class=algolia-results><div id=algolia-stats></div><div id=algolia-hits></div><div class=algolia-pagination id=algolia-pagination></div></div></div></div></div></header><a class="book-mark-link book-mark-link-fixed" role=button></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://www.sekyoro.top/2026/01/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg itemprop=image> <meta content=Sekyoro itemprop=name> <meta content=什么也无法舍弃的人，什么也做不了. itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Sekyoro的博客小屋 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>经典算法题解析</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2026-01-27 10:34:25" datetime=2026-01-27T10:34:25+08:00>2026-01-27</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2026-02-28 20:09:16" datetime=2026-02-28T20:09:16+08:00 itemprop=dateModified>2026-02-28</time> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>195k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>2:57</span> </span></div></header><div class=post-body itemprop=articleBody><div class=post-tags><a href=/tags/%E7%AE%97%E6%B3%95/ rel=tag># 算法</a></div><p>再次总结经典算法题目。<br><span id=more></span><h1 id=复杂度分析><a class=headerlink href=#复杂度分析 title=复杂度分析></a>复杂度分析</h1><p>一个程序的运行时间主要和两个因素有关：<p>1.执行每条语句的耗时。2.执行每条语句的频率。前者取决于硬件，后者取决于算法本身和程序的输入。在相同的硬件环境下，不同算法的执行时间只取决于语句的执行频率，因此可以将对执行时间的关注进一步简化为对执行频率的关注。<p><strong>定义</strong>：$T(n) = O(f(n))$ 表示当 $n$ 趋于无穷大时，$T(n)$ 的增长率不超过 $f(n)$。<div class=table-container><table><thead><tr><th><strong>复杂度</strong><th><strong>名称</strong><th><strong>形象描述</strong><th><strong>典型案例</strong><tbody><tr><td><strong>$O(1)$</strong><td>常数阶<td>无论数据多少，一瞬间完成<td>数组下标取值、哈希表单次查询<tr><td><strong>$O(\log n)$</strong><td>对数阶<td>每走一步，范围缩小一半<td>二分查找（Binary Search）<tr><td><strong>$O(n)$</strong><td>线性阶<td>每一个都要过一遍<td>简单遍历、求最大值<tr><td><strong>$O(n \log n)$</strong><td>线性对数阶<td>比较高效的排序<td>快速排序、归并排序、堆排序<tr><td><strong>$O(n^2)$</strong><td>平方阶<td>每个人都要跟所有人打个招呼<td>冒泡排序、插入排序、嵌套循环<tr><td><strong>$O(2^n)$</strong><td>指数阶<td>噩梦，数据多一点点就炸了<td>暴力解斐波那契、汉诺塔<tr><td><strong>$O(n!)$</strong><td>阶乘阶<td>宇宙爆炸级别<td>全排列问题（旅行商问题暴力解）</table></div><h2 id=递归算法的复杂度分析><a class=headerlink href=#递归算法的复杂度分析 title=递归算法的复杂度分析></a>递归算法的复杂度分析</h2><p>总时间 = 递归调用的总次数 $\times$ 每次调用产生的额外工作量<p>当你看不清逻辑时，就把递归画成一棵树。每一层代表递归的一级，每个节点代表一次函数调用。<p>例子：斐波那契数列（暴力递归）<figure class="highlight isbl"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=title>fib</span>(<span class=variable>n</span>) = <span class=title>fib</span>(<span class=variable>n</span>-<span class=number>1</span>) + <span class=title>fib</span>(<span class=variable>n</span>-<span class=number>2</span>)</span></span><br></pre></table></figure><ul><li><strong>树的深度</strong>：$n$。<li><strong>每一层的节点数</strong>：每个节点分出 2 个子节点，第 $k$ 层就有 $2^k$ 个节点。<li><strong>总节点数</strong>：$1 + 2 + 4 + … + 2^{n-1} \approx 2^n$。<li><strong>结论</strong>：复杂度是 $O(2^n)$。这是指数级的，数据稍微大一点（比如 $n=50$）电脑就跑不动了。</ul><p>例子：归并排序 (Merge Sort)<ol><li>把数组对半切开：$2 \times T(n/2)$<li>合并两个有序数组：$O(n)$</ol><ul><li><strong>树的深度</strong>：$\log n$（因为每次都砍一半，砍 $\log n$ 次就剩 1 个了）。<li><strong>每一层的工作量</strong>：每一层的所有节点合并起来的总长度永远是 $n$，所以每一层的工作量都是 $O(n)$。<li><strong>结论</strong>：$O(n \times \log n)$。</ul><p>如果你面对的是类似“分治法”的递归（规模按比例缩小），可以直接套用<strong>主定理</strong>。它的标准形式是：</p><script type="math/tex; mode=display">T(n) = aT(n/b) + f(n)</script><ul><li>$a$：产生的子问题个数。<li>$n/b$：每个子问题的规模（把原问题缩小的倍数）。<li>$f(n)$：递归之外要做的工作（比如合并结果的花费）。</ul><p>快速判断口诀：<ol><li><strong>如果 $f(n)$ 很大</strong>（合并比递归慢）：复杂度就是 $O(f(n))$。<li><strong>如果 $a$ 很大</strong>（分裂出的子问题太多）：复杂度就是 $O(n^{\log_b a})$。<li><strong>如果两边差不多</strong>（比如归并排序）：复杂度就是 $O(f(n) \cdot \log n)$。</ol><p>递归不仅耗时间，还非常耗<strong>内存</strong>。<strong>递归的空间复杂度 = 递归调用的最大深度 $\times$ 每次调用产生的辅助空间</strong>即使你的递归里没开数组，每次函数调用都会在 <strong>系统栈（Stack）</strong> 里压入一个“栈帧”（保存局部变量、返回地址等）。<h1 id=数学相关><a class=headerlink href=#数学相关 title=数学相关></a>数学相关</h1><h2 id=公倍数与公因数><a class=headerlink href=#公倍数与公因数 title=公倍数与公因数></a>公倍数与公因数</h2><p>最大公因数gcd<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>gcd</span><span class=params>(<span class=keyword>int</span> a,<span class=keyword>int</span> b)</span> </span>{</span><br><span class=line>	<span class=keyword>return</span> b==<span class=number>0</span>?a:<span class=built_in>gcd</span>(b,a%b);</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>gcd</span><span class=params>(<span class=keyword>int</span> a,<span class=keyword>int</span> b)</span> </span>{</span><br><span class=line>    <span class=keyword>while</span>(b!=<span class=number>0</span>) {</span><br><span class=line>		<span class=keyword>int</span> tmp = a;</span><br><span class=line>        a = b;</span><br><span class=line>        b = tmp%b;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> a;</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>lcm</span><span class=params>(<span class=keyword>int</span> a, <span class=keyword>int</span> b)</span> </span>{ </span><br><span class=line>    <span class=keyword>return</span> a * b / <span class=built_in>gcd</span>(a, b); </span><br><span class=line>}</span><br></pre></table></figure><p>利用<code>辗转相除法</code>，可以很方便地求得两个数的最大公因数（greatest common divisor，GCD）；将两个数相乘再除以最大公因数即可得到最小公倍数（least common multiple, LCM）。<p>也可以通过<code>扩展欧几里得算法</code>（extended gcd）在求得 a 和 b 最大公因数的同时，也得到它们的系数 x 和 y，从而使 ax + by = gcd(a, b)<p>普通欧几里得算法只能帮你算出 $a$ 和 $b$ 的<strong>最大公约数（GCD）</strong>，而扩展欧几里得算法不仅能算出 GCD，还能帮你找到一对整数 $x, y$，使得它们满足<strong>贝祖等式（Bézout’s identity）</strong>：</p><script type="math/tex; mode=display">ax + by = \text{gcd}(a, b)</script><h3 id=推导><a class=headerlink href=#推导 title=推导></a>推导</h3><p>普通 GCD 的递归项是 $\text{gcd}(a, b) = \text{gcd}(b, a \pmod b)$。<p>假设我们已经通过递归，找到了下一层状态 $b$ 和 $a \pmod b$ 的解 $x’$ 和 $y’$，即：</p><script type="math/tex; mode=display">b \cdot x' + (a \pmod b) \cdot y' = \text{gcd}(a, b)</script><p>因为 $a \pmod b = a - \lfloor a/b \rfloor \cdot b$，代入上式：</p><script type="math/tex; mode=display">b \cdot x' + (a - \lfloor a/b \rfloor \cdot b) \cdot y' = \text{gcd}(a, b)</script><p>整理一下，把含有 $a$ 和 $b$ 的项分开：</p><script type="math/tex; mode=display">a \cdot y' + b \cdot (x' - \lfloor a/b \rfloor \cdot y') = \text{gcd}(a, b)</script><p>对比最原始的等式 $ax + by = \text{gcd}(a, b)$，我们可以直接得出 $x$ 和 $y$ 的变换规律：<ul><li><strong>$x = y’$</strong><li><strong>$y = x’ - \lfloor a/b \rfloor \cdot y’$</strong></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>exgcd</span><span class=params>(<span class=keyword>long</span> <span class=keyword>long</span> a, <span class=keyword>long</span> <span class=keyword>long</span> b, <span class=keyword>long</span> <span class=keyword>long</span> &x, <span class=keyword>long</span> <span class=keyword>long</span> &y)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (b == <span class=number>0</span>) {</span><br><span class=line>        x = <span class=number>1</span>;</span><br><span class=line>        y = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>return</span> a; <span class=comment>// 返回的是 gcd(a, b)</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>long</span> <span class=keyword>long</span> d = <span class=built_in>exgcd</span>(b, a % b, y, x); <span class=comment>// 这里的传参顺序有玄机，利用 y 接收 x'</span></span><br><span class=line>    y -= (a / b) * x; <span class=comment>// 此时 x 已经是 y'，y 已经是 x'，套用公式进行更新</span></span><br><span class=line>    <span class=keyword>return</span> d;</span><br><span class=line>}</span><br></pre></table></figure><p>EXGCD 并不是为了算 GCD 凑热闹的，它的主要应用在以下三个领域：<p>A. 求解模反元素（Modular Inverse）<p>如果你需要计算 $(a / b) \pmod m$，由于取模运算不支持直接除法，你需要找到 $b$ 的逆元 $x$，满足 $bx \equiv 1 \pmod m$。<p>这等价于解方程：$bx + my = 1$。<p><strong>只有当 $\text{gcd}(b, m) = 1$ 时，逆元才存在。</strong><p>B. 求解线性同余方程<p>求解 $ax \equiv c \pmod m$。<p>这可以转化为 $ax + my = c$。只要 $c$ 是 $\text{gcd}(a, m)$ 的倍数，方程就有解。<p>C. 中国剩余定理 (CRT)<p>在处理多个同余方程组时，EXGCD 是合并方程的核心工具。<blockquote><p>求模和取余在有负数时表现不同，对于a%b和a mod b<p><strong><code>%</code> (取余 - Remainder)</strong>：<strong>左边</strong>是老板。结果的符号跟被除数（左边的 $a$）一致。<p><strong><code>mod</code> (取模 - Modulo)</strong>：<strong>右边</strong>是老板。结果的符号跟除数（右边的 $b$）一致。<p>数学本质：向 0 靠拢 vs 向负无穷靠拢<p>之所以符号不同，是因为它们在处理 $a / b$ 的商（quotient）时，取整的方向不同。<strong>取余 (%)</strong>：使用 <strong>截断取整（Truncate）</strong>。往 $0$ 的方向靠。<strong>取模 (mod)</strong>：使用 <strong>地板取整（Floor）</strong>。往负无穷的方向靠（向下取整）。</blockquote><h2 id=质数><a class=headerlink href=#质数 title=质数></a>质数</h2><p>质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，<strong>每一个数都可以分解成质数的乘积</strong>。<h3 id=判断是否是质数><a class=headerlink href=#判断是否是质数 title=判断是否是质数></a>判断是否是质数</h3><ol><li>基础方案：平方根试除法 ($O(\sqrt{n})$)</ol><p>这是最直观的方法。核心逻辑是：如果 $n$ 有一个大于 $\sqrt{n}$ 的因数，那么它必然有一个对应的因数小于 $\sqrt{n}$。<ul><li><strong>逻辑</strong>：从 $2$ 遍历到 $\sqrt{n}$，只要能整除就不是质数。<li><strong>注意</strong>：$1$ 不是质数，$2$ 是最小的质数。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>bool</span> <span class=title>isPrime</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>	<span class=keyword>for</span>(<span class=keyword>int</span> i =<span class=number>2</span>;i*i<=n;i++) {</span><br><span class=line>		<span class=keyword>if</span>(n%i == <span class=number>0</span>) {</span><br><span class=line>		<span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>		}</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><ol><li>进阶优化：$6k \pm 1$ 法（面试推荐）</ol><p>这是一个非常聪明的优化。除了 $2$ 和 $3$ 之外，<strong>所有的质数都可以表示为 $6k-1$ 或 $6k+1$ 的形式。</strong><p><strong>为什么？</strong><p>我们将所有整数按 $6$ 的余数分类：<ul><li>$6k, 6k+2, 6k+3, 6k+4$ 分别能被 $6, 2, 3, 2$ 整除，显然不是质数（除非是 $2$ 和 $3$ 本身）。<li>剩下的只有 $6k+1$ 和 $6k+5$（即 $6k-1$）。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>bool</span> <span class=title>isPrime</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (n <= <span class=number>3</span>) <span class=keyword>return</span> n > <span class=number>1</span>;</span><br><span class=line>    <span class=comment>// 排除掉不在 6 附近波动的数</span></span><br><span class=line>    <span class=keyword>if</span> (n % <span class=number>2</span> == <span class=number>0</span> || n % <span class=number>3</span> == <span class=number>0</span>) <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 从 5 开始（即 6*1 - 1），步长为 6</span></span><br><span class=line>    <span class=comment>// 每次检查 i (6k-1) 和 i+2 (6k+1)</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>5</span>; i * i <= n; i += <span class=number>6</span>) {</span><br><span class=line>        <span class=keyword>if</span> (n % i == <span class=number>0</span> || n % (i + <span class=number>2</span>) == <span class=number>0</span>) <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><div class=table-container><table><thead><tr><th><strong>方法</strong><th><strong>复杂度</strong><th><strong>优点</strong><th><strong>缺点</strong><tbody><tr><td><strong>暴力试除</strong><td>$O(n)$<td>简单到不需要脑子<td>$n > 10^7$ 基本就废了<tr><td><strong>平方根优化</strong><td>$O(\sqrt{n})$<td>逻辑清晰，最常用<td>处理 $10^{14}$ 以上的数开始吃力<tr><td><strong>$6k \pm 1$ 优化</strong><td>$O(\frac{\sqrt{n}}{3})$<td>常数极小，比普通试除快 3 倍<td>需要记住 6 的倍数特性<tr><td><strong>Miller-Rabin</strong><td>$O(k \log^3 n)$<td>解决天文数字级别的判定<td>实现复杂，需要大数处理</table></div><h3 id=计算-1-到-n-之间的质数个数><a title="计算 $1$ 到 $n$ 之间的质数个数" class=headerlink href=#计算-1-到-n-之间的质数个数></a>计算 $1$ 到 $n$ 之间的质数个数</h3><p>根据 $n$ 的范围不同，我们有三种主流的解决方法：<p><strong>埃氏筛法</strong><p>埃氏筛的核心思想非常朴素：<strong>质数的倍数一定不是质数。</strong><ul><li><strong>流程</strong>：<ol><li>创建一个长度为 $n+1$ 的布尔数组，初始全部设为“是质数”。<li>从 $2$ 开始往后扫描。<li>如果当前数 $i$ 是质数，就把它所有的倍数（$2i, 3i, \dots$）全部标记为“不是质数”。<li>为了优化，可以从 $i \times i$ 开始标记，因为更小的倍数（如 $2i$）在扫描到前面的数字时已经被标记过了。</ol><li><strong>复杂度</strong>：时间 $O(n \log \log n)$，空间 $O(n)$。<li><strong>评价</strong>：在 $n < 10^7$ 时表现非常出色，代码实现极其简单。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=function>vector<<span class=keyword>int</span>> <span class=title>sieve</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isPrime</span><span class=params>(n + <span class=number>1</span>, <span class=literal>true</span>)</span></span>;</span><br><span class=line>    isPrime[<span class=number>0</span>] = isPrime[<span class=number>1</span>] = <span class=literal>false</span>;</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i * i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (isPrime[i]) {</span><br><span class=line>            <span class=comment>// 从 i*i 开始标记，步长为 i</span></span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = i * i; j <= n; j += i) {</span><br><span class=line>                isPrime[j] = <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    vector<<span class=keyword>int</span>> result;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (isPrime[i]) result.<span class=built_in>push_back</span>(i);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>线性筛法</strong><p>埃氏筛有一个小缺点：一个合数可能被多次重复标记（比如 $6$ 既会被 $2$ 筛掉，也会被 $3$ 筛掉）。线性筛通过<strong>让每个合数只被它的最小质因子筛掉</strong>，实现了严格的 $O(n)$ 复杂度。<blockquote><p>通过核心逻辑 <code>if (i % p == 0) break;</code>，保证<strong>每个合数只被它的最小质因子筛掉一次</strong>。</blockquote><ul><li><p><strong>核心逻辑</strong>：</p> <p>维护一个质数列表。对于每一个数 $i$，遍历已找到的质数 $p$：</p> <ol><li>标记 $i \times p$ 为合数。<li><strong>关键停止条件</strong>：如果 <code>i % p == 0</code>，立即停止。这保证了 $i \times (\text{下一个质数})$ 会被那个质数更小的因子筛掉，从而避免重复。</ol></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>countPrimes</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    vector<<span class=keyword>int</span>> primes;</span><br><span class=line>    <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isPrime</span><span class=params>(n, <span class=literal>true</span>)</span></span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i < n; ++i) {</span><br><span class=line>        <span class=keyword>if</span> (isPrime[i]) primes.<span class=built_in>push_back</span>(i);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> p : primes) {</span><br><span class=line>            <span class=keyword>if</span> (i * p >= n) <span class=keyword>break</span>;</span><br><span class=line>            isPrime[i * p] = <span class=literal>false</span>;</span><br><span class=line>            <span class=keyword>if</span> (i % p == <span class=number>0</span>) <span class=keyword>break</span>; <span class=comment>// 核心：避免重复筛选</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> primes.<span class=built_in>size</span>();</span><br><span class=line>}</span><br></pre></table></figure><p><strong>分块筛或 Meissel-Lehmer 算法</strong><p>如果遇到的 $n$ 达到了 $10^{10}$ 甚至更高，内存开不下 $O(n)$ 的数组，线性筛就失效了。<p><strong>分块筛</strong>：将 $1$ 到 $n$ 分成若干个小块，每块大小约 $\sqrt{n}$，逐块统计，空间复杂度降至 $O(\sqrt{n})$。<p><strong>Meissel-Lehmer 算法</strong>：这是一种基于数论组合公式的方法，不需要遍历所有数，就能直接计算出质数个数，复杂度约为 $O(n^{2/3})$。<p>1175.请你帮忙给从 <code>1</code> 到 <code>n</code> 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。<p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。<p>由于答案可能会很大，所以请你返回答案 <strong>模 mod <code>10^9 + 7</code></strong> 之后的结果即可。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>// long factorial(int n) {</span></span><br><span class=line>    <span class=comment>//     long res = 1;</span></span><br><span class=line>    <span class=comment>//     for (int i = 1; i <= n; i++) {</span></span><br><span class=line>    <span class=comment>//         res *= i;</span></span><br><span class=line>    <span class=comment>//         res %= MOD;</span></span><br><span class=line>    <span class=comment>//     }</span></span><br><span class=line>    <span class=comment>//     return res;</span></span><br><span class=line>    <span class=comment>// }</span></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>factorial</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span>(n==<span class=number>0</span>){</span><br><span class=line>            <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (n == <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> (n * <span class=built_in>factorial</span>(n - <span class=number>1</span>)) % (MOD);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>int</span> MOD = <span class=number>1e9</span> + <span class=number>7</span>;</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>calcPrimesCount</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isPrimes</span><span class=params>(<span class=number>1</span> + n, <span class=literal>true</span>)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> cnt = n - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>if</span> (isPrimes[i]) {</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>int</span> j = i * i; j <= n; j += i) {</span><br><span class=line>                    <span class=keyword>if</span> (isPrimes[j]) {</span><br><span class=line>                        isPrimes[j] = <span class=literal>false</span>;</span><br><span class=line>                        cnt--;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 线性筛</span></span><br><span class=line>     <span class=function><span class=keyword>int</span> <span class=title>LinearcalcPrimesCount</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isPrimes</span><span class=params>(<span class=number>1</span> + n, <span class=literal>true</span>)</span></span>;</span><br><span class=line>        vector<<span class=keyword>int</span>> primes;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>if</span> (isPrimes[i]) {</span><br><span class=line>                primes.<span class=built_in>push_back</span>(i);</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span>& t : primes) {</span><br><span class=line>                <span class=keyword>int</span> num = t * i;</span><br><span class=line>                <span class=keyword>if</span> (num > n) {</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                }</span><br><span class=line>                isPrimes[num] = <span class=literal>false</span>;</span><br><span class=line>                <span class=comment>// 排除</span></span><br><span class=line>                <span class=keyword>if</span> (i % t == <span class=number>0</span>) {</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> primes.<span class=built_in>size</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>numPrimeArrangements</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 计算1-n的质数个数</span></span><br><span class=line>        <span class=comment>// 结果m!(n-m)!</span></span><br><span class=line>        <span class=keyword>int</span> m = <span class=built_in>calcPrimesCount</span>(n);</span><br><span class=line>        <span class=comment>// 2 3</span></span><br><span class=line>        <span class=keyword>return</span> (<span class=keyword>int</span>) (<span class=built_in>factorial</span>(m) * <span class=built_in>factorial</span>(n - m) % MOD);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>模运算有一个非常重要的性质：</p><script type="math/tex; mode=display">(a \times b) \pmod m = ((a \pmod m) \times (b \pmod m)) \pmod m</script><p>这意味着，如果你要计算一连串数字的乘积并取模，你可以<strong>在中间任何一步</strong>取模，结果都不会改变。<div class=table-container><table><thead><tr><th><strong>运算类型</strong><th><strong>规则</strong><th><strong>是否等价</strong><tbody><tr><td><strong>加法</strong><td>$(a + b) \% m = (a\%m + b\%m) \% m$<td><strong>是</strong><tr><td><strong>减法</strong><td>$(a - b) \% m = (a\%m - b\%m + m) \% m$<td><strong>是</strong>（需加 $m$ 防止负数）<tr><td><strong>乘法</strong><td>$(a \times b) \% m = (a\%m \times b\%m) \% m$<td><strong>是</strong><tr><td><strong>除法</strong><td>$(a / b) \% m$<td><strong>否！</strong>（需使用<strong>逆元</strong>）</table></div><p>如果需要<strong>永远返回正数</strong>的取模结果（例如在处理循环数组下标时），可以使用这个通用的“数学模”技巧：</p><script type="math/tex; mode=display">\text{positive\_mod} = (a \% b + b) \% b</script><h3 id=一个数的因数与一个数的质因数><a class=headerlink href=#一个数的因数与一个数的质因数 title=一个数的因数与一个数的质因数></a>一个数的因数与一个数的质因数</h3><p><strong>求解一个数的所有因数</strong><p>如果 $n \pmod i == 0$，那么 $i$ 就是 $n$ 的因数。 <strong>核心思路：</strong> 利用对称性。如果 $i$ 是 $n$ 的因数，那么 $n/i$ 必然也是 $n$ 的因数。因此，我们只需要遍历到 $\sqrt{n}$ 即可。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=function>vector<<span class=keyword>int</span>> <span class=title>getDivisors</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    vector<<span class=keyword>int</span>> res;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i * i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(i); <span class=comment>// 较小的因数</span></span><br><span class=line>            <span class=keyword>if</span> (i * i != n) {</span><br><span class=line>                res.<span class=built_in>push_back</span>(n / i); <span class=comment>// 对称的较大因数（避免完全平方数重复计算）</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>sort</span>(res.<span class=built_in>begin</span>(), res.<span class=built_in>end</span>()); <span class=comment>// 如果需要有序</span></span><br><span class=line>    <span class=keyword>return</span> res;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>求解一个数的质因数分解</strong><p>将一个合数表示成若干个质数相乘的形式。 <strong>核心思路：</strong> 试除法。从最小的质数 $2$ 开始尝试，只要能整除，就一直除下去，直到除不动为止，然后再试下一个数。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=function>vector<<span class=keyword>int</span>> <span class=title>getPrimeFactors</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    vector<<span class=keyword>int</span>> res;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i * i <= n; i++) {</span><br><span class=line>        <span class=keyword>while</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(i);</span><br><span class=line>            n /= i; <span class=comment>// 关键：除掉已经找到的质因子</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (n > <span class=number>1</span>) res.<span class=built_in>push_back</span>(n); <span class=comment>// 如果最后剩下的数大于1，说明它是最后一个质因子</span></span><br><span class=line>    <span class=keyword>return</span> res;</span><br><span class=line>}</span><br></pre></table></figure><p>不同的质因数分解<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=function>vector<<span class=keyword>int</span>> <span class=title>getDistinctPrimeFactors</span><span class=params>(<span class=keyword>long</span> <span class=keyword>long</span> n)</span> </span>{</span><br><span class=line>    vector<<span class=keyword>int</span>> res;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>long</span> <span class=keyword>long</span> i = <span class=number>2</span>; i * i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(i); <span class=comment>// 记录这个不同的质因数</span></span><br><span class=line>            <span class=keyword>while</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>                n /= i; <span class=comment>// 关键：彻底除尽，把所有的 i 都从 n 中剥离</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 如果最后 n > 1，剩下的 n 本身就是一个质数</span></span><br><span class=line>    <span class=keyword>if</span> (n > <span class=number>1</span>) {</span><br><span class=line>        res.<span class=built_in>push_back</span>(n);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> res;</span><br><span class=line>}</span><br></pre></table></figure><p>2521给你一个正整数数组 <code>nums</code> ，对 <code>nums</code> 所有元素求积之后，找出并返回乘积中 <strong>不同质因数</strong> 的数目。<p><strong>注意：</strong><ul><li><strong>质数</strong> 是指大于 <code>1</code> 且仅能被 <code>1</code> 及自身整除的数字。<li>如果 <code>val2 / val1</code> 是一个整数，则整数 <code>val1</code> 是另一个整数 <code>val2</code> 的一个因数。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>distinctPrimeFactors</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=comment>// 求解数组中每个数的不同质因数</span></span><br><span class=line>        unordered_set<<span class=keyword>int</span>> uset;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> n : nums) {</span><br><span class=line>            <span class=comment>// 计算每个n的不同质因数</span></span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i * i <= n; i++) {</span><br><span class=line>                <span class=keyword>if</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>                    uset.<span class=built_in>insert</span>(i);</span><br><span class=line>                    <span class=keyword>while</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>                        n /= i;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (n > <span class=number>1</span>) {</span><br><span class=line>                uset.<span class=built_in>insert</span>(n);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> uset.<span class=built_in>size</span>();</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=1-到-N-范围内所有数的质因数><a title="$1$ 到 $N$ 范围内所有数的质因数" class=headerlink href=#1-到-N-范围内所有数的质因数></a>$1$ 到 $N$ 范围内<strong>所有数</strong>的质因数</h3><p>利用<strong>线性筛（欧拉筛）进行预处理，通过维护一个最小质因子数组 (Minimum Prime Factor, MPF)</strong>，将每个数的分解过程优化到极速。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class=keyword>int</span> MAXN = <span class=number>1000005</span>;</span><br><span class=line><span class=keyword>int</span> min_prime[MAXN]; <span class=comment>// 记录每个数的最小质因子</span></span><br><span class=line>vector<<span class=keyword>int</span>> primes;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>sieve</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (min_prime[i] == <span class=number>0</span>) { <span class=comment>// i 是质数</span></span><br><span class=line>            min_prime[i] = i;    <span class=comment>// 质数的最小质因子是它自己</span></span><br><span class=line>            primes.<span class=built_in>push_back</span>(i);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> p : primes) {</span><br><span class=line>            <span class=keyword>if</span> (p > min_prime[i] || i * p > n) <span class=keyword>break</span>;</span><br><span class=line>            min_prime[i * p] = p; <span class=comment>// 记录合数的最小质因子</span></span><br><span class=line>            <span class=keyword>if</span> (i % p == <span class=number>0</span>) <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=function>vector<<span class=keyword>int</span>> <span class=title>factorize</span><span class=params>(<span class=keyword>int</span> x)</span> </span>{</span><br><span class=line>    vector<<span class=keyword>int</span>> factors;</span><br><span class=line>    <span class=keyword>while</span> (x > <span class=number>1</span>) {</span><br><span class=line>        factors.<span class=built_in>push_back</span>(min_prime[x]); <span class=comment>// 拿到当前最小质因子</span></span><br><span class=line>        x /= min_prime[x];               <span class=comment>// 直接除掉它</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> factors;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class=keyword>int</span> MAXN = <span class=number>1e6</span> + <span class=number>5</span>;</span><br><span class=line><span class=keyword>int</span> min_p[MAXN];    <span class=comment>// 存储最小质因子</span></span><br><span class=line><span class=keyword>int</span> f[MAXN];        <span class=comment>// 存储质因子相关的递推属性（如质因子总数）</span></span><br><span class=line>vector<<span class=keyword>int</span>> primes;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>linear_sieve</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    f[<span class=number>1</span>] = <span class=number>0</span>; <span class=comment>// 1 没有质因子</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (min_p[i] == <span class=number>0</span>) { <span class=comment>// i 是质数</span></span><br><span class=line>            min_p[i] = i;</span><br><span class=line>            primes.<span class=built_in>push_back</span>(i);</span><br><span class=line>            f[i] = <span class=number>1</span>; <span class=comment>// 质数本身只有 1 个质因子</span></span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> p : primes) {</span><br><span class=line>            <span class=keyword>if</span> (p > min_p[i] || i * p > n) <span class=keyword>break</span>;</span><br><span class=line>            </span><br><span class=line>            <span class=keyword>int</span> target = i * p;</span><br><span class=line>            min_p[target] = p; <span class=comment>// p 一定是 target 的最小质因子</span></span><br><span class=line></span><br><span class=line>            <span class=comment>// --- 核心递推逻辑 ---</span></span><br><span class=line>            <span class=keyword>if</span> (i % p == <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// p 已经是 i 的质因子</span></span><br><span class=line>                f[target] = f[i] + <span class=number>1</span>; <span class=comment>// 示例：总质因子数递增</span></span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// p 是一个全新的、更小的质因子</span></span><br><span class=line>                f[target] = f[i] + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-到-N-范围内所有数的不同的质因数个数><a title="$1$ 到 $N$ 范围内所有数的不同的质因数个数" class=headerlink href=#1-到-N-范围内所有数的不同的质因数个数></a>$1$ 到 $N$ 范围内<strong>所有数</strong>的不同的质因数个数</h3><p>如果只需要知道每个数有<strong>多少个不同</strong>的质因子，线性筛还可以在筛的过程中递推：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> distinct_count[MAXN];</span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>count_sieve</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (min_prime[i] == <span class=number>0</span>) { <span class=comment>// 质数</span></span><br><span class=line>            min_prime[i] = i;</span><br><span class=line>            distinct_count[i] = <span class=number>1</span>;</span><br><span class=line>            primes.<span class=built_in>push_back</span>(i);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> p : primes) {</span><br><span class=line>            <span class=keyword>if</span> (i * p > n) <span class=keyword>break</span>;</span><br><span class=line>            min_prime[i * p] = p;</span><br><span class=line>            <span class=keyword>if</span> (i % p == <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// p 是 i 的因子，i*p 和 i 的不同质因子种类一样</span></span><br><span class=line>                distinct_count[i * p] = distinct_count[i];</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// p 不是 i 的因子，i*p 比 i 多了一个质因子 p</span></span><br><span class=line>                distinct_count[i * p] = distinct_count[i] + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-n中所有数的因数个数><a class=headerlink href=#1-n中所有数的因数个数 title=1-n中所有数的因数个数></a>1-n中所有数的因数个数</h3><p>最容易理解和编写的方法。我们不关注某个数有哪些因数，而是关注<strong>每个数作为因数贡献了多少次</strong>。<p><strong>逻辑：</strong><ol><li>准备一个数组 <code>count[n+1]</code>，全部初始化为 0。<li>遍历 $i$ 从 $1$ 到 $n$（作为可能的因数）。<li>对于每个 $i$，找到它在 $n$ 范围内的所有倍数 $j = i, 2i, 3i, \dots$，并将 <code>count[j]</code> 加 1。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=function>vector<<span class=keyword>int</span>> <span class=title>countAllDivisors</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>count</span><span class=params>(n + <span class=number>1</span>, <span class=number>0</span>)</span></span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = i; j <= n; j += i) {</span><br><span class=line>            count[j]++; <span class=comment>// i 是 j 的一个因数</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> count;</span><br><span class=line>}</span><br></pre></table></figure><p>如果追求极致的 $O(n)$ 性能，可以利用<strong>约数个数定理</strong>和线性筛。<h4 id=约数个数定理><a class=headerlink href=#约数个数定理 title=约数个数定理></a>约数个数定理</h4><p>如何利用质因数分解的结果，一秒求出某个数的所有因数个数<p><strong>约数个数定理：</strong><p>如果 $i$ 的质因数分解为 $p_1^{a_1} \cdot p_2^{a_2} \cdots p_k^{a_k}$，那么其因数个数为：</p><script type="math/tex; mode=display">d(i) = (a_1 + 1)(a_2 + 1) \cdots (a_k + 1)</script><p>假设一个数 $n$ 的质因数分解结果为：</p><script type="math/tex; mode=display">n = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k}</script><p>（其中 $p$ 是质因数，$a$ 是该质因数的指数）<p>那么 $n$ 的所有正因数个数为：</p><script type="math/tex; mode=display">\text{因数个数} = (a_1 + 1) \times (a_2 + 1) \times \dots \times (a_k + 1)</script><p>如果你需要批量处理，可以利用之前提到的 <code>min_prime</code>（最小质因子）数组，配合递推公式在 $O(N)$ 时间内完成。<p><strong>算法逻辑：</strong><p>我们维护两个数组：<ol><li><code>d[i]</code>：数字 $i$ 的因数个数。<li><code>num[i]</code>：数字 $i$ 的最小质因子的幂次（即上面的 $a_1$）。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class=keyword>int</span> MAXN = <span class=number>1000005</span>;</span><br><span class=line><span class=keyword>int</span> d[MAXN], num[MAXN], primes[MAXN], cnt;</span><br><span class=line><span class=keyword>bool</span> is_prime[MAXN];</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>get_divisors</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    d[<span class=number>1</span>] = <span class=number>1</span>; <span class=comment>// 1 只有一个因数</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (!is_prime[i]) {</span><br><span class=line>            primes[++cnt] = i;</span><br><span class=line>            d[i] = <span class=number>2</span>;   <span class=comment>// 质数只有 1 和自己，共 2 个因数</span></span><br><span class=line>            num[i] = <span class=number>1</span>; <span class=comment>// 最小质因子 i 的幂次是 1</span></span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= cnt && i * primes[j] <= n; j++) {</span><br><span class=line>            is_prime[i * primes[j]] = <span class=literal>true</span>;</span><br><span class=line>            <span class=keyword>if</span> (i % primes[j] == <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// 如果 primes[j] 是 i 的最小质因子</span></span><br><span class=line>                num[i * primes[j]] = num[i] + <span class=number>1</span>;</span><br><span class=line>                <span class=comment>// 利用公式：原本是 (num[i]+1)，现在变成 (num[i]+2)</span></span><br><span class=line>                d[i * primes[j]] = d[i] / (num[i] + <span class=number>1</span>) * (num[i * primes[j]] + <span class=number>1</span>);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 如果 primes[j] 是比 i 的最小质因子还要小的质数</span></span><br><span class=line>                num[i * primes[j]] = <span class=number>1</span>;</span><br><span class=line>                <span class=comment>// 新质因子的指数是 1，所以因数个数直接乘以 (1+1)=2</span></span><br><span class=line>                d[i * primes[j]] = d[i] * <span class=number>2</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>核心：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// i: 当前处理的数, p: 当前遍历到的质数</span></span><br><span class=line><span class=keyword>if</span> (i % p == <span class=number>0</span>) { </span><br><span class=line>    <span class=comment>// 情况 B：p 已经是 i 的最小质子</span></span><br><span class=line>    e[i * p] = e[i] + <span class=number>1</span>; <span class=comment>// 指数加1</span></span><br><span class=line>    d[i * p] = d[i] / (e[i] + <span class=number>1</span>) * (e[i * p] + <span class=number>1</span>); <span class=comment>// 更新总个数</span></span><br><span class=line>    <span class=keyword>break</span>; <span class=comment>// 线性筛核心：找到最小质因子就停止</span></span><br><span class=line>} <span class=keyword>else</span> {</span><br><span class=line>    <span class=comment>// 情况 A：p 是全新的最小质子</span></span><br><span class=line>    e[i * p] = <span class=number>1</span>;      <span class=comment>// 新质子的指数就是1</span></span><br><span class=line>    d[i * p] = d[i] * <span class=number>2</span>; <span class=comment>// 总个数直接翻倍 (因为 (1+1)=2 )</span></span><br><span class=line>}</span><br></pre></table></figure><h3 id=因数之和><a class=headerlink href=#因数之和 title=因数之和></a>因数之和</h3><p>假设一个数 $n$ 的质因数分解结果为：</p><script type="math/tex; mode=display">n = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k}</script><p>那么 $n$ 的所有正约数之和为：</p><script type="math/tex; mode=display">\sigma(n) = (1 + p_1 + p_1^2 + \dots + p_1^{a_1}) \times (1 + p_2 + p_2^2 + \dots + p_2^{a_2}) \times \dots \times (1 + p_k + p_k^{a_k})</script><p>要在 $O(N)$ 时间内递推，逻辑和之前求个数的方法（维护最小质因子指数）极其相似，但这次我们需要维护：<ul><li><code>sigma[i]</code>：$i$ 的约数之和。<li><code>g[i]</code>：$i$ 的<strong>最小质因子贡献的那一部分和</strong>（即公式中第一个括号的值：$1 + p_1 + \dots + p_1^{a_1}$）。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=keyword>const</span> <span class=keyword>int</span> MAXN = <span class=number>1000005</span>;</span><br><span class=line><span class=keyword>long</span> <span class=keyword>long</span> sigma[MAXN], g[MAXN]; <span class=comment>// sigma 存总和，g 存最小质因子部分的等比数列和</span></span><br><span class=line><span class=keyword>int</span> primes[MAXN], cnt;</span><br><span class=line><span class=keyword>bool</span> not_prime[MAXN];</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>get_sigma</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    sigma[<span class=number>1</span>] = <span class=number>1</span>; <span class=comment>// 1 的约数之和就是 1</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        <span class=keyword>if</span> (!not_prime[i]) {</span><br><span class=line>            primes[++cnt] = i;</span><br><span class=line>            sigma[i] = i + <span class=number>1</span>; <span class=comment>// 质数 p 的约数之和是 1 + p</span></span><br><span class=line>            g[i] = i + <span class=number>1</span>;     <span class=comment>// 最小质因子部分也是 1 + p</span></span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= cnt && i * primes[j] <= n; j++) {</span><br><span class=line>            not_prime[i * primes[j]] = <span class=literal>true</span>;</span><br><span class=line>            <span class=keyword>if</span> (i % primes[j] == <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// 情况 A：primes[j] 是 i 的最小质因子</span></span><br><span class=line>                <span class=comment>// 新的 g = 原有的 g 乘上 p 再加 1 (例如：从 1+2+4 变成 1+2+4+8)</span></span><br><span class=line>                g[i * primes[j]] = g[i] * primes[j] + <span class=number>1</span>;</span><br><span class=line>                <span class=comment>// 更新总和：先除掉旧的最小质因子部分，再乘上新的</span></span><br><span class=line>                sigma[i * primes[j]] = sigma[i] / g[i] * g[i * primes[j]];</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 情况 B：primes[j] 是一个新的、更小的质因子</span></span><br><span class=line>                g[i * primes[j]] = primes[j] + <span class=number>1</span>;</span><br><span class=line>                <span class=comment>// 直接乘上新质因子的贡献 (1 + p)</span></span><br><span class=line>                sigma[i * primes[j]] = sigma[i] * (primes[j] + <span class=number>1</span>);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><div class=table-container><table><thead><tr><th><strong>属性</strong><th><strong>约数个数 d(n)</strong><th><strong>约数之和 σ(n)</strong><tbody><tr><td><strong>基础单位</strong><td>指数 $(a_i + 1)$<td>等比数列和 $(1 + p_i + \dots + p_i^{a_i})$<tr><td><strong>质数 $p$ 的值</strong><td>$2$<td>$p + 1$<tr><td><strong>递推核心</strong><td>维护最小质因子的<strong>指数</strong><td>维护最小质因子的<strong>等比数列和</strong></table></div><h4 id=常见质因数属性的递推公式><a class=headerlink href=#常见质因数属性的递推公式 title=常见质因数属性的递推公式></a>常见质因数属性的递推公式</h4><p>利用上面的模板，你可以在 $O(N)$ 内一次性求出以下所有属性：<p>A. 质因子总数（包含重复）<ul><li><strong>含义</strong>：$12 = 2 \times 2 \times 3 \to f(12) = 3$。<li><strong>递推</strong>：$f(i \cdot p) = f(i) + 1$。</ul><p>B. 不同质因子的个数<ul><li><strong>含义</strong>：$12 = 2^2 \times 3 \to f(12) = 2$。<li><strong>递推</strong>：<ul><li>如果 <code>i % p == 0</code>：$f(i \cdot p) = f(i)$（$p$ 已经出现过了）。<li>如果 <code>i % p != 0</code>：$f(i \cdot p) = f(i) + 1$（$p$ 是新面孔）。</ul></ul><p>C. 最小质因子的幂次（指数）<ul><li><strong>含义</strong>：$12 = 2^2 \times 3 \to f(12) = 2$。<li><strong>递推</strong>：<ul><li>如果 <code>i % p == 0</code>：$f(i \cdot p) = f(i) + 1$。<li>如果 <code>i % p != 0</code>：$f(i \cdot p) = 1$。</ul></ul><p><strong>四因数</strong><p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 <code>0</code><p>暴力法<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>sumFourDivisors</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> totalSum = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> n : nums) {</span><br><span class=line>            <span class=keyword>int</span> count = <span class=number>0</span>;</span><br><span class=line>            <span class=keyword>int</span> currentSum = <span class=number>0</span>;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i * i <= n; ++i) {</span><br><span class=line>                <span class=keyword>if</span> (n % i == <span class=number>0</span>) {</span><br><span class=line>                    count++;</span><br><span class=line>                    currentSum += i;</span><br><span class=line>                    <span class=keyword>if</span> (i * i != n) { <span class=comment>// 避免平方数重复计算</span></span><br><span class=line>                        count++;</span><br><span class=line>                        currentSum += n / i;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>if</span> (count > <span class=number>4</span>) <span class=keyword>break</span>; <span class=comment>// 剪枝优化</span></span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (count == <span class=number>4</span>) {</span><br><span class=line>                totalSum += currentSum;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> totalSum;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>欧拉筛<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>sumFourDivisors</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>const</span> <span class=keyword>int</span> N = <span class=number>100000</span>;</span><br><span class=line>        vector<<span class=keyword>int</span>> primes;</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isNotPrime</span><span class=params>(N + <span class=number>1</span>, <span class=literal>false</span>)</span></span>;</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>d</span><span class=params>(N + <span class=number>1</span>, <span class=number>0</span>)</span></span>;          <span class=comment>// 因数个数</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>long</span> <span class=keyword>long</span>> <span class=title>sigma</span><span class=params>(N + <span class=number>1</span>, <span class=number>0</span>)</span></span>; <span class=comment>// 因数之和</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>a</span><span class=params>(N + <span class=number>1</span>, <span class=number>0</span>)</span></span>;          <span class=comment>// 最小质因子的指数</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>long</span> <span class=keyword>long</span>> <span class=title>g</span><span class=params>(N + <span class=number>1</span>, <span class=number>0</span>)</span></span>;    <span class=comment>// 最小质因子的等比数列和</span></span><br><span class=line></span><br><span class=line>        d[<span class=number>1</span>] = <span class=number>1</span>; sigma[<span class=number>1</span>] = <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= N; ++i) {</span><br><span class=line>            <span class=keyword>if</span> (!isNotPrime[i]) {</span><br><span class=line>                primes.<span class=built_in>push_back</span>(i);</span><br><span class=line>                d[i] = <span class=number>2</span>;</span><br><span class=line>                sigma[i] = i + <span class=number>1</span>;</span><br><span class=line>                a[i] = <span class=number>1</span>;</span><br><span class=line>                g[i] = i + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> p : primes) {</span><br><span class=line>                <span class=keyword>if</span> (i * p > N) <span class=keyword>break</span>;</span><br><span class=line>                isNotPrime[i * p] = <span class=literal>true</span>;</span><br><span class=line>                <span class=keyword>if</span> (i % p == <span class=number>0</span>) {</span><br><span class=line>                    a[i * p] = a[i] + <span class=number>1</span>;</span><br><span class=line>                    d[i * p] = d[i] / (a[i] + <span class=number>1</span>) * (a[i * p] + <span class=number>1</span>);</span><br><span class=line>                    g[i * p] = g[i] * p + <span class=number>1</span>;</span><br><span class=line>                    sigma[i * p] = sigma[i] / g[i] * g[i * p];</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    a[i * p] = <span class=number>1</span>;</span><br><span class=line>                    d[i * p] = d[i] * <span class=number>2</span>;</span><br><span class=line>                    g[i * p] = p + <span class=number>1</span>;</span><br><span class=line>                    sigma[i * p] = sigma[i] * (p + <span class=number>1</span>);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> ans = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> n : nums) {</span><br><span class=line>            <span class=keyword>if</span> (d[n] == <span class=number>4</span>) ans += sigma[n];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h2 id=进制转换><a class=headerlink href=#进制转换 title=进制转换></a>进制转换</h2><h3 id=十进制转七进制><a class=headerlink href=#十进制转七进制 title=十进制转七进制></a>十进制转七进制</h3><p>给定一个整数 <code>num</code>，将其转化为 <strong>7 进制</strong>，并以字符串形式输出。<p><code>进制转换</code>类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=function>string <span class=title>convertToBase7</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (num == <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"0"</span>;</span><br><span class=line>    }</span><br><span class=line>    string base7;</span><br><span class=line>    <span class=keyword>bool</span> is_negative = num < <span class=number>0</span>;</span><br><span class=line>    num = <span class=built_in>abs</span>(num);</span><br><span class=line>    <span class=keyword>while</span> (num) {</span><br><span class=line>        <span class=keyword>int</span> quotient = num / <span class=number>7</span>, remainder = num % <span class=number>7</span>;</span><br><span class=line>        base7 = <span class=built_in>to_string</span>(remainder) + base7;</span><br><span class=line>        num = quotient;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> is_negative ? <span class=string>"-"</span> + base7 : base7;</span><br><span class=line>}</span><br></pre></table></figure><p>给定一个非负整数，判断它的阶乘结果的结尾有几个 0。<p>每个尾部的 0 由 2 × 5 =10 而来，因此我们可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5。明显的，质因子 2 的数量远多于质因子 5 的数量，因此我们可以只统计阶乘结果里有多少个质因子 5。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>trailingZeroes</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 尾随0的个数就是质因数5的个数</span></span><br><span class=line>        <span class=comment>// 计算5-n中质因数为5的个数</span></span><br><span class=line>        <span class=keyword>int</span> cnt{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>5</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>int</span> tmp = i;</span><br><span class=line>            <span class=keyword>while</span> (tmp % <span class=number>5</span> == <span class=number>0</span>) {</span><br><span class=line>                cnt++;</span><br><span class=line>                tmp /= <span class=number>5</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>字符串相加。给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>addStrings</span><span class=params>(string num1, string num2)</span> </span>{</span><br><span class=line>        string res;</span><br><span class=line>        <span class=keyword>int</span> sz1 = num1.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> sz2 = num2.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> i = sz1 - <span class=number>1</span>, j = sz2 - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>int</span> car{};</span><br><span class=line>        <span class=keyword>while</span> (i >= <span class=number>0</span> || j >= <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>int</span> r = car;</span><br><span class=line>            r += (i >= <span class=number>0</span>) ? (num1[i--] - <span class=string>'0'</span>) : <span class=number>0</span>;</span><br><span class=line>            r += (j >= <span class=number>0</span>) ? (num2[j--] - <span class=string>'0'</span>) : <span class=number>0</span>;</span><br><span class=line>            res = <span class=built_in>to_string</span>(r % <span class=number>10</span>) + res;</span><br><span class=line>            car = r / <span class=number>10</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (car > <span class=number>0</span>) {</span><br><span class=line>            res = <span class=string>"1"</span> + res;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>实现 <a href=https://www.cplusplus.com/reference/valarray/pow/ rel=noopener target=_blank>pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。<p>利用递归，可以较为轻松地解决本题。注意边界条件的处理。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>double</span> <span class=title>myPow</span><span class=params>(<span class=keyword>double</span> x, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (n == <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (x == <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (n == numeric_limits<<span class=keyword>int</span>>::<span class=built_in>min</span>()) {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span> / (x * <span class=built_in>myPow</span>(x, numeric_limits<<span class=keyword>int</span>>::<span class=built_in>max</span>()));</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (n < <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span> / <span class=built_in>myPow</span>(x, -n);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (n % <span class=number>2</span> != <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> x * <span class=built_in>myPow</span>(x, n - <span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>double</span> myPowSqrt = <span class=built_in>myPow</span>(x, n >> <span class=number>1</span>);</span><br><span class=line>    <span class=keyword>return</span> myPowSqrt * myPowSqrt;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=随机取样><a class=headerlink href=#随机取样 title=随机取样></a>随机取样</h2><p>给定一个数组，要求实现两个指令函数。第一个函数“shuﬄe”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。<p>采用经典的 <code>Fisher-Yates 洗牌算法</code>，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法，且实现非常方便。注意这里“reset”函数以及 Solution 类的构造函数的实现细节。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector<<span class=keyword>int</span>> nums;</span><br><span class=line>    vector<<span class=keyword>int</span>> onums;</span><br><span class=line>    <span class=built_in>Solution</span>(vector<<span class=keyword>int</span>>& nums) :<span class=built_in>nums</span>(nums), <span class=built_in>onums</span>(nums) {}</span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>reset</span><span class=params>()</span> </span>{ <span class=keyword>return</span> onums; }</span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>shuffle</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 反向</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = nums.<span class=built_in>size</span>() - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=built_in>swap</span>(nums[i], nums[<span class=built_in>rand</span>() % (i + <span class=number>1</span>)]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> nums;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>洗牌算法</strong>：<p>对于数组<code>nums</code>，其长度为<code>n</code>。我们调用<code>shuffle()</code>方法返回的数组，应该有<em>n</em>!种可能，我们就可以说<code>shuffle()</code>方法返回的数组是随机的。<p>那最简单直白的做法就是，将数组<code>nums</code>的<em>n</em>!种排列组合都提前生成出来，每调用一次<code>shuffle()</code>，就取一种<code>nums</code>的排列组合出来返回。<p>这时候就轮到我们的<strong>洗牌算法</strong>出场了。不需要提前把<em>n</em>!种排列组合都生成好。<p>洗牌算法的思路很简单。我们有个长度为<em>n</em>的数组<code>nums</code>，对于每个<code>nums[i]</code>来说，都生成一个[<em>i</em>,<em>n</em>−1]范围的随机数，作为<code>random_idx</code>，然后交换<code>nums[i]</code>和<code>nums[random_idx</code>。<p>为什么说<strong>洗牌算法</strong>实现的<code>shuffle()</code>返回的数组会有<em>n</em>!种可能呢？<ul><li>对于<code>nums[0]</code>，它可能会和[0,<em>n</em>−1]范围内的任何一个数交换，有<em>n</em>种可能。<li>对于<code>nums[1]</code>，它可能会和[1,<em>n</em>−1]范围内的任何一个数交换，有<em>n</em>−1种可能。<li>…<li>对于<code>nums[n-1]</code>，它只能和<code>nums[n-1]</code>自己交换，只有1种可能。</ul><p>所以总的可能性是: <em>n</em>+(<em>n</em>−1)+(<em>n</em>−2)+…+1=<em>n</em>!<p>按权重随机选择<p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表第 <code>i</code> 个下标的权重。<p>请你实现一个函数 <code>pickIndex</code> ，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code> 的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。<ul><li><p>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，<code>75%</code>）。</p> <p>前缀和+二分</p></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector<<span class=keyword>int</span>>& w;</span><br><span class=line>    vector<<span class=keyword>int</span>> prefix_sum;</span><br><span class=line></span><br><span class=line>    <span class=built_in>Solution</span>(vector<<span class=keyword>int</span>>& w) : <span class=built_in>w</span>(w), <span class=built_in>prefix_sum</span>(w.<span class=built_in>size</span>()) {</span><br><span class=line>        <span class=comment>// 2 3 5</span></span><br><span class=line>        prefix_sum[<span class=number>0</span>] = w[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < prefix_sum.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            prefix_sum[i] = prefix_sum[i - <span class=number>1</span>] + w[i];</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>lower_bound</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> val)</span> </span>{</span><br><span class=line>        <span class=comment>// 求第一个大于等于val的索引</span></span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>0</span>, right = nums.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>while</span> (left <= right) {</span><br><span class=line>            <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>            <span class=keyword>if</span> (nums[mid] >= val) {</span><br><span class=line>                res = mid;</span><br><span class=line>                right = mid - <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                left = mid + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>pickIndex</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=comment>// 计算前缀和数组</span></span><br><span class=line>        <span class=keyword>int</span> randomVal = (<span class=built_in>rand</span>() % (prefix_sum.<span class=built_in>back</span>())) + <span class=number>1</span>;</span><br><span class=line>        <span class=comment>// 判断生成的randomIdx在哪个区间 lower_bound</span></span><br><span class=line>        <span class=keyword>int</span> res_idx = <span class=built_in>lower_bound</span>(prefix_sum, randomVal);</span><br><span class=line>        <span class=keyword>return</span> res_idx;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Your Solution object will be instantiated and called as such:</span></span><br><span class=line><span class=comment> * Solution* obj = new Solution(w);</span></span><br><span class=line><span class=comment> * int param_1 = obj->pickIndex();</span></span><br><span class=line><span class=comment> */</span></span><br></pre></table></figure><p><img alt=image-20260127200828547 data-src=https://s2.loli.net/2026/01/27/ZOiU1tYajTzcCMf.png><p><a href=https://leetcode.cn/problems/add-without-plus-lcci/ rel=noopener target=_blank>不用加号的加法</a><p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。<p>考虑两个二进制位相加的四种情况如下：<p>0 + 0 = 0<br>0 + 1 = 1<br>1 + 0 = 1<br>1 + 1 = 0 (进位)<br>可以发现，对于整数 a 和 b：<p>在不考虑进位的情况下，其无进位加法结果为 a⊕b。<p>而所有需要进位的位为 a & b，进位后的进位结果为 (a & b) << 1。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>add</span><span class=params>(<span class=keyword>int</span> a, <span class=keyword>int</span> b)</span> </span>{</span><br><span class=line>        <span class=comment>// 0 0 0</span></span><br><span class=line>        <span class=comment>// 0 1 0</span></span><br><span class=line>        <span class=comment>// 1 1 1</span></span><br><span class=line>        <span class=comment>// 不考虑进位 ,加法结果  s = a^b;</span></span><br><span class=line>        <span class=comment>// 进位如何计算 c = (a&b)<&LT1;</span></span><br><span class=line>        <span class=keyword>while</span> (b != <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>unsigned</span> <span class=keyword>int</span> car = (a & b) << <span class=number>1</span>;</span><br><span class=line>            a = a ^ b;</span><br><span class=line>            b = car;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> a;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>两数相除<p>给你两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。<p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的 <strong>商</strong> 。<p><strong>注意：</strong>假设我们的环境只能存储 <strong>32 位</strong> 有符号整数，其数值范围是 <code>[−231, 231 − 1]</code> 。本题中，如果商 <strong>严格大于</strong> <code>231 − 1</code> ，则返回 <code>231 − 1</code> ；如果商 <strong>严格小于</strong> <code>-231</code> ，则返回 <code>-231</code> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>divide</span><span class=params>(<span class=keyword>int</span> dividend, <span class=keyword>int</span> divisor)</span> </span>{</span><br><span class=line>        <span class=comment>// 1. 处理最特殊的溢出情况</span></span><br><span class=line>        <span class=keyword>if</span> (dividend == INT_MIN && divisor == <span class=number>-1</span>)</span><br><span class=line>            <span class=keyword>return</span> INT_MAX;</span><br><span class=line>        <span class=keyword>if</span> (dividend == INT_MIN && divisor == <span class=number>1</span>)</span><br><span class=line>            <span class=keyword>return</span> INT_MIN;</span><br><span class=line>        <span class=comment>// 2. 确定最终符号</span></span><br><span class=line>        <span class=keyword>bool</span> negative = (dividend > <span class=number>0</span>) ^ (divisor > <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3. 全部转为负数处理，防止绝对值溢出</span></span><br><span class=line>        <span class=keyword>int</span> a = dividend > <span class=number>0</span> ? -dividend : dividend;</span><br><span class=line>        <span class=keyword>int</span> b = divisor > <span class=number>0</span> ? -divisor : divisor;</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> res = <span class=number>0</span>;</span><br><span class=line>        <span class=comment>// 4. 核心逻辑：利用位移寻找最大的倍数</span></span><br><span class=line>        <span class=keyword>while</span> (a <= b) {</span><br><span class=line>            <span class=keyword>int</span> value = b;</span><br><span class=line>            <span class=keyword>int</span> k = <span class=number>1</span>;</span><br><span class=line>            <span class=comment>// 这里的判断是为了防止 value << 1 溢出</span></span><br><span class=line>            <span class=comment>// 注意 a 和 value 都是负数，所以是 >=</span></span><br><span class=line>            <span class=keyword>while</span> (value >= (INT_MIN >> <span class=number>1</span>) && a <= (value << <span class=number>1</span>)) {</span><br><span class=line>                value <<= <span class=number>1</span>;</span><br><span class=line>                k <<= <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>            a -= value;</span><br><span class=line>            res += k;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> negative ? -res : res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><blockquote><figure class="highlight lisp"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>while (<span class=name>value</span> >= (<span class=name>INT_MIN</span> >> <span class=number>1</span>) <span class=symbol>&&</span> a <= (<span class=name>value</span> << <span class=number>1</span>))</span><br></pre></table></figure></blockquote><p>这行代码有两个判断条件：<ol><li><strong><code>value >= (INT_MIN >> 1)</code></strong>：<ul><li>这是<strong>安全检查</strong>。<li>因为接下来我们要执行 <code>value << 1</code>（即乘以 $2$）。如果 <code>value</code> 已经比 <code>INT_MIN</code> 的一半还要小了，再乘 $2$ 就会溢出。</ul><li><strong><code>a <= (value << 1)</code></strong>：<ul><li>这是<strong>空间检查</strong>。<li>翻译成白话：<strong>“如果我把现在除数再翻一倍，被除数 $a$ 还够不够减？”</strong><li>如果够减，就执行 <code>value <<= 1</code>（价值翻倍）和 <code>k <<= 1</code>（数量翻倍）。</ul></ol><p>字符串相乘<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>multiply</span><span class=params>(string num1, string num2)</span> </span>{</span><br><span class=line>        <span class=comment>//</span></span><br><span class=line>        <span class=keyword>if</span> (num1 == <span class=string>"0"</span> || num2 == <span class=string>"0"</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=string>"0"</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 3 4</span></span><br><span class=line>        <span class=keyword>int</span> n1 = num1.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n2 = num2.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 12</span></span><br><span class=line>        <span class=comment>// 19</span></span><br><span class=line>        <span class=comment>//   0018</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>ans</span><span class=params>(n1 + n2)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = n1 - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = n2 - <span class=number>1</span>; j >= <span class=number>0</span>; j--) {</span><br><span class=line>                <span class=comment>// 相乘+低位</span></span><br><span class=line>                <span class=keyword>int</span> mul = (num1[i] - <span class=string>'0'</span>) * (num2[j] - <span class=string>'0'</span>) + ans[i + j + <span class=number>1</span>];</span><br><span class=line>                ans[i + j + <span class=number>1</span>] = mul % <span class=number>10</span>;</span><br><span class=line>                ans[i + j] += mul / <span class=number>10</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        string res;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < ans.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (res.<span class=built_in>empty</span>() && ans[i] == <span class=number>0</span>) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            res += <span class=built_in>to_string</span>(ans[i]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> sum = mul + res[i + j + <span class=number>1</span>]; <span class=comment>// 1. 把当前的乘积加上这一位原有的数（包含之前的进位）</span></span><br><span class=line>res[i + j + <span class=number>1</span>] = sum % <span class=number>10</span>;      <span class=comment>// 2. 确定这一位的最终数字（0-9）</span></span><br><span class=line>res[i + j] += sum / <span class=number>10</span>;         <span class=comment>// 3. 把多出来的进位“送”给左边一位</span></span><br></pre></table></figure><p>这种写法的精妙之处在于：<strong>它把复杂的进位处理变成了“原地滚雪球”。</strong> 你不需要写 <code>while</code> 循环去处理连续进位（比如 $999 + 1$），因为外层的 <code>i, j</code> 循环在向左移动时，会自动处理掉之前留在 <code>res[i+j]</code> 里的进位。<p>x的平方根<p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>mySqrt</span><span class=params>(<span class=keyword>int</span> x)</span> </span>{</span><br><span class=line>        <span class=comment>// 二分法</span></span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>1</span>, right = x;</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>while</span> (left <= right) {</span><br><span class=line>            <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>            <span class=keyword>if</span> (mid <= x/mid) {</span><br><span class=line>                ans = mid;</span><br><span class=line>                left = mid + <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                right = mid - <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>此外也可以用牛顿迭代法<p>计数质数<p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>countPrimes</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (n <= <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> cnt = n - <span class=number>2</span>;</span><br><span class=line>        <span class=comment>// 埃氏筛</span></span><br><span class=line>        <span class=comment>// 质数的倍数不是质数</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isPrime</span><span class=params>(n, <span class=literal>true</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i < n; i++) {</span><br><span class=line>            <span class=keyword>if</span> (isPrime[i]) {</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>long</span> <span class=keyword>long</span> j = (<span class=keyword>long</span> <span class=keyword>long</span>)i * i; j < n; j += i) {</span><br><span class=line>                    <span class=keyword>if</span> (isPrime[j]) {</span><br><span class=line>                        cnt--;</span><br><span class=line>                        isPrime[j] = <span class=literal>false</span>;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>丑数<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和 <code>5</code> 的 <em>正</em> 整数。<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isUgly</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (n <= <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 计算一个数的所有质因数</span></span><br><span class=line>        <span class=comment>// 是否包含非2,3,5的正整数</span></span><br><span class=line>        vector<<span class=keyword>int</span>> factor = {<span class=number>2</span>,<span class=number>3</span>,<span class=number>5</span>};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>auto</span>& f:factor) {</span><br><span class=line>            <span class=keyword>while</span>(n%f == <span class=number>0</span>) {</span><br><span class=line>                n/=f;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> n==<span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><ul><li>质数:质数概念，质数筛选法<li>实现加减乘除、平方、次方以及开根号。<li>矩阵运算，矩阵基本性质，矩阵旋转。<li>最大公约数。<li>排列组合。</ul><h3 id=位运算><a class=headerlink href=#位运算 title=位运算></a>位运算</h3><p><code>位运算</code>是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：<ul><li><code>∧</code>：按位异或<li><code>&</code>：按位与<li><code>|</code>：按位或<li><code>~</code>：取反<li><code><<</code>：算术左移<li><code>>></code>：算术右移</ul><p>以下是一些常见的位运算特性，其中 <code>0s</code> 和 <code>1s</code> 分别表示只由 <code>0</code> 或 <code>1</code> 构成的二进制数字。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>x ^ 0s = x      x & 0s = 0     x | 0s = x</span><br><span class=line>x ^ 1s = ~x     x & 1s = x     x | 1s = 1s</span><br><span class=line>x ^ x = 0       x & x = x      x | x = x</span><br></pre></table></figure><p>除此之外，n & (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，减去 1 得到 11110011，这两个数按位与得到 11110000。<strong>n & (-n) 可以得到 n 的位级表示中最低的那一位</strong>，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。x - x&(-x) = x&(x-1)<h3 id=二进制特性><a class=headerlink href=#二进制特性 title=二进制特性></a>二进制特性</h3><p>给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。<p>怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字，每个位置表示是否存在该字母。如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0。同时，我们可以建立一个哈希表来存储二进制数字到最长子母串长度的映射关系<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>maxProduct</span><span class=params>(vector&LTstring>& words)</span> </span>{</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> cache;</span><br><span class=line>    <span class=keyword>int</span> max_prod = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>const</span> string& word : words) {</span><br><span class=line>        <span class=keyword>int</span> mask = <span class=number>0</span>, w_len = word.<span class=built_in>length</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>char</span> c : word) {</span><br><span class=line>            mask |= <span class=number>1</span> << (c - ’a’);</span><br><span class=line>        }</span><br><span class=line>        cache[mask] = <span class=built_in>max</span>(cache[mask], w_len);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> [h_mask, h_len] : cache) {</span><br><span class=line>            <span class=keyword>if</span> ((mask & h_mask) == <span class=number>0</span>) {</span><br><span class=line>                max_prod = <span class=built_in>max</span>(max_prod, w_len * h_len);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> max_prod;</span><br><span class=line>}</span><br></pre></table></figure><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。<p>可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp[i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数则为 dp[i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp[i>>1]。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>countBits</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 一次遍历 状态递推</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>res</span><span class=params>(n + <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=comment>// 如果i是奇数 res[i] = res[i-1]+1</span></span><br><span class=line>        <span class=comment>// 偶数 res[i] = res[i/2];</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>if</span> (i & <span class=number>1</span>) {</span><br><span class=line>                res[i] = res[i - <span class=number>1</span>] + <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                res[i] = res[i / <span class=number>2</span>];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h1 id=回文><a class=headerlink href=#回文 title=回文></a>回文</h1><h3 id=验证回文串><a class=headerlink href=#验证回文串 title=验证回文串></a>验证回文串</h3><p>给你一个字符串 <code>s</code>，<strong>最多</strong> 可以从中删除一个字符。<p>请你判断 <code>s</code> 是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code><p>考虑“最多删除一个字符，然后判断其能否成为回文字符串”。对上述回文字符串算法稍加改造，然后加上一些额外的逻辑来解决本题。我们仍然采用头/尾双指针的方法，并且更新指针的逻辑和上面也是一样的，不同之处如下。1．如果头/尾指针对应的字符相同，那么没有必要删除任何字符。2．如果头/尾指针对应的字符不同，那么必须删除一个字符才可能使之回文，并且由于只能删除一次，接下来只需要判断剩下的字符串是否能够构成回文即可。具体算法如下。<p>1．建立头/尾双指针l和r，分别指向字符串的第一个元素和最后一个元素。<p>2．如果l和r没有交会，则比较两个指针对应的字符。●　如果两个字符相同，则更新双指针，即l+=1，r-=1，重复执行步骤。●　如果两个字符不同，考虑删除左指针对应的字符或删除右指针对应的字符，并观察删除之后是否可以构成回文字符串。如果可以，则直接返回True；如果不可以，则直接返回False。<p>3．表示该字符串不需要删除字符就已经是回文字符串，直接返回True。<p>判断回文链表<p>判断回文数<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isPalindrome</span><span class=params>(<span class=keyword>int</span> x)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (x < <span class=number>0</span> || (x != <span class=number>0</span> && x % <span class=number>10</span> == <span class=number>0</span>)) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> reverse_num{};</span><br><span class=line>        <span class=keyword>while</span> (x > reverse_num) {</span><br><span class=line>            reverse_num = reverse_num * <span class=number>10</span> + x % <span class=number>10</span>;</span><br><span class=line>            x /= <span class=number>10</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 字长度为奇数</span></span><br><span class=line>        <span class=keyword>return</span> reverse_num == x || x == reverse_num / <span class=number>10</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>最长回文串<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。<p>动态规划或中心扩展<p>最长回文子序列<p>动态规划<p>用 <em>dp</em>[<em>i</em>][<em>j</em>] 表示字符串 <em>s</em> 的下标范围 [<em>i</em>,<em>j</em>] 内的最长回文子序列的长度<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>longestPalindromeSubseq</span><span class=params>(string s)</span> </span>{</span><br><span class=line>        <span class=comment>// 动态规划</span></span><br><span class=line>        <span class=keyword>int</span> sz = s.<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(</span><br><span class=line>            sz,</span><br><span class=line>            vector<<span class=keyword>int</span>>(sz)); <span class=comment>// 以s[i-j]的子串中最长回文子序列</span></span><br><span class=line>        <span class=comment>// dp[i][j] = dp[i+1][j-1]+2, s[i] == s[j]</span></span><br><span class=line>        <span class=comment>// max(dp[i+1][j],dp[i][j-1])</span></span><br><span class=line>      <span class=comment>//  由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = sz - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = i; j < sz; j++) {</span><br><span class=line>                <span class=keyword>if</span> (i == j) {</span><br><span class=line>                    dp[i][j] = <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    <span class=keyword>if</span> (s[i] == s[j]) {</span><br><span class=line>                        dp[i][j] = dp[i + <span class=number>1</span>][j - <span class=number>1</span>] + <span class=number>2</span>;</span><br><span class=line>                    } <span class=keyword>else</span> {</span><br><span class=line>                        dp[i][j] = <span class=built_in>max</span>(dp[i + <span class=number>1</span>][j], dp[i][j - <span class=number>1</span>]);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[<span class=number>0</span>][sz - <span class=number>1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>滚动数组优化,由于dp[i][j]仅依赖于dp[i+1][j]和dp[i][j-1],使用滚动数组优化<blockquote><p>核心逻辑是：<strong>既然计算当前状态只依赖于前一个（或前几个）状态，那我们就没必要把整张 DP 大表都存在内存里。</strong></blockquote><p>在标准的 DP 中，我们通常会开一个很大的数组（比如 <code>dp[n][m]</code>）来记录每一个子问题的解。但很多时候，你在计算第 $i$ 行时，只会用到第 $i-1$ 行的数据，而第 $i-2, i-3$ 行的数据就变成了“过时信息”<p>两种常见的演进方式<p>第一种：模运算切换（双行滚动）<p>这种方式最直观。如果你发现 $dp[i]$ 只依赖于 $dp[i-1]$，你可以只开两个数组：<code>dp[0]</code> 和 <code>dp[1]</code>。<ul><li><strong>第 0 次</strong>：计算结果存入 <code>dp[0]</code><li><strong>第 1 次</strong>：根据 <code>dp[0]</code> 计算结果，存入 <code>dp[1]</code><li><strong>第 2 次</strong>：根据 <code>dp[1]</code> 计算结果，存入 <code>dp[0]</code>（覆盖掉没用的旧数据）</ul><p><strong>代码技巧：</strong><p>使用 <code>i % 2</code> 或者 <code>i & 1</code> 来切换下标。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment>// 优化前：dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class=line><span class=comment>// 优化后：</span></span><br><span class=line>dp[i % <span class=number>2</span>] = dp[(i - <span class=number>1</span>) % <span class=number>2</span>] + dp[(i - <span class=number>2</span>) % <span class=number>2</span>];</span><br></pre></table></figure><p>第二种：单行覆盖（最极致的优化）<p>如果你能巧妙地安排计算顺序，甚至连两行都不需要，<strong>只需要一个一维数组</strong>。<p>最经典的例子是 <strong>0-1 背包问题</strong>：<ul><li><strong>原本</strong>：<code>dp[i][j]</code> 表示前 $i$ 个物品在容量为 $j$ 时的最大价值。<li><strong>优化后</strong>：<code>dp[j]</code>。<li><strong>关键点</strong>：为了防止在计算当前行时使用了“已经被更新过的当前行数据”（即重复放入物品），我们需要<strong>倒序遍历</strong>容量 $j$。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>longestPalindromeSubseq</span><span class=params>(string s)</span> </span>{</span><br><span class=line>        <span class=comment>// 动态规划</span></span><br><span class=line>        <span class=keyword>int</span> sz = s.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(sz)</span></span>; <span class=comment>// 以s[i-j]的子串中最长回文子序列</span></span><br><span class=line>        <span class=comment>// dp[i][j] = dp[i+1][j-1]+2, s[i] == s[j]</span></span><br><span class=line>        <span class=comment>// max(dp[i+1][j],dp[i][j-1])</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>tmp</span><span class=params>(sz)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = sz - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = i; j < sz; j++) {</span><br><span class=line>                <span class=keyword>if</span> (i == j) {</span><br><span class=line>                    dp[j] = <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    <span class=keyword>if</span> (s[i] == s[j]) {</span><br><span class=line>                        dp[j] = tmp[j - <span class=number>1</span>] + <span class=number>2</span>;</span><br><span class=line>                    } <span class=keyword>else</span> {</span><br><span class=line>                        dp[j] = <span class=built_in>max</span>(tmp[j], dp[j - <span class=number>1</span>]);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            tmp = dp;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[sz - <span class=number>1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>超级回文数<p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为 <strong>超级回文数</strong> 。<p>现在，给你两个以字符串形式表示的正整数 left 和 right ，统计并返回区间 <code>[left, right]</code> 中的 <strong>超级回文数</strong> 的数目。<p>直接在 $10^{18}$ 的区间里找回文数无异于大海捞针，但构造 $10^9$ 以内的回文数非常快。<p>一个回文数 $R$ 可以由它的“前半部分”决定：<ul><li>如果 $R$ 的长度为 $L$，我们只需要枚举前 $\lceil L/2 \rceil$ 位数字。<li>例如，前缀 <code>123</code> 可以构造出：<ul><li>奇数长度回文：<code>12321</code><li>偶数长度回文：<code>123321</code></ul></ul><p>由于 $R \le 10^9$，它的前缀最大只需要到 $10^{4.5} \approx 31622$。实际上，我们只需要从 $1$ 枚举到 $10^5$ 左右，就能构造出所有的回文根 $R$。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>check</span><span class=params>(string& x, <span class=keyword>long</span> <span class=keyword>long</span> left, <span class=keyword>long</span> <span class=keyword>long</span> right)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (x.<span class=built_in>size</span>() >= <span class=number>10</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> num = <span class=built_in>stoll</span>(x);</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> r = num * num;</span><br><span class=line>        <span class=keyword>if</span> (r > right) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 验证根号值在范围内并且平方为回文</span></span><br><span class=line>        string s = <span class=built_in>to_string</span>(r);</span><br><span class=line>        <span class=keyword>if</span> (r >= left && <span class=built_in>validPalindrome</span>(s)) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>validPalindrome</span><span class=params>(string& s)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>0</span>, r = s.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (l < r) {</span><br><span class=line>            <span class=keyword>if</span> (s[l] != s[r]) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>            l++;</span><br><span class=line>            r--;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>superpalindromesInRange</span><span class=params>(string left, string right)</span> </span>{</span><br><span class=line>        <span class=keyword>const</span> <span class=keyword>int</span> MAGIC = <span class=number>1e5</span>;</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> l = <span class=built_in>stoll</span>(left);</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> r = <span class=built_in>stoll</span>(right);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < MAGIC; i++) {</span><br><span class=line>            string s = <span class=built_in>to_string</span>(i);</span><br><span class=line>            string rs = s;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = s.<span class=built_in>size</span>() - <span class=number>2</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>                rs += s[i];</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>check</span>(rs, l, r)) {</span><br><span class=line>                res++;</span><br><span class=line>            }</span><br><span class=line>            rs = s;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = s.<span class=built_in>size</span>() - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>                rs += s[i];</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>check</span>(rs, l, r)) {</span><br><span class=line>                res++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=游戏问题><a class=headerlink href=#游戏问题 title=游戏问题></a>游戏问题</h3><p>给定一个长度为4的整数数组 <code>cards</code> 。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符 <code>['+', '-', '*', '/']</code> 和括号 <code>'('</code> 和 <code>')'</code> 将这些卡片上的数字排列成数学表达式，以获得值24。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>solve</span><span class=params>(vector<<span class=keyword>double</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (nums.<span class=built_in>size</span>() == <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>abs</span>(nums[<span class=number>0</span>] - <span class=number>24.0</span>) < <span class=number>1e-6</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 选择其中两个数</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < nums.<span class=built_in>size</span>(); j++) {</span><br><span class=line>                <span class=keyword>if</span> (i == j) {</span><br><span class=line>                    <span class=comment>// 同一个数</span></span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                vector<<span class=keyword>double</span>> nextNums;</span><br><span class=line>                <span class=comment>// 剩下的数</span></span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>int</span> k = <span class=number>0</span>; k < nums.<span class=built_in>size</span>(); k++) {</span><br><span class=line>                    <span class=keyword>if</span> (k != i && k != j) {</span><br><span class=line>                        <span class=comment>// 选择剩余的数</span></span><br><span class=line>                        nextNums.<span class=built_in>push_back</span>(nums[k]);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>                <span class=comment>// 对选择的两个数进行计算</span></span><br><span class=line>                <span class=keyword>double</span> n = nums[i] + nums[j];</span><br><span class=line>                nextNums.<span class=built_in>push_back</span>(n);</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>solve</span>(nextNums)) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>                nextNums.<span class=built_in>pop_back</span>();</span><br><span class=line>                <span class=comment>// 减法</span></span><br><span class=line>                n = nums[i] - nums[j];</span><br><span class=line>                nextNums.<span class=built_in>push_back</span>(n);</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>solve</span>(nextNums)) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>                nextNums.<span class=built_in>pop_back</span>();</span><br><span class=line></span><br><span class=line>                <span class=comment>// 乘法</span></span><br><span class=line>                n = nums[i] * nums[j];</span><br><span class=line>                nextNums.<span class=built_in>push_back</span>(n);</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>solve</span>(nextNums)) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>                nextNums.<span class=built_in>pop_back</span>();</span><br><span class=line>                <span class=comment>// 除法</span></span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>abs</span>(nums[j]) > <span class=number>1e-6</span>) {</span><br><span class=line>                    n = nums[i] / nums[j];</span><br><span class=line>                    nextNums.<span class=built_in>push_back</span>(n);</span><br><span class=line>                    <span class=keyword>if</span> (<span class=built_in>solve</span>(nextNums)) {</span><br><span class=line>                        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                    }</span><br><span class=line>                    nextNums.<span class=built_in>pop_back</span>();</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>judgePoint24</span><span class=params>(vector<<span class=keyword>int</span>>& cards)</span> </span>{</span><br><span class=line>        <span class=comment>// 4个数字选择其中两个 进行计算 直到只剩1个</span></span><br><span class=line>        <span class=comment>// 回溯/穷举</span></span><br><span class=line>        vector<<span class=keyword>double</span>> nums;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& n : cards) {</span><br><span class=line>            nums.<span class=built_in>push_back</span>(<span class=keyword>static_cast</span><<span class=keyword>double</span>>(n));</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>solve</span>(nums);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>解数独<p>编写一个程序，通过填充空格来解决数独问题。<p>数独的解法需 <strong>遵循如下规则</strong>：<ol><li>数字 <code>1-9</code> 在每一行只能出现一次。<li>数字 <code>1-9</code> 在每一列只能出现一次。<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示<h2 id=广度优先和深度优先遍历><a class=headerlink href=#广度优先和深度优先遍历 title=广度优先和深度优先遍历></a>广度优先和深度优先遍历</h2><p>据搜索方式的不同，搜索算法大致可以分为深度优先遍历（Depth First Search，DFS）和广度优先遍历（Breadth First Search，BFS）。<p>以树为例，DFS的思路是沿着子树尽可能深地搜索树的分支，到达叶子节点后通过回溯重复上述过程，直到所有的节点都被访问。BFS的思路则是一层一层地访问节点，直到完成遍历。由于DFS和BFS的这种差异，BFS一般用来求解最短问题（dijkstra算法的特例），而DFS书写起来比较简单，因此对于不是最短问题的情况，我们优先考虑使用DFS。然而事无绝对，DFS 也可以解决最短问题，但是要注意栈溢出的问题。在很多情况下，两者可以交替使用，比如本章要讲的岛屿问题。不管是DFS还是BFS，本质上都是搜索，而这样的搜索通常来说都是暴力搜索，因此当需要对问题的所有可能情况进行穷举时，我们就应该想到DFS和BFS。而第16章要讲解的回溯法，也是DFS的一种，即也是一种暴力搜索方法，只不过回溯法会涉及前进和回溯的过程。<p>使用DFS进行解题的大概思路是定义起始节点和结束节点，从起点开始不断深入其他节点，在搜索的过程中判断是否满足特定条件<p><img alt=image-20260202132556224 data-src=https://s2.loli.net/2026/02/02/bcyS78esmrTuiHl.png><p>如果在树的题目中使用DFS，由于树是不存在环的，因此有关树的题目大多数不需要visited，但是如果对树的结构做了修改，使之出现了环，那就仍然需要visited<p>对于二叉树的题目，除了递归出口的条件，还会写一些其他的逻辑，这些逻辑由于位置的不同，产生的效果也截然不同。根据DFS逻辑位置的不同，我们将其分为三种类型，一种是自顶向下（前序遍历）的，一种是自底向上（后序遍历）的，最后一种是中序遍历。<p>大多数有关树的题目使用后序遍历会比较简单，并且大多需要依赖左/右子树的返回值。例如第1448题统计二叉树中好节点的数目。<p>●　也有一部分有关树的题目需要前序遍历，而前序遍历通常要结合参数扩展技巧。例如第1022题从根到叶的二进制数之和。<p>●　如果能使用参数和节点本身的值来决定应该传递给它的子节点的参数，那么就用前序遍历。<p>●　对于树中的任意一个节点，如果知道它子节点的答案，就能计算出当前节点的答案，那么就用后序遍历。●　如果遇到二叉搜索树，则考虑使用中序遍历。<p>相对于DFS来说，BFS的变种比较少，能解决的问题种类比较单一。BFS比较适合用来找最短距离，因此如果题目中提到了最短距离，首先应该想到使用BFS。使用BFS进行解题的思路同样是定义起始节点和结束节点，从起点开始不断深入其他节点，在搜索的过程中判断是否满足特定条件。BFS和DFS只是遍历的方向不同，即上面提到的DFS是尽可能深地搜索树的分支，而BFS则是一层一层地访问节点。队列可以帮我们实现“一层一层地访问节点”的效果。其本质就是不断访问邻居，把邻居逐个加入队列，根据队列先进先出的特点，把每一层节点访问完后，会继续访问下一层节点<p>路径之和<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。<p><strong>叶子节点</strong> 是指没有子节点的节点。<p>一种直观的思路是自顶向下，使用前序遍历+参数扩展，在向下递归的同时更新参数，当到达叶子节点或空节点时判断是否满足条件。在这里，我们可以将目标和sum通过参数扩展的形式向下传递，在叶子节点上判断当前节点的val是否等于传递下来的参数sum。这是一种非常常见的DFS解题思路，除了前序遍历，还有一种常见的二叉树的深度遍历法是后序遍历，即在递归函数返回时对问题进行求解，使用子树的返回值来计算当前节点的返回值。通常来讲，DFS有递归和迭代两种实现方式。因为树结构天然具有递归的特性（子树性质和整个树性质一致），使用递归可以很容易地将整个树问题转换成子树问题。当我们层层递归到最小的子树时，这个最小子树的解（也被称为递归出口）往往很容易就能够得到，再一步步回溯就能得到原问题的解。小提示：树的题目，优先考虑使用DFS递归解决。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>dfs</span><span class=params>(TreeNode* node, <span class=keyword>int</span> targetSum)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (node->left == <span class=literal>nullptr</span> && node->right == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>if</span> (node->val == targetSum) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>bool</span> leftIsValid = <span class=built_in>dfs</span>(node->left, targetSum - node->val);</span><br><span class=line>        <span class=keyword>bool</span> rightIsValid = <span class=built_in>dfs</span>(node->right, targetSum - node->val);</span><br><span class=line>        <span class=keyword>if</span> (leftIsValid || rightIsValid) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>hasPathSum</span><span class=params>(TreeNode* root, <span class=keyword>int</span> targetSum)</span> </span>{</span><br><span class=line>        <span class=comment>// 先序遍历DFS</span></span><br><span class=line>        <span class=comment>// 递归</span></span><br><span class=line>        <span class=comment>// return dfs(root, targetSum);</span></span><br><span class=line>        <span class=comment>// 迭代</span></span><br><span class=line>        <span class=keyword>if</span> (!root) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        stack&LTpair&LTTreeNode*, <span class=keyword>int</span>>> stk;</span><br><span class=line>        stk.<span class=built_in>push</span>({root, targetSum});</span><br><span class=line>        <span class=keyword>while</span> (!stk.<span class=built_in>empty</span>()) {</span><br><span class=line>            <span class=keyword>auto</span> [node, target] = stk.<span class=built_in>top</span>();</span><br><span class=line>            stk.<span class=built_in>pop</span>();</span><br><span class=line>            <span class=keyword>if</span> (node->left == <span class=literal>nullptr</span> && node->right == <span class=literal>nullptr</span>) {</span><br><span class=line>                <span class=keyword>if</span> (node->val == target) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (node->left) {</span><br><span class=line>                stk.<span class=built_in>push</span>({node->left, target - node->val});</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (node->right) {</span><br><span class=line>                stk.<span class=built_in>push</span>({node->right, target - node->val});</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>二叉树中的最大路径和<p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>int</span> res{INT_MIN};</span><br><span class=line>    <span class=comment>// 获得该节点的“贡献”</span></span><br><span class=line>    <span class=comment>// 也就是该节点为根节点/开始，的最大路径和</span></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>dfs</span><span class=params>(TreeNode* node)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 后序遍历</span></span><br><span class=line>        <span class=keyword>int</span> lVal = <span class=built_in>max</span>(<span class=number>0</span>, <span class=built_in>dfs</span>(node->left));</span><br><span class=line>        <span class=keyword>int</span> rVal = <span class=built_in>max</span>(<span class=number>0</span>, <span class=built_in>dfs</span>(node->right));</span><br><span class=line>        <span class=comment>// 计算每个节点贡献的值</span></span><br><span class=line>        <span class=keyword>int</span> nodeVal = <span class=built_in>max</span>(lVal, rVal) + node->val;</span><br><span class=line>        <span class=comment>// 更新最大值</span></span><br><span class=line>        res = <span class=built_in>max</span>(res, lVal + rVal + node->val);</span><br><span class=line>        <span class=keyword>return</span> nodeVal;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxPathSum</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>        <span class=comment>// 路径和的组成</span></span><br><span class=line>        <span class=comment>// 1.经过根节点以及左右子节点</span></span><br><span class=line>        <span class=comment>// 2.不经过根节点 左子树</span></span><br><span class=line>        <span class=comment>// 3.不经过根节点 右子树</span></span><br><span class=line>        <span class=comment>// 选取这其中的最大值</span></span><br><span class=line>        <span class=built_in>dfs</span>(root);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h3 id=岛屿问题><a class=headerlink href=#岛屿问题 title=岛屿问题></a>岛屿问题</h3><p>给你一个大小为 <code>m x n</code> 的二维二进制网格 <code>grid</code> 。网格表示一个地图，其中，<code>0</code> 表示水，<code>1</code> 表示陆地。最初，<code>grid</code> 中的所有单元格都是水单元格（即，所有单元格都是 <code>0</code>）。<p>可以通过执行 <code>addLand</code> 操作，将某个位置的水转换成陆地。给你一个数组 <code>positions</code> ，其中 <code>positions[i] = [ri, ci]</code> 是要执行第 <code>i</code> 次操作的位置 <code>(ri, ci)</code> 。<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将单元格 <code>(ri, ci)</code> 转换为陆地后，地图中岛屿的数量。<p><strong>岛屿</strong> 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。<p>需要动态地求出每次addLand操作之后的无向图中的连通分量。而求连通分量的数量的问题都可以通过DFS、BFS或并查集来解决。首先来看DFS和BFS，任何通过DFS和BFS来解决的图类问题都有一个前提：图是被预先处理好的。而本题中的图是动态变化的，因此这时用DFS或BFS来处理效率就不那么高了。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=class><span class=keyword>class</span> <span class=title>UnionFind</span> {</span></span><br><span class=line>    <span class=keyword>private</span>:</span><br><span class=line>        vector<<span class=keyword>int</span>> parent;</span><br><span class=line>        <span class=keyword>int</span> m;</span><br><span class=line>        <span class=keyword>int</span> cnt{};</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span>:</span><br><span class=line>        <span class=built_in>UnionFind</span>(<span class=keyword>int</span> m, <span class=keyword>int</span> n) : <span class=built_in>m</span>(m) {</span><br><span class=line>            <span class=keyword>int</span> sz = m * n;</span><br><span class=line>            parent.<span class=built_in>resize</span>(sz);</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < sz; i++) {</span><br><span class=line>                parent[i] = <span class=number>-1</span>; <span class=comment>// 水</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=function><span class=keyword>void</span> <span class=title>addLand</span><span class=params>(<span class=keyword>int</span> x, <span class=keyword>int</span> y)</span> </span>{</span><br><span class=line>            <span class=keyword>int</span> p = x * m + y;</span><br><span class=line>            <span class=keyword>if</span> (parent[p] != <span class=number>-1</span>) {</span><br><span class=line>                <span class=comment>// 如果是陆地</span></span><br><span class=line>                <span class=keyword>return</span>;</span><br><span class=line>            }</span><br><span class=line>            parent[p] = p; <span class=comment>// 设置值为本身位置(>0)</span></span><br><span class=line>            cnt++;</span><br><span class=line>        }</span><br><span class=line>        <span class=function><span class=keyword>int</span> <span class=title>find</span><span class=params>(<span class=keyword>int</span> p)</span> </span>{ <span class=keyword>return</span> parent[p] == p ? p : parent[p] = <span class=built_in>find</span>(p); }</span><br><span class=line>        <span class=function><span class=keyword>int</span> <span class=title>find</span><span class=params>(<span class=keyword>int</span> pos_x, <span class=keyword>int</span> pos_y)</span> </span>{</span><br><span class=line>            <span class=keyword>int</span> p = pos_x * m + pos_y;</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>find</span>(p);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=function><span class=keyword>bool</span> <span class=title>isLand</span><span class=params>(<span class=keyword>int</span> x, <span class=keyword>int</span> y)</span> </span>{</span><br><span class=line>            <span class=keyword>int</span> pos = x * m + y;</span><br><span class=line>            <span class=keyword>return</span> parent[pos] != <span class=number>-1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=function><span class=keyword>int</span> <span class=title>getCount</span><span class=params>()</span> </span>{ <span class=keyword>return</span> cnt; }</span><br><span class=line>        <span class=function><span class=keyword>void</span> <span class=title>join</span><span class=params>(<span class=keyword>int</span> u, <span class=keyword>int</span> v)</span> </span>{</span><br><span class=line>            <span class=keyword>int</span> px = <span class=built_in>find</span>(u);</span><br><span class=line>            <span class=keyword>int</span> py = <span class=built_in>find</span>(v);</span><br><span class=line>            <span class=keyword>if</span> (px == py) {</span><br><span class=line>                <span class=keyword>return</span>;</span><br><span class=line>            }</span><br><span class=line>            parent[py] = px;</span><br><span class=line>            cnt--;</span><br><span class=line>        }</span><br><span class=line>    };</span><br><span class=line>    vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> dirs = {{<span class=number>0</span>, <span class=number>1</span>}, {<span class=number>0</span>, <span class=number>-1</span>}, {<span class=number>1</span>, <span class=number>0</span>}, {<span class=number>-1</span>, <span class=number>0</span>}};</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>numIslands2</span><span class=params>(<span class=keyword>int</span> m, <span class=keyword>int</span> n, vector&LTvector<<span class=keyword>int</span>>>& positions)</span> </span>{</span><br><span class=line>        <span class=function>UnionFind <span class=title>uf</span><span class=params>(m, n)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> sz = positions.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>res</span><span class=params>(sz)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < sz; i++) {</span><br><span class=line>            <span class=keyword>int</span> x = positions[i][<span class=number>0</span>];</span><br><span class=line>            <span class=keyword>int</span> y = positions[i][<span class=number>1</span>];</span><br><span class=line>            <span class=keyword>if</span> (uf.<span class=built_in>isLand</span>(x, y)) {</span><br><span class=line>                <span class=comment>// 本身是陆地</span></span><br><span class=line>                res[i] = res[i - <span class=number>1</span>];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 是水</span></span><br><span class=line>                uf.<span class=built_in>addLand</span>(x, y);</span><br><span class=line>                <span class=comment>// 进行合并</span></span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>auto</span>& dir : dirs) {</span><br><span class=line>                    <span class=keyword>int</span> nx = x + dir.first;</span><br><span class=line>                    <span class=keyword>int</span> ny = y + dir.second;</span><br><span class=line>                    <span class=comment>// 判断四个方向能否合并</span></span><br><span class=line>                    <span class=keyword>if</span> (nx < <span class=number>0</span> || nx >= m || ny < <span class=number>0</span> || ny >= n) {</span><br><span class=line>                        <span class=keyword>continue</span>;</span><br><span class=line>                    }</span><br><span class=line>                    <span class=keyword>if</span> (!uf.<span class=built_in>isLand</span>(nx, ny)) {</span><br><span class=line>                        <span class=keyword>continue</span>; <span class=comment>// 如果是水 跳过</span></span><br><span class=line>                    }</span><br><span class=line>                    <span class=keyword>int</span> pos = x * m + y;</span><br><span class=line>                    uf.<span class=built_in>join</span>(pos, nx * m + ny);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            res[i] = uf.<span class=built_in>getCount</span>();</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>DFS和BFS都属于树/图的搜索算法，两者在用于具体问题时各有优劣，具体如下。<p>●　求给定图中两点之间最短路径或检验图的二分性，使用BFS更优。<p>●　求无向图的连通分量数量，两者差不多。两者在实现过程中使用的基础数据结构也有区别。<p>在实际做题当中，一般使用栈来实现DFS，使用队列来实现BFS。另外，DFS和回溯算法之间的关系界线是模糊的，网上的说法也各不一样，在这里我们没必要过于纠结其精确的定义。对于DFS，另外一个知识点也是值得注意的。在二叉树中，DFS可以被分为前序遍历、中序遍历和后序遍历，并且引申出一系列相关题目。最后，本章的路径和问题、岛屿问题只详细讲述了两种算法的基本写法，而在实际的刷题过程中，我们可能会使用这两种基本写法的变种或延伸，比如运用双向搜索技巧、dijkstra 算法、A* 算法等<p>从前序和中序构建二叉树<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Definition for a binary tree node.</span></span><br><span class=line><span class=comment> * struct TreeNode {</span></span><br><span class=line><span class=comment> *     int val;</span></span><br><span class=line><span class=comment> *     TreeNode *left;</span></span><br><span class=line><span class=comment> *     TreeNode *right;</span></span><br><span class=line><span class=comment> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class=line><span class=comment> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class=line><span class=comment> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class=line><span class=comment> * right(right) {}</span></span><br><span class=line><span class=comment> * };</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>TreeNode* <span class=title>buildNode</span><span class=params>(vector<<span class=keyword>int</span>>& preorder, vector<<span class=keyword>int</span>>& inorder,</span></span></span><br><span class=line><span class=params><span class=function>                        unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>>& inOrderMap, <span class=keyword>int</span> leftIdxPre,</span></span></span><br><span class=line><span class=params><span class=function>                        <span class=keyword>int</span> rightIdxPre, <span class=keyword>int</span> leftIdxIn, <span class=keyword>int</span> rightIdxIn)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (leftIdxPre > rightIdxPre) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 1.找到根节点</span></span><br><span class=line>        <span class=keyword>int</span> nodeVal = preorder[leftIdxPre];</span><br><span class=line></span><br><span class=line>        <span class=comment>// 2.确定根节点在中序中位置</span></span><br><span class=line>        <span class=keyword>int</span> idxInOrder = inOrderMap[nodeVal];</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3.确定左右子树范围</span></span><br><span class=line>        <span class=comment>// 左子树节点个数</span></span><br><span class=line>        <span class=keyword>int</span> leftNodeNum = idxInOrder - leftIdxIn;</span><br><span class=line>        <span class=comment>// 4. 递归处理</span></span><br><span class=line>        TreeNode* node = <span class=keyword>new</span> <span class=built_in>TreeNode</span>(nodeVal);</span><br><span class=line>        <span class=comment>// 在先序中 左节点开始的位置是leftIdxPre+1</span></span><br><span class=line>        node->left =</span><br><span class=line>            <span class=built_in>buildNode</span>(preorder, inorder, inOrderMap, leftIdxPre + <span class=number>1</span>,</span><br><span class=line>                      leftIdxPre + leftNodeNum, leftIdxIn, idxInOrder - <span class=number>1</span>);</span><br><span class=line>        node->right = <span class=built_in>buildNode</span>(preorder, inorder, inOrderMap,</span><br><span class=line>                                leftIdxPre + leftNodeNum + <span class=number>1</span>, rightIdxPre,</span><br><span class=line>                                idxInOrder + <span class=number>1</span>, rightIdxIn);</span><br><span class=line>        <span class=keyword>return</span> node;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function>TreeNode* <span class=title>buildTree</span><span class=params>(vector<<span class=keyword>int</span>>& preorder, vector<<span class=keyword>int</span>>& inorder)</span> </span>{</span><br><span class=line>        <span class=comment>// 先序遍历确定根节点</span></span><br><span class=line>        <span class=comment>// 中序遍历确定左右子树/子节点</span></span><br><span class=line>        unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> inOrderMap;</span><br><span class=line>        <span class=keyword>int</span> sz = inorder.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < sz; i++) {</span><br><span class=line>            inOrderMap[inorder[i]] = i; <span class=comment>// 记录中序遍历节点位置</span></span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>auto</span> node =</span><br><span class=line>            <span class=built_in>buildNode</span>(preorder, inorder, inOrderMap, <span class=number>0</span>, sz - <span class=number>1</span>, <span class=number>0</span>, sz - <span class=number>1</span>);</span><br><span class=line>        <span class=keyword>return</span> node;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>不同路径<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<p>问总共有多少条不同的路径？<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>uniquePaths</span><span class=params>(<span class=keyword>int</span> m, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(m,vector<<span class=keyword>int</span>>(n));</span><br><span class=line>        <span class=comment>// 初始化</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>;i&LTn;i++) {</span><br><span class=line>            dp[<span class=number>0</span>][i] = <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>;i&LTm;i++) {</span><br><span class=line>            dp[i][<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>;i&LTm;i++) {</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j = <span class=number>1</span>;j&LTn;j++) {</span><br><span class=line>                dp[i][j] = dp[i<span class=number>-1</span>][j] + dp[i][j<span class=number>-1</span>];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[m<span class=number>-1</span>][n<span class=number>-1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>不同路径I<p>给定一个 <code>m x n</code> 的整数数组 <code>grid</code>。一个机器人初始位于 <strong>左上角</strong>（即 <code>grid[0][0]</code>）。机器人尝试移动到 <strong>右下角</strong>（即 <code>grid[m - 1][n - 1]</code>）。机器人每次只能向下或者向右移动一步。<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。机器人的移动路径中不能包含 <strong>任何</strong> 有障碍物的方格。<p>返回机器人能够到达右下角的不同路径数量。<p>测试用例保证答案小于等于 <code>2 * 109</code>。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>uniquePathsWithObstacles</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& obstacleGrid)</span> </span>{</span><br><span class=line>        <span class=comment>// 动态规划</span></span><br><span class=line>        <span class=keyword>int</span> m = obstacleGrid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = obstacleGrid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// dp[i][j]表示到达i,j的路径数目</span></span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(m, vector<<span class=keyword>int</span>>(n));</span><br><span class=line>        <span class=comment>// 初始化</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>            <span class=keyword>if</span> (obstacleGrid[<span class=number>0</span>][j] == <span class=number>0</span>) {</span><br><span class=line>                dp[<span class=number>0</span>][j] = <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>if</span> (obstacleGrid[i][<span class=number>0</span>] == <span class=number>0</span>) {</span><br><span class=line>                dp[i][<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j < n; j++) {</span><br><span class=line>                <span class=keyword>if</span> (obstacleGrid[i][j] == <span class=number>1</span>) {</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                dp[i][j] = dp[i - <span class=number>1</span>][j] + dp[i][j - <span class=number>1</span>];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[m - <span class=number>1</span>][n - <span class=number>1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>不同路径II<p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：<ul><li><code>1</code> 表示起始方格。且只有一个起始方格。<li><code>2</code> 表示结束方格，且只有一个结束方格。<li><code>0</code> 表示我们可以走过的空方格。<li><code>-1</code> 表示我们无法跨越的障碍。</ul><p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目<strong>。</strong><p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。<p>虽然题目名字叫“不同路径”，但它和普通的动态规划路径题完全不同，因为它有一个硬性约束：<strong>必须经过每一个无障碍方格（0）恰好一次</strong>。图论的角度来看，这实际上是在寻找网格图中的<strong>哈密顿路径（Hamiltonian Path）</strong>。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>int</span> res{};</span><br><span class=line>    vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> dirs = {{<span class=number>0</span>, <span class=number>1</span>}, {<span class=number>0</span>, <span class=number>-1</span>}, {<span class=number>1</span>, <span class=number>0</span>}, {<span class=number>-1</span>, <span class=number>0</span>}};</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>dfs</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& grid, <span class=keyword>int</span> x, <span class=keyword>int</span> y, <span class=keyword>int</span> step,</span></span></span><br><span class=line><span class=params><span class=function>             <span class=keyword>int</span> targetStep)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = grid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = grid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 四个方向</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& dir : dirs) {</span><br><span class=line>            <span class=keyword>int</span> nx = x + dir.first;</span><br><span class=line>            <span class=keyword>int</span> ny = y + dir.second;</span><br><span class=line>            <span class=keyword>if</span> (nx < <span class=number>0</span> || nx >= m || ny < <span class=number>0</span> || ny >= n) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (grid[nx][ny] == <span class=number>-1</span> || grid[nx][ny] == <span class=number>1</span>) {</span><br><span class=line>                <span class=comment>// 不能到达</span></span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (grid[nx][ny] == <span class=number>2</span>) {</span><br><span class=line>                <span class=comment>// 到达终点且必须都走一次</span></span><br><span class=line>                <span class=keyword>if</span> (step == targetStep) {</span><br><span class=line>                    res++;</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=comment>// 不能重复走</span></span><br><span class=line>            grid[nx][ny] = <span class=number>-1</span>;</span><br><span class=line>            <span class=built_in>dfs</span>(grid, nx, ny, step + <span class=number>1</span>, targetStep);</span><br><span class=line>            grid[nx][ny] = <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>uniquePathsIII</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& grid)</span> </span>{</span><br><span class=line>        <span class=comment>// dfs</span></span><br><span class=line>        <span class=keyword>int</span> m = grid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = grid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 记录0的个数</span></span><br><span class=line>        <span class=keyword>int</span> cnt{};</span><br><span class=line>        <span class=keyword>int</span> start_x{}, start_y{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>                <span class=keyword>if</span> (grid[i][j] == <span class=number>0</span>) {</span><br><span class=line>                    cnt++;</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>if</span> (grid[i][j] == <span class=number>1</span>) {</span><br><span class=line>                    start_x = i;</span><br><span class=line>                    start_y = j;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 四个方向走</span></span><br><span class=line>        <span class=built_in>dfs</span>(grid, start_x, start_y, <span class=number>0</span>, cnt);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><ol><li>DFS 回溯 (Backtracking)：试错的探险家</ol><p>回溯的核心是<strong>“尝试 -> 撤销”</strong>。它不关心过去是否算过这个点，它关心的是当前的<strong>路径</strong>。<ul><li><strong>核心逻辑</strong>：走不通就退回来，把标记抹掉，换条路再试。<li><strong>状态依赖</strong>：当前的状态通常依赖于<strong>路径历史</strong>（比如你走过的路，别人就不能再走了）。<li><strong>空间复杂度</strong>：通常较小，只取决于递归深度。<li><strong>时间复杂度</strong>：通常是指数级的，比如 $O(2^n)$ 或 $O(n!)$。</ul><ol><li>记忆化搜索 (Memoization)：聪明的收纳狂</ol><p>记忆化搜索本质上是<strong>“自顶向下的动态规划（DP）”</strong>。它的核心是<strong>“查表 -> 存储”</strong>。<ul><li><strong>核心逻辑</strong>：如果这个子问题我以前算过，直接把结果扔给你，绝不浪费时间重算。<li><strong>状态依赖</strong>：当前的状态只取决于<strong>当前的参数</strong>，与你是怎么走到这一步的（路径）无关。这就是所谓的“无后效性”。<li><strong>空间复杂度</strong>：较大，需要额外的空间（哈希表或数组）来存储中间结果。<li><strong>时间复杂度</strong>：通常能将指数级降低到多项式级，如 $O(n^2)$。</ul><p>如果在 DFS 递归函数的末尾看到了类似这样的代码：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>grid[x][y] = <span class=number>0</span>; <span class=comment>// 恢复现场</span></span><br><span class=line><span class=keyword>return</span> res;</span><br></pre></table></figure><p>这通常是 <strong>回溯</strong>。<p>如果你在递归函数的开头和结尾看到了这样的代码：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (memo[state] != <span class=number>-1</span>) <span class=keyword>return</span> memo[state]; <span class=comment>// 查表</span></span><br><span class=line>...</span><br><span class=line><span class=keyword>return</span> memo[state] = res; <span class=comment>// 存表</span></span><br></pre></table></figure><p>这一定是 <strong>记忆化搜索</strong>。<div class=table-container><table><thead><tr><th><strong>特性</strong><th><strong>记忆化搜索 (Top-down)</strong><th><strong>动态规划 (Bottom-up)</strong><tbody><tr><td><strong>实现方式</strong><td><strong>递归 + 缓存</strong> (通常是哈希表或数组)<td><strong>迭代 + 递推表</strong> (通常是数组)<tr><td><strong>思维方向</strong><td><strong>自顶向下</strong>：从大问题拆解成小问题<td><strong>自底向上</strong>：从小问题推导出大问题<tr><td><strong>计算顺序</strong><td>依赖驱动：只计算到达目标所需的子状态<td>顺序驱动：按预定顺序计算所有可能状态<tr><td><strong>空间开销</strong><td>缓存空间 + <strong>递归调用栈</strong> (容易溢出)<td>缓存空间 (通常可以通过滚动数组优化)<tr><td><strong>适用场景</strong><td>状态空间稀疏、转移方程复杂<td>状态空间密集、需要极致性能优化</table></div><p>公式：$f(n) = f(n-1) + f(n-2)$<p><strong>记忆化搜索版</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>int</span> memo[<span class=number>1001</span>]; <span class=comment>// 初始化为 -1</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>fib</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (n <= <span class=number>1</span>) <span class=keyword>return</span> n;</span><br><span class=line>    <span class=keyword>if</span> (memo[n] != <span class=number>-1</span>) <span class=keyword>return</span> memo[n]; <span class=comment>// 查表</span></span><br><span class=line>    <span class=keyword>return</span> memo[n] = <span class=built_in>fib</span>(n - <span class=number>1</span>) + <span class=built_in>fib</span>(n - <span class=number>2</span>); <span class=comment>// 存表</span></span><br><span class=line>}</span><br></pre></table></figure><p><strong>动态规划版</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>fib</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>    <span class=keyword>if</span> (n <= <span class=number>1</span>) <span class=keyword>return</span> n;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(n + <span class=number>1</span>)</span></span>;</span><br><span class=line>    dp[<span class=number>0</span>] = <span class=number>0</span>; dp[<span class=number>1</span>] = <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>        dp[i] = dp[i - <span class=number>1</span>] + dp[i - <span class=number>2</span>]; <span class=comment>// 顺序填表</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> dp[n];</span><br><span class=line>}</span><br></pre></table></figure><p>统计二叉树中好节点数目<p>给你一棵根为 <code>root</code> 的二叉树，请你返回二叉树中好节点的数目。<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Definition for a binary tree node.</span></span><br><span class=line><span class=comment> * struct TreeNode {</span></span><br><span class=line><span class=comment> *     int val;</span></span><br><span class=line><span class=comment> *     TreeNode *left;</span></span><br><span class=line><span class=comment> *     TreeNode *right;</span></span><br><span class=line><span class=comment> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class=line><span class=comment> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class=line><span class=comment> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class=line><span class=comment> * right(right) {}</span></span><br><span class=line><span class=comment> * };</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>int</span> res{};</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>dfs</span><span class=params>(TreeNode* node, <span class=keyword>int</span> max_val)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 判断一个节点是好节点</span></span><br><span class=line>        <span class=comment>// 从根节点到当前节点的值均小于等于当前节点的值</span></span><br><span class=line>        <span class=comment>// 记录路径中的最大值判断是否小于等于当前值</span></span><br><span class=line>        max_val = <span class=built_in>max</span>(max_val, node->val);</span><br><span class=line>        <span class=keyword>if</span> (max_val <= node->val) {</span><br><span class=line>            res++;</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>dfs</span>(node->left, max_val);</span><br><span class=line>        <span class=built_in>dfs</span>(node->right, max_val);</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>goodNodes</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>        <span class=built_in>dfs</span>(root, INT_MIN);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>矩阵中最长递增路径<p>定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>int</span> ans{<span class=number>1</span>};</span><br><span class=line>    vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> dirs = {{<span class=number>0</span>, <span class=number>1</span>}, {<span class=number>0</span>, <span class=number>-1</span>}, {<span class=number>1</span>, <span class=number>0</span>}, {<span class=number>-1</span>, <span class=number>0</span>}};</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>dfs</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& matrix, <span class=keyword>int</span> x, <span class=keyword>int</span> y,</span></span></span><br><span class=line><span class=params><span class=function>            vector&LTvector<<span class=keyword>int</span>>>& memo)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo[x][y] != <span class=number>-1</span>) {</span><br><span class=line>            <span class=keyword>return</span> memo[x][y];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> m = matrix.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = matrix[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 还未访问过</span></span><br><span class=line>        <span class=keyword>int</span> val{<span class=number>1</span>};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& dir : dirs) {</span><br><span class=line>            <span class=keyword>int</span> nx = x + dir.first;</span><br><span class=line>            <span class=keyword>int</span> ny = y + dir.second;</span><br><span class=line>            <span class=keyword>if</span> (nx < <span class=number>0</span> || nx >= m || ny < <span class=number>0</span> || ny >= n) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (matrix[nx][ny] < matrix[x][y]) {</span><br><span class=line>                val = <span class=built_in>max</span>(val, <span class=number>1</span> + <span class=built_in>dfs</span>(matrix, nx, ny, memo));</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        memo[x][y] = val;</span><br><span class=line>        ans = <span class=built_in>max</span>(ans, val);</span><br><span class=line>        <span class=keyword>return</span> val;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>longestIncreasingPath</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& matrix)</span> </span>{</span><br><span class=line>        <span class=comment>// 反向来,从一个位置向周围四个方向走</span></span><br><span class=line>        <span class=comment>// 直到走到最小值,记录该路径的最长递增路径</span></span><br><span class=line>        <span class=comment>// 重复处理时记忆化</span></span><br><span class=line>        <span class=keyword>int</span> m = matrix.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = matrix[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>memo</span>(m, vector<<span class=keyword>int</span>>(n, <span class=number>-1</span>));</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>                <span class=built_in>dfs</span>(matrix, i, j, memo);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h4 id=博弈论题目><a class=headerlink href=#博弈论题目 title=博弈论题目></a>博弈论题目</h4><p>Nim游戏<p>你和你的朋友，两个人一起玩 <a href=https://baike.baidu.com/item/Nim游戏/6737105 rel=noopener target=_blank>Nim 游戏</a>：<ul><li>桌子上有一堆石头。<li>你们轮流进行自己的回合， <strong>你作为先手</strong> 。<li>每一回合，轮到的人拿掉 1 - 3 块石头。<li>拿掉最后一块石头的人就是获胜者。</ul><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。<p><strong>我能赢吗</strong><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong> 100 的玩家，即为胜者。<p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。<p>给定两个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和 <code>desiredTotal</code>（累计和），若先出手的玩家能稳赢则返回 <code>true</code> ，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。<p>博弈类题目通常很难写出迭代式的 DP，但用<strong>记忆化搜索</strong>配合<strong>状态压缩（Bitmask）</strong>则非常直观。<p>考虑边界情况，当所有数字选完仍无法到达 desiredTotal 时，两人都无法获胜，返回 false。当所有数字的和大于等于 desiredTotal 时，其中一方能获得胜利，需要通过搜索来判断获胜方。<p>在游戏中途，假设已经被使用的数字的集合为 usedNumbers，这些数字的和为 currentTotal。当某方行动时，如果他能在未选择的数字中选出一个 i，使得 i+currentTotal≥desiredTotal，则他能获胜。否则，需要继续通过搜索来判断获胜方。在剩下的数字中，如果他能选择一个 i，使得对方在接下来的局面中无法获胜，则他会获胜。否则，他会失败。<p>根据这个思想设计搜索函数 dfs，其中 usedNumbers 可以用一个整数来表示，从低位到高位，第 i 位为 1 则表示数字 i 已经被使用，为 0 则表示数字 i 未被使用。如果当前玩家获胜，则返回 true，否则返回 false。为了避免重复计算，需要使用记忆化的操作来降低时间复杂度<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>// memo[mask] == 0: 未计算</span></span><br><span class=line>    <span class=comment>// memo[mask] == 1: 必胜 (true)</span></span><br><span class=line>    <span class=comment>// memo[mask] == 2: 必败 (false)</span></span><br><span class=line>    <span class=keyword>int</span> memo[<span class=number>1</span> << <span class=number>21</span>]; </span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>canIWin</span><span class=params>(<span class=keyword>int</span> maxChoosableInteger, <span class=keyword>int</span> desiredTotal)</span> </span>{</span><br><span class=line>        <span class=comment>// 特判 1：如果所有数字之和都达不到目标，谁都赢不了</span></span><br><span class=line>        <span class=keyword>int</span> sum = (<span class=number>1</span> + maxChoosableInteger) * maxChoosableInteger / <span class=number>2</span>;</span><br><span class=line>        <span class=keyword>if</span> (sum < desiredTotal) <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 特判 2：如果最大的数直接能达到目标，先手秒胜</span></span><br><span class=line>        <span class=keyword>if</span> (desiredTotal <= <span class=number>0</span>) <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(maxChoosableInteger, desiredTotal, <span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>dfs</span><span class=params>(<span class=keyword>int</span> maxInt, <span class=keyword>int</span> total, <span class=keyword>int</span> mask)</span> </span>{</span><br><span class=line>        <span class=comment>// 查表：如果算过这个状态，直接返回</span></span><br><span class=line>        <span class=keyword>if</span> (memo[mask] != <span class=number>0</span>) <span class=keyword>return</span> memo[mask] == <span class=number>1</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 尝试选择每一个还没被选过的数字</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= maxInt; i++) {</span><br><span class=line>            <span class=keyword>int</span> bit = <span class=number>1</span> << i;</span><br><span class=line>            <span class=keyword>if</span> (!(mask & bit)) { <span class=comment>// 如果数字 i 还没被选</span></span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 1. 如果选了 i 直接达到目标，我赢了</span></span><br><span class=line>                <span class=comment>// 2. 或者选了 i 之后，递归下去对方会输 (dfs 返回 false)</span></span><br><span class=line>                <span class=keyword>if</span> (total - i <= <span class=number>0</span> || !<span class=built_in>dfs</span>(maxInt, total - i, mask | bit)) {</span><br><span class=line>                    memo[mask] = <span class=number>1</span>; <span class=comment>// 记录必胜</span></span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        memo[mask] = <span class=number>2</span>; <span class=comment>// 所有尝试都失败了，我必败</span></span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><a href=https://leetcode.cn/problems/guess-number-higher-or-lower-ii/ rel=noopener target=_blank>猜数字大小 II</a><p>我们正在玩一个猜数游戏，游戏规则如下：<ol><li>我从 <code>1</code> 到 <code>n</code> 之间选择一个数字。<li>你来猜我选了哪个数字。<li>如果你猜到正确的数字，就会 <strong>赢得游戏</strong> 。<li>如果你猜错了，那么我会告诉你，我选的数字比你的 <strong>更大或者更小</strong> ，并且你需要继续猜数。<li>每当你猜了数字 <code>x</code> 并且猜错了的时候，你需要支付金额为 <code>x</code> 的现金。如果你花光了钱，就会 <strong>输掉游戏</strong> 。</ol><p>给你一个特定的数字 <code>n</code> ，返回能够 <strong>确保你获胜</strong> 的最小现金数，<strong>不管我选择那个数字</strong><p><img alt=image-20260203160641411 data-src=https://s2.loli.net/2026/02/03/bhlRSygsmIWnpoV.png><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getMoneyAmount</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// dp[i][j] = k+max(dp[i][k-1],dp[k+1][j])</span></span><br><span class=line>        <span class=comment>// dp[i][j]表示在[i,j]范围内获胜的最小现金数</span></span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(n + <span class=number>1</span>, vector<<span class=keyword>int</span>>(n + <span class=number>1</span>));</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = n<span class=number>-1</span>;i>=<span class=number>1</span>;i--) {</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j = i+<span class=number>1</span>;j<=n;j++) {</span><br><span class=line>                dp[i][j] = dp[i][j<span class=number>-1</span>] + j;</span><br><span class=line>                <span class=keyword>for</span>(<span class=keyword>int</span> k = i;k&LTj;k++) {</span><br><span class=line>                    dp[i][j] = <span class=built_in>min</span>(dp[i][j],k+<span class=built_in>max</span>(dp[i][k<span class=number>-1</span>],dp[k+<span class=number>1</span>][j]));</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[<span class=number>1</span>][n];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>翻转游戏<p>你和朋友玩一个叫做「翻转游戏」的游戏。游戏规则如下：<p>给你一个字符串 <code>currentState</code> ，其中只含 <code>'+'</code> 和 <code>'-'</code> 。你和朋友轮流将 <strong>连续</strong> 的两个 <code>"++"</code> 反转成 <code>"--"</code> 。当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。<p>计算并返回 <strong>一次有效操作</strong> 后，字符串 <code>currentState</code> 所有的可能状态，返回结果可以按 <strong>任意顺序</strong> 排列。如果不存在可能的有效操作，请返回一个空列表 <code>[]</code> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector&LTstring> <span class=title>generatePossibleNextMoves</span><span class=params>(string currentState)</span> </span>{</span><br><span class=line>        <span class=comment>// 对连续的++或者--进行翻转</span></span><br><span class=line>        vector&LTstring> res;</span><br><span class=line>        <span class=keyword>int</span> start_idx{};</span><br><span class=line>        <span class=keyword>while</span> (start_idx < currentState.<span class=built_in>size</span>() - <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>if</span> (currentState[start_idx] == currentState[start_idx + <span class=number>1</span>]) {</span><br><span class=line>                <span class=comment>// 翻转</span></span><br><span class=line>                string s = currentState;</span><br><span class=line>                <span class=keyword>if</span> (currentState[start_idx] == <span class=string>'+'</span>) {</span><br><span class=line>                    s[start_idx] = <span class=string>'-'</span>;</span><br><span class=line>                    s[start_idx + <span class=number>1</span>] = <span class=string>'-'</span>;</span><br><span class=line>                    res.<span class=built_in>push_back</span>(s);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>            start_idx++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>翻转游戏II<p>你和朋友玩一个叫做「翻转游戏」的游戏。游戏规则如下：<p>给你一个字符串 currentState ，其中只含 ‘+’ 和 ‘-‘ 。你和朋友轮流将 连续 的两个 “++” 反转成 “—“ 。当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。默认每个人都会采取最优策略。<p>请你写出一个函数来判定起始玩家 是否存在必胜的方案 ：如果存在，返回 true ；否则，返回 false 。<p>在博弈问题中，我们通常使用<strong>递归</strong>来模拟每一轮的操作。<ul><li><strong>必胜态 (Winning State)</strong>：从当前状态出发，存在至少一种移动方式，能够进入“必败态”。<li><strong>必败态 (Losing State)</strong>：从当前状态出发，无论做出什么移动，下个状态都是“必胜态”；或者根本无法移动。</ul><p>算法步骤：<ol><li><strong>遍历字符串</strong>：寻找所有连续的 <code>++</code>。<li><strong>模拟翻转</strong>：将当前的 <code>++</code> 替换为 <code>--</code>，得到一个新的字符串。<li><strong>递归判断</strong>：调用函数判断<strong>对手</strong>在面对新字符串时是否会输掉。如果对手输了（返回 <code>false</code>），说明我们找到了一个必胜点，直接返回 <code>true</code>。<li><strong>记忆化 (Memoization)</strong>：为了避免重复计算（同一个字符串可能通过不同的翻转路径达到），我们使用哈希表记录已经计算过的状态。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>dfs</span><span class=params>(string& currentState, unordered_map&LTstring, <span class=keyword>bool</span>>& memo)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(currentState)) {</span><br><span class=line>            <span class=keyword>return</span> memo[currentState];</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// DFS</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < currentState.<span class=built_in>size</span>() - <span class=number>1</span>; i++) {</span><br><span class=line>            <span class=keyword>if</span> (currentState[i] == currentState[i + <span class=number>1</span>]) {</span><br><span class=line>                <span class=keyword>if</span> (currentState[i] == <span class=string>'+'</span>) {</span><br><span class=line>                    string nextState = currentState;</span><br><span class=line>                    nextState[i] = <span class=string>'-'</span>;</span><br><span class=line>                    nextState[i + <span class=number>1</span>] = <span class=string>'-'</span>;</span><br><span class=line>                    <span class=keyword>bool</span> flag = <span class=built_in>dfs</span>(nextState, memo);</span><br><span class=line>                    <span class=keyword>if</span> (!flag) {</span><br><span class=line>                        <span class=comment>// 对方必输</span></span><br><span class=line>                        memo[currentState] = <span class=literal>true</span>;</span><br><span class=line>                        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        memo[currentState] = <span class=literal>false</span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>canWin</span><span class=params>(string currentState)</span> </span>{</span><br><span class=line>        <span class=comment>// 动态规划/记忆化搜索</span></span><br><span class=line>        <span class=comment>// 递推</span></span><br><span class=line>        <span class=comment>// 记忆化搜索</span></span><br><span class=line>        unordered_map&LTstring, <span class=keyword>bool</span>> memo;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(currentState, memo);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>对于 这类博弈题，<strong>递归 + 记忆化</strong> 是通杀方案。只要记住“我的胜利建立在对手的绝望之上”这个博弈原则，逻辑就能顺理成章。<p>求出硬币游戏赢家<p>给你两个 <strong>正</strong> 整数 <code>x</code> 和 <code>y</code> ，分别表示价值为 75 和 10 的硬币的数目。<p>Alice 和 Bob 正在玩一个游戏。每一轮中，Alice 先进行操作，Bob 后操作。每次操作中，玩家需要拿走价值 <strong>总和</strong> 为 115 的硬币。如果一名玩家无法执行此操作，那么这名玩家 <strong>输掉</strong> 游戏。<p>两名玩家都采取 <strong>最优</strong> 策略，请你返回游戏的赢家。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>winningPlayer</span><span class=params>(<span class=keyword>int</span> x, <span class=keyword>int</span> y)</span> </span>{</span><br><span class=line>        <span class=comment>// 每次x-1,y-4</span></span><br><span class=line>        <span class=comment>// 直到为0</span></span><br><span class=line>        <span class=keyword>int</span> ops = <span class=built_in>min</span>(x, y / <span class=number>4</span>);</span><br><span class=line>        <span class=keyword>return</span> ops % <span class=number>2</span> ? <span class=string>"Alice"</span> : <span class=string>"Bob"</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>预测赢家<p>给一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。<p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。<p>在处理这类“两个人都采取最优策略”的问题时，我们不要去管玩家 1 拿了多少分、玩家 2 拿了多少分。我们只关心一个值：<strong>当前玩家相对于对手的“净胜分”</strong>。<p>定义函数 $f(i, j)$：表示在数组 <code>nums</code> 从索引 $i$ 到 $j$ 的这段区间内，当前走棋的人能拿到的<strong>最大净分数</strong>（即：我的得分 - 对手的得分）。<ul><li><strong>如果你选左端点 <code>nums[i]</code></strong>：你得到了 <code>nums[i]</code> 分，剩下的区间是 $[i+1, j]$。在剩下的区间里，对手会作为先手，他能拿到的最大净分值是 $f(i+1, j)$。所以你的净胜分就是 <code>nums[i] - f(i+1, j)</code>。<li><strong>如果你选右端点 <code>nums[j]</code></strong>：同理，你的净胜分就是 <code>nums[j] - f(i, j-1)</code>。</ul><p>作为大师级玩家，你当然会在这两种选择中选那个<strong>更大的</strong>。<ol><li>递归逻辑与状态转移</ol><script type="math/tex; mode=display">f(i, j) = \max(\text{nums}[i] - f(i+1, j), \text{nums}[j] - f(i, j-1))</script><p><strong>基准情况 (Base Case)</strong>：<p>当 $i == j$ 时，只剩一个数字，当前玩家直接拿走，净胜分为 $f(i, i) = \text{nums}[i]$。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>max_diff</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> i, <span class=keyword>int</span> j)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (j == i) {</span><br><span class=line>            <span class=keyword>return</span> nums[i];</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 净分数</span></span><br><span class=line>        <span class=keyword>int</span> l = nums[i] - <span class=built_in>max_diff</span>(nums, i + <span class=number>1</span>, j);</span><br><span class=line>        <span class=keyword>int</span> r = nums[j] - <span class=built_in>max_diff</span>(nums, i, j - <span class=number>1</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>max</span>(l, r);</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>predictTheWinner</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>max_diff</span>(nums, <span class=number>0</span>, nums.<span class=built_in>size</span>() - <span class=number>1</span>) >= <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=comment>// 动态规划</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>PredictTheWinner</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> length = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>auto</span> dp = vector&LTvector<<span class=keyword>int</span>>> (length, vector<<span class=keyword>int</span>>(length));</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < length; i++) {</span><br><span class=line>            dp[i][i] = nums[i];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = length - <span class=number>2</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = i + <span class=number>1</span>; j < length; j++) {</span><br><span class=line>                dp[i][j] = <span class=built_in>max</span>(nums[i] - dp[i + <span class=number>1</span>][j], nums[j] - dp[i][j - <span class=number>1</span>]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[<span class=number>0</span>][length - <span class=number>1</span>] >= <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>求出胜利玩家数目<p>给你一个整数 <code>n</code> ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 <code>pick</code> ，其中 <code>pick[i] = [xi, yi]</code> 表示玩家 <code>xi</code> 获得了一个颜色为 <code>yi</code> 的球。<p>如果玩家 <code>i</code> 获得的球中任何一种颜色球的数目 <strong>严格大于</strong> <code>i</code> 个，那么我们说玩家 <code>i</code> 是胜利玩家。换句话说：<ul><li>如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。<li>如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。<li>…<li>如果玩家 <code>i</code> 获得了至少 <code>i + 1</code> 个相同颜色的球，那么玩家 <code>i</code> 是胜利玩家。</ul><p>请你返回游戏中 <strong>胜利玩家</strong> 的数目。<p><strong>注意</strong>，可能有多个玩家是胜利玩家。<p>石子游戏<p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code> 。<p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。<p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 <code>true</code> ，当 Bob 赢得比赛时返回 <code>false</code><p>永远为true<p>单词拆分<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>wordBreak</span><span class=params>(string s, vector&LTstring>& wordDict)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = s.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>unordered_set&LTstring> <span class=title>wordSet</span><span class=params>(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>dp</span><span class=params>(sz + <span class=number>1</span>)</span></span>;</span><br><span class=line>        dp[<span class=number>0</span>] = <span class=literal>true</span>;</span><br><span class=line>        <span class=comment>// 状态转移方程</span></span><br><span class=line>        <span class=comment>// dp[i]表示前i个字符能否被表示</span></span><br><span class=line>        <span class=comment>// dp[j] = dp[j-len]|word[j-len:j]</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= sz; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < i; j++) {</span><br><span class=line>                <span class=comment>// 字符串起点 j-(i-1)</span></span><br><span class=line>                string sstr = s.<span class=built_in>substr</span>(j, i - j);</span><br><span class=line>                <span class=keyword>if</span> (wordSet.<span class=built_in>count</span>(sstr) && dp[j]) {</span><br><span class=line>                    dp[i] = <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[sz];</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>bool</span>> memo;</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>dfs</span><span class=params>(string& s, <span class=keyword>int</span> start_idx, unordered_set&LTstring> wordSet)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(start_idx)) {</span><br><span class=line>            <span class=keyword>return</span> memo[start_idx];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (start_idx == s.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = start_idx; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            string tmp = s.<span class=built_in>substr</span>(start_idx, i - start_idx + <span class=number>1</span>);</span><br><span class=line>            <span class=keyword>if</span> (wordSet.<span class=built_in>count</span>(tmp) && <span class=built_in>dfs</span>(s, i + <span class=number>1</span>, wordSet)) {</span><br><span class=line>                memo[start_idx] = <span class=literal>true</span>;</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        memo[start_idx] = <span class=literal>false</span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>wordBreak</span><span class=params>(string s, vector&LTstring>& wordDict)</span> </span>{</span><br><span class=line>        <span class=function>unordered_set&LTstring> <span class=title>wordSet</span><span class=params>(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(s, <span class=number>0</span>, wordSet);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>单词拆分II<p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code> ，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<strong>以任意顺序</strong> 返回所有这些可能的句子。<p><strong>注意：</strong>词典中的同一个单词可能在分段中被重复使用多次。<p>将大问题拆解为：<strong>“当前单词 + 剩余子串的所有拆分可能”</strong>。<ul><li><strong>定义函数</strong> <code>dfs(start)</code>：返回字符串 <code>s[start:]</code> 能够组成的所有合法句子列表。<li><strong>递归过程</strong>：<ol><li>从 <code>start</code> 开始，尝试所有可能的结尾 <code>end</code>。<li>如果 <code>s[start:end]</code> 是一个单词：<ul><li>递归调用 <code>dfs(end)</code> 获取后缀的所有组合。<li>将当前单词与后缀的每一个组合用空格连接。</ul><li><strong>记忆化</strong>：使用字典 <code>memo</code> 记录 <code>start</code> 对应的所有结果。如果下次再遇到相同的 <code>start</code>，直接返回结果，不再重复搜索。</ol></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>// 记忆化搜索 存储结果</span></span><br><span class=line>    unordered_map<<span class=keyword>int</span>, vector&LTstring>> memo;</span><br><span class=line>    <span class=function>vector&LTstring> <span class=title>dfs</span><span class=params>(string& s, unordered_set&LTstring>& uset, <span class=keyword>int</span> start)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(start)) {</span><br><span class=line>            <span class=keyword>return</span> memo[start];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (start == s.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=comment>// 到末尾</span></span><br><span class=line>            <span class=keyword>return</span> {<span class=string>""</span>};</span><br><span class=line>        }</span><br><span class=line>        vector&LTstring> ans;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = start; j < s.<span class=built_in>size</span>(); j++) {</span><br><span class=line>            string sstr = s.<span class=built_in>substr</span>(start, j - start + <span class=number>1</span>);</span><br><span class=line>            <span class=keyword>if</span> (uset.<span class=built_in>count</span>(sstr)) {</span><br><span class=line>                <span class=comment>// 获得后缀</span></span><br><span class=line>                <span class=keyword>auto</span> res = <span class=built_in>dfs</span>(s, uset, j + <span class=number>1</span>);</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>auto</span>& s : res) {</span><br><span class=line>                    <span class=keyword>if</span> (s.<span class=built_in>empty</span>()) {</span><br><span class=line>                        ans.<span class=built_in>push_back</span>(sstr);</span><br><span class=line>                    } <span class=keyword>else</span> {</span><br><span class=line>                        ans.<span class=built_in>push_back</span>(sstr + <span class=string>" "</span> + s);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        memo[start] = ans;</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>vector&LTstring> <span class=title>wordBreak</span><span class=params>(string s, vector&LTstring>& wordDict)</span> </span>{</span><br><span class=line>        <span class=function>unordered_set&LTstring> <span class=title>uset</span><span class=params>(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(s, uset, <span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>划分为k个相等的子集<p>给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>bool</span>> memo;</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>dfs</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> usedNums, <span class=keyword>int</span> curSum, <span class=keyword>int</span> targetSum,</span></span></span><br><span class=line><span class=params><span class=function>             <span class=keyword>int</span> cnt, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(usedNums)) {</span><br><span class=line>            <span class=keyword>return</span> memo[usedNums];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (cnt == k) {</span><br><span class=line>            memo[usedNums] = <span class=literal>true</span>;</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (targetSum == curSum) {</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>dfs</span>(nums, usedNums, <span class=number>0</span>, targetSum, cnt + <span class=number>1</span>, k)) {</span><br><span class=line>                memo[usedNums] = <span class=literal>true</span>;</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (usedNums & (<span class=number>1</span> << i)) {</span><br><span class=line>                <span class=comment>// 已经用过</span></span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (nums[i] + curSum > targetSum) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (nums[i] + curSum <= targetSum) {</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>dfs</span>(nums, usedNums | (<span class=number>1</span> << i), nums[i] + curSum, targetSum,</span><br><span class=line>                        cnt, k)) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        memo[usedNums] = <span class=literal>false</span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>canPartitionKSubsets</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sum_val = <span class=built_in>accumulate</span>(nums.<span class=built_in>begin</span>(), nums.<span class=built_in>end</span>(), <span class=number>0</span>);</span><br><span class=line>        <span class=comment>// 不能整除</span></span><br><span class=line>        <span class=keyword>if</span> (sum_val % k) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> target = sum_val / k;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(nums, <span class=number>0</span>, <span class=number>0</span>, target, <span class=number>0</span>, k);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>戳气球<p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。<p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。<p>求所能获得硬币的最大数量。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxCoins</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 1 xxxx 1</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>coins</span><span class=params>(n + <span class=number>2</span>, <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>            coins[i] = nums[i - <span class=number>1</span>];</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// dp[i][j]表示在(i,j)范围也就是[i+1,j-1]范围的最大硬币数</span></span><br><span class=line>        <span class=comment>// k在[i+1,j-1]内，表示(i,j)内最后一个戳破的气球</span></span><br><span class=line>        <span class=comment>// dp[i][j] = dp[i][k]*dp[k][j]nums[i]*nums[k]*nums[j]</span></span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(n + <span class=number>2</span>, vector<<span class=keyword>int</span>>(n + <span class=number>2</span>));</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = n + <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = i + <span class=number>2</span>; j <= n + <span class=number>1</span>; j++) {</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>int</span> k = i + <span class=number>1</span>; k < j; k++) {</span><br><span class=line>                    dp[i][j] =</span><br><span class=line>                        <span class=built_in>max</span>(dp[i][k] + dp[k][j] + coins[i] * coins[j] * coins[k],</span><br><span class=line>                            dp[i][j]);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[<span class=number>0</span>][n + <span class=number>1</span>];</span><br><span class=line>    }</span><br><span class=line>}; </span><br><span class=line><span class=comment>// 记忆化搜索</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> rec;</span><br><span class=line>    vector<<span class=keyword>int</span>> val;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>solve</span><span class=params>(<span class=keyword>int</span> left, <span class=keyword>int</span> right)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (left >= right - <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (rec[left][right] != <span class=number>-1</span>) {</span><br><span class=line>            <span class=keyword>return</span> rec[left][right];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = left + <span class=number>1</span>; i < right; i++) {</span><br><span class=line>            <span class=keyword>int</span> sum = val[left] * val[i] * val[right];</span><br><span class=line>            sum += <span class=built_in>solve</span>(left, i) + <span class=built_in>solve</span>(i, right);</span><br><span class=line>            rec[left][right] = <span class=built_in>max</span>(rec[left][right], sum);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> rec[left][right];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxCoins</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = nums.<span class=built_in>size</span>();</span><br><span class=line>        val.<span class=built_in>resize</span>(n + <span class=number>2</span>);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>            val[i] = nums[i - <span class=number>1</span>];</span><br><span class=line>        }</span><br><span class=line>        val[<span class=number>0</span>] = val[n + <span class=number>1</span>] = <span class=number>1</span>;</span><br><span class=line>        rec.<span class=built_in>resize</span>(n + <span class=number>2</span>, vector<<span class=keyword>int</span>>(n + <span class=number>2</span>, <span class=number>-1</span>));</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>solve</span>(<span class=number>0</span>, n + <span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>通配符匹配<p>给你一个输入字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，请你实现一个支持 <code>'?'</code> 和 <code>'*'</code> 匹配规则的通配符匹配：<ul><li><code>'?'</code> 可以匹配任何单个字符。<li><code>'*'</code> 可以匹配任意字符序列（包括空字符序列）。</ul><p>判定匹配成功的充要条件是：字符模式必须能够 <strong>完全匹配</strong> 输入字符串（而不是部分匹配<p>定义 $dp[i][j]$ 为 $s$ 的前 $i$ 个字符和 $p$ 的前 $j$ 个字符是否匹配。<p>情况 A：<code>p[j-1]</code> 是普通字符或 <code>?</code><p>如果 <code>s[i-1] == p[j-1]</code> 或者 <code>p[j-1] == '?'</code>，匹配 1 对 1。</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1]</script><p>情况 B：<code>p[j-1]</code> 是 <code>*</code><p>这时候 <code>*</code> 有两种选择：<ol><li><p><strong>当成空字符串（匹配 0 个）</strong>：直接看模式串前一个位置是否匹配当前字符串。</p> <script type="math/tex; mode=display">dp[i][j] = dp[i][j-1]</script><li><p><strong>匹配 1 个或多个字符</strong>：既然 <code>*</code> 能匹配任意序列，只要 $s$ 的前一个字符已经和当前 <code>*</code> 匹配上了，那么当前字符也能被这个 <code>*</code> 吸收。</p> <script type="math/tex; mode=display">dp[i][j] = dp[i-1][j]</script></ol><p><strong>综合逻辑</strong>：$dp[i][j] = dp[i][j-1] \lor dp[i-1][j]$<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isMatch</span><span class=params>(string s, string p)</span> </span>{</span><br><span class=line>        <span class=comment>// 动态规划</span></span><br><span class=line>        <span class=keyword>int</span> n1 = s.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n2 = p.<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>bool</span>>> <span class=built_in>dp</span>(n1 + <span class=number>1</span>, vector<<span class=keyword>bool</span>>(n2 + <span class=number>1</span>));</span><br><span class=line>        dp[<span class=number>0</span>][<span class=number>0</span>] = <span class=literal>true</span>;</span><br><span class=line>        <span class=comment>// 状态转移方程</span></span><br><span class=line>        <span class=comment>// p[j] = '*' 可以匹配任意序列</span></span><br><span class=line>        <span class=comment>// dp[i][j] = dp[i-1][j]</span></span><br><span class=line>        <span class=comment>// 初始化</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n2; i++) {</span><br><span class=line>            <span class=keyword>if</span> (p[i - <span class=number>1</span>] == <span class=string>'*'</span>) {</span><br><span class=line>                dp[<span class=number>0</span>][i] = dp[<span class=number>0</span>][i - <span class=number>1</span>];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                dp[<span class=number>0</span>][i] = <span class=literal>false</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n1; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= n2; j++) {</span><br><span class=line>                <span class=keyword>if</span> (p[j - <span class=number>1</span>] == <span class=string>'*'</span>) {</span><br><span class=line>                    <span class=comment>// 匹配0个          或者            匹配多个</span></span><br><span class=line>                    dp[i][j] = dp[i][j - <span class=number>1</span>] || dp[i - <span class=number>1</span>][j];</span><br><span class=line>                } <span class=keyword>else</span> <span class=keyword>if</span> (p[j - <span class=number>1</span>] == <span class=string>'?'</span> || p[j - <span class=number>1</span>] == s[i - <span class=number>1</span>]) {</span><br><span class=line>                    dp[i][j] = dp[i - <span class=number>1</span>][j - <span class=number>1</span>];</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[n1][n2];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>正则表达式匹配<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。<ul><li><code>'.'</code> 匹配任意单个字符<li><code>'*'</code> 匹配零个或多个前面的那一个元素</ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。<p>难点在于 <code>*</code> 的处理：它不是独立存在的，而是必须和<strong>前一个字符</strong>绑在一起看，表示“0 个或多个前面的那个元素”。这种“回头看”的逻辑让匹配变得非常复杂。<p>遍历 <code>i</code>（从 0 到 $m$）和 <code>j</code>（从 1 到 $n$），对于每个 <code>dp[i][j]</code>：<p>情况 A：<code>p[j-1]</code> 不是 <code>*</code><p>如果当前字符匹配（<code>s[i-1] == p[j-1]</code> 或 <code>p[j-1] == '.'</code>），则：</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1]</script><p>情况 B：<code>p[j-1]</code> 是 <code>*</code><p>此时模式串中 <code>*</code> 前面的字符是 <code>p[j-2]</code>。<ol><li><p><strong>匹配 0 次</strong>：无论如何，我们可以选择忽略 <code>x*</code>。</p> <script type="math/tex; mode=display">dp[i][j] = dp[i][j-2]</script><li><p><strong>匹配 1 次或多次</strong>：如果 <code>s[i-1]</code> 能匹配 <code>p[j-2]</code>，则我们可以“吃掉” <code>s</code> 的当前字符，并保持模式串位置不变。</p> <script type="math/tex; mode=display">dp[i][j] = dp[i][j] \text{ 或 } dp[i-1][j]</script></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isMatch</span><span class=params>(string s, string p)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz1 = s.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> sz2 = p.<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>bool</span>>> <span class=built_in>dp</span>(sz1 + <span class=number>1</span>, vector<<span class=keyword>bool</span>>(sz2 + <span class=number>1</span>));</span><br><span class=line>        dp[<span class=number>0</span>][<span class=number>0</span>] = <span class=literal>true</span>;</span><br><span class=line>        <span class=comment>// 初始化dp</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>2</span>; j <= sz2; j++) {</span><br><span class=line>            <span class=keyword>if</span> (p[j - <span class=number>1</span>] == <span class=string>'*'</span>) {</span><br><span class=line>                dp[<span class=number>0</span>][j] = dp[<span class=number>0</span>][j - <span class=number>2</span>];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= sz1; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= sz2; j++) {</span><br><span class=line>                <span class=comment>// 判断更新dp情况</span></span><br><span class=line>                <span class=comment>// 如果前一个字符相等</span></span><br><span class=line>                <span class=comment>// cb a*</span></span><br><span class=line>                <span class=keyword>if</span> (p[j - <span class=number>1</span>] == <span class=string>'*'</span>) {</span><br><span class=line>                    <span class=comment>// 匹配0个</span></span><br><span class=line>                    dp[i][j] = dp[i][j - <span class=number>2</span>];</span><br><span class=line>                    <span class=keyword>bool</span> is_match =</span><br><span class=line>                        ((s[i - <span class=number>1</span>] == p[j - <span class=number>2</span>]) || (p[j - <span class=number>2</span>] == <span class=string>'.'</span>));</span><br><span class=line>                    <span class=keyword>if</span> (is_match) {</span><br><span class=line>                        <span class=comment>// 如果前一个字符匹配</span></span><br><span class=line>                        <span class=comment>// ab a*c</span></span><br><span class=line>                        dp[i][j] = (dp[i - <span class=number>1</span>][j] || dp[i][j]);</span><br><span class=line>                    }</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    <span class=comment>// 正常匹配</span></span><br><span class=line>                    <span class=keyword>if</span> (s[i - <span class=number>1</span>] == p[j - <span class=number>1</span>] || p[j - <span class=number>1</span>] == <span class=string>'.'</span>) {</span><br><span class=line>                        dp[i][j] = dp[i - <span class=number>1</span>][j - <span class=number>1</span>];</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[sz1][sz2];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>记忆化搜索题目</strong><ol><li>矩阵与路径类（最直观的应用）</ol><p>这类问题通常具有明确的方向性，递归路径清晰，但存在大量重复计算。<ul><li><strong><a href=https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/ rel=noopener target=_blank>329. 矩阵中的最长递增路径</a> (Hard)</strong><ul><li><strong>核心点</strong>：从任意点出发找最长路径。如果不用记忆化，DFS 会呈指数级增长。由于递增的限制，路径不会成环，非常适合递归缓存结果。</ul><li><strong><a href=https://leetcode.cn/problems/unique-paths/ rel=noopener target=_blank>62. 不同路径</a> (Medium)</strong><ul><li><strong>核心点</strong>：虽然入门选手机通常用迭代 DP，但用递归+记忆化实现逻辑最自然。</ul></ul><ol><li>博弈论类（必须用记忆化）</ol><p>正如你刚才问的“翻转游戏”，博弈题几乎是记忆化搜索的本命题。<ul><li><strong><a href=https://leetcode.cn/problems/can-i-win/ rel=noopener target=_blank>464. 我能赢吗</a> (Medium)</strong><ul><li><strong>核心点</strong>：状态压缩 + 记忆化。需要记录哪些数字被选过（用二进制位表示），并判断当前玩家是否必胜。</ul><li><strong><a href=https://leetcode.cn/problems/predict-the-winner/ rel=noopener target=_blank>486. 预测赢家</a> (Medium)</strong><ul><li><strong>核心点</strong>：经典的从数组两端取数的博弈，递归逻辑是 <code>max(左端取数 - 剩下的递归结果, 右端取数 - 剩下的递归结果)</code>。</ul><li><strong><a href=https://leetcode.cn/problems/stone-game/ rel=noopener target=_blank>877. 石子游戏</a> (Medium)</strong><ul><li><strong>核心点</strong>：虽然数学推导必胜，但作为算法练习，它是典型的区间记忆化搜索。</ul></ul><ol><li>拆分与区间类（Range DP）</ol><p>将一个大问题拆解成多个小区间，再合并结果。<ul><li><strong><a href=https://leetcode.cn/problems/burst-balloons/ rel=noopener target=_blank>312. 戳气球</a> (Hard)</strong><ul><li><strong>核心点</strong>：区间 DP 的巅峰之作。自顶向下的记忆化搜索比自底向上的三层循环更容易理解：<code>solve(left, right)</code> 表示戳破 <code>(left, right)</code> 之间所有气球的最大收益。</ul><li><strong><a href=https://leetcode.cn/problems/word-break/ rel=noopener target=_blank>139. 单词拆分</a> (Medium)</strong><ul><li><strong>核心点</strong>：判断字符串是否能由字典组成。递归判断 <code>s[i:]</code> 是否合法，并用 <code>memo</code> 记录。</ul><li><strong><a href=https://leetcode.cn/problems/word-break-ii/ rel=noopener target=_blank>140. 单词拆分 II</a> (Hard)</strong><ul><li><strong>核心点</strong>：不仅要判断，还要返回所有路径。由于要构造大量字符串，记忆化搜索几乎是唯一解法。</ul></ul><ol><li>字符串匹配类</ol><ul><li><strong><a href=https://leetcode.cn/problems/regular-expression-matching/ rel=noopener target=_blank>10. 正则表达式匹配</a> (Hard)</strong><ul><li><strong>核心点</strong>：处理 <code>*</code> 和 <code>.</code> 的复杂逻辑。记忆化搜索可以让你专注处理当前的字符匹配，而不用纠结 DP 表的初始化。</ul><li><strong><a href=https://leetcode.cn/problems/wildcard-matching/ rel=noopener target=_blank>44. 通配符匹配</a> (Hard)</strong><ul><li><strong>核心点</strong>：逻辑与 10 题类似，是练习递归思维的佳作。</ul></ul><ol><li>状态压缩类（进阶必备）</ol><p>当状态无法简单用数组下标表示时，通常配合位运算。<ul><li><strong><a href=https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/ rel=noopener target=_blank>698. 划分为k个相等的子集</a> (Medium)</strong><ul><li><strong>核心点</strong>：搜索过程中的状态（哪些元素已用过）通过位掩码记录在 <code>memo</code> 中。</ul></ul><p>当你发现题目有以下特征时，请优先考虑记忆化搜索：<ol><li><p><strong>状态转移方向“不规律”或“跳跃”</strong>：</p> <p>比如在博弈类题目（如之前的“翻转游戏”）中，一个状态下一步可能跳到任何地方，你很难写出一个简单的 <code>for</code> 循环顺序。</p><li><p><strong>状态空间很大，但实际访问的状态很少（稀疏性）</strong>：</p> <p>如果你开了一个 $1000 \times 1000$ 的 DP 表，但题目实际上只需要计算其中的几十个格子，用循环（DP）会浪费大量时间去填那些没用的格子。</p><li><p><strong>递归逻辑更符合直觉</strong>：</p> <p>比如“单词拆分”或者“组合总和”，这种“拆解大问题”的思维用递归写起来非常顺手。</p> <p>什么时候选“动态规划”？（For Loop + DP Table）</p></ol><p>当你发现题目有以下特征时，动态规划更香：<ol><li><p><strong>状态转移极其规律</strong>：</p> <p>比如“爬楼梯”、“路径和”、“打家劫舍”。可以清晰地看到第 <code>i</code> 步只依赖 <code>i-1</code> 和 <code>i-2</code>。</p><li><p><strong>需要极致的空间优化</strong>：</p> <p>如果你发现 <code>dp[i]</code> 只依赖 <code>dp[i-1]</code>，你可以用<strong>滚动数组</strong>把 $O(n)$ 空间压缩到 $O(1)$。记忆化搜索（因为有递归栈）很难做这种优化。</p><li><p><strong>避免递归深度限制</strong>：</p> <p>在某些语言（如 Python/C++）中，如果递归太深（比如几万层），会导致栈溢出（Stack Overflow）。这时必须用循环（DP）。</p></ol><p>用rand7实现rand10<p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数。<p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法。<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数。<h2 id=二分法><a class=headerlink href=#二分法 title=二分法></a>二分法</h2><p>二分法是一种常用的算法，主要包括原始二分查找及实现难度更大的二分变种。<strong>二分法是分治思想的体现，它与分治法的区别在于分治法是将一个复杂的问题不断分解成几个规模更小的子问题，直至子问题可以直接求解</strong>；而二分法则是<strong>不断地通过比较操作将问题规模缩小一半，直至找到目标元素</strong><p>搜索旋转排序数组<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 <= k < nums.length</code>）上进行了 <strong>向左旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 下标 <code>3</code> 上向左旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>search</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>        <span class=comment>// 二分法</span></span><br><span class=line>        <span class=comment>// 左侧值均大于右侧值</span></span><br><span class=line>        <span class=comment>// 通过nums[mid]比较nums[right]</span></span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>0</span>, right = nums.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (left <= right) {</span><br><span class=line>            <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>            <span class=keyword>if</span> (target == nums[mid]) {</span><br><span class=line>                <span class=keyword>return</span> mid;</span><br><span class=line>            } <span class=keyword>else</span> <span class=keyword>if</span> (nums[left] > nums[mid]) {</span><br><span class=line>                <span class=comment>// mid-right单增</span></span><br><span class=line>                <span class=keyword>if</span> (target > nums[mid] && target <= nums[right]) {</span><br><span class=line>                    left = mid + <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    right = mid - <span class=number>1</span>;</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// left-mid单增</span></span><br><span class=line>                <span class=keyword>if</span> (target >= nums[left] && target < nums[mid]) {</span><br><span class=line>                    right = mid - <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    left = mid + <span class=number>1</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>寻找旋转排序数组中的最小值<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：<ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。<p>查询的中间元素变得不确定，以往能够通过直接比对判断某个元素是否符合题目要求，而现在缺少直接判断的条件（mid==target）。幸运的是，还是能够通过二分法不断地缩小最终答案可能存在的区间，当区间只剩下一个元素时（l==h），那么它就是最终答案。二分法中有一种类型是查找最左（最右）满足条件的值，这也运用了类似的思想，即在找到满足条件的一个候选答案时，不是直接返回，而是贪心地继续查看是否还有其他答案。例如要在一个数组[1,2,2,3,4]中找最左边的等于2的值，当我们找到索引值为2的项时，不能直接返回，而是继续贪心地搜索区间，将右边的区间舍弃并继续查看左侧是否还有另外一个2<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>findMin</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=comment>// 旋转数组</span></span><br><span class=line>        <span class=comment>//  左侧值均大于右侧</span></span><br><span class=line>        <span class=comment>// 两侧都是增加</span></span><br><span class=line>        <span class=comment>// 最小值的左右两侧值均大于它</span></span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>0</span>, right = nums.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (left <= right) {</span><br><span class=line>            <span class=keyword>if</span> (left == right) {</span><br><span class=line>                <span class=keyword>return</span> nums[left];</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>            <span class=keyword>if</span> (nums[mid] < nums[right]) {</span><br><span class=line>                right = mid;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                left = mid + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>findMin</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> low = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>int</span> high = nums.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (low < high) {</span><br><span class=line>            <span class=keyword>int</span> pivot = low + (high - low) / <span class=number>2</span>;</span><br><span class=line>            <span class=keyword>if</span> (nums[pivot] < nums[high]) {</span><br><span class=line>                high = pivot;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>else</span> {</span><br><span class=line>                low = pivot + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> nums[low];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>搜索旋转排序II</strong><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 <= k < nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。<p>你必须尽可能减少整个操作步骤。<p>在上一题中，通过 <code>nums[left] <= nums[mid]</code> 就能确切地判断左半部分是否有序。但在有重复的情况下，如果 <strong><code>nums[left] == nums[mid]</code></strong>，我们就无法判断旋转点到底在左边还是右边。<p>为了解决这个问题，当我们遇到 <code>nums[left] == nums[mid]</code> 时，我们不能简单地排除一半区间，但我们可以确定：<strong>既然 <code>nums[mid]</code> 不是我们要找的 <code>target</code>，那么当前的 <code>left</code> 也是多余的。</strong><ul><li><strong>对策：</strong> 执行 <code>left++</code>，缩小范围，然后进入下一次二分判定。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>search</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>0</span>, right = nums.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (left <= right) {</span><br><span class=line>            <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>            <span class=keyword>if</span> (nums[mid] == target) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (nums[mid] == nums[left]) {</span><br><span class=line>                left++;</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (nums[mid] < nums[left]) {</span><br><span class=line>                <span class=comment>// mid-right单增</span></span><br><span class=line>                <span class=keyword>if</span> (target > nums[mid] && target <= nums[right]) {</span><br><span class=line>                    left = mid + <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    right = mid - <span class=number>1</span>;</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>if</span> (target >= nums[left] && target < nums[mid]) {</span><br><span class=line>                    right = mid - <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    left = mid + <span class=number>1</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>爱吃香蕉的珂珂<p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。<p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。<p>由于每小时最多只能吃一堆香蕉，速度最多达到最大堆的数量即可，因此，速度的范围为[1,max(piles)]，也就是答案一定在这个范围内。<p>道题可以看作在[1,max(piles)]中查找一个元素k。因此一个简单的思路是枚举从1到max(piles)的所有速度，并判断是否可以吃完，返回最早能够吃完的速度即可。注意在从1到max(piles)进行枚举的过程中，速度是单调递增变化的，这很容易让我们联想到前面的题目。具体来说，当我们在[l,h]中判断中间的速度mid是否可行时，有如下可能。●　mid不可行，则速度不够快，最小速度位于[mid+1,h]中，更新左边界l为mid+1。<p>●　mid可行，则可能的最小速度小于或等于mid，最小速度位于[l,mid]中，mid可能是最终答案，但不能直接排除，更新右边界h为mid。<p>●　l等于h，则查找区间只剩下一个l，最小速度等于l。因此这道题就是找到最小的可以吃完的速度，也就是上一节提到的最左满足条件的值的题目类型<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector<<span class=keyword>int</span>>& piles, <span class=keyword>int</span> m, <span class=keyword>int</span> h)</span> </span>{</span><br><span class=line>        <span class=comment>// 速度为m,看能否在h小时内吃完</span></span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span>  cnt{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& p : piles) {</span><br><span class=line>            <span class=comment>// cnt += ceil(double(p) / m);</span></span><br><span class=line>            cnt += (p + m - <span class=number>1</span>) / m;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt <= h;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>minEatingSpeed</span><span class=params>(vector<<span class=keyword>int</span>>& piles, <span class=keyword>int</span> h)</span> </span>{</span><br><span class=line>        <span class=comment>// 最大最小值</span></span><br><span class=line>        <span class=comment>// 二分</span></span><br><span class=line>        <span class=keyword>int</span> max_val = *<span class=built_in>max_element</span>(piles.<span class=built_in>begin</span>(), piles.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>1</span>, r = max_val;</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> m = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>isValid</span>(piles, m, h)) {</span><br><span class=line>                res = m;</span><br><span class=line>                r = m - <span class=number>1</span>; <span class=comment>// 必须为m-1,否则可能死循环</span></span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                l = m + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>类似的题目<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>candies</code> 。数组中的每个元素表示大小为 <code>candies[i]</code> 的一堆糖果。你可以将每堆糖果分成任意数量的 <strong>子堆</strong> ，但 <strong>无法</strong> 再将两堆合并到一起。<p>另给你一个整数 <code>k</code> 。你需要将这些糖果分配给 <code>k</code> 个小孩，使每个小孩分到 <strong>相同</strong> 数量的糖果。每个小孩可以拿走 <strong>至多一堆</strong> 糖果，有些糖果可能会不被分配。<p>返回每个小孩可以拿走的 <strong>最大糖果数目</strong> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector<<span class=keyword>int</span>>& candies, <span class=keyword>int</span> m, <span class=keyword>long</span> <span class=keyword>long</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (m == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> cnt{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& c : candies) {</span><br><span class=line>            cnt += c / m;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt >= k;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maximumCandies</span><span class=params>(vector<<span class=keyword>int</span>>& candies, <span class=keyword>long</span> <span class=keyword>long</span> k)</span> </span>{</span><br><span class=line>        <span class=comment>// 每个小孩拿到的糖果数量(1,min(candies[i]))</span></span><br><span class=line>        <span class=comment>//</span></span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>0</span>, r = *<span class=built_in>max_element</span>(candies.<span class=built_in>begin</span>(), candies.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> m = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>isValid</span>(candies, m, k)) {</span><br><span class=line>                l = m + <span class=number>1</span>;</span><br><span class=line>                res = m;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                r = m - <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 间零售商店。总共有 <code>m</code> 种商品，每种商品的数目用一个下标从 <strong>0</strong> 开始的整数数组 <code>quantities</code> 表示，其中 <code>quantities[i]</code> 表示第 <code>i</code> 种商品的数目。<p>你需要将 <strong>所有商品</strong> 分配到零售商店，并遵守这些规则：<ul><li>一间商店 <strong>至多</strong> 只能有 <strong>一种商品</strong> ，但一间商店拥有的商品数目可以为 <strong>任意</strong> 件。<li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code> 件）。用 <code>x</code> 表示所有商店中分配商品数目的最大值，你希望 <code>x</code> 越小越好。也就是说，你想 <strong>最小化</strong> 分配给任意商店商品数目的 <strong>最大值</strong> 。</ul><p>请你返回最小的可能的 <code>x</code> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector<<span class=keyword>int</span>>& quantities, <span class=keyword>int</span> m, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 满足条件</span></span><br><span class=line>        <span class=keyword>int</span> cnt{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& q : quantities) {</span><br><span class=line>            cnt += (q + m - <span class=number>1</span>) / m;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt <= n;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>minimizedMaximum</span><span class=params>(<span class=keyword>int</span> n, vector<<span class=keyword>int</span>>& quantities)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>1</span>, r = *<span class=built_in>max_element</span>(quantities.<span class=built_in>begin</span>(), quantities.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> mid = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>isValid</span>(quantities, mid, n)) {</span><br><span class=line>                r = mid - <span class=number>1</span>;</span><br><span class=line>                ans = mid;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                l = mid + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给你一个整数数组 <code>ranks</code> ，表示一些机械工的 <strong>能力值</strong> 。<code>ranksi</code> 是第 <code>i</code> 位机械工的能力值。能力值为 <code>r</code> 的机械工可以在 <code>r * n2</code> 分钟内修好 <code>n</code> 辆车。<p>同时给你一个整数 <code>cars</code> ，表示总共需要修理的汽车数目。<p>请你返回修理所有汽车 <strong>最少</strong> 需要多少时间。<p><strong>注意：</strong>所有机械工可以同时修理汽车。<p><strong>寻找峰值</strong><p>峰值元素是指其值严格大于左右相邻值的元素。<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。<p>这道题的背景是在数组中查找目标值（峰值元素），虽然数组不是有序的，但峰值元素具备某种性质（大于左右相邻值的元素），可以尝试使用二分法。关注中间元素和左右相邻元素的关系，当右相邻元素大于中间元素时，意味着右相邻元素可能是峰值，其大于左边元素的条件已经满足，只要右相邻元素也大于它右边元素即可。顺着右边的方向继续扫描，存在以下两种情况。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>findPeakElement</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>0</span>, r = sz - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> m = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>int</span> n = nums[m];</span><br><span class=line>            <span class=keyword>if</span> ((m + <span class=number>1</span> < sz) && nums[m + <span class=number>1</span>] > n) {</span><br><span class=line>                <span class=comment>// 右侧值可能是峰值</span></span><br><span class=line>                l = m + <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> <span class=keyword>if</span> (m != <span class=number>0</span> && nums[m - <span class=number>1</span>] > n) {</span><br><span class=line>                r = m - <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>return</span> m;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>findPeakElement</span><span class=params>(<span class=keyword>int</span>[] nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>0</span>, right = nums.length - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (left < right) {</span><br><span class=line>            <span class=keyword>int</span> mid = left + (right - left) / <span class=number>2</span>;</span><br><span class=line>            <span class=keyword>if</span> (nums[mid] > nums[mid + <span class=number>1</span>]) {</span><br><span class=line>                <span class=comment>// 中间元素大于右边元素，说明峰值在左边（包括mid）</span></span><br><span class=line>                right = mid;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 中间元素小于右边元素，说明峰值在右边</span></span><br><span class=line>                left = mid + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> left;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>寻找峰值II</strong><p>一个 2D 网格中的 <strong>峰值</strong> 是指那些 <strong>严格大于</strong> 其相邻格子(上、下、左、右)的元素。<p>给你一个 <strong>从 0 开始编号</strong> 的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都 <strong>不相同</strong> 。找出 <strong>任意一个 峰值</strong> <code>mat[i][j]</code> 并 <strong>返回其位置</strong> <code>[i,j]</code> 。<p>你可以假设整个矩阵周边环绕着一圈值为 <code>-1</code> 的格子。<p>要求必须写出时间复杂度为 <code>O(m log(n))</code> 或 <code>O(n log(m))</code> 的算法<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>findPeakGrid</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& mat)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = mat.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = mat[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> l =<span class=number>0</span>, r = m - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> i = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>int</span> j = <span class=built_in>max_element</span>(mat[i].<span class=built_in>begin</span>(), mat[i].<span class=built_in>end</span>()) - mat[i].<span class=built_in>begin</span>();</span><br><span class=line>            <span class=keyword>if</span> ((i >= <span class=number>1</span>) && mat[i][j] < mat[i - <span class=number>1</span>][j]) {</span><br><span class=line>                r = i - <span class=number>1</span>;</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> ((i < m - <span class=number>1</span>) && mat[i][j] < mat[i + <span class=number>1</span>][j]) {</span><br><span class=line>                l = i + <span class=number>1</span>;</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> {i, j};</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> {};</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>分割数组的最大值</strong><p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>k</code> ，你需要将这个数组分成 <code>k</code> 个非空的连续子数组，使得这 <code>k</code> 个子数组各自和的最大值 <strong>最小</strong>。返回分割后最小的和的最大值。<strong>子数组</strong> 是数组中连续的部分。<p>假设这个和为 $X$：<ul><li>如果我们可以把数组分成 $\le k$ 个子数组，且每个子数组的和都不超过 $X$，说明 $X$ <strong>可能太大了</strong>，我们可以尝试更小的 $X$。<li>如果我们无论如何都要分成超过 $k$ 个子数组才能保证每组和 $\le X$，说明 $X$ <strong>太小了</strong>，必须调大。</ul><p>确定二分的边界：<ul><li><strong>左边界 (<code>left</code>)</strong>：数组中的<strong>最大值</strong>。因为每个数都要属于一个子数组，最大值所在的组之和至少就是它自己。<li><strong>右边界 (<code>right</code>)</strong>：数组中<strong>所有元素之和</strong>。对应 $k=1$ 的极端情况。</ul><p>对于给定的目标值 <code>mid</code>，我们如何判断 $k$ 个子数组是否够用？ 使用<strong>贪心策略</strong>：从左往右累加元素，只要当前和超过了 <code>mid</code>，就必须在这里“切一刀”，开启一个新的子数组。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> k, <span class=keyword>int</span> m)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> cnt{<span class=number>1</span>};</span><br><span class=line>        <span class=keyword>int</span> acc{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (acc + nums[i] <= m) {</span><br><span class=line>                acc += nums[i];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                acc = nums[i];</span><br><span class=line>                cnt++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cnt <= k;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>splitArray</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> l = *<span class=built_in>max_element</span>(nums.<span class=built_in>begin</span>(), nums.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>int</span> r = <span class=built_in>accumulate</span>(nums.<span class=built_in>begin</span>(), nums.<span class=built_in>end</span>(), <span class=number>0</span>);</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> m = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>isValid</span>(nums, k, m)) {</span><br><span class=line>                <span class=comment>// 满足条件</span></span><br><span class=line>                r = m - <span class=number>1</span>;</span><br><span class=line>                ans = m;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                l = m + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>简单的题目能够一眼看出“查找”任务，读者也就可以联想到使用二分法；中等级别或困难级别的题目往往背景复杂，无法马上看出是“查找”任务，需要读者进一步加工并对题目进行转换，利用题目中的已知信息，构建查找的目标，以及目标所在的范围。此外，当题目的数据规模超过1e7时，有较大的可能是二分法类型的题目，这也是一个识别二分法的小技巧。<p>关注查找范围内的中间元素，挖掘背后的规律，往往<strong>中间元素和题目的目标值、左右相邻元素及左右边界元素等存在一定的关联</strong>，根据这些关联可以将查找范围缩小一半。<p>具体的实现方法包括原始的二分查找及二分查找的变种，二者的实现难度不大，唯一需要注意的是二分查找的变种的边界问题，当更新左边界l=mid时，需要修改循环的退出条件为l+1==h or l==h。<p><a href=https://leetcode.cn/problems/magnetic-force-between-two-balls/ rel=noopener target=_blank>两球之间的磁力</a><p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 <code>n</code> 个空的篮子，第 <code>i</code> 个篮子的位置在 <code>position[i]</code> ，Morty 想把 <code>m</code> 个球放到这些篮子里，使得任意两球间 <strong>最小磁力</strong> 最大。<p>已知两个球如果分别位于 <code>x</code> 和 <code>y</code> ，那么它们之间的磁力为 <code>|x - y|</code> 。<p>给你一个整数数组 <code>position</code> 和一个整数 <code>m</code> ，请你返回最大化的最小磁力。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector<<span class=keyword>int</span>>& pos, <span class=keyword>int</span> r, <span class=keyword>int</span> m)</span> </span>{</span><br><span class=line>        <span class=comment>// 以r为最小磁力，能放多少个球</span></span><br><span class=line>        <span class=keyword>int</span> res{<span class=number>1</span>};</span><br><span class=line>        <span class=keyword>int</span> prevpose = pos[<span class=number>0</span>];</span><br><span class=line>        <span class=comment>// 磁力越大，能放的球越少</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < pos.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>int</span> p = pos[i];</span><br><span class=line>            <span class=keyword>if</span> (p - prevpose >= r) {</span><br><span class=line>                res++;</span><br><span class=line>                prevpose = p;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res >= m;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxDistance</span><span class=params>(vector<<span class=keyword>int</span>>& position, <span class=keyword>int</span> m)</span> </span>{</span><br><span class=line>        <span class=built_in>sort</span>(position.<span class=built_in>begin</span>(), position.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>1</span>, r = position.<span class=built_in>back</span>() - position.<span class=built_in>front</span>();</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>while</span> (l <= r) {</span><br><span class=line>            <span class=keyword>int</span> mid = (r - l) / <span class=number>2</span> + l;</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>isValid</span>(position, mid, m)) {</span><br><span class=line>                ans = mid;</span><br><span class=line>                l = mid + <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                r = mid - <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>最长递增子序列</strong><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTalgorithm></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>lengthOfLIS</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (nums.<span class=built_in>empty</span>()) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// tails[i] 存储长度为 i+1 的子序列的最小末尾</span></span><br><span class=line>        vector<<span class=keyword>int</span>> tails;</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> x : nums) {</span><br><span class=line>            <span class=comment>// 使用二分查找在 tails 中找到第一个 >= x 的位置</span></span><br><span class=line>            <span class=keyword>auto</span> it = <span class=built_in>lower_bound</span>(tails.<span class=built_in>begin</span>(), tails.<span class=built_in>end</span>(), x);</span><br><span class=line>            </span><br><span class=line>            <span class=keyword>if</span> (it == tails.<span class=built_in>end</span>()) {</span><br><span class=line>                <span class=comment>// 如果 x 比所有尾数都大，说明可以延长 LIS</span></span><br><span class=line>                tails.<span class=built_in>push_back</span>(x);</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 如果找到了，就用 x 更新那个位置，减小该长度子序列的末尾值</span></span><br><span class=line>                *it = x;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>return</span> tails.<span class=built_in>size</span>();</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h1 id=位运算-1><a class=headerlink href=#位运算-1 title=位运算></a>位运算</h1><p>计算机中的数据都是以二进制的形式存储的，二进制的运算都是按位来进行的。以整数为例，位运算就是直接对整数在内存中的二进制位进行操作，效率比算术运算要高。<p>例如，求一个数的2倍的值，使用位运算比算术运算要快很多，因为算术运算的乘法指令所用的指令周期（指令周期是指CPU从内存取出一条指令并执行这条指令的时间总和）比位运算的移位指令所用的指令周期长<p>位运算包括取反、按位或、按位异或、按位与、移位等操作。常见的位运算符如下。<ul><li>取反（~）：按位取反，1变0，0变1。<li>按位或（|）：操作位中只要有1，则结果为1；否则结果为0。<li>按位异或（^）：操作位中只要有两位相反（一个为1，一个为0），则结果为1；否则结果为0。<li>按位与（&）：操作位中只要有两位全部为1，则结果为1；否则结果为0。<li>移位（<<或>>）：移位分为算术移位和逻辑移位；根据移位方向又分为左移运算和右移运算。</ul><p>给定一个正整数 <code>n</code>，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 设置位 的个数（也被称为<a href=https://baike.baidu.com/item/汉明重量 rel=noopener target=_blank>汉明重量</a>）。<p>不去检测整数的每一位，而是依次将最低位且值为1的比特位翻转为0，并增加计数器。当执行结果使整数为0时，该整数不再包含任何为1的比特，返回计数器的值。此时的关键问题是如何执行“翻转最低有效比特为1的比特为0”，此处可以使用n &(n-1)的操作。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>hammingWeight</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>while</span> (n > <span class=number>0</span>) {</span><br><span class=line>            n = n & (n - <span class=number>1</span>);</span><br><span class=line>            res++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>两整数之和</strong><p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用</strong> 运算符 <code>+</code> 和 <code>-</code> ，计算并返回两整数之和。<p>有符号整数通常用补码来表示和存储，补码具有如下特征：<p>正整数的补码与原码相同；负整数的补码为其原码除符号位外的所有位取反后加 1。可以将减法运算转化为补码的加法运算来实现。符号位与数值位可以一起参与运算.<p><strong>逻辑右移 (Logical Right Shift)</strong><ul><li><strong>规则</strong>：不管三七二十一，左边统一<strong>补 0</strong>。<li><strong>适用</strong>：无符号数（<code>unsigned</code>）。<li><strong>后果</strong>：如果你把一个负数进行逻辑右移，符号位的 <code>1</code> 会被移走，左边补 <code>0</code>，这个数会瞬间从负数变成一个巨大的正数。</ul><p><strong>算术右移 (Arithmetic Right Shift)</strong><ul><li><strong>规则</strong>：左边<strong>补符号位</strong>（原来是 0 就补 0，原来是 1 就补 1）。<li><strong>适用</strong>：有符号数（<code>int</code>）。<li><strong>意义</strong>：为了维持数学上的<strong>“除以 2”</strong>。如果一个负数除以 2 之后变成了正数，那数学逻辑就崩了，所以必须补 1 来保持它的负号。</ul><p><strong>术左移和逻辑左移是同一条指令。</strong><ul><li><strong>操作</strong>：右边统一<strong>补 0</strong>。</ul><p>在 C++20 之前，<code>int</code> 的右移行为是由“编译器实现决定”的（Implementation-defined），虽然几乎所有现代编译器都默认使用算术右移，但理论上存在不确定性。<strong>C++20 正式将其统一为算术右移。</strong><p>在 Java 语言中，为了避免 C++ 这种“隐式”的规则，专门设计了两个操作符：<ul><li><strong><code>>></code></strong>：算术右移（保留符号）。<li><strong><code>>>></code></strong>：无符号右移（逻辑右移，通通补 0）。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getSum</span><span class=params>(<span class=keyword>int</span> a, <span class=keyword>int</span> b)</span> </span>{</span><br><span class=line>        <span class=keyword>while</span> (b != <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>unsigned</span> <span class=keyword>int</span> carry = (<span class=keyword>unsigned</span> <span class=keyword>int</span>)(a & b) << <span class=number>1</span>;</span><br><span class=line>            a = a ^ b;</span><br><span class=line>            b = carry;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> a;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>整数替换</strong><p>给定一个正整数 <code>n</code> ，你可以做如下操作：<ol><li>如果 <code>n</code> 是偶数，则用 <code>n / 2</code>替换 <code>n</code> 。<li>如果 <code>n</code> 是奇数，则可以用 <code>n + 1</code>或<code>n - 1</code>替换 <code>n</code> 。</ol><p>返回 <code>n</code> 变为 <code>1</code> 所需的 <em>最小替换次数</em> 。<p>当 n 为奇数时，我们可以选择将 n 增加 1 或减少 1。由于这两种方法都会将 n 变为偶数，那么下一步一定是除以 2，因此这里我们可以看成使用两次操作，将 n 变为 (n+1)/2和(n-1)/2.<p><img alt=image-20260210124408364 data-src=https://img.proanimer.com/imgs/image-20260210124408364.png><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>search</span><span class=params>(unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>>& memo, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(n)) {</span><br><span class=line>            <span class=keyword>return</span> memo[n];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (n & <span class=number>1</span>) {</span><br><span class=line>            <span class=comment>// n</span></span><br><span class=line>            <span class=comment>// n-1 n+1</span></span><br><span class=line>            <span class=comment>// (n-1)/2 == n//2</span></span><br><span class=line>            <span class=comment>// (n+1)/2 == n//2+1</span></span><br><span class=line>            <span class=keyword>int</span> l1 = <span class=built_in>search</span>(memo, n / <span class=number>2</span>);</span><br><span class=line>            <span class=keyword>int</span> l2 = <span class=built_in>search</span>(memo, n / <span class=number>2</span> + <span class=number>1</span>);</span><br><span class=line>            memo[n] = <span class=built_in>min</span>(l1, l2) + <span class=number>2</span>;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>int</span> l = <span class=built_in>search</span>(memo, n / <span class=number>2</span>);</span><br><span class=line>            memo[n] = l + <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> memo[n];</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>integerReplacement</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> memo;</span><br><span class=line>        memo[<span class=number>1</span>] = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>search</span>(memo, n);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>利用二进制特性的最优解。核心思想是：<strong>奇数时，通过 $+1$ 或 $-1$ 尽可能让低位产生更多的 $0$。</strong><p>算法逻辑：<ul><li><strong>若 $n$ 是偶数</strong>：直接右移（$n = n >> 1$）。<li><strong>若 $n$ 是奇数</strong>：<ul><li>观察最后两位：<ul><li>如果是 <code>...01</code>：减 1 效果更好（变为 <code>...00</code>）。<li>如果是 <code>...11</code>：加 1 效果更好（进位变为 <code>...00</code>）。</ul><li><strong>特例处理</strong>：当 $n = 3$ 时，二进制虽是 <code>11</code>，但 $3 \to 2 \to 1$（2步）优于 $3 \to 4 \to 2 \to 1$（3步），所以 $3$ 选择减 1。</ul></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>integerReplacement</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 贪心</span></span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>while</span> (n != <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>if</span> (n & <span class=number>1</span>) {</span><br><span class=line>                <span class=comment>// 奇数</span></span><br><span class=line>                <span class=comment>// 01</span></span><br><span class=line>                <span class=comment>// 11</span></span><br><span class=line>                <span class=keyword>if</span> (n == <span class=number>3</span>) {</span><br><span class=line>                    <span class=comment>// 特殊情况</span></span><br><span class=line>                    res += <span class=number>2</span>;</span><br><span class=line>                    n = <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> <span class=keyword>if</span> ((n & <span class=number>3</span>) == <span class=number>3</span>) {</span><br><span class=line>                    res += <span class=number>2</span>;</span><br><span class=line>                    n = n / <span class=number>2</span> + <span class=number>1</span>;</span><br><span class=line>                } <span class=keyword>else</span> <span class=keyword>if</span> ((n & <span class=number>3</span>) == <span class=number>1</span>) {</span><br><span class=line>                    res += <span class=number>2</span>;</span><br><span class=line>                    n /= <span class=number>2</span>;</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 偶数</span></span><br><span class=line>                n /= <span class=number>2</span>;</span><br><span class=line>                res++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>只出现一次的数字</strong><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>singleNumber</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>auto</span>& n:nums) {</span><br><span class=line>            res ^= n;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>只出现一次的数字II</strong><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。<p>简单异或法无法筛选出唯一的单一元素，因为异或法无法将3个元素消除，但考虑到在元素的二进制形式中，对于出现3次的元素，它的二进制形式中的每一位都是3的倍数，统计所有数字的二进制形式中1出现的次数，并对3求余，如果结果不为0，则说明出现1次的数字在该二进制位上为1<p>逐位计数法（通用且稳健），这种方法遍历 32 个比特位，统计每一位上 $1$ 出现的次数。如果某一位的计数不能被 3 整除，那么目标数字在该位就是 $1$。如果改为出现 $k$ 次，只需将 <code>% 3</code> 改为 <code>% k</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>singleNumber</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>32</span>; i++) {</span><br><span class=line>            <span class=keyword>int</span> r{};</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>auto</span>& n : nums) {</span><br><span class=line>                r += ((n>>i)&<span class=number>1</span>); <span class=comment>// 第i位出现次数</span></span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (r % <span class=number>3</span> == <span class=number>1</span>) {</span><br><span class=line>                res |= (<span class=number>1</span> << i);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>另外还可以利用真值表推导转换为规则并行处理二进制<p><strong>只出现一次的数字</strong>II<p>给你一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。<p>假设这两个只出现一次的数字是 $x$ 和 $y$。<ol><li><strong>全局异或</strong>：对数组所有元素进行异或。因为出现两次的数字都会抵消（$a \oplus a = 0$），最终结果 <code>xorSum = x ^ y</code>。<li><strong>寻找差异位</strong>：由于 $x \neq y$，<code>xorSum</code> 必然不为 0。这意味着 $x$ 和 $y$ 的二进制表示中至少有一位是不同的（一个是 0，一个是 1）。我们取出 <code>xorSum</code> 中最低位的 1（称为 <code>lowbit</code>）。<li><strong>分组异或</strong>：根据 <code>lowbit</code> 这一位是否为 1，将原数组中的所有数字分成两组：<ul><li>第一组：该位为 1 的所有数字。<li>第二组：该位为 0 的所有数字</ul><li><strong>结果产出</strong>：<ul><li>相同的数字必然会被分到同一组并相互抵消。<li>$x$ 和 $y$ 必然会被分到不同的组。<li>对两组分别异或，剩下的两个数就是 $x$ 和 $y$。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>singleNumber</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=comment>// 1. 全员异或得到 x ^ y</span></span><br><span class=line>        <span class=comment>// 使用 long 防止 INT_MIN 取负时溢出</span></span><br><span class=line>        <span class=keyword>long</span> xorSum = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> num : nums) {</span><br><span class=line>            xorSum ^= num;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 2. 获取 x ^ y 中最低位的 1 (lowbit)</span></span><br><span class=line>        <span class=comment>// 这个 1 是 x 和 y 的不同点</span></span><br><span class=line>        <span class=keyword>int</span> lowbit = xorSum & -xorSum;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3. 分组异或得到两个结果</span></span><br><span class=line>        <span class=keyword>int</span> x = <span class=number>0</span>, y = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> num : nums) {</span><br><span class=line>            <span class=keyword>if</span> (num & lowbit) {</span><br><span class=line>                <span class=comment>// 第一组：该位为 1</span></span><br><span class=line>                x ^= num;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 第二组：该位为 0</span></span><br><span class=line>                y ^= num;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> {x, y};</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>在面试过程中，如果题目中出现二进制、与2的倍数相关的问题、不能使用算术运算符等情况时，都可以考虑是否可以使用位运算解题。当然，在做题的过程中，也要善于总结规律，这样在真正的笔试、面试过程中，才能够迅速写出简洁、高效的代码。另外还有一种常见的位运算使用场景是状态压缩<h1 id=设计><a class=headerlink href=#设计 title=设计></a>设计</h1><p>这类题更加强调对数据结构的设计，以达到高效实现某些操作的目的。这种题目需要我们对各种基础数据结构的特性及基本操作有着非常好的理解。<p><strong>最小栈</strong><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。<p>实现 <code>MinStack</code> 类:<ul><li><code>MinStack()</code> 初始化堆栈对象。<li><code>void push(int val)</code> 将元素val推入堆栈。<li><code>void pop()</code> 删除堆栈顶部的元素。<li><code>int top()</code> 获取堆栈顶部的元素。<li><code>int getMin()</code> 获取堆栈中的最小元素。</ul><p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么只要 a 在栈中，b, c, d 就一定在栈中。<p>那么在任何时候只要栈a在栈中，栈中元素一定是a,b,c,d.那么可以在每个元素 <code>a</code> 入栈时把当前栈的最小值 <code>m</code> 存储起来。在这之后无论何时，如果栈顶元素是 <code>a</code>，就可以直接返回存储的最小值 <code>m</code>。<p>只需要设计一个数据结构，使得每个元素 <code>a</code> 与其相应的最小值 <code>m</code> 时刻保持一一对应。因此可以使用一个辅助栈，与元素栈同步插入与删除<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MinStack</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    stack<<span class=keyword>int</span>> stk; <span class=comment>// 存储数据 正常栈</span></span><br><span class=line>    stack<<span class=keyword>int</span>> mstack;</span><br><span class=line>    <span class=built_in>MinStack</span>() { mstack.<span class=built_in>push</span>(INT_MAX); }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>push</span><span class=params>(<span class=keyword>int</span> val)</span> </span>{</span><br><span class=line>        stk.<span class=built_in>push</span>(val);</span><br><span class=line>        mstack.<span class=built_in>push</span>(<span class=built_in>min</span>(mstack.<span class=built_in>top</span>(),val));</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 弹出一个值时需要更新最小值</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>pop</span><span class=params>()</span> </span>{</span><br><span class=line>        stk.<span class=built_in>pop</span>();</span><br><span class=line>        mstack.<span class=built_in>pop</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>top</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> val = stk.<span class=built_in>top</span>();</span><br><span class=line>        <span class=keyword>return</span> val;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getMin</span><span class=params>()</span> </span>{ <span class=keyword>return</span> mstack.<span class=built_in>top</span>(); }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>实现前缀树</strong><p><strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。<p>一棵有根树，其每个节点包含以下字段：<p><strong>指向子节点的指针数组 children</strong>。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。<br>布尔字段 isEnd，表示该节点是否为字符串的结尾<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Trie</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=class><span class=keyword>class</span> <span class=title>Node</span> {</span></span><br><span class=line>    <span class=keyword>public</span>:</span><br><span class=line>        vector&LTNode*> children{<span class=number>26</span>};</span><br><span class=line>        <span class=keyword>bool</span> isEnd{<span class=literal>false</span>};</span><br><span class=line>    };</span><br><span class=line>    Node* root{};</span><br><span class=line>    <span class=built_in>Trie</span>() { root = <span class=keyword>new</span> <span class=built_in>Node</span>(); }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>insert</span><span class=params>(string word)</span> </span>{</span><br><span class=line>        Node* cur = root;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : word) {</span><br><span class=line>            <span class=keyword>int</span> idx = ch - <span class=string>'a'</span>;</span><br><span class=line>            Node* node = cur->children[idx];</span><br><span class=line>            <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>                <span class=comment>// 如果不存在</span></span><br><span class=line>                node = <span class=keyword>new</span> Node;</span><br><span class=line>                cur->children[idx] = node;</span><br><span class=line>            }</span><br><span class=line>            cur = node;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 当前字符结束 代表有这个字符串</span></span><br><span class=line>        cur->isEnd = <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>search</span><span class=params>(string word)</span> </span>{</span><br><span class=line>        Node* cur = root;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : word) {</span><br><span class=line>            <span class=keyword>int</span> idx = ch - <span class=string>'a'</span>;</span><br><span class=line>            Node* node = cur->children[idx];</span><br><span class=line>            <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>                <span class=comment>// 不存在</span></span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>            cur = node;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (cur->isEnd == <span class=literal>false</span>) {</span><br><span class=line>            <span class=comment>// 当前字符串仍然有后续字符不存在</span></span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>startsWith</span><span class=params>(string prefix)</span> </span>{</span><br><span class=line>        Node* cur = root;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : prefix) {</span><br><span class=line>            <span class=keyword>int</span> idx = ch - <span class=string>'a'</span>;</span><br><span class=line>            Node* node = cur->children[idx];</span><br><span class=line>            <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>                <span class=comment>// 不存在</span></span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>            cur = node;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>LRU缓存</strong><p>请你设计并实现一个满足 <a href=https://baike.baidu.com/item/LRU rel=noopener target=_blank>LRU (最近最少使用) 缓存</a> 约束的数据结构。<p>实现 <code>LRUCache</code> 类：<ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。<blockquote><p>在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</blockquote><p>为什么使用双向链表而不是单向链表？其原因在于，如果想在常数时间内将链表中间的节点移动到尾部，需要能够在O(1)时间内获得当前节点的前驱节点。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>LRUCache</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>// 查询 unordered_map</span></span><br><span class=line>    <span class=comment>// 增加 双向链表 增/改 将节点放在首位</span></span><br><span class=line>    unordered_map<<span class=keyword>int</span>, list&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>>::iterator> umap;</span><br><span class=line>    <span class=comment>// class LinkedNode{</span></span><br><span class=line>    <span class=comment>//     public:</span></span><br><span class=line>    <span class=comment>//         int key{};</span></span><br><span class=line>    <span class=comment>//         int val{};</span></span><br><span class=line>    <span class=comment>//         LinkedNode* next_node{};</span></span><br><span class=line>    <span class=comment>//         LinedNode* prev_node{};</span></span><br><span class=line>    <span class=comment>// };</span></span><br><span class=line>    <span class=comment>// LinkedNode * root;</span></span><br><span class=line>    <span class=comment>// unordered_map&LTint,LinkedNode*> umap</span></span><br><span class=line>    list&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> vals;</span><br><span class=line>    <span class=keyword>int</span> _capacity{};</span><br><span class=line>    <span class=keyword>int</span> cnt{};</span><br><span class=line>    <span class=built_in>LRUCache</span>(<span class=keyword>int</span> capacity) : _capacity(capacity) {}</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>get</span><span class=params>(<span class=keyword>int</span> key)</span> </span>{</span><br><span class=line>        <span class=comment>// 获取值</span></span><br><span class=line>        <span class=keyword>if</span> (umap.<span class=built_in>count</span>(key)) {</span><br><span class=line>            <span class=comment>// 返回值 并更新节点在链表中位置</span></span><br><span class=line>            <span class=keyword>auto</span> it = umap[key];</span><br><span class=line>            <span class=keyword>int</span> val = it->second;</span><br><span class=line>            <span class=comment>// 插入在map中值</span></span><br><span class=line>            umap.<span class=built_in>erase</span>(key);</span><br><span class=line>            vals.<span class=built_in>erase</span>(it); <span class=comment>// 在双向链表中删除</span></span><br><span class=line>            <span class=comment>// 插入值</span></span><br><span class=line>            vals.<span class=built_in>push_front</span>({key, val});</span><br><span class=line>            umap[key] = vals.<span class=built_in>begin</span>(); <span class=comment>// 更新</span></span><br><span class=line>            <span class=keyword>return</span> val;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 不存在</span></span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>put</span><span class=params>(<span class=keyword>int</span> key, <span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (umap.<span class=built_in>count</span>(key)) {</span><br><span class=line>            <span class=comment>// 如果存在 更新位置</span></span><br><span class=line>            <span class=keyword>auto</span> it = umap[key];</span><br><span class=line>            vals.<span class=built_in>erase</span>(it);</span><br><span class=line>            vals.<span class=built_in>push_front</span>({key, value});</span><br><span class=line>            umap.<span class=built_in>erase</span>(key);</span><br><span class=line>            umap[key] = vals.<span class=built_in>begin</span>();</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 不存在  插入值并更新位置 判断容量</span></span><br><span class=line>            vals.<span class=built_in>push_front</span>({key, value});</span><br><span class=line>            umap[key] = vals.<span class=built_in>begin</span>();</span><br><span class=line>            cnt++;</span><br><span class=line>            <span class=comment>// 判断容量</span></span><br><span class=line>            <span class=keyword>if</span> (cnt > _capacity) {</span><br><span class=line>                <span class=comment>// 删除链表最后一个元素</span></span><br><span class=line>                <span class=keyword>auto</span> it = vals.<span class=built_in>rbegin</span>();</span><br><span class=line>                umap.<span class=built_in>erase</span>(it->first);</span><br><span class=line>                vals.<span class=built_in>pop_back</span>();</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>实际的算法历史上，出现了很多性能更加优秀的变种，比如下面这两种。●　LRU-K算法，用于删除第k个最近使用的数据。●　ARC算法，维护了最近被删除数据的历史，特别适合用于需要连续扫描的情况。而在著名的Redis中同样实现了两个LRU算法的变种。<p>●　volatile-LRU：从已设置过期时间的数据集中挑选最近最少使用的数据来淘汰。<p>●　allkeys-LRU：从所有数据集中挑选最近最少使用的数据来淘汰。在Redis中LRU变种的具体实现细节<p><strong>LFU缓存</strong><p>请你为 <a href=https://baike.baidu.com/item/缓存算法 rel=noopener target=_blank>最不经常使用（LFU）</a>缓存算法设计并实现数据结构。<p>实现 <code>LFUCache</code> 类：<ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象<li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。<li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最久未使用</strong> 的键。</ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>LFUCache</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=class><span class=keyword>class</span> <span class=title>Node</span> {</span></span><br><span class=line>    <span class=keyword>public</span>:</span><br><span class=line>        <span class=keyword>int</span> key{};</span><br><span class=line>        <span class=keyword>int</span> val{};</span><br><span class=line>        <span class=keyword>int</span> freq{};</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span>:</span><br><span class=line>        <span class=built_in>Node</span>() {</span><br><span class=line></span><br><span class=line>        };</span><br><span class=line>        <span class=built_in>Node</span>(<span class=keyword>int</span> k, <span class=keyword>int</span> v, <span class=keyword>int</span> f) : <span class=built_in>key</span>(k), <span class=built_in>val</span>(v), <span class=built_in>freq</span>(f) {}</span><br><span class=line>    };</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, list&LTNode>::iterator> nodeMap; <span class=comment>// 值->节点在list中位置</span></span><br><span class=line>    unordered_map<<span class=keyword>int</span>, list&LTNode>> freqMap;           <span class=comment>// 频率->相同频率节点</span></span><br><span class=line>    <span class=keyword>int</span> min_freq{INT_MAX};</span><br><span class=line>    <span class=keyword>int</span> _capacity{};</span><br><span class=line>    <span class=keyword>int</span> cnt{};</span><br><span class=line>    <span class=built_in>LFUCache</span>(<span class=keyword>int</span> capacity) : _capacity(capacity) {}</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>get</span><span class=params>(<span class=keyword>int</span> key)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!nodeMap.<span class=built_in>count</span>(key)) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 如果存在 频率+1,更新双向链表中位置/时间</span></span><br><span class=line>        <span class=comment>// 找到节点</span></span><br><span class=line>        <span class=keyword>int</span> val = <span class=built_in>touch</span>(key);</span><br><span class=line>        <span class=keyword>return</span> val;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>touch</span><span class=params>(<span class=keyword>int</span> key)</span> </span>{</span><br><span class=line>        <span class=keyword>auto</span> it = nodeMap[key];</span><br><span class=line>        <span class=keyword>int</span> val = it->val;</span><br><span class=line>        <span class=keyword>int</span> freq = it->freq;</span><br><span class=line>        <span class=comment>// 移除频率中该节点值</span></span><br><span class=line>        freqMap[freq].<span class=built_in>erase</span>(it);</span><br><span class=line>        <span class=keyword>if</span>(freqMap[freq].<span class=built_in>empty</span>()) {</span><br><span class=line>            freqMap.<span class=built_in>erase</span>(freq);</span><br><span class=line>            <span class=keyword>if</span>(freq == min_freq) {</span><br><span class=line>                min_freq++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        ++freq;</span><br><span class=line>        freqMap[freq].<span class=built_in>push_front</span>({key, val, freq});</span><br><span class=line>        nodeMap[key] = freqMap[freq].<span class=built_in>begin</span>();</span><br><span class=line>        <span class=keyword>return</span> val;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>put</span><span class=params>(<span class=keyword>int</span> key, <span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>        <span class=comment>// 如果存在 更新频率与位置</span></span><br><span class=line>        <span class=keyword>if</span> (nodeMap.<span class=built_in>count</span>(key)) {</span><br><span class=line>            <span class=keyword>auto</span> it = nodeMap[key];</span><br><span class=line>            it->val = value;</span><br><span class=line>            <span class=built_in>touch</span>(key);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 不存在</span></span><br><span class=line>        <span class=keyword>if</span> (cnt == _capacity) {</span><br><span class=line>            <span class=comment>// 淘汰频率最低的值</span></span><br><span class=line>            <span class=keyword>auto</span>& nodes = freqMap[min_freq];</span><br><span class=line>            <span class=comment>// 删除链表中最后一个节点</span></span><br><span class=line>            <span class=keyword>auto</span> it = nodes.<span class=built_in>rbegin</span>();</span><br><span class=line>            nodeMap.<span class=built_in>erase</span>(it->key);</span><br><span class=line>            nodes.<span class=built_in>pop_back</span>();</span><br><span class=line>            <span class=keyword>if</span> (nodes.<span class=built_in>empty</span>()) {</span><br><span class=line>                freqMap.<span class=built_in>erase</span>(min_freq);</span><br><span class=line>            }</span><br><span class=line>            cnt--;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 添加节点</span></span><br><span class=line>        <span class=comment>// 移除频率中该节点值</span></span><br><span class=line>        freqMap[<span class=number>1</span>].<span class=built_in>push_front</span>({key, value, <span class=number>1</span>});</span><br><span class=line>        nodeMap[key] = freqMap[<span class=number>1</span>].<span class=built_in>begin</span>();</span><br><span class=line>        min_freq = <span class=number>1</span>;</span><br><span class=line>        cnt++;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><p><strong>设计跳表</strong><p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。<p>跳表是一种随机化的数据结构，可以被看做二叉树的一个变种，它在性能上和红黑树、AVL 树不相上下，但是跳表的原理非常简单，目前在 Redis 和 LevelDB 中都有用到。跳表的期望空间复杂度为 O(n)，跳表的查询，插入和删除操作的期望时间复杂度均为 O(logn)。<p>跳表实际为一种多层的有序链表，跳表的每一层都为一个有序链表，且满足每个位于第 i 层的节点有 p 的概率出现在第 i+1 层，其中 p 为常数。<p>查找时，从当前最高层开始开始，如果当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第一层。此时，若下一个节点是目标节点，则成功查找；反之，则元素不存在。由于从高层往低层开始查找，由于低层出现的元素可能不会出现在高层，因此跳表在进行查找的过程中会跳过一些元素，相比于有序链表的查询，跳表的查询速度会更快。<p>添加时，从跳表的当前的最大层数 level 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 1 层。设新加入的节点为 newNode，我们需要计算出此次节点插入的层数 lv，如果 level 小于 lv，则同时需要更新 level。用数组 update 保存每一层查找的最后一个节点，第 i 层最后的节点为 update[i]。我们将 newNode 的后续节点指向 update[i] 的下一个节点，同时更新 update[i] 的后续节点为 newNode。 lv随机生成，从第一层开始，如果概率小于某个值，则再加一层。<p>删除时，首先我们需要查找当前元素是否存在跳表中。从跳表的当前的最大层数 level 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 1 层。如果第 1 层的下一个节点不等于 num 时，则表示当前元素不存在直接返回。我们用数组 update 保存每一层查找的最后一个节点，第 i 层最后的节点为 update[i]。此时第 i 层的下一个节点的值为 num，则我们需要将其从跳表中将其删除。由于第 i 层的以 p 的概率出现在第 i+1 层，因此我们应当从第 1 层开始往上进行更新，将 num 从 update[i] 的下一跳中删除，同时更新 update[i] 的后续节点，直到当前层的链表中没有出现 num 的节点为止。最后我们还需要更新跳表中当前的最大层数 level。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Skiplist</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>static</span> <span class=keyword>int</span> MAX_LEVEL = <span class=number>32</span>;</span><br><span class=line>    <span class=keyword>const</span> <span class=keyword>static</span> <span class=keyword>int</span> factor = <span class=number>.25</span>;</span><br><span class=line>    <span class=class><span class=keyword>class</span> <span class=title>SkipListNode</span> {</span></span><br><span class=line>    <span class=keyword>public</span>:</span><br><span class=line>        <span class=keyword>int</span> val{};</span><br><span class=line>        vector&LTSkipListNode*> next;</span><br><span class=line>        <span class=built_in>SkipListNode</span>(<span class=keyword>int</span> t_val, <span class=keyword>int</span> max_level = MAX_LEVEL)</span><br><span class=line>            : <span class=built_in>val</span>(t_val), <span class=built_in>next</span>(max_level, <span class=literal>nullptr</span>) {}</span><br><span class=line>    };</span><br><span class=line>    SkipListNode* skipNode;</span><br><span class=line>    <span class=keyword>int</span> level{};</span><br><span class=line>    <span class=built_in>Skiplist</span>() { skipNode = <span class=keyword>new</span> <span class=built_in>SkipListNode</span>(<span class=number>-1</span>); }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>search</span><span class=params>(<span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>        <span class=comment>// 从最顶层搜索，</span></span><br><span class=line>        SkipListNode* cur = skipNode;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = level - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=comment>// 如果同层下一个节点值小于target 继续到下一个节点</span></span><br><span class=line>            <span class=comment>// 否则跳向下一层</span></span><br><span class=line>            <span class=keyword>while</span> (cur->next[i] && cur->next[i]->val < target) {</span><br><span class=line>                cur = cur->next[i];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        cur = cur->next[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>if</span> (cur && cur->val == target) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>randomLevel</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> lv{<span class=number>1</span>};</span><br><span class=line>        <span class=keyword>while</span> (<span class=built_in>rand</span>() < factor && lv < MAX_LEVEL) {</span><br><span class=line>            lv++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> lv;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>add</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=function>vector&LTSkipListNode*> <span class=title>update</span><span class=params>(MAX_LEVEL, skipNode)</span></span>;</span><br><span class=line>        SkipListNode* cur = skipNode;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = level - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>while</span> (cur->next[i] && cur->next[i]->val < num) {</span><br><span class=line>                cur = cur->next[i];</span><br><span class=line>            }</span><br><span class=line>            <span class=comment>// 记录每层要添加的位置</span></span><br><span class=line>            update[i] = cur;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> lv = <span class=built_in>randomLevel</span>();</span><br><span class=line>        level = <span class=built_in>max</span>(lv, MAX_LEVEL);</span><br><span class=line>        SkipListNode* newNode = <span class=keyword>new</span> <span class=built_in>SkipListNode</span>(num, lv);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < lv; i++) {</span><br><span class=line>            <span class=comment>// 到lv之前 每层都添加</span></span><br><span class=line>            newNode->next[i] = update[i]->next[i];</span><br><span class=line>            update[i]->next[i] = newNode;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>erase</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=function>vector&LTSkipListNode*> <span class=title>update</span><span class=params>(MAX_LEVEL, <span class=literal>nullptr</span>)</span></span>;</span><br><span class=line>        <span class=comment>// 记录从最高层要删除的节点之前的节点</span></span><br><span class=line>        SkipListNode* cur = skipNode;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = level - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>while</span> (cur->next[i] && cur->next[i]->val < num) {</span><br><span class=line>                cur = cur->next[i];</span><br><span class=line>            }</span><br><span class=line>            update[i] = cur;</span><br><span class=line>        }</span><br><span class=line>        cur = cur->next[<span class=number>0</span>];</span><br><span class=line>        <span class=comment>// 看要删除的值是否存在</span></span><br><span class=line>        <span class=keyword>if</span> (!cur || cur->val != num) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < level; i++) {</span><br><span class=line>            <span class=keyword>if</span> (update[i]->next[i] != cur) {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            update[i]->next[i] = cur->next[i];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>delete</span> cur;</span><br><span class=line>        <span class=keyword>while</span> (level > <span class=number>1</span> && skipNode->next[level - <span class=number>1</span>] == <span class=literal>nullptr</span>) {</span><br><span class=line>            level--;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>添加与搜索单词</strong><p>字典树（前缀树）是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。前缀树可以用 O(∣S∣) 的时间复杂度完成如下操作，其中 ∣S∣ 是插入字符串或查询前缀的长度：<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>WordDictionary</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>Node</span> {</span></span><br><span class=line>        <span class=keyword>char</span> ch{};</span><br><span class=line>        vector&LTNode*> next{<span class=number>26</span>, <span class=literal>nullptr</span>};</span><br><span class=line>        <span class=comment>// 是否是字符串结尾</span></span><br><span class=line>        <span class=keyword>bool</span> isEnd{};</span><br><span class=line>    };</span><br><span class=line>    Node* root{};</span><br><span class=line>    <span class=built_in>WordDictionary</span>() { root = <span class=keyword>new</span> Node; }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>addWord</span><span class=params>(string word)</span> </span>{</span><br><span class=line>        Node* cur = root;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : word) {</span><br><span class=line>            Node* node = cur->next[ch - <span class=string>'a'</span>];</span><br><span class=line>            <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>                node = <span class=keyword>new</span> Node;</span><br><span class=line>                node->ch = ch;</span><br><span class=line>                cur->next[ch - <span class=string>'a'</span>] = node;</span><br><span class=line>            }</span><br><span class=line>            cur = node;</span><br><span class=line>        }</span><br><span class=line>        cur->isEnd = <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>dfs</span><span class=params>(string& word, <span class=keyword>int</span> idx, Node* cur)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (idx == word.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>if</span> (cur->isEnd == <span class=literal>true</span>) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>char</span> ch = word[idx];</span><br><span class=line>        <span class=keyword>if</span> (ch == <span class=string>'.'</span>) {</span><br><span class=line>            <span class=comment>// 针对下一个节点</span></span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < <span class=number>26</span>; i++) {</span><br><span class=line>                <span class=keyword>if</span> (cur->next[i]) {</span><br><span class=line>                    <span class=keyword>if</span> (<span class=built_in>dfs</span>(word, idx + <span class=number>1</span>, cur->next[i])) {</span><br><span class=line>                        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>int</span> index = ch - <span class=string>'a'</span>;</span><br><span class=line>            <span class=keyword>if</span> (cur->next[index]) {</span><br><span class=line>                <span class=keyword>return</span> <span class=built_in>dfs</span>(word, idx + <span class=number>1</span>, cur->next[index]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>search</span><span class=params>(string word)</span> </span>{</span><br><span class=line>        Node* cur = root;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(word, <span class=number>0</span>, cur);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>二叉树的序列化与反序列化</strong><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Codec</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>// 序列为字符串</span></span><br><span class=line>    <span class=comment>// 依规定顺序和规则序列化和反序列化</span></span><br><span class=line>    <span class=comment>// DFS 前序 中序 后序</span></span><br><span class=line>    <span class=comment>// BFS 层序</span></span><br><span class=line>    <span class=comment>// Encodes a tree to a single string.</span></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>serializeTree</span><span class=params>(TreeNode* node, string& str)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=comment>// 根节点</span></span><br><span class=line>            str += <span class=string>"None,"</span>;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        str += <span class=built_in>to_string</span>(node->val) + <span class=string>","</span>;</span><br><span class=line>        <span class=built_in>serializeTree</span>(node->left, str);</span><br><span class=line>        <span class=built_in>serializeTree</span>(node->right, str);</span><br><span class=line>    }</span><br><span class=line>    <span class=function>string <span class=title>serialize</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>        <span class=comment>// 规定序列化顺序</span></span><br><span class=line>        <span class=comment>// 先序</span></span><br><span class=line>        string res;</span><br><span class=line>        <span class=built_in>serializeTree</span>(root, res);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>TreeNode* <span class=title>rserialize</span><span class=params>(list&LTstring>& dataArray)</span> </span>{</span><br><span class=line>        <span class=comment>// 根据数组值</span></span><br><span class=line>        <span class=keyword>if</span> (dataArray.<span class=built_in>front</span>() == <span class=string>"None"</span>) {</span><br><span class=line>            <span class=comment>// 空节点</span></span><br><span class=line>            dataArray.<span class=built_in>erase</span>(dataArray.<span class=built_in>begin</span>());</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        TreeNode* node = <span class=keyword>new</span> <span class=built_in>TreeNode</span>(<span class=built_in>stoi</span>(dataArray.<span class=built_in>front</span>()));</span><br><span class=line>        dataArray.<span class=built_in>erase</span>(dataArray.<span class=built_in>begin</span>());</span><br><span class=line>        node->left = <span class=built_in>rserialize</span>(dataArray);</span><br><span class=line>        node->right = <span class=built_in>rserialize</span>(dataArray);</span><br><span class=line>        <span class=keyword>return</span> node;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// Decodes your encoded data to tree.</span></span><br><span class=line>    <span class=function>TreeNode* <span class=title>deserialize</span><span class=params>(string data)</span> </span>{</span><br><span class=line>        list&LTstring> dataArray;</span><br><span class=line>        string str;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>char</span>& ch : data) {</span><br><span class=line>            <span class=keyword>if</span> (ch == <span class=string>','</span>) {</span><br><span class=line>                dataArray.<span class=built_in>push_back</span>(str);</span><br><span class=line>                str.<span class=built_in>clear</span>();</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                str.<span class=built_in>push_back</span>(ch);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (!str.<span class=built_in>empty</span>()) {</span><br><span class=line>            dataArray.<span class=built_in>push_back</span>(str);</span><br><span class=line>            str.<span class=built_in>clear</span>();</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 拆分为数组</span></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>rserialize</span>(dataArray);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>可以先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。那么我们如何反序列化呢？首先我们需要根据 , 把原先的序列分割开来得到先序遍历的元素列表，然后从左向右遍历这个序列：<p>如果当前的元素为 None，则当前为空树.否则先解析这棵树的左子树，再解析它的右子树<p><strong>字符的编码与解码</strong><p>请你设计一个算法，可以将一个 <strong>字符串列表</strong> 编码成为一个 <strong>字符串</strong>。这个编码后的字符串是可以通过网络进行高效传送的，并且可以在接收端被解码回原来的字符串列表。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Codec</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>strLen</span><span class=params>(string& str)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = str.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>to_string</span>(sz) + <span class=string>"#"</span> + str;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// Encodes a list of strings to a single string.</span></span><br><span class=line>    <span class=function>string <span class=title>encode</span><span class=params>(vector&LTstring>& strs)</span> </span>{</span><br><span class=line>        string res;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& str : strs) {</span><br><span class=line>            res += <span class=built_in>strLen</span>(str);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// Decodes a single string to a list of strings.</span></span><br><span class=line>    <span class=function>vector&LTstring> <span class=title>decode</span><span class=params>(string s)</span> </span>{</span><br><span class=line>        vector&LTstring> res;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>int</span> num{};</span><br><span class=line>            <span class=keyword>while</span> (i < s.<span class=built_in>size</span>() && <span class=built_in>isdigit</span>(s[i])) {</span><br><span class=line>                num = num * <span class=number>10</span> + (s[i] - <span class=string>'0'</span>);</span><br><span class=line>                i++;</span><br><span class=line>            }</span><br><span class=line>            i++;</span><br><span class=line>            res.<span class=built_in>push_back</span>(s.<span class=built_in>substr</span>(i, num));</span><br><span class=line>            i = i+num<span class=number>-1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>循环双端队列</strong><p>以通过一个数组进行模拟，通过操作数组的索引构建一个虚拟的首尾相连的环。在循环队列结构中，设置一个队尾 <em>rear</em> 与队首 <em>front</em>，且大小固定<p>在循环队列中，当队列为空，可知 front=rear；而当所有队列空间全占满时，也有 front=rear。为了区别这两种情况，假设队列使用的数组有 capacity 个存储空间，则此时规定循环队列最多只能有capacity−1 个队列元素，当循环队列中只剩下一个空存储单元时，则表示队列已满。根据以上可知，队列判空的条件是 front=rear，而队列判满的条件是 front=(rear+1)modcapacity。<p>elements：一个固定大小的数组，用于保存循环队列的元素。<br>capacity：循环队列的容量，即队列中最多可以容纳的元素数量。<br>front：队列首元素对应的数组的索引。<br>rear：队列尾元素对应的索引的下一个索引。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyCircularDeque</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>int</span> _cap{};</span><br><span class=line>    <span class=keyword>int</span>* arr;</span><br><span class=line>    <span class=keyword>int</span> start{};</span><br><span class=line>    <span class=keyword>int</span> end{}; <span class=comment>// 记录最后一个位置+1</span></span><br><span class=line>    <span class=built_in>MyCircularDeque</span>(<span class=keyword>int</span> k) {</span><br><span class=line>        _cap = k + <span class=number>1</span>;</span><br><span class=line>        arr = <span class=keyword>new</span> <span class=keyword>int</span>[_cap];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>insertFront</span><span class=params>(<span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>isFull</span>()) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        arr[(start - <span class=number>1</span> + _cap) % _cap] = value;</span><br><span class=line>        start = (start - <span class=number>1</span> + _cap) % _cap;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>insertLast</span><span class=params>(<span class=keyword>int</span> value)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>isFull</span>()) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        arr[end] = value;</span><br><span class=line>        end = (end + <span class=number>1</span>) % _cap;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>deleteFront</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>isEmpty</span>())</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        start = (start + <span class=number>1</span>) % _cap;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>deleteLast</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>isEmpty</span>())</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        end = (end - <span class=number>1</span> + _cap) % _cap;</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getFront</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>isEmpty</span>())</span><br><span class=line>            <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>        <span class=keyword>return</span> arr[start];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getRear</span><span class=params>()</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>isEmpty</span>())</span><br><span class=line>            <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>        <span class=keyword>return</span> arr[(end - <span class=number>1</span> + _cap) % _cap];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isEmpty</span><span class=params>()</span> </span>{ <span class=keyword>return</span> start == end; }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isFull</span><span class=params>()</span> </span>{ <span class=keyword>return</span> ((end + <span class=number>1</span>) % _cap) == start; }</span><br><span class=line>};</span><br></pre></table></figure><h1 id=双指针><a class=headerlink href=#双指针 title=双指针></a>双指针</h1><p>双指针是一个很宽泛的概念，就像数组、链表一样，其类型有很多。比如二分法经常用到左/右端点双指针，滑动窗口会用到快/慢指针和固定间距指针，因此双指针其实是一种综合性很强的类型，类似于数组、栈等，但是这里所讲述的双指针，往往指的是某几种类型的双指针，而不是只要有两个指针就是双指针<p>头/尾指针是指游标同时指向数组、字符串的第一个元素和最后一个元素，典型应用是求数组元素或子串是否满足特定条件。快/慢指针是指两个指针的移动速度不同（比如有的移动步长为2，有的移动步长为1），典型的应用是判断链表是否有环。<p><strong>盛最多水的容器</strong><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxArea</span><span class=params>(vector<<span class=keyword>int</span>>& height)</span> </span>{</span><br><span class=line>        <span class=comment>// 双指针</span></span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>int</span> l = <span class=number>0</span>, r = height.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (l < r) {</span><br><span class=line>            <span class=keyword>int</span> h = <span class=built_in>min</span>(height[l], height[r]);</span><br><span class=line>            ans = <span class=built_in>max</span>(ans, (r-l) * h);</span><br><span class=line>            <span class=keyword>if</span> (height[l] < height[r]) {</span><br><span class=line>                l++;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                r--;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>环形链表</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>hasCycle</span><span class=params>(ListNode *head)</span> </span>{</span><br><span class=line>        ListNode* slow = head,*fast = head;</span><br><span class=line>        <span class=keyword>while</span>(fast && fast->next) {</span><br><span class=line>            slow = slow->next;</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            <span class=keyword>if</span>(slow == fast) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>无重复字符的最长字串</strong><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>lengthOfLongestSubstring</span><span class=params>(string s)</span> </span>{</span><br><span class=line>        <span class=comment>// 记录字串内重复出现字符</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>chs</span><span class=params>(<span class=number>128</span>)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> left{};</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>while</span> (left&LTi && chs[s[i]]) {</span><br><span class=line>                <span class=comment>// 出现过 移动左窗口</span></span><br><span class=line>                chs[s[left]] = <span class=literal>false</span>;</span><br><span class=line>                left++;</span><br><span class=line>            }</span><br><span class=line>            <span class=comment>// 记录</span></span><br><span class=line>            chs[s[i]] = <span class=literal>true</span>;</span><br><span class=line>            ans = <span class=built_in>max</span>(ans, i - left + <span class=number>1</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>双指针一般解决的是与字符串、数组、链表相关的问题，当题目中出现需要字符串的子串、数组的几个子元素、链表的多个节点时，都可以考虑一下能否用双指针的方法来解决。一旦确定可以使用双指针来解答问题，要注意是否可以通过边界条件提前退出检测、是否可以利用其他结构体（比如字典等）来优化解法<p>双指针问题首先要考虑使用的双指针类型是选择从两边开始的头/尾指针，还是选择从一边开始的快/慢指针。针对快/慢指针，在用于滑动窗口问题时，还可以考虑通过指针控制窗口的大小来优化算法<h1 id=动态规划><a class=headerlink href=#动态规划 title=动态规划></a>动态规划</h1><p>动态规划和其他算法思想如递归、回溯、分治和贪心等方法都有一定的联系。其背后的基本思想是枚举，虽然看起来简单，但如何涵盖所有的可能，并尽量减少重叠子问题的计算是一个难点。<p>解动态规划类问题，分析过程是有章可循的，<strong>通过对阶段、子问题和状态的拆解基本可以得到解决问题的框架</strong>。具体的求解过程一般可以<strong>通过推导状态转移方程或填状态转移表这两种方法</strong>来实现。<p>解决动态规划问题的核心在于找到状态转移方程和处理边界条件。这两者中更为困难的当然是状态转移方程了，看出了状态转移方程，解题就是水到渠成的事情了。对于某一道动态规划题目来说，状态转移方程可能不止一种，不同的状态转移方程对应不同的解法，而不同的转移方程的性能差别可能是巨大的<p><strong>鸡蛋掉落问题</strong><p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。<p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？<p>可以<strong>转换思路</strong>，换一个视角来看：<strong>如果我们有 $k$ 个鸡蛋，允许扔 $m$ 次，我们最高能测出多少层楼？</strong><p>设 $dp[m][k]$ 为：当有 <strong>$k$ 个鸡蛋</strong>，可以<strong>扔 $m$ 次</strong>时，能确定的<strong>最大楼层数</strong>。<p>当我们从某一层扔下一枚鸡蛋时，只有两种结果：<ol><li><strong>鸡蛋碎了</strong>：<ul><li>我们损失了一个鸡蛋（剩下 $k-1$ 个）。<li>我们损失了一次机会（剩下 $m-1$ 次）。<li>我们能向下确定的楼层数是 $dp[m-1][k-1]$。</ul><li><strong>鸡蛋没碎</strong>：<ul><li>鸡蛋数量不变（剩下 $k$ 个）。<li>我们损失了一次机会（剩下 $m-1$ 次）。<li>我们能向上确定的楼层数是 $dp[m-1][k]$。</ul></ol><p>再加上<strong>当前扔鸡蛋的那一层</strong>（1 层），总共能确定的楼层数为：</p><script type="math/tex; mode=display">dp[m][k] = dp[m-1][k-1] + dp[m-1][k] + 1</script><ol><li>初始化一个二维数组（或者优化为一维）。<li>不断增加投掷次数 $m$，直到 $dp[m][k] \ge n$。<li>此时的 $m$ 就是我们要找的<strong>最小操作次数</strong>。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>superEggDrop</span><span class=params>(<span class=keyword>int</span> k, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (n == <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(n + <span class=number>1</span>, vector<<span class=keyword>int</span>>(k + <span class=number>1</span>));</span><br><span class=line>        <span class=comment>// 1层楼</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= k; i++) {</span><br><span class=line>            dp[<span class=number>1</span>][i] = <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= k; j++) {</span><br><span class=line>                dp[i][j] = dp[i - <span class=number>1</span>][j] + dp[i - <span class=number>1</span>][j - <span class=number>1</span>] + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (dp[i][k] >= n) {</span><br><span class=line>                ans = i;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>打家劫舍系列</strong><p><strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k>2) 间房屋，有两个选项：<ol><li><p>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</p><li><p>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</p></ol><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。<p>从状态转移方程可以知道状态f(n)只依赖状态f(n-1)和状态f(n-2)，因此，额外的n大小的辅助空间是不需要的，只需要两个额外的变量来表示两个依赖状态即可。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>rob</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span>(sz == <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> nums[<span class=number>0</span>];</span><br><span class=line>        }</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(sz)</span></span>;</span><br><span class=line>        dp[<span class=number>0</span>] = nums[<span class=number>0</span>];</span><br><span class=line>        dp[<span class=number>1</span>] = <span class=built_in>max</span>(nums[<span class=number>0</span>],nums[<span class=number>1</span>]);</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>2</span>;i&LTsz;i++) {</span><br><span class=line>            dp[i] = <span class=built_in>max</span>(dp[i<span class=number>-2</span>]+nums[i],dp[i<span class=number>-1</span>]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[sz<span class=number>-1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>rob</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span> (sz == <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> nums[<span class=number>0</span>];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> prev = <span class=number>0</span>, cur = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < sz; i++) {</span><br><span class=line>            <span class=keyword>int</span> tmp = cur;</span><br><span class=line>            cur = <span class=built_in>max</span>(cur, nums[i] + prev);</span><br><span class=line>            prev = tmp;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cur;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。<p>首尾的房屋是相连的，也就是说：如果偷了开头的房屋，那么结尾的房屋不能偷；如果偷了结尾的房屋，那么开头的房屋不能偷。范围[0,n-1)的解和范围[1,n-1]的解中的较大值即为解，这里n是数组的长度。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>robRange</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> start, <span class=keyword>int</span> end)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> first = nums[start], second = <span class=built_in>max</span>(nums[start], nums[start + <span class=number>1</span>]);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = start + <span class=number>2</span>; i <= end; i++) {</span><br><span class=line>            <span class=keyword>int</span> temp = second;</span><br><span class=line>            second = <span class=built_in>max</span>(first + nums[i], second);</span><br><span class=line>            first = temp;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> second;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>rob</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> length = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span> (length == <span class=number>1</span>) {</span><br><span class=line>            <span class=keyword>return</span> nums[<span class=number>0</span>];</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (length == <span class=number>2</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>max</span>(nums[<span class=number>0</span>], nums[<span class=number>1</span>]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>max</span>(<span class=built_in>robRange</span>(nums, <span class=number>0</span>, length - <span class=number>2</span>), <span class=built_in>robRange</span>(nums, <span class=number>1</span>, length - <span class=number>1</span>));</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。<p>给定二叉树的 <code>root</code> 。返回 <strong>*在不触动警报的情况下</strong> ，小偷能够盗取的最高金额* 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>pair<<span class=keyword>int</span>,<span class=keyword>int</span>> <span class=title>dfs</span><span class=params>(TreeNode* node)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=keyword>return</span> {<span class=number>0</span>,<span class=number>0</span>};</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 偷当前节点</span></span><br><span class=line>        <span class=keyword>auto</span> [l1,l2] = <span class=built_in>dfs</span>(node->left);</span><br><span class=line>        <span class=keyword>auto</span> [r1,r2] = <span class=built_in>dfs</span>(node->right);</span><br><span class=line>        <span class=comment>// 偷当前节点</span></span><br><span class=line>        <span class=keyword>int</span>  f1 = node->val + l2+r2;</span><br><span class=line>        <span class=comment>// 不偷当前节点</span></span><br><span class=line>        <span class=keyword>int</span> f2 = <span class=built_in>max</span>(l1,l2)+<span class=built_in>max</span>(r1,r2);</span><br><span class=line>        <span class=keyword>return</span> {f1,f2}; </span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>rob</span><span class=params>(TreeNode* root)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!root) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>auto</span> [x1,x2] = <span class=built_in>dfs</span>(root);</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>max</span>(x1,x2);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>不同路径</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>uniquePaths</span><span class=params>(<span class=keyword>int</span> m, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(n,<span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i =<span class=number>1</span>;i&LTm;i++) {</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j =<span class=number>1</span>;j&LTn;j++) {</span><br><span class=line>                dp[j] += dp[j<span class=number>-1</span>];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[n<span class=number>-1</span>];</span><br><span class=line>        <span class=comment>// vector&LTvector&LTint>> dp(m, vector&LTint>(n));</span></span><br><span class=line>        <span class=comment>// for (int i = 0; i < m; i++) {</span></span><br><span class=line>        <span class=comment>//     dp[i][0] = 1;</span></span><br><span class=line>        <span class=comment>// }</span></span><br><span class=line>        <span class=comment>// for (int i = 0; i < n; i++) {</span></span><br><span class=line>        <span class=comment>//     dp[0][i] = 1;</span></span><br><span class=line>        <span class=comment>// }</span></span><br><span class=line>        <span class=comment>// for (int i = 1; i < m; i++) {</span></span><br><span class=line>        <span class=comment>//     for (int j = 1; j < n; j++) {</span></span><br><span class=line>        <span class=comment>//         dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></span><br><span class=line>        <span class=comment>//     }</span></span><br><span class=line>        <span class=comment>// }</span></span><br><span class=line>        <span class=comment>// return dp[m - 1][n - 1];</span></span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给定一个 <code>m x n</code> 的整数数组 <code>grid</code>。一个机器人初始位于 <strong>左上角</strong>（即 <code>grid[0][0]</code>）。机器人尝试移动到 <strong>右下角</strong>（即 <code>grid[m - 1][n - 1]</code>）。机器人每次只能向下或者向右移动一步。<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。机器人的移动路径中不能包含 <strong>任何</strong> 有障碍物的方格。<p>返回机器人能够到达右下角的不同路径数量。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>uniquePathsWithObstacles</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& obstacleGrid)</span> </span>{</span><br><span class=line>        <span class=comment>// 动态规划</span></span><br><span class=line>        <span class=keyword>int</span> m = obstacleGrid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = obstacleGrid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// dp[i][j]表示到达i,j的路径数目</span></span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(m, vector<<span class=keyword>int</span>>(n));</span><br><span class=line>        <span class=comment>// 初始化</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>            <span class=keyword>if</span> (obstacleGrid[<span class=number>0</span>][j] == <span class=number>0</span>) {</span><br><span class=line>                dp[<span class=number>0</span>][j] = <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>if</span> (obstacleGrid[i][<span class=number>0</span>] == <span class=number>0</span>) {</span><br><span class=line>                dp[i][<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j < n; j++) {</span><br><span class=line>                <span class=keyword>if</span> (obstacleGrid[i][j] == <span class=number>1</span>) {</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                dp[i][j] = dp[i - <span class=number>1</span>][j] + dp[i][j - <span class=number>1</span>];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[m - <span class=number>1</span>][n - <span class=number>1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>零钱系列</strong><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。<p>你可以认为每种硬币的数量是无限的。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>coinChange</span><span class=params>(vector<<span class=keyword>int</span>>& coins, <span class=keyword>int</span> amount)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(amount + <span class=number>1</span>, INT_MAX)</span></span>;</span><br><span class=line>        dp[<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= amount; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>auto</span>& coin : coins) {</span><br><span class=line>                <span class=keyword>if</span> (coin > i || dp[i - coin] == INT_MAX) {</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                dp[i] = <span class=built_in>min</span>(dp[i - coin] + <span class=number>1</span>,dp[i]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> (dp[amount] == INT_MAX) ? <span class=number>-1</span> : dp[amount];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。<p>假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>change</span><span class=params>(<span class=keyword>int</span> amount, vector<<span class=keyword>int</span>>& coins)</span> </span>{</span><br><span class=line>        <span class=comment>// 方案数</span></span><br><span class=line>        <span class=comment>// 组合 完全背包</span></span><br><span class=line>        <span class=keyword>int</span> n = coins.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(amount + <span class=number>1</span>)</span></span>; <span class=comment>// 凑到金额i的方案数</span></span><br><span class=line>        dp[<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; ++i) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= amount; j++) {</span><br><span class=line>                <span class=keyword>if</span> (j >= coins[i] && dp[j]&LTINT_MAX-dp[j-coins[i]]) {</span><br><span class=line>                    dp[j] += dp[j - coins[i]];</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[amount];</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>change</span><span class=params>(<span class=keyword>int</span> amount, vector<<span class=keyword>int</span>>& coins)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = coins.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// memo[index][target] 存储结果</span></span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>memo</span>(n, vector<<span class=keyword>int</span>>(amount + <span class=number>1</span>, <span class=number>-1</span>));</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(<span class=number>0</span>, amount, coins, memo);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>dfs</span><span class=params>(<span class=keyword>int</span> index, <span class=keyword>int</span> target, vector<<span class=keyword>int</span>>& coins, vector&LTvector<<span class=keyword>int</span>>>& memo)</span> </span>{</span><br><span class=line>        <span class=comment>// 基准情况 1：金额正好凑齐</span></span><br><span class=line>        <span class=keyword>if</span> (target == <span class=number>0</span>) <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 基准情况 2：硬币用完了或者金额过大</span></span><br><span class=line>        <span class=keyword>if</span> (index == coins.<span class=built_in>size</span>() || target < <span class=number>0</span>) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 检查记忆化</span></span><br><span class=line>        <span class=keyword>if</span> (memo[index][target] != <span class=number>-1</span>) <span class=keyword>return</span> memo[index][target];</span><br><span class=line></span><br><span class=line>        <span class=comment>// 决策：</span></span><br><span class=line>        <span class=comment>// 1. 使用当前硬币：dfs(index, target - coins[index])</span></span><br><span class=line>        <span class=comment>// 2. 跳过当前硬币：dfs(index + 1, target)</span></span><br><span class=line>        <span class=keyword>int</span> res = <span class=built_in>dfs</span>(index, target - coins[index], coins, memo) </span><br><span class=line>                + <span class=built_in>dfs</span>(index + <span class=number>1</span>, target, coins, memo);</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> memo[index][target] = res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>解动态规划类问题，分析过程是有章可循的，通过<strong>对阶段、子问题和状态的拆解基本可以得到解决问题的框架</strong>。具体的求解过程一般可以通过推导状态转移方程或填状态转移表这两种方法来实现。<p>动态规划问题通常伴随着滚动数组的技巧，从而在空间上达到更优，这正是其相对于记忆化递归而言最大的优点，还有一个好处是动态规划避免了递归产生的额外调用栈的性能开销。<p>递归调用子问题时会出现很多重复的子问题计算。一个显而易见的想法是将已经计算过的子问题结果保存起来以备后面使用。如此处理之后，在下一次遇到同样的子问题时直接返回结果可以大大地降低计算的时间复杂度。这种解题思路被称为带“记忆”的递归调用（也被称为自顶向下的动态规划）。<p><a href=https://juejin.cn/post/7484471047720206370 rel=noopener target=_blank>动态规划-可重复装背包问题-排列数和组合数理解 2025.3.17完全背包问题中，求组合数是外层遍历物品，内层遍历背包容 - 掘金</a><p><a href=https://www.programmercarl.com/背包理论基础01背包-1.html#思路 rel=noopener target=_blank>动态规划：01背包理论基础 | 代码随想录</a><p><a href=https://blog.csdn.net/theonepiece/article/details/126227234 rel=noopener target=_blank>背包问题总结【0-1背包、完全背包、排列组合问题】_背包问题 排列 组合-CSDN博客</a><h2 id=01背包，完全背包，组合排列与滚动数组><a class=headerlink href=#01背包，完全背包，组合排列与滚动数组 title=01背包，完全背包，组合排列与滚动数组></a>01背包，完全背包，组合排列与滚动数组</h2><p>1 背包问题<ul><li><strong>场景</strong>：有 $N$ 件物品和一个容量为 $W$ 的背包。每件物品<strong>仅有一件</strong>，只有“装（1）”或“不装（0）”两种选择。<li><strong>核心矛盾</strong>：在容量有限的情况下，如何抉择才能让价值最大。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTbits/stdc++.h></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, bagweight;<span class=comment>// bagweight代表行李箱空间</span></span><br><span class=line></span><br><span class=line>    cin >> n >> bagweight;</span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>weight</span><span class=params>(n, <span class=number>0</span>)</span></span>; <span class=comment>// 存储每件物品所占空间</span></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>value</span><span class=params>(n, <span class=number>0</span>)</span></span>;  <span class=comment>// 存储每件物品价值</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < n; ++i) {</span><br><span class=line>        cin >> weight[i];</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> j = <span class=number>0</span>; j < n; ++j) {</span><br><span class=line>        cin >> value[j];</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span></span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(weight.<span class=built_in>size</span>(), vector<<span class=keyword>int</span>>(bagweight + <span class=number>1</span>, <span class=number>0</span>));</span><br><span class=line></span><br><span class=line>    <span class=comment>// 初始化, 因为需要用到dp[i - 1]的值</span></span><br><span class=line>    <span class=comment>// j < weight[0]已在上方被初始化为0</span></span><br><span class=line>    <span class=comment>// j >= weight[0]的值就初始化为value[0]</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j = weight[<span class=number>0</span>]; j <= bagweight; j++) {</span><br><span class=line>        dp[<span class=number>0</span>][j] = value[<span class=number>0</span>];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>; i < weight.<span class=built_in>size</span>(); i++) { <span class=comment>// 遍历科研物品</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> j = <span class=number>0</span>; j <= bagweight; j++) { <span class=comment>// 遍历行李箱容量</span></span><br><span class=line>            <span class=keyword>if</span> (j < weight[i]) dp[i][j] = dp[i - <span class=number>1</span>][j]; <span class=comment>// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span></span><br><span class=line>            <span class=keyword>else</span> {</span><br><span class=line>                dp[i][j] = <span class=built_in>max</span>(dp[i - <span class=number>1</span>][j], dp[i - <span class=number>1</span>][j - weight[i]] + value[i]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    cout << dp[n - <span class=number>1</span>][bagweight] << endl;</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>倒序遍历是为了保证物品i只被放入一次</strong>。如果一旦正序遍历了，那么物品0就会被重复加入多次<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=comment>// 读取 M 和 N</span></span><br><span class=line>    <span class=keyword>int</span> M, N;</span><br><span class=line>    cin >> M >> N;</span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>costs</span><span class=params>(M)</span></span>;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>values</span><span class=params>(M)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < M; i++) {</span><br><span class=line>        cin >> costs[i];</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < M; j++) {</span><br><span class=line>        cin >> values[j];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建一个动态规划数组dp，初始值为0</span></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(N + <span class=number>1</span>, <span class=number>0</span>)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 外层循环遍历每个类型的研究材料</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < M; ++i) {</span><br><span class=line>        <span class=comment>// 内层循环从 N 空间逐渐减少到当前研究材料所占空间</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = N; j >= costs[i]; --j) {</span><br><span class=line>            <span class=comment>// 考虑当前研究材料选择和不选择的情况，选择最大值</span></span><br><span class=line>            dp[j] = <span class=built_in>max</span>(dp[j], dp[j - costs[i]] + values[i]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值</span></span><br><span class=line>    cout << dp[N] << endl;</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>完全背包<ul><li><strong>场景</strong>：基本背景相同，但每种物品都有<strong>无限件</strong>。只要背包装得下，你可以一直拿同一种物品。<li><strong>核心矛盾</strong>：不再是“拿不拿”，而是“拿几个</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, bagWeight;</span><br><span class=line>    <span class=keyword>int</span> w, v;</span><br><span class=line>    cin >> n >> bagWeight;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>weight</span><span class=params>(n)</span></span>;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>value</span><span class=params>(n)</span></span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n; i++) {</span><br><span class=line>        cin >> weight[i] >> value[i];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(n, vector<<span class=keyword>int</span>>(bagWeight + <span class=number>1</span>, <span class=number>0</span>));</span><br><span class=line></span><br><span class=line>    <span class=comment>// 初始化</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j = weight[<span class=number>0</span>]; j <= bagWeight; j++)</span><br><span class=line>        dp[<span class=number>0</span>][j] = dp[<span class=number>0</span>][j - weight[<span class=number>0</span>]] + value[<span class=number>0</span>];</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < n; i++) { <span class=comment>// 遍历物品</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> j = <span class=number>0</span>; j <= bagWeight; j++) { <span class=comment>// 遍历背包容量</span></span><br><span class=line>            <span class=keyword>if</span> (j < weight[i]) dp[i][j] = dp[i - <span class=number>1</span>][j];</span><br><span class=line>            <span class=keyword>else</span> dp[i][j] = <span class=built_in>max</span>(dp[i - <span class=number>1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    cout << dp[n - <span class=number>1</span>][bagWeight] << endl;</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> N, bagWeight;</span><br><span class=line>    cin >> N >> bagWeight;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>weight</span><span class=params>(N, <span class=number>0</span>)</span></span>;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>value</span><span class=params>(N, <span class=number>0</span>)</span></span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < N; i++) {</span><br><span class=line>        <span class=keyword>int</span> w;</span><br><span class=line>        <span class=keyword>int</span> v;</span><br><span class=line>        cin >> w >> v;</span><br><span class=line>        weight[i] = w;</span><br><span class=line>        value[i] = v;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(bagWeight + <span class=number>1</span>, <span class=number>0</span>)</span></span>;</span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> j = <span class=number>0</span>; j <= bagWeight; j++) { <span class=comment>// 遍历背包容量</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < weight.<span class=built_in>size</span>(); i++) { <span class=comment>// 遍历物品</span></span><br><span class=line>            <span class=keyword>if</span> (j - weight[i] >= <span class=number>0</span>) dp[j] = <span class=built_in>max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    cout << dp[bagWeight] << endl;</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>为什么需要滚动数组？<p>在二维状态 $dp[i][j]$ 中，计算第 $i$ 行只依赖于第 $i-1$ 行。因此我们可以只用一个一维数组 $dp[j]$，通过不断“覆盖”旧值来节省空间<p><strong>对于纯完全背包问题，其for循环的先后循环是可以颠倒的</strong><p>求组合数 (Combinations) —— 顺序无关<ul><li><strong>场景</strong>：硬币 <code>{1, 2}</code> 和 <code>{2, 1}</code> 算同一种。<li><strong>秘籍</strong>：<strong>外层遍历物品，内层遍历容量</strong>。<li><p><strong>逻辑</strong>：先算完只用硬币 1 的方案，再往里加硬币 2。这保证了硬币 2 只会出现在硬币 1 之后。</p> <p>求排列数 (Permutations) —— 顺序有关</p><li><p><strong>场景</strong>：硬币 <code>{1, 2}</code> 和 <code>{2, 1}</code> 算两种（比如爬楼梯，先走 1 阶再走 2 阶不同于先 2 后 1）。</p><li><strong>秘籍</strong>：<strong>外层遍历容量，内层遍历物品</strong>。<li><strong>逻辑</strong>：对于每一个容量 $j$，我们都重新尝试所有的硬币。这样在凑出 3 的时候，既可以从 $dp[3-1]$ 转移（最后一步是 1），也可以从 $dp[3-2]$ 转移（最后一步是 2）。</ul><ol><li>物理层：解决“选几次” (01 vs 完全)</ol><p>这主要体现在<strong>内层循环的遍历方向</strong>上。<p><strong>逆序遍历：解决“01 背包”</strong><ul><li><strong>场景</strong>：每个物品只能选 1 次。<li><strong>逻辑</strong>：我们需要用“上一行（即不包含当前物品）”的数据。<li><strong>原因</strong>：因为是从大到小更新，当我们更新 $dp[j]$ 时，$dp[j - weight]$ 还是旧的值，还没有被当前物品污染过。</ul><p><strong>正序遍历：解决“完全背包”</strong><ul><li><strong>场景</strong>：每个物品可以选无限次。<li><strong>逻辑</strong>：我们需要用“当前行（即已经考虑过放入当前物品）”的数据。<li><strong>原因</strong>：从小到大更新，更新 $dp[j]$ 时，$dp[j - weight]$ 可能已经在本轮循环中放入过当前物品了，现在是在它的基础上“再多拿一个”。</ul><ol><li>逻辑层：解决“怎么排” (组合 vs 排列)</ol><p>这主要体现在<strong>内、外层循环谁包着谁</strong>。<p><strong>外层物品，内层容量 $\rightarrow$ 组合 (Combination)</strong><ul><li><p><strong>适用问题</strong>：<code>{1, 5}</code> 和 <code>{5, 1}</code> 算同一种方案。</p><li><p><strong>代表题</strong>：LeetCode 518. 零钱兑换 II。</p><li><p><strong>底层原理</strong>：</p> <p>我们是挨个处理物品的。处理完 1 号硬币，再处理 2 号。这就意味着，在任何一个状态下，硬币的编号只能是递增的。你不可能在放入 2 号硬币后的某个状态里，又跑回去拿 1 号硬币。</p> <blockquote><p><strong>结论</strong>：这种顺序强制去掉了“乱序”的可能性，只留下唯一的一种组合。</blockquote></ul><p><strong>外层容量，内层物品 $\rightarrow$ 排列 (Permutation)</strong><ul><li><p><strong>适用问题</strong>：<code>{1, 5}</code> 和 <code>{5, 1}</code> 算两种不同的方案。</p><li><p><strong>代表题</strong>：LeetCode 377. 组合总和 Ⅳ（虽然叫组合总和，其实求的是排列）。</p><li><p><strong>底层原理</strong>：</p> <p>对于每一个容量 $j$，我们都把所有物品拿出来试一遍。</p> <p>比如容量为 6：</p> <ul><li><p>它可以从 $dp[6-1]$ 走一步 1 过来（最后一步是 1）。</p><li><p>它可以从 $dp[6-5]$ 走一步 5 过来（最后一步是 5）。</p> <p>只要最后一步不同，就是不同的路径。</p></ul> <blockquote><p><strong>结论</strong>：这种顺序允许同一个容量被不同的“最后一步”推导出来，从而计入所有排列。</blockquote></ul><p>极值问题：对顺序“迟钝”<ul><li><strong>适用问题</strong>：求“最少硬币数”或“最大价值”。<li><strong>代表题</strong>：LeetCode 322. 零钱兑换（求最少硬币数）。<li><strong>现象</strong>：你会发现，求最少硬币数时，外层是物品还是容量，代码都能过。<li><strong>原因</strong>：极值问题（$\min / \max$）只关心<strong>最终结果</strong>，不关心你是通过 <code>{1, 5}</code> 还是 <code>{5, 1}</code> 凑出来的。反正它们凑出来的硬币数都是 2，取 $\min$ 的结果是一样的。</ul><p>当你看到一道背包题，请按以下步骤决定你的 <code>for</code> 循环：<div class=table-container><table><thead><tr><th><strong>步骤</strong><th><strong>提问</strong><th><strong>决定</strong><tbody><tr><td><strong>1. 看次数</strong><td>物品只能用一次吗？<td><strong>是</strong>：内层逆序；<strong>否</strong>：内层正序。<tr><td><strong>2. 看性质</strong><td>是求最大价值吗？<td><strong>是</strong>：外层物品/容量皆可，通常选外层物品（逻辑更顺）。<tr><td><strong>3. 看顺序</strong><td>是求方案数且 <code>{1,2} != {2,1}</code> 吗？<td><strong>是</strong>：外层容量，内层物品。<tr><td><strong>4. 看顺序</strong><td>是求方案数且 <code>{1,2} == {2,1}</code> 吗？<td><strong>是</strong>：外层物品，内层容量。</table></div><p><strong>单词拆分</strong><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。<p>定义 <em>dp</em>[<em>i</em>] 表示字符串 <em>s</em> 前 <em>i</em> 个字符组成的字符串 <em>s</em>[0..<em>i</em>−1] 是否能被空格拆分成若干个字典中出现的单词。<p><em>dp</em>[<em>i</em>]=<em>dp</em>[<em>j</em>] && <em>check</em>(<em>s</em>[<em>j</em>..<em>i</em>−1])<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>wordBreak</span><span class=params>(string s, vector&LTstring>& wordDict)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = s.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// dp[j]表示字符串s[0-j]能否被字典中单词拼接</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>dp</span><span class=params>(sz + <span class=number>1</span>)</span></span>;</span><br><span class=line>        dp[<span class=number>0</span>] = <span class=literal>true</span>;</span><br><span class=line>        <span class=function>unordered_set&LTstring> <span class=title>wordSet</span><span class=params>(wordDict.begin(),wordDict.end())</span></span>;</span><br><span class=line>        <span class=comment>// dp[j] = dp[j-word.size()] || word exist</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>;i<=sz;i++) { </span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j = <span class=number>0</span>;j&LTi;j++) {</span><br><span class=line>                string word = s.<span class=built_in>substr</span>(j,i-j);</span><br><span class=line>                <span class=keyword>if</span>(wordSet.<span class=built_in>count</span>(word)) {</span><br><span class=line>                    dp[i] = dp[i] || dp[j];</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[sz];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code> ，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<strong>以任意顺序</strong> 返回所有这些可能的句子。<strong>注意：</strong>词典中的同一个单词可能在分段中被重复使用多次。<p>对于字符串 s，如果某个前缀是单词列表中的单词，则拆分出该单词，然后对 s 的剩余部分继续拆分。如果可以将整个字符串 s 拆分成单词列表中的单词，则得到一个句子。在对 s 的剩余部分拆分得到一个句子之后，将拆分出的第一个单词（即 s 的前缀）添加到句子的头部，即可得到一个完整的句子。上述过程可以通过回溯实现。<p>假设字符串 s 的长度为 n，回溯的时间复杂度在最坏情况下高达 O(n )。时间复杂度高的原因是存在大量重复计算，可以通过记忆化的方式降低时间复杂度。<p>具体做法是，使用哈希表存储字符串 s 的每个下标和从该下标开始的部分可以组成的句子列表，在回溯过程中如果遇到已经访问过的下标，则可以直接从哈希表得到结果，而不需要重复计算。如果到某个下标发现无法匹配，则哈希表中该下标对应的是空列表，因此可以对不能拆分的情况进行剪枝优化。<p>还有一个可优化之处为使用哈希集合存储单词列表中的单词，这样在判断一个字符串是否是单词列表中的单词时只需要判断该字符串是否在哈希集合中即可，而不再需要遍历单词列表<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, vector&LTstring>> memo;</span><br><span class=line>    <span class=function>vector&LTstring> <span class=title>dfs</span><span class=params>(string& s, <span class=keyword>int</span> index, unordered_set&LTstring>& wordSet)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (index == s.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>return</span> {<span class=string>""</span>};</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(index)) {</span><br><span class=line>            <span class=keyword>return</span> memo[index];</span><br><span class=line>        }</span><br><span class=line>        vector&LTstring> res;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = index; j < s.<span class=built_in>size</span>(); j++) {</span><br><span class=line>            string str = s.<span class=built_in>substr</span>(index, j - index + <span class=number>1</span>);</span><br><span class=line>            <span class=keyword>if</span> (wordSet.<span class=built_in>count</span>(str)) {</span><br><span class=line>                <span class=keyword>auto</span> ans = <span class=built_in>dfs</span>(s, j + <span class=number>1</span>, wordSet);</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>auto</span>& sstr : ans) {</span><br><span class=line>                    <span class=keyword>if</span> (sstr == <span class=string>""</span>) {</span><br><span class=line>                        res.<span class=built_in>push_back</span>(str);</span><br><span class=line>                    } <span class=keyword>else</span> {</span><br><span class=line>                        res.<span class=built_in>push_back</span>(str + <span class=string>" "</span> + sstr);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        memo[index] = res;</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>vector&LTstring> <span class=title>wordBreak</span><span class=params>(string s, vector&LTstring>& wordDict)</span> </span>{</span><br><span class=line>        <span class=function>unordered_set&LTstring> <span class=title>wordSet</span><span class=params>(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(s, <span class=number>0</span>, wordSet);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>股票系列</strong><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=comment>// 最大值减去最小值</span></span><br><span class=line>        <span class=keyword>int</span> min_price{INT_MAX};</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>;i&LTprices.<span class=built_in>size</span>();i++) {</span><br><span class=line>            min_price = <span class=built_in>min</span>(min_price,prices[i]);</span><br><span class=line>            ans = <span class=built_in>max</span>(prices[i] - min_price,ans);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>每次遍历，相对于比较当前价格与其前边的每个价格来寻找最大差值max_diff，我们只需要对比前面出现过的那个最小值即可。定义并使用变量min_price来保存遇到的最小价格，将循环内操作的时间复杂度降低至常数阶，算法的总体时间复杂度也就降至为O(n)。<p>一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。然而，你可以在 <strong>同一天</strong> 多次买卖该股票，但要确保你持有的股票不超过一股。返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = prices.<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(sz, vector<<span class=keyword>int</span>>(<span class=number>2</span>));</span><br><span class=line>        <span class=comment>// dp[i][0]表示当前不持有的最大利润</span></span><br><span class=line>        <span class=comment>// dp[i][1]表示当前持有的最大利润</span></span><br><span class=line>        dp[<span class=number>0</span>][<span class=number>1</span>] = -prices[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < sz; i++) {</span><br><span class=line>            <span class=comment>// 卖出</span></span><br><span class=line>            dp[i][<span class=number>0</span>] = <span class=built_in>max</span>(dp[i - <span class=number>1</span>][<span class=number>0</span>], prices[i] + dp[i - <span class=number>1</span>][<span class=number>1</span>]);</span><br><span class=line>            <span class=comment>// 买入</span></span><br><span class=line>            dp[i][<span class=number>1</span>] = <span class=built_in>max</span>(dp[i - <span class=number>1</span>][<span class=number>1</span>], -prices[i] + dp[i - <span class=number>1</span>][<span class=number>0</span>]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[sz - <span class=number>1</span>][<span class=number>0</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1][0] 和 dp[i−1][1] 存放在两个变量中，通过它们计算出 dp[i][0] 和 dp[i][1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = prices.<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(sz, vector<<span class=keyword>int</span>>(<span class=number>2</span>));</span><br><span class=line>        <span class=comment>// dp[i][0]表示当前不持有的最大利润</span></span><br><span class=line>        <span class=comment>// dp[i][1]表示当前持有的最大利润</span></span><br><span class=line>        <span class=keyword>int</span> soldPrice{};</span><br><span class=line>        <span class=keyword>int</span> buyPrice = -prices[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < sz; i++) {</span><br><span class=line>            <span class=keyword>int</span> tmp = soldPrice;</span><br><span class=line>            <span class=comment>// 卖出</span></span><br><span class=line>            soldPrice = <span class=built_in>max</span>(soldPrice,buyPrice+prices[i]);</span><br><span class=line>            <span class=comment>// dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]);</span></span><br><span class=line>            <span class=comment>// 买入</span></span><br><span class=line>            buyPrice = <span class=built_in>max</span>(buyPrice,-prices[i]+tmp);</span><br><span class=line>            <span class=comment>// dp[i][1] = max(dp[i - 1][1], -prices[i] + dp[i - 1][0]);</span></span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> soldPrice;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。<p>考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益，但需要支付 fee 的手续费。因此为了收益最大化，我们列出如下的转移方程：<p>dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]−fee}<br>再来按照同样的方式考虑 dp[i][1] 按状态转移，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程：<p>dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}<br>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候有 dp[0][0]=0 以及 dp[0][1]=−prices[0]。<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices, <span class=keyword>int</span> fee)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = prices.<span class=built_in>size</span>();</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(n, vector<<span class=keyword>int</span>>(<span class=number>2</span>));</span><br><span class=line>        dp[<span class=number>0</span>][<span class=number>0</span>] = <span class=number>0</span>, dp[<span class=number>0</span>][<span class=number>1</span>] = -prices[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < n; ++i) {</span><br><span class=line>            dp[i][<span class=number>0</span>] = <span class=built_in>max</span>(dp[i - <span class=number>1</span>][<span class=number>0</span>], dp[i - <span class=number>1</span>][<span class=number>1</span>] + prices[i] - fee);</span><br><span class=line>            dp[i][<span class=number>1</span>] = <span class=built_in>max</span>(dp[i - <span class=number>1</span>][<span class=number>1</span>], dp[i - <span class=number>1</span>][<span class=number>0</span>] - prices[i]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[n - <span class=number>1</span>][<span class=number>0</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=comment>//注意到在状态转移方程中，dp[i][0] 和 dp[i][1] 只会从 dp[i−1][0] 和 dp[i−1][1] 转移而来，因此我们不必使用数组存储所有的状态，而是使用两个变量 sell 以及 buy 分别表示 dp[..][0] 和 dp[..][1] 直接进行状态转移即可。</span></span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices, <span class=keyword>int</span> fee)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = prices.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// vector&LTint> buyPrice(sz);</span></span><br><span class=line>        <span class=keyword>int</span> soldPrice{};</span><br><span class=line>        <span class=keyword>int</span> buyPrice = -prices[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i =<span class=number>1</span>;i&LTprices.<span class=built_in>size</span>();i++) {</span><br><span class=line>            <span class=comment>// 状态压缩</span></span><br><span class=line>            <span class=keyword>int</span> newSoldPrice = <span class=built_in>max</span>(soldPrice,buyPrice-fee+prices[i]);</span><br><span class=line>            <span class=keyword>int</span> newBuyPrice = <span class=built_in>max</span>(buyPrice,soldPrice-prices[i]);</span><br><span class=line>            soldPrice = newSoldPrice;</span><br><span class=line>            buyPrice = newBuyPrice;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> soldPrice;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz= prices.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// vector&LTvector&LTint>> dp(sz,vector&LTint>(3));</span></span><br><span class=line>        <span class=keyword>int</span> dp0{},dp1{},dp2{};</span><br><span class=line>        <span class=comment>// dp[i][0] 买入状态</span></span><br><span class=line>        <span class=comment>// dp[i][1] 卖出状态 不包括冷冻期</span></span><br><span class=line>        <span class=comment>// dp[i][2] 冷冻期</span></span><br><span class=line>        dp0 = -prices[<span class=number>0</span>];</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>;i&LTsz;i++) {</span><br><span class=line>            <span class=comment>// 买入状态可由 买入或者冷冻期转换</span></span><br><span class=line>            <span class=comment>// dp[i][0] = max(dp[i-1][0],dp[i-1][2]-prices[i]);</span></span><br><span class=line>            <span class=keyword>int</span> newDp0 = <span class=built_in>max</span>(dp0,dp2-prices[i]);</span><br><span class=line>            <span class=keyword>int</span> newDp1 = <span class=built_in>max</span>(dp1,dp0+prices[i]);</span><br><span class=line>            <span class=keyword>int</span> newDp2 = dp1;</span><br><span class=line>            dp0 = newDp0;</span><br><span class=line>            dp1 = newDp1;</span><br><span class=line>            dp2 = newDp2;</span><br><span class=line>            <span class=comment>// 卖出状态可由买入或者卖出转换</span></span><br><span class=line>            <span class=comment>// dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);</span></span><br><span class=line>            <span class=comment>// 冷冻期收益就是前一天卖出时收益</span></span><br><span class=line>            <span class=comment>// dp[i][2] = dp[i-1][1];</span></span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>max</span>(dp1,dp2);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。<strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(<span class=keyword>int</span> k, vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (prices.<span class=built_in>empty</span>()) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> n = prices.<span class=built_in>size</span>();</span><br><span class=line>        k = <span class=built_in>min</span>(k, n / <span class=number>2</span>);</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>buy</span>(n, vector<<span class=keyword>int</span>>(k + <span class=number>1</span>, <span class=number>-1e9</span>));</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>sell</span>(n, vector<<span class=keyword>int</span>>(k + <span class=number>1</span>, <span class=number>-1e9</span>));</span><br><span class=line>        <span class=keyword>if</span> (k >= <span class=number>1</span>) {</span><br><span class=line>            buy[<span class=number>0</span>][<span class=number>1</span>] = -prices[<span class=number>0</span>];</span><br><span class=line>        }</span><br><span class=line>        sell[<span class=number>0</span>][<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < n; ++i) {</span><br><span class=line>            sell[i][<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= k; ++j) {</span><br><span class=line>                buy[i][j] = <span class=built_in>max</span>(buy[i - <span class=number>1</span>][j], sell[i - <span class=number>1</span>][j - <span class=number>1</span>] - prices[i]);</span><br><span class=line>                sell[i][j] = <span class=built_in>max</span>(sell[i - <span class=number>1</span>][j], buy[i - <span class=number>1</span>][j] + prices[i]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>       <span class=comment>// 最终结果在最后一天完成各种交易次数中的最大值</span></span><br><span class=line>        <span class=keyword>return</span> *<span class=built_in>max_element</span>(sell[n - <span class=number>1</span>].<span class=built_in>begin</span>(), sell[n - <span class=number>1</span>].<span class=built_in>end</span>());</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><p>每一笔交易都包含“买入”和“卖出”两个动作。对于最多 $k$ 次交易，我们在每一天可能处于以下 $2k$ 种状态之一：<ul><li><strong><code>buy[j]</code></strong>：第 $j$ 次持有股票（已经买入，还没卖出）。<li><strong><code>sell[j]</code></strong>：第 $j$ 次卖出股票（手里是空的，且已经完成了 $j$ 次交易）。</ul><p>这里 $j$ 的取值范围是 $1$ 到 $k$。<p>对于每一天的价格 <code>price</code>，我们要更新这 $2k$ 个状态：<ol><li><p><strong>第 $j$ 次持有 (<code>buy[j]</code>)</strong>：</p> <ul><li>保持现状：昨天就持有第 $j$ 次的股票。<li>今天买入：由<strong>上一次交易完成</strong>的状态 <code>sell[j-1]</code> 减去今天的价格。<li>公式：<code>buy[j] = max(buy[j], sell[j-1] - price)</code></ul><li><p><strong>第 $j$ 次卖出 (<code>sell[j]</code>)</strong>：</p> <ul><li>保持现状：昨天就已经完成了第 $j$ 次交易。<li>今天卖出：由<strong>本次持有</strong>的状态 <code>buy[j]</code> 加上今天的价格。<li>公式：<code>sell[j] = max(sell[j], buy[j] + price)</code></ul> <p>核心思维是一致的：用状态记录你的“处境”，用转移方程描述“动作”。</p></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(<span class=keyword>int</span> k, vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = prices.<span class=built_in>size</span>() ;</span><br><span class=line>        k = <span class=built_in>min</span>(k, sz/<span class=number>2</span>);</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>buy</span><span class=params>(k + <span class=number>1</span>, INT_MIN)</span></span>;</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>sell</span><span class=params>(k + <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < sz; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= k; j++) {</span><br><span class=line>                buy[j] = <span class=built_in>max</span>(sell[j - <span class=number>1</span>] - prices[i], buy[j]);</span><br><span class=line>                sell[j] = <span class=built_in>max</span>(prices[i] + buy[j], sell[j]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> sell[k];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。<strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = prices.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> buy1 = -prices[<span class=number>0</span>], sell1 = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>int</span> buy2 = -prices[<span class=number>0</span>], sell2 = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < n; ++i) {</span><br><span class=line>            buy1 = <span class=built_in>max</span>(buy1, -prices[i]);</span><br><span class=line>            sell1 = <span class=built_in>max</span>(sell1, buy1 + prices[i]);</span><br><span class=line>            buy2 = <span class=built_in>max</span>(buy2, sell1 - prices[i]);</span><br><span class=line>            sell2 = <span class=built_in>max</span>(sell2, buy2 + prices[i]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> sell2;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maxProfit</span><span class=params>(vector<<span class=keyword>int</span>>& prices)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>buy</span><span class=params>(<span class=number>3</span>, INT_MIN)</span></span>;</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>sell</span><span class=params>(<span class=number>3</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < prices.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= <span class=number>2</span>; j++) {</span><br><span class=line>                buy[j] = <span class=built_in>max</span>(buy[j], -prices[i] + sell[j - <span class=number>1</span>]);</span><br><span class=line>                sell[j] = <span class=built_in>max</span>(sell[j], prices[i] + buy[j]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> sell[<span class=number>2</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给你两个下标从 <strong>0</strong> 开始的数组 <code>present</code> 和 <code>future</code> ，<code>present[i]</code> 和 <code>future[i]</code> 分别代表第 <code>i</code> 支股票现在和将来的价格。每支股票你最多购买 <strong>一次</strong> ，你的预算为 <code>budget</code> 。求最大的收益。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>maximumProfit</span><span class=params>(vector<<span class=keyword>int</span>>& present, vector<<span class=keyword>int</span>>& future, <span class=keyword>int</span> budget)</span> </span>{</span><br><span class=line>        <span class=comment>// 0/1背包问题</span></span><br><span class=line>        <span class=comment>// 容量为i时最大收益</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(budget+<span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> sz = present.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>value</span><span class=params>(sz)</span></span>;</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i =<span class=number>0</span>;i&LTsz;i++) {</span><br><span class=line>            value[i] = future[i] - present[i];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>;i&LTsz;i++) {</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j = budget;j>=<span class=number>0</span>;j--) {</span><br><span class=line>                <span class=keyword>if</span>(j>=present[i]) {</span><br><span class=line>                    dp[j] = <span class=built_in>max</span>(dp[j],dp[j-present[i]]+value[i]);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[budget];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>当股票收益最大时，应购买哪些股票？如果有多种方案，返回其中任意一种。<p>要找出具体的股票清单（路径回溯），我们不能直接使用状态压缩后的一维数组，因为一维数组丢弃了“这个最优值是从哪个物品转移过来”的信息。我们需要使用 <strong>二维数组 <code>dp[i][j]</code></strong>。<h4 id=回溯算法：><a class=headerlink href=#回溯算法： title=回溯算法：></a>回溯算法：</h4><ol><li><p>从最后一支股票 $n$ 和总预算 <code>budget</code> 开始。</p><li><p>如果 $dp[i][j] == dp[i-1][j]$，说明第 $i$ 支股票<strong>没买</strong>，继续检查 $dp[i-1][j]$。</p><li><p>如果 $dp[i][j] \neq dp[i-1][j]$，说明第 $i$ 支股票<strong>买了</strong>，记录下标 $i$，然后剩余预算变为 $j - \text{present}[i]$，继续检查 $dp[i-1][j - \text{present}[i]]$。</p><li><p>```c++<br>class Solution {<br>public:</p> <pre><code>pair&LTint, vector&LTint>> getStocks(vector&LTint>& present, vector&LTint>& future, int budget) {
    int n = present.size();
    // dp[i][j] 表示前 i 支股票在预算 j 下的最大收益
    vector&LTvector&LTint>> dp(n + 1, vector&LTint>(budget + 1, 0));

    for (int i = 1; i <= n; ++i) {
        int cost = present[i-1];
        int profit = max(0, future[i-1] - present[i-1]);
        for (int j = 0; j <= budget; ++j) {
            if (j >= cost) {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - cost] + profit);
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }

    // 回溯找出购买的股票下标
    vector&LTint> selectedStocks;
    int curBudget = budget;
    for (int i = n; i >= 1; --i) {
        // 如果当前最大收益不等于“不买这支股票时的收益”，说明买了
        if (dp[i][curBudget] > dp[i-1][curBudget]) {
            selectedStocks.push_back(i - 1); // 存入下标
            curBudget -= present[i-1];
        }
    }

    return {dp[n][budget], selectedStocks};
}
</code></pre><p>};</p> <figure class="highlight reasonml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line></span><br><span class=line>   </span><br><span class=line></span><br><span class=line># 滑动窗口</span><br><span class=line></span><br><span class=line>滑动窗口是双指针的特殊应用，该题型本身并不复杂，但有些具体细节需要注意。滑动窗口常用于解决数组、字符串的子元素问题，它可以将嵌套的循环展开，通过减少内层循环次数来降低算法的时间复杂度。滑动窗口类题目通常需要用到双指针，还可能用到其他的数据结构，比如哈希表、队列。</span><br><span class=line></span><br><span class=line>按照滑动窗口的窗口大小是否固定，以及可变窗口中求最大窗口还是最小窗口，可以分类如下。</span><br><span class=line></span><br><span class=line>●　固定窗口类型</span><br><span class=line></span><br><span class=line>●　可变窗口类型。此类题目不会给出窗口大小，而是求符合条件的最大窗口或最小窗口。</span><br><span class=line></span><br><span class=line>➢　求最大窗口。例如第<span class=number>424</span>题。</span><br><span class=line></span><br><span class=line>➢　求最小窗口。例如第<span class=number>72</span>题。</span><br><span class=line></span><br><span class=line>通常会使用双指针来界定窗口的边界，两个指针之间的部分属于窗口内，反之属于窗口外。固定窗口类型的题目，两个指针要同时移动；而可变窗口类型的题目，则移动其中一个指针来实现窗口大小的变化。</span><br><span class=line></span><br><span class=line>滑动窗口类型的题目是有“套路”可循的，用两个指针分别表示窗口的左右端点，然后右指针不断地去扩充右侧窗口边界，左指针不断地缩小左边窗口边界，同时维护窗口的信息，在这个过程中不断判断窗口信息是否满足条件，如果是，则更新答案；如果不是，则继续移动窗口（收缩、扩展或平移）。</span><br><span class=line></span><br><span class=line>**滑动窗口最大值**</span><br><span class=line></span><br><span class=line>给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。</span><br><span class=line></span><br><span class=line>返回 *滑动窗口中的最大值*</span><br><span class=line></span><br><span class=line>```c++</span><br><span class=line><span class=keyword>class</span> Solution {</span><br><span class=line>public:</span><br><span class=line>    vector<<span class=built_in>int</span>> max<span class=constructor>SlidingWindow(<span class=params>vector</span><<span class=params>int</span>>& <span class=params>nums</span>, <span class=params>int</span> <span class=params>k</span>)</span> {</span><br><span class=line>        <span class=comment>// 固定窗口</span></span><br><span class=line>        <span class=comment>// 每次加入一个值 删除一个值</span></span><br><span class=line>        vector<<span class=built_in>int</span>> res;</span><br><span class=line>        <span class=built_in>list</span><<span class=built_in>int</span>> lst; <span class=comment>// 维护最大值</span></span><br><span class=line>        <span class=built_in>int</span> sz = nums.size<span class=literal>()</span>;</span><br><span class=line>        <span class=keyword>for</span>(<span class=built_in>int</span> i = <span class=number>0</span>;i&LTk;i++) {</span><br><span class=line>            <span class=keyword>while</span>(!lst.empty<span class=literal>()</span><span class=operator> && </span>nums<span class=literal>[<span class=identifier>i</span>]</span>>lst.back<span class=literal>()</span>) {</span><br><span class=line>                lst.pop<span class=constructor>_back()</span>;</span><br><span class=line>            }</span><br><span class=line>            lst.push<span class=constructor>_back(<span class=params>nums</span>[<span class=params>i</span>])</span>;</span><br><span class=line>        }</span><br><span class=line>        res.push<span class=constructor>_back(<span class=params>lst</span>.<span class=params>front</span>()</span>);</span><br><span class=line>        <span class=keyword>for</span>(<span class=built_in>int</span> i = k;i&LTsz;i++) {</span><br><span class=line>            <span class=keyword>while</span>(!lst.empty<span class=literal>()</span><span class=operator> && </span>nums<span class=literal>[<span class=identifier>i</span>]</span>>lst.back<span class=literal>()</span>) {</span><br><span class=line>                lst.pop<span class=constructor>_back()</span>;</span><br><span class=line>            }</span><br><span class=line>            lst.push<span class=constructor>_back(<span class=params>nums</span>[<span class=params>i</span>])</span>;</span><br><span class=line>            <span class=keyword>if</span>(nums<span class=literal>[<span class=identifier>i</span>-<span class=identifier>k</span>]</span><span class=operator> == </span>lst.front<span class=literal>()</span>) {</span><br><span class=line>                lst.pop<span class=constructor>_front()</span>;</span><br><span class=line>            }</span><br><span class=line>            res.push<span class=constructor>_back(<span class=params>lst</span>.<span class=params>front</span>()</span>);</span><br><span class=line>        }</span><br><span class=line>        return res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure></ol><p><strong>最小覆盖子串</strong><p>给定两个字符串 <code>s</code> 和 <code>t</code>，长度分别是 <code>m</code> 和 <code>n</code>，返回 s 中的 <strong>最短窗口 子串</strong>，使得该子串包含 <code>t</code> 中的每一个字符（<strong>包括重复字符</strong>）。如果没有这样的子串，返回空字符串 <code>""</code>。<p>测试用例保证答案唯一。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>minWindow</span><span class=params>(string s, string t)</span> </span>{</span><br><span class=line>        unordered_map<<span class=keyword>char</span>, <span class=keyword>int</span>> cnts;</span><br><span class=line>        <span class=keyword>int</span> targetCnt{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : t) {</span><br><span class=line>            cnts[ch]++;</span><br><span class=line>            targetCnt++;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 计算窗口内有效字符</span></span><br><span class=line>        <span class=keyword>int</span> slen{INT_MAX};</span><br><span class=line>        <span class=keyword>int</span> start_pos{};</span><br><span class=line>        <span class=keyword>int</span> totalCnt{};</span><br><span class=line>        <span class=keyword>int</span> left{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (cnts.<span class=built_in>count</span>(s[i])) {</span><br><span class=line>                <span class=comment>// 还有剩余字符</span></span><br><span class=line>                <span class=keyword>if</span> (cnts[s[i]] >= <span class=number>1</span>) {</span><br><span class=line>                    <span class=comment>// 剩余字符个数大于0，有效字符+1</span></span><br><span class=line>                    totalCnt++;</span><br><span class=line>                }</span><br><span class=line>                cnts[s[i]]--;</span><br><span class=line>                <span class=keyword>while</span> (left <= i && totalCnt == targetCnt) {</span><br><span class=line>                    <span class=keyword>int</span> len = i - left + <span class=number>1</span>;</span><br><span class=line>                    <span class=keyword>if</span> (len < slen) {</span><br><span class=line>                        start_pos = left;</span><br><span class=line>                        slen = len;</span><br><span class=line>                    }</span><br><span class=line>                    <span class=keyword>if</span> (cnts.<span class=built_in>count</span>(s[left])) {</span><br><span class=line>                        <span class=keyword>if</span> (cnts[s[left]] >= <span class=number>0</span>) {</span><br><span class=line>                            totalCnt--;</span><br><span class=line>                        }</span><br><span class=line>                        cnts[s[left]]++;</span><br><span class=line>                    }</span><br><span class=line>                    left++;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> INT_MAX == slen ? <span class=string>""</span> : s.<span class=built_in>substr</span>(start_pos, slen);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>替换后的最长重复字符</strong><p>你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。在执行上述操作后，返回 <em>包含相同字母的最长子字符串的长度</em><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>characterReplacement</span><span class=params>(string s, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=comment>// 可以跳过k次</span></span><br><span class=line>        unordered_map<<span class=keyword>char</span>, <span class=keyword>int</span>> cnts;</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>int</span> left{};</span><br><span class=line>        <span class=keyword>int</span> max_cnt{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            cnts[s[i]]++;</span><br><span class=line>            max_cnt = <span class=built_in>max</span>(max_cnt, cnts[s[i]]);</span><br><span class=line>            <span class=keyword>while</span>(left<=i && i-left+<span class=number>1</span>>max_cnt+k) {</span><br><span class=line>                <span class=comment>//移动左窗口  不满足要求</span></span><br><span class=line>                cnts[s[left]]--;</span><br><span class=line>                left++;</span><br><span class=line>            }</span><br><span class=line>            ans = <span class=built_in>max</span>(ans,i-left+<span class=number>1</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>字符串的排列</strong><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的 排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong><p>此问题的关键点是，如果能在S2中找到一个子串的长度与S1相等，并且S1中每个字符对应的个数与S2中这个子串的每个字符对应的个数相等，那S2就一定包含S1的一个排列。因此可以使用与S1等长的滑动窗口，判断S2在这个窗口内的字符出现个数和S1的字符出现个数是否相等。又因为题目中给出了条件，所有的字符都是小写字母，因此可以通过哈希表来统计每个字符出现的个数。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>checkInclusion</span><span class=params>(string s1, string s2)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = s1.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span>(sz>s2.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>cnts</span><span class=params>(<span class=number>26</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : s1) {</span><br><span class=line>            cnts[ch - <span class=string>'a'</span>]++;</span><br><span class=line>        }</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>targets</span><span class=params>(<span class=number>26</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s1.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            targets[s2[i] - <span class=string>'a'</span>]++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (targets == cnts) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = sz; i < s2.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            targets[s2[i] - <span class=string>'a'</span>]++;</span><br><span class=line>            targets[s2[i - sz] - <span class=string>'a'</span>]--;</span><br><span class=line>            <span class=keyword>if</span> (targets == cnts) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>滑动窗口大多用于解决数组、字符串、链表的子区间题型，如果题目中出现求解子数组、子串，或者寻找符合某个特征的子数组、子串问题，就可以考虑使用滑动窗口的方法。滑动窗口问题的优化思路主要包括：是否可以通过某个条件来缩减检测的子序列个数；是否可以通过使用特定的数据结构（如字典）来降低检测子序列的某个特征是否符合条件的复杂度。其中，缩减子序列的方法包括改变序列的大小、边界的提前退出等。<p><img alt=image-20260218195651652 data-src=https://files.seeusercontent.com/2026/02/18/jy3S/image-20260218195651652.png><h1 id=博弈问题><a class=headerlink href=#博弈问题 title=博弈问题></a>博弈问题</h1><p><strong>石子游戏</strong><p>lice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code> 。游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。<p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 <code>true</code> ，当 Bob 赢得比赛时返回 <code>false</code><figure class="highlight kotlin"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>return</span> <span class=literal>true</span>;</span><br></pre></table></figure><p><strong>预测赢家</strong><p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。<p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>predictTheWinner</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// dp[i][j]表示还剩nums[i-j]时最大差异</span></span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(n,vector<<span class=keyword>int</span>>(n));</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = n<span class=number>-2</span>;i>=<span class=number>0</span>;i--) {</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j = i;j&LTn;j++) {</span><br><span class=line>                <span class=keyword>if</span>(j == i) {</span><br><span class=line>                    dp[i][j] = nums[i];</span><br><span class=line>                }<span class=keyword>else</span>{</span><br><span class=line>                    dp[i][j] = <span class=built_in>max</span>(nums[i] - dp[i+<span class=number>1</span>][j],nums[j] - dp[i][j<span class=number>-1</span>]);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[<span class=number>0</span>][n<span class=number>-1</span>]>=<span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>猜数字游戏</strong><p>我们正在玩一个猜数游戏，游戏规则如下：<ol><li>我从 <code>1</code> 到 <code>n</code> 之间选择一个数字。<li>你来猜我选了哪个数字。<li>如果你猜到正确的数字，就会 <strong>赢得游戏</strong> 。<li>如果你猜错了，那么我会告诉你，我选的数字比你的 <strong>更大或者更小</strong> ，并且你需要继续猜数。<li>每当你猜了数字 <code>x</code> 并且猜错了的时候，你需要支付金额为 <code>x</code> 的现金。如果你花光了钱，就会 <strong>输掉游戏</strong> 。</ol><p>给你一个特定的数字 <code>n</code> ，返回能够 <strong>确保你获胜</strong> 的最小现金数，<strong>不管我选择那个数字</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getMoneyAmount</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>dp</span>(<span class=number>1</span> + n, vector<<span class=keyword>int</span>>(<span class=number>1</span> + n));</span><br><span class=line>        <span class=comment>// dp[i][j]</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = n - <span class=number>1</span>; i >= <span class=number>1</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span> + i; j <= n; j++) {</span><br><span class=line>                dp[i][j] = j+dp[i][j<span class=number>-1</span>];</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>int</span> k = i; k < j; k++) {</span><br><span class=line>                    dp[i][j] =</span><br><span class=line>                        <span class=built_in>min</span>(dp[i][j], k + <span class=built_in>max</span>(dp[i][k - <span class=number>1</span>], dp[k + <span class=number>1</span>][j]));</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[<span class=number>1</span>][n];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>实现方面，创建行数和列数都是 n+1 的二维数组 f，其中 f[i][j] 即为状态 f(i,j)。在根据状态转移方程计算时需要注意下标的边界问题，当 j=n 时，如果 k=j 则 k+1>n，此时 f[k][j] 会出现下标越界。为了避免出现下标越界，计算 f[i][j] 的方法是：首先令 f[i][j]=j+f[i][j−1]，然后遍历 i≤k&LTj 的每个 k，更新 f[i][j] 的值。<p><img alt=image-20260219112111053 data-src=https://files.seeusercontent.com/2026/02/19/oZg6/image-20260219112111053.png><h1 id=分治法><a class=headerlink href=#分治法 title=分治法></a>分治法</h1><p>分治法是一种很重要的算法，属于五大常用算法之一。其字面意思是“分而治之”，具体可以分为3个步骤。　<p>“分”指的是将一个复杂的问题分成多个性质相同但规模更小的子问题，而子问题同样能够继续分解直到能够被解决。　<ol><li>“治”指的是对子问题分别进行处理。</ol><p>“合”就是将子问题的解进行合并，从而得到原问题的解。<p>与动态规划一样，分治法很大程度上也基于递归的思想，两者的区别在于动态规划分解后的子问题是有重复的（重叠子问题性质），而分治法的子问题通常不会重复。因此，分治法所能解决的问题一般具有以下几个特征。1．问题的规模缩小到一定程度后可以被很容易地解决。<p>2．问题可以分解为若干个规模较小的相同性质的问题。<p>3．问题的解等于子问题解的合并。<p>4．问题分解的各个子问题相互独立，没有重复。<p>上述前3点决定了问题能否通过分治法来解决。而最后一点涉及分治法的效率，原因在于如果各个子问题不相互独立，则会产生重复的工作，此时虽然可以使用分治法，但使用动态规划效率会更高。<p>下面我们列出常见的可以使用分治法的经典问题<p>●　二分搜索。<p>●　大整数的乘法。<p>核心思路（分→治→合）<p>传统大数乘法（逐位相乘再相加）时间复杂度是 O(n2)，而 Karatsuba 算法通过分治将复杂度降到 O(nlog23)≈O(n1.585)，核心步骤：<ol><li><p>分（Divide）</p> <p>设两个 n 位大数 x和 y，拆分为高位和低位：x = a <em> 10^(n/2) + b，y = c </em> 10^(n/2) + d</p> <p>（比如 x=1234，拆为 a=12，b=34；y=5678，拆为 c=56，d=78）</p><li><p>治（Conquer）</p> <p>递归计算 3 个子问题（而非传统的 4 个，这是优化核心）：</p> <ul><li><code>ac = 分治乘法(a, c)</code><li><code>bd = 分治乘法(b, d)</code><li>ad_bc = 分治乘法(a+b, c+d) - ac - bd</ul><li><p>合（Combine）</p> <p>原结果 = ac <em> 10^n + ad_bc </em> 10^(n/2) + bd</p></ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>def</span> <span class=title>karatsuba</span>(<span class=params>x: <span class=built_in>int</span>, y: <span class=built_in>int</span></span>) -> <span class=built_in>int</span>:</span></span><br><span class=line>    <span class=comment># 基准情况：数字足够小时直接相乘</span></span><br><span class=line>    <span class=keyword>if</span> x < <span class=number>10</span> <span class=keyword>or</span> y < <span class=number>10</span>:</span><br><span class=line>        <span class=keyword>return</span> x * y</span><br><span class=line>    </span><br><span class=line>    <span class=comment># 确定拆分的位数（取两个数的最大位数的一半）</span></span><br><span class=line>    n = <span class=built_in>max</span>(<span class=built_in>len</span>(<span class=built_in>str</span>(x)), <span class=built_in>len</span>(<span class=built_in>str</span>(y)))</span><br><span class=line>    half = n // <span class=number>2</span></span><br><span class=line>    </span><br><span class=line>    <span class=comment># 拆分x和y为高位a/b，低位c/d</span></span><br><span class=line>    a, b = <span class=built_in>divmod</span>(x, <span class=number>10</span>**half)</span><br><span class=line>    c, d = <span class=built_in>divmod</span>(y, <span class=number>10</span>**half)</span><br><span class=line>    </span><br><span class=line>    <span class=comment># 递归计算3个子问题</span></span><br><span class=line>    ac = karatsuba(a, c)</span><br><span class=line>    bd = karatsuba(b, d)</span><br><span class=line>    ad_bc = karatsuba(a + b, c + d) - ac - bd</span><br><span class=line>    </span><br><span class=line>    <span class=comment># 合并结果</span></span><br><span class=line>    <span class=keyword>return</span> ac * <span class=number>10</span>**(<span class=number>2</span>*half) + ad_bc * <span class=number>10</span>**half + bd</span><br></pre></table></figure><p>●　strassen矩阵乘法。<p><img alt=image-20260223131535419 data-src=https://files.seeusercontent.com/2026/02/23/8Lrb/image-20260223131535419.png><p>●　棋盘覆盖问题。●　归并排序和快速排序。●　最接近点对问题。●　汉诺塔问题。<p><strong>合并K个升序链表</strong><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表.<p>用分治的方法进行合并。<p>将 k 个链表配对并将同一对中的链表合并；<br>第一轮合并以后， k 个链表被合并成了 k/2个链表,然后是k/4个链表等等.<p>核心逻辑：<ul><li>将 <code>lists</code> 分为左右两半。<li>递归处理左半部分，递归处理右半部分。<li>最后调用“合并两个有序链表”的函数将两部分合并</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>mergeTwoLists</span><span class=params>(ListNode* node1, ListNode* node2)</span> </span>{</span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        ListNode* cur = dummy;</span><br><span class=line>        <span class=keyword>while</span> (node1 && node2) {</span><br><span class=line>            <span class=keyword>if</span> (node1->val < node2->val) {</span><br><span class=line>                cur->next = node1;</span><br><span class=line>                node1 = node1->next;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                cur->next = node2;</span><br><span class=line>                node2 = node2->next;</span><br><span class=line>            }</span><br><span class=line>            cur = cur->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (node1) {</span><br><span class=line>            cur->next = node1;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (node2) {</span><br><span class=line>            cur->next = node2;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>ListNode* <span class=title>mergeLists</span><span class=params>(<span class=keyword>int</span> left, <span class=keyword>int</span> right, vector&LTListNode*>& lists)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (left > right) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (left == right) {</span><br><span class=line>            <span class=keyword>return</span> lists[left];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>        ListNode* l1 = <span class=built_in>mergeLists</span>(left, mid, lists);</span><br><span class=line>        ListNode* l2 = <span class=built_in>mergeLists</span>(mid + <span class=number>1</span>, right, lists);</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>mergeTwoLists</span>(l1, l2);</span><br><span class=line>    }</span><br><span class=line>    <span class=function>ListNode* <span class=title>mergeKLists</span><span class=params>(vector&LTListNode*>& lists)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = lists.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span> (sz == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        ListNode* res = <span class=built_in>mergeLists</span>(<span class=number>0</span>, sz - <span class=number>1</span>, lists);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>mergeKLists</span><span class=params>(vector&LTListNode*>& lists)</span> </span>{</span><br><span class=line>        <span class=keyword>auto</span> comp = [](ListNode* a, ListNode* b) { <span class=keyword>return</span> a->val > b->val; };</span><br><span class=line>        <span class=comment>// 最小堆</span></span><br><span class=line>        priority_queue&LTListNode*, vector&LTListNode*>, <span class=keyword>decltype</span>(comp)> <span class=built_in>pq</span>(comp);</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span> l : lists) {</span><br><span class=line>            <span class=keyword>if</span> (l) {</span><br><span class=line>                pq.<span class=built_in>push</span>(l);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        ListNode *dummy = <span class=keyword>new</span> ListNode, *cur = dummy;</span><br><span class=line>        <span class=keyword>while</span> (!pq.<span class=built_in>empty</span>()) {</span><br><span class=line>            cur->next = pq.<span class=built_in>top</span>();</span><br><span class=line>            pq.<span class=built_in>pop</span>();</span><br><span class=line>            cur = cur->next;</span><br><span class=line>            <span class=keyword>if</span> (cur->next) {</span><br><span class=line>                pq.<span class=built_in>push</span>(cur->next);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>数组中的第K个最大元素</strong><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。<p>在计算机科学中，快速选择（quick select）作为一种在无序列表中获得第k小元素的选择算法，是分治思想的经典应用之一。它和快速排序（quick sort）算法一样，都来自Tony Hoare，因此也被称为Hoare’s selection algorithm。快速排序算法在实践中拥有非常好的平均性能，很多工业界的排序算法都有其身影（比如各种高级编程语言官方库中的排序方法）。与快速排序算法思想相近的快速选择算法及其变种，同样拥有非常好的平均性能，但缺点也是类似的，即该算法在最坏情况下性能很差。回归到题目，<strong>求第k大元素可以直接转换成求第n-k+1小的元素，这里的n是数组的大小，也就是说我们可以在这里使用快速选择算法</strong>。<p>速选择算法和快速排序算法共用了partition子过程，也就是分治法中的分解操作。而两者之间的区别在于，快速排序算法会将问题划分为两个子问题分开递归解决，其只需要递归处理一个子问题即可。快速选择算法的逻辑很简单，如下所示。1．随机选择一个pivot（支点）。2．使用partition子过程将pivot放在数组中合适的位置，将其设为pos。partition的作用就是将小于pivot的元素移到左边，大于或等于pivot的元素移到右边。<p>partition之后，我们先判断pos是否是想要的结果，如果是，则直接得到答案（这里也是上面讲述分治法时提到的可以直接求解的最简单子问题）。<p>如果不是，判断答案是在pos的左边还是右边，然后在新的范围中重复步骤1和2。这就是将问题拆分成子问题，并对子问题进行递归处理的过程。这里随机选择一个pivot是为了尽量降低快速选择算法中最坏情况发生的可能性。另外一种技巧是随机化打乱数组的预处理。<p>通常来讲，有两种partition方式：Lomuto partition和Hoare partition。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>partition</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> left, <span class=keyword>int</span> right, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (left == right) {</span><br><span class=line>            <span class=keyword>return</span> nums[left];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> i = left - <span class=number>1</span>, j = right + <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>int</span> pivot = nums[left];</span><br><span class=line>        <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>            <span class=keyword>do</span> {</span><br><span class=line>                i++;</span><br><span class=line>            } <span class=keyword>while</span> (nums[i] < pivot);</span><br><span class=line>            <span class=keyword>do</span> {</span><br><span class=line>                j--;</span><br><span class=line>            } <span class=keyword>while</span> (nums[j] > pivot);</span><br><span class=line>            <span class=keyword>if</span> (i >= j) {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=built_in>swap</span>(nums[i], nums[j]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (k <= j) {</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>partition</span>(nums, left, j, k);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>partition</span>(nums, j + <span class=number>1</span>, right, k);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>findKthLargest</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>partition</span>(nums, <span class=number>0</span>, nums.<span class=built_in>size</span>() - <span class=number>1</span>, nums.<span class=built_in>size</span>() - k);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>Hoare 分区的特点是：<ul><li>基准值最终可能在任意位置<li>只保证 <code>left..j</code>的元素 ≤ 基准值<li>只保证 <code>j+1..right</code>的元素 ≥ 基准值<li>为什么 Hoare 分区可以用于快速选择？关键在于：不需要知道 pivot 的确切位置，只需要知道目标元素 <code>k</code>在哪一边分区即可。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 分区后：j 是分界点</span></span><br><span class=line><span class=comment>// [left .. j] [j+1 .. right]</span></span><br><span class=line><span class=comment>//   ≤ pivot     ≥ pivot</span></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> (k <= j) search left;   <span class=comment>// 注意：包含 j！</span></span><br><span class=line><span class=keyword>else</span> search right;</span><br></pre></table></figure><p>lumoto分区特点. <strong>基准值放在正确位置</strong>，对重复元素处理较差<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 分区后：pivot 在最终位置 p</span></span><br><span class=line><span class=comment>// [left .. p-1] [p] [p+1 .. right]</span></span><br><span class=line><span class=comment>//   ≤ pivot     pivot   ≥ pivot</span></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> (k == p) <span class=keyword>return</span> nums[p];</span><br><span class=line><span class=keyword>else</span> <span class=keyword>if</span> (k < p) search left;</span><br><span class=line><span class=keyword>else</span> search right;  <span class=comment>// 注意：k > p</span></span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>lomutoPartition</span><span class=params>(vector<<span class=keyword>int</span>>& arr, <span class=keyword>int</span> low, <span class=keyword>int</span> high)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> pivot = arr[high]; <span class=comment>// 选最后一位</span></span><br><span class=line>    <span class=keyword>int</span> i = low - <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j = low; j < high; j++) {</span><br><span class=line>        <span class=keyword>if</span> (arr[j] <= pivot) {</span><br><span class=line>            i++;</span><br><span class=line>            <span class=built_in>swap</span>(arr[i], arr[j]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>swap</span>(arr[i + <span class=number>1</span>], arr[high]); <span class=comment>// 把 pivot 放到中间</span></span><br><span class=line>    <span class=keyword>return</span> i + <span class=number>1</span>;</span><br><span class=line>}</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>quickSelect2</span><span class=params>(vector<<span class=keyword>int</span>>&nums,<span class=keyword>int</span> l,<span class=keyword>int</span> r)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> target = nums[l];</span><br><span class=line>        <span class=keyword>int</span> i = l,j = r;</span><br><span class=line>        <span class=keyword>while</span>(i&LTj) {</span><br><span class=line>            <span class=keyword>while</span>(i&LTj && nums[j]>=target) {</span><br><span class=line>                j--;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>while</span>(i&LTj && nums[i]<=target) {</span><br><span class=line>                i++;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span>(i>=j) {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        	<span class=built_in>swap</span>(nums[i],nums[j]);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>swap</span>(nums[i],nums[l]);</span><br><span class=line>        <span class=keyword>return</span> i;</span><br><span class=line>  }</span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>hoarePartition</span><span class=params>(vector<<span class=keyword>int</span>>& arr, <span class=keyword>int</span> low, <span class=keyword>int</span> high)</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> pivot = arr[low]; <span class=comment>// 选第一位</span></span><br><span class=line>    <span class=keyword>int</span> i = low - <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>int</span> j = high + <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        <span class=keyword>do</span> { i++; } <span class=keyword>while</span> (arr[i] < pivot);</span><br><span class=line>        <span class=keyword>do</span> { j--; } <span class=keyword>while</span> (arr[j] > pivot);</span><br><span class=line>        <span class=keyword>if</span> (i >= j) <span class=keyword>return</span> j;</span><br><span class=line>        <span class=built_in>swap</span>(arr[i], arr[j]);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br></pre><td class=code><pre><span class=line><span class=comment>// ====================== 1. Lomuto 分区（带随机基准） ======================</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>lomutoPartition</span><span class=params>(vector<<span class=keyword>int</span>>& arr, <span class=keyword>int</span> low, <span class=keyword>int</span> high)</span> </span>{</span><br><span class=line>    <span class=comment>// 步骤1：随机选择基准值，交换到右边界（Lomuto默认选右边界）</span></span><br><span class=line>    <span class=keyword>int</span> randIdx = low + <span class=built_in>rand</span>() % (high - low + <span class=number>1</span>); <span class=comment>// 生成[low, high]的随机数</span></span><br><span class=line>    <span class=built_in>swap</span>(arr[randIdx], arr[high]);</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 步骤2：标准 Lomuto 分区逻辑</span></span><br><span class=line>    <span class=keyword>int</span> pivot = arr[high]; <span class=comment>// 基准值（已交换到右边界）</span></span><br><span class=line>    <span class=keyword>int</span> i = low - <span class=number>1</span>;       <span class=comment>// 左区（<=pivot）的右边界</span></span><br><span class=line>    </span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j = low; j < high; ++j) {</span><br><span class=line>        <span class=comment>// 把<=pivot的元素归集到左区</span></span><br><span class=line>        <span class=keyword>if</span> (arr[j] <= pivot) {</span><br><span class=line>            ++i;</span><br><span class=line>            <span class=built_in>swap</span>(arr[i], arr[j]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 步骤3：将基准值放到分界点（i+1）</span></span><br><span class=line>    <span class=built_in>swap</span>(arr[i + <span class=number>1</span>], arr[high]);</span><br><span class=line>    <span class=keyword>return</span> i + <span class=number>1</span>; <span class=comment>// 返回基准值的位置（分界点）</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// ====================== 2. Hoare 分区（带随机基准） ======================</span></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>hoarePartition</span><span class=params>(vector<<span class=keyword>int</span>>& arr, <span class=keyword>int</span> low, <span class=keyword>int</span> high)</span> </span>{</span><br><span class=line>    <span class=comment>// 步骤1：随机选择基准值，交换到左边界（Hoare示例选左边界）</span></span><br><span class=line>    <span class=keyword>int</span> randIdx = low + <span class=built_in>rand</span>() % (high - low + <span class=number>1</span>);</span><br><span class=line>    <span class=built_in>swap</span>(arr[randIdx], arr[low]);</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 步骤2：标准 Hoare 分区逻辑</span></span><br><span class=line>    <span class=keyword>int</span> pivot = arr[low]; <span class=comment>// 基准值（已交换到左边界）</span></span><br><span class=line>    <span class=keyword>int</span> i = low - <span class=number>1</span>;      <span class=comment>// 左指针（初始左移一位，避免漏判）</span></span><br><span class=line>    <span class=keyword>int</span> j = high + <span class=number>1</span>;     <span class=comment>// 右指针（初始右移一位，避免漏判）</span></span><br><span class=line>    </span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        <span class=comment>// 左指针右移：找 > pivot 的元素（适配找第k大，左区存更大值）</span></span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            ++i;</span><br><span class=line>        } <span class=keyword>while</span> (arr[i] < pivot);</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 右指针左移：找 < pivot 的元素</span></span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            --j;</span><br><span class=line>        } <span class=keyword>while</span> (arr[j] > pivot);</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 指针相遇，分区结束</span></span><br><span class=line>        <span class=keyword>if</span> (i >= j) {</span><br><span class=line>            <span class=keyword>return</span> j; <span class=comment>// 返回分界点（左区[low,j] >= pivot，右区[j+1,high] <= pivot）</span></span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 交换违规元素</span></span><br><span class=line>        <span class=built_in>swap</span>(arr[i], arr[j]);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><div class=table-container><table><thead><tr><th><strong>特性</strong><th><strong>Lomuto 分区</strong><th><strong>Hoare 分区</strong><tbody><tr><td><strong>指针方向</strong><td>同向移动（都向右）<td><strong>对向移动</strong>（向中间靠拢）<tr><td><strong>代码简洁度</strong><td>非常简洁<td>略复杂（有死循环风险，需谨慎处理）<tr><td><strong>交换频率</strong><td>高<td><strong>低（效率更高）</strong><tr><td><strong>Pivot 位置</strong><td>结束后 Pivot 就在最终排序位置<td>结束后 Pivot 可能不在最终位置<tr><td><strong>重复元素处理</strong><td>较差（容易造成分区不平衡）<td><strong>更好</strong>（能更均匀地分配重复元素）</table></div><p><strong>搜索二维矩阵</strong><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：<ul><li>每行的元素从左到右升序排列。<li>每列的元素从上到下升序排列。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>searchValue</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& matrix, <span class=keyword>int</span> target, <span class=keyword>int</span> row,</span></span></span><br><span class=line><span class=params><span class=function>                     <span class=keyword>int</span> col)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (row >= matrix.<span class=built_in>size</span>() || col < <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (matrix[row][col] == target) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (matrix[row][col] < target) {</span><br><span class=line>            <span class=comment>// 行数增加</span></span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>searchValue</span>(matrix, target, row + <span class=number>1</span>, col);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 列数减小</span></span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>searchValue</span>(matrix, target, row, col - <span class=number>1</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>searchMatrix</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& matrix, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = matrix.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = matrix[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>searchValue</span>(matrix, target, <span class=number>0</span>, n - <span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>如果能够满足本章开头说的分治法特征，就可以尝试使用分治法来处理，具体如下所示。●　问题的规模缩小到一定程度后可以被很容易地解决。●　问题可以分解为若干个规模较小的相同性质的问题。●　问题的解等于子问题解的合并。●　问题分解的各个子问题相互独立，没有重复。而在具体使用分治法时，紧紧抓住“分解”“解决”和“合并”这3个步骤<p><a href=https://leetcode.cn/problems/median-of-two-sorted-arrays/ rel=noopener target=_blank>寻找两个正序数组的中位数</a><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。算法的时间复杂度应该为 <code>O(log (m+n))</code> 。<p>要达到 O (log (m+n)) 的时间复杂度，必须使用<strong>二分查找</strong>而非简单的合并数组（合并数组的时间复杂度是 O (m+n)）。核心思路是：<ol><li>将问题转化为<strong>寻找两个有序数组中的第 k 小元素</strong>（中位数本质上就是第 (m+n)/2 小的元素）。<li>通过二分法不断缩小搜索范围：每次比较两个数组中第 k/2 位置的元素，排除不可能包含第 k 小元素的部分，直到 k=1 时直接取较小值。<li>处理奇偶情况：如果 m+n 是奇数，中位数就是第 (m+n+1)/2 小的元素；如果是偶数，就是第 (m+n)/2 和 (m+n)/2 +1 小的元素的平均值。</ol><p>如何找第k小？<p>假设我们要找第 k 小元素：<ol><li>比较两个数组的第 <code>k/2</code>个元素<li>较小的那个数组的前 <code>k/2</code>个元素都不可能是第 k 小<li>排除这些元素，问题规模减小</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>double</span> <span class=title>findMedianSortedArrays</span><span class=params>(vector<<span class=keyword>int</span>>& nums1, vector<<span class=keyword>int</span>>& nums2)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = nums1.<span class=built_in>size</span>(), n = nums2.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> total = m + n;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 中位数可能是两个数（偶数长度）或一个数（奇数长度）</span></span><br><span class=line>        <span class=keyword>if</span> (total % <span class=number>2</span> == <span class=number>1</span>) {</span><br><span class=line>            <span class=comment>// 奇数：第 k 小，k = (total+1)/2</span></span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>findKth</span>(nums1, <span class=number>0</span>, nums2, <span class=number>0</span>, (total + <span class=number>1</span>) / <span class=number>2</span>);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 偶数：第 k 小和第 k+1 小的平均值，k = total/2</span></span><br><span class=line>            <span class=keyword>int</span> left = <span class=built_in>findKth</span>(nums1, <span class=number>0</span>, nums2, <span class=number>0</span>, total / <span class=number>2</span>);</span><br><span class=line>            <span class=keyword>int</span> right = <span class=built_in>findKth</span>(nums1, <span class=number>0</span>, nums2, <span class=number>0</span>, total / <span class=number>2</span> + <span class=number>1</span>);</span><br><span class=line>            <span class=keyword>return</span> (left + right) / <span class=number>2.0</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=comment>// 寻找两个有序数组的第 k 小元素</span></span><br><span class=line>    <span class=comment>// i, j 分别是 nums1 和 nums2 的起始位置</span></span><br><span class=line>    <span class=function><span class=keyword>double</span> <span class=title>findKth</span><span class=params>(vector<<span class=keyword>int</span>>& nums1, <span class=keyword>int</span> i, vector<<span class=keyword>int</span>>& nums2, <span class=keyword>int</span> j, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = nums1.<span class=built_in>size</span>(), n = nums2.<span class=built_in>size</span>();</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 如果一个数组为空，直接从另一个数组取第k个</span></span><br><span class=line>        <span class=keyword>if</span> (i >= m) <span class=keyword>return</span> nums2[j + k - <span class=number>1</span>];</span><br><span class=line>        <span class=keyword>if</span> (j >= n) <span class=keyword>return</span> nums1[i + k - <span class=number>1</span>];</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 如果 k=1，返回两个数组首元素的最小值</span></span><br><span class=line>        <span class=keyword>if</span> (k == <span class=number>1</span>) <span class=keyword>return</span> <span class=built_in>min</span>(nums1[i], nums2[j]);</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 计算每个数组应该比较的位置</span></span><br><span class=line>        <span class=comment>// 防止越界：如果剩余长度不足 k/2，就取剩余长度</span></span><br><span class=line>        <span class=keyword>int</span> mid1 = <span class=built_in>min</span>(i + k / <span class=number>2</span> - <span class=number>1</span>, m - <span class=number>1</span>);</span><br><span class=line>        <span class=keyword>int</span> mid2 = <span class=built_in>min</span>(j + k / <span class=number>2</span> - <span class=number>1</span>, n - <span class=number>1</span>);</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 比较两个数组第 k/2 个元素</span></span><br><span class=line>        <span class=keyword>if</span> (nums1[mid1] <= nums2[mid2]) {</span><br><span class=line>            <span class=comment>// 说明 nums1 的前 k/2 个元素都不可能是第 k 小</span></span><br><span class=line>            <span class=comment>// 排除掉 nums1[i...mid1] 这些元素</span></span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>findKth</span>(nums1, mid1 + <span class=number>1</span>, nums2, j, k - (mid1 - i + <span class=number>1</span>));</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 排除掉 nums2[j...mid2] 这些元素</span></span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>findKth</span>(nums2, i, nums2, mid2 + <span class=number>1</span>, k - (mid2 - j + <span class=number>1</span>));</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>在成千上万个文件中找第 $k$ 大的数<p>这个问题将之前的“有序数组排除法”推向了<strong>分布式计算</strong>和<strong>大数据处理</strong>的实战领域。<p>当数据量大到无法装入内存，且分布在成千上万个文件中时，我们不能再依赖简单的指针移动，而要利用<strong>“值域划分”</strong>或<strong>“分桶统计”</strong>的思想。这本质上是把“对索引的二分”转变成了<strong>“对数值范围的二分”</strong>。<p>以下是三种最主流的解决策略：<ol><li>桶计数法（最推荐：MapReduce 思想）</ol><p>这是处理海量数据最稳健的方法。它的核心是将“寻找第 <em>k</em> 大”转化为“统计落在各个区间的数字个数”。<p>步骤：<ol><li><strong>确定值域</strong>：假设数字是 32 位整数，范围是 [0,232−1]。<li><strong>分桶</strong>：将这个范围均匀分成 <em>M</em> 个桶（例如 1024 个桶）。每个桶代表一个数值区间（如桶 0 代表 [0,4×106]）。<li><strong>第一轮扫描（Map）</strong>：遍历成千上万个文件，统计落入每个桶中的数字总数。<ul><li><em>结果示例</em>：桶 0 有 10 亿个数，桶 1 有 5 亿个数……</ul><li><strong>定位目标桶（Reduce）</strong>：从大到小累加桶的计数。<ul><li>如果前 2 个桶的总数小于 <em>k</em>，但前 3 个桶的总数大于等于 <em>k</em>，那么第 <em>k</em> 大的数一定在<strong>桶 2</strong> 中。</ul><li><p><strong>精细化搜索</strong>：</p> <ul><li>如果桶 2 中的数据量已经足够小（能装进内存），直接读入内存用 <code>QuickSelect</code> 解决。<li>如果依然太大，对桶 2 的值域范围再次进行“分桶”，重复上述过程。</ul><li><p>外部快速选择（External QuickSelect）</p></ol><p>这种方法是 <code>QuickSelect</code> 的分布式版本，适合数据分布在多台服务器上的场景。<p>步骤：<ol><li><strong>选基准值（Pivot）</strong>：从随机一个文件中选一个数作为 Pivot。<li><strong>分布式分区</strong>：所有节点同时扫描自己负责的文件，将数字分为“大于 Pivot”、“等于 Pivot”和“小于 Pivot”三类，并记录每类的<strong>总数</strong>。<li><strong>判断路径</strong>：<ul><li>如果“大于 Pivot”的总数 ≥<em>k</em>，则第 <em>k</em> 大在这一半，抛弃其余数据，在这一半中继续找。<li>如果总数 <<em>k</em> 且（大于+等于）的总数 ≥<em>k</em>，则 Pivot 就是答案。<li>否则，去“小于 Pivot”的那一半找第 <em>k</em>−(大于+等于) 大。</ul></ol><p><strong>缺点</strong>：如果 Pivot 选得不好（比如选到了极值），需要频繁扫描磁盘，I/O 开销极大。<ol><li>堆排序法（仅限 <em>k</em> 较小时）</ol><p>如果你要找的是“前 1000 大”，而不是“中位数”或“第 10 亿大”，那么堆是无敌的。<p>步骤：<ol><li>建立一个大小为 <em>k</em> 的<strong>最小堆</strong>。<li>逐个读取文件中的数字：<ul><li>如果数字比堆顶大，弹出堆顶，压入新数。</ul><li>扫描完所有文件后，堆顶即为所求。</ol><p><strong>优点</strong>：只需要扫描一遍数据，内存占用极低（仅 <em>O</em>(<em>k</em>)）。<p><strong>计算右侧小于当前元素的个数</strong><p>给你一个整数数组 <code>nums</code> ，按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是 <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。<p>在归并排序的“合并（Merge）”阶段，我们将两个有序的子数组合并。假设左子数组为 <code>L</code>，右子数组为 <code>R</code>。<ul><li>当我们从 <code>L</code> 中取出一个元素放入结果数组时，如果 <code>R</code> 中已经有若干个元素先被放入了结果数组，那么<strong>这些先被放入的 <code>R</code> 中的元素，一定是原数组中位于该 <code>L</code> 元素右侧且比它小的数</strong>。<li>我们只需要在合并时，记录 <code>R</code> 中有多少个元素已经被移动到了 <code>L</code> 元素的前面即可。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>merge</span><span class=params>(vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>>& nums, <span class=keyword>int</span> left, <span class=keyword>int</span> right,</span></span></span><br><span class=line><span class=params><span class=function>               vector<<span class=keyword>int</span>>& cnt)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (left >= right)</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>        <span class=built_in>merge</span>(nums, left, mid, cnt);</span><br><span class=line>        <span class=built_in>merge</span>(nums, <span class=number>1</span> + mid, right, cnt);</span><br><span class=line>        vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> <span class=built_in>tmp</span>(right - left + <span class=number>1</span>);</span><br><span class=line>        <span class=keyword>int</span> i = left, j = mid + <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>int</span> rightCount{};</span><br><span class=line>        <span class=keyword>int</span> idx{};</span><br><span class=line>        <span class=keyword>while</span> (i <= mid && j <= right) {</span><br><span class=line>            <span class=keyword>if</span> (nums[i].first <= nums[j].first) {</span><br><span class=line>                cnt[nums[i].second] += rightCount;</span><br><span class=line>                tmp[idx++] = nums[i++];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 大于</span></span><br><span class=line>                rightCount++;</span><br><span class=line>                tmp[idx++] = nums[j++];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 处理左半部分剩余元素 设置左半部分元素的count</span></span><br><span class=line>        <span class=keyword>while</span> (i <= mid) {</span><br><span class=line>            cnt[nums[i].second] += rightCount;</span><br><span class=line>            tmp[idx++] = nums[i++];</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 处理右半部分剩余元素</span></span><br><span class=line>        <span class=keyword>while</span> (j <= right) {</span><br><span class=line>            tmp[idx++] = nums[j++];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = left; i <= right; i++) {</span><br><span class=line>            nums[i] = tmp[i - left];</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>countSmaller</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> index_nums;</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < sz; i++) {</span><br><span class=line>            index_nums.<span class=built_in>push_back</span>({nums[i], i}); <span class=comment>// 值和对应位置</span></span><br><span class=line>        }</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>cnt</span><span class=params>(sz)</span></span>;</span><br><span class=line>        <span class=built_in>merge</span>(index_nums, <span class=number>0</span>, sz - <span class=number>1</span>, cnt);</span><br><span class=line>        <span class=keyword>return</span> cnt;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>交易逆序对的总数</strong><p>在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 <code>record</code>，返回其中存在的「交易逆序对」总数<ol><li><strong>逆序对定义</strong>：对于 <code>i < j</code>，如果 <code>record[i] > record[j]</code>，则 <code>(i, j)</code>是一个逆序对<li><strong>归并排序法的核心思想</strong>：<ul><li>分治：将数组分成两半<li>合并时统计：如果左半部分的元素大于右半部分的元素，则左半部分剩余的所有元素都与右半部分的该元素构成逆序对<li>时间复杂度：O(nlogn)，空间复杂度：O(n)</ul><li><strong>为什么归并排序法有效</strong>：<ul><li>在合并两个有序子数组时，可以高效地统计跨越两个子数组的逆序对<li>递归地统计每个子数组内部的逆序对</ul></ol><p>这是面试中常见的问题，<strong>归并排序法</strong>是必须掌握的标准解法。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>reversePairs</span><span class=params>(vector<<span class=keyword>int</span>>& record)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = record.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span> (n < <span class=number>2</span>) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>temp</span><span class=params>(n)</span></span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>mergeSort</span>(record, temp, <span class=number>0</span>, n - <span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>mergeSort</span><span class=params>(vector<<span class=keyword>int</span>>& nums, vector<<span class=keyword>int</span>>& temp, <span class=keyword>int</span> left, <span class=keyword>int</span> right)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (left >= right) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>int</span> mid = left + (right - left) / <span class=number>2</span>;</span><br><span class=line>        <span class=keyword>int</span> count = <span class=number>0</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 分治</span></span><br><span class=line>        count += <span class=built_in>mergeSort</span>(nums, temp, left, mid);</span><br><span class=line>        count += <span class=built_in>mergeSort</span>(nums, temp, mid + <span class=number>1</span>, right);</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 合并并计数</span></span><br><span class=line>        <span class=keyword>int</span> i = left, j = mid + <span class=number>1</span>, k = left;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 先统计逆序对</span></span><br><span class=line>        <span class=keyword>while</span> (i <= mid && j <= right) {</span><br><span class=line>            <span class=keyword>if</span> (nums[i] > nums[j]) {</span><br><span class=line>                <span class=comment>// nums[i] > nums[j]，那么 nums[i..mid] 都 > nums[j]</span></span><br><span class=line>                count += (mid - i + <span class=number>1</span>);</span><br><span class=line>                j++;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                i++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 再真正合并（也可以边统计边合并）</span></span><br><span class=line>        i = left, j = mid + <span class=number>1</span>, k = left;</span><br><span class=line>        <span class=keyword>while</span> (i <= mid && j <= right) {</span><br><span class=line>            <span class=keyword>if</span> (nums[i] <= nums[j]) {</span><br><span class=line>                temp[k++] = nums[i++];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                temp[k++] = nums[j++];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>while</span> (i <= mid) temp[k++] = nums[i++];</span><br><span class=line>        <span class=keyword>while</span> (j <= right) temp[k++] = nums[j++];</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> idx = left; idx <= right; idx++) {</span><br><span class=line>            nums[idx] = temp[idx];</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>return</span> count;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>漂亮数组</strong><p>如果长度为 <code>n</code> 的数组 <code>nums</code> 满足下述条件，则认为该数组是一个 <strong>漂亮数组</strong> ：<ul><li><code>nums</code> 是由范围 <code>[1, n]</code> 的整数组成的一个排列。<li>对于每个 <code>0 <= i < j < n</code> ，均不存在下标 <code>k</code>（<code>i < k < j</code>）使得 <code>2 * nums[k] == nums[i] + nums[j]</code> 。</ul><p>给你整数 <code>n</code> ，返回长度为 <code>n</code> 的任一 <strong>漂亮数组</strong> 。本题保证对于给定的 <code>n</code> 至少存在一个有效答案。<p>通过以下步骤递归构造长度为 $n$ 的漂亮数组：<ol><li><strong>分</strong>：将 $n$ 个数分成两部分，左边是 $(n+1)/2$ 个数，右边是 $n/2$ 个数。<li><strong>变换</strong>：<ul><li>左边由长度为 $(n+1)/2$ 的漂亮数组通过 $2x - 1$ 变换得到（映射为奇数）。<li>右边由长度为 $n/2$ 的漂亮数组通过 $2x$ 变换得到（映射为偶数）。</ul><li><strong>合</strong>：将左右两部分拼接。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, vector<<span class=keyword>int</span>>> memo;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>dfs</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(n)) {</span><br><span class=line>            <span class=keyword>return</span> memo[n];</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 将n分为两半 (n+1)/2 n/2</span></span><br><span class=line>        <span class=comment>// 左半部分全为奇数</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>res</span><span class=params>(n)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> i{};</span><br><span class=line>        vector<<span class=keyword>int</span>> l = <span class=built_in>dfs</span>((n + <span class=number>1</span>) / <span class=number>2</span>);</span><br><span class=line>        <span class=comment>// 进行转换</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& n : l) {</span><br><span class=line>            <span class=comment>// 全转为奇数</span></span><br><span class=line>            res[i++] = <span class=number>2</span> * n - <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        vector<<span class=keyword>int</span>> r = <span class=built_in>dfs</span>(n / <span class=number>2</span>);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& n : r) {</span><br><span class=line>            <span class=comment>// 全转为偶数</span></span><br><span class=line>            res[i++] = <span class=number>2</span> * n;</span><br><span class=line>        }</span><br><span class=line>        memo[n] = res;</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>beautifulArray</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        memo[<span class=number>1</span>] = {<span class=number>1</span>};</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(n);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h1 id=贪心><a class=headerlink href=#贪心 title=贪心></a>贪心</h1><p>每次根据问题的当前状态，选择一个局部最优策略，并且能够不断迭代，最后产生一个全局最优解。换句话说，每次都是从当前问题出发，而不考虑之前或之后的问题的状态，然后做出一个最有利于当前问题的决策，迭代更新问题，不断重复同样的操作直到问题得到解决，此时得到的解为全局最优解。<p>一般而言，贪心法的题目只要求我们想到一个合理的局部最优策略，并且通过自己举例测试局部最优策略是否会出问题即可，而不需要去关注如何证明这个策略能够产生一个全局最优解。<p><strong>分发饼干</strong><p>为了尽可能满足最多数量的孩子，从贪心的角度考虑，应该按照孩子的胃口从小到大的顺序依次满足每个孩子，且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>findContentChildren</span><span class=params>(vector<<span class=keyword>int</span>>& g, vector<<span class=keyword>int</span>>& s)</span> </span>{</span><br><span class=line>        <span class=built_in>sort</span>(g.<span class=built_in>begin</span>(), g.<span class=built_in>end</span>());</span><br><span class=line>        <span class=built_in>sort</span>(s.<span class=built_in>begin</span>(), s.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>int</span> i{}, j{};</span><br><span class=line>        <span class=keyword>while</span> (i < g.<span class=built_in>size</span>() && j < s.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>if</span> (g[i] <= s[j]) {</span><br><span class=line>                <span class=comment>// 满足胃口</span></span><br><span class=line>                i++;</span><br><span class=line>                j++;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 不满足</span></span><br><span class=line>                j++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> i;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>跳跃游戏</strong><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。<p>依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新 最远可以到达的位置。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>canJump</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> max_step{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (i <= max_step) {</span><br><span class=line>                max_step = <span class=built_in>max</span>(max_step, nums[i] + i);</span><br><span class=line>                <span class=keyword>if</span> (max_step >= nums.<span class=built_in>size</span>() - <span class=number>1</span>) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>任务调度器</strong><p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表，用字母 A 到 Z 表示，以及一个冷却时间 <code>n</code>。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个 <strong>相同种类</strong> 的任务之间必须有长度为 <code>n</code> 的冷却时间。返回完成所有任务所需要的 <strong>最短时间间隔</strong> 。<p>假设出现次数最多的任务是 <code>A</code>，它的频率为 <code>max_freq</code>。 为了让时间最短，我们应该尽可能把 <code>A</code> 均匀地排开，中间填入冷却时间或其它任务。<p>计算出的结果可能面临两种情况：<ul><li><p><strong>情况 A：空位不够填</strong></p> <p>如果任务种类非常多，导致空位被填满后还有多余任务。此时，我们不需要任何额外的冷却时间（Idle time），总时间就是任务的总数 <code>tasks.size()</code>。</p><li><p><strong>情况 B：空位填不满</strong></p> <p>如果冷却时间 $n$ 很大，而任务种类很少，空位填不满，必须插入 <code>idle</code>。此时答案就是上面的公式结果。</p></ul><p><strong>结论</strong>：最终结果是 $\max(\text{tasks.size()}, (max_f - 1) \times (n + 1) + max_count)$。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>leastInterval</span><span class=params>(vector<<span class=keyword>char</span>>& tasks, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>cnts</span><span class=params>(<span class=number>26</span>)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> max_cnt{};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>auto</span>& ch:tasks) {</span><br><span class=line>            cnts[ch-<span class=string>'A'</span>]++;</span><br><span class=line>            max_cnt = <span class=built_in>max</span>(max_cnt,cnts[ch-<span class=string>'A'</span>]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> max_chars{};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>;i<<span class=number>26</span>;i++){</span><br><span class=line>            <span class=keyword>if</span>(cnts[i] == max_cnt) {</span><br><span class=line>                max_chars++;</span><br><span class=line>            }</span><br><span class=line>        }        </span><br><span class=line>        <span class=comment>// 选择频率最多的字符</span></span><br><span class=line>        <span class=comment>// 该字符每个一组,</span></span><br><span class=line>        <span class=keyword>int</span> res = (n+<span class=number>1</span>)*(max_cnt<span class=number>-1</span>) + max_chars;</span><br><span class=line>        <span class=keyword>return</span> max<<span class=keyword>int</span>>(tasks.<span class=built_in>size</span>(),res);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>分发糖果</strong><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。<p>你需要按照以下要求，给这些孩子分发糖果：<ul><li>每个孩子至少分配到 <code>1</code> 个糖果。<li>相邻两个孩子中，评分更高的那个会获得更多的糖果。</ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。<p>我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。<p>左规则：当 ratings[i−1]&LTratings[i] 时，i 号学生的糖果数量将比 i−1 号孩子的糖果数量多。<p>右规则：当 ratings[i]>ratings[i+1] 时，i 号学生的糖果数量将比 i+1 号孩子的糖果数量多。<p>我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。<p>具体地，以左规则为例：我们从左到右遍历该数组，假设当前遍历到位置 i，如果有 ratings[i−1]&LTratings[i] 那么 i 号学生的糖果数量将比 i−1 号孩子的糖果数量多，我们令 left[i]=left[i−1]+1 即可，否则我们令 left[i]=1。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>candy</span><span class=params>(vector<<span class=keyword>int</span>>& ratings)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = ratings.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>left</span><span class=params>(sz, <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>right</span><span class=params>(sz, <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < sz; i++) {</span><br><span class=line>            <span class=keyword>if</span> (ratings[i] > ratings[i - <span class=number>1</span>]) {</span><br><span class=line>                left[i] = left[i - <span class=number>1</span>] + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> ans{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = sz - <span class=number>2</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>if</span> (ratings[i] > ratings[i + <span class=number>1</span>]) {</span><br><span class=line>                right[i] = right[i + <span class=number>1</span>] + <span class=number>1</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>;i&LTsz;i++) {</span><br><span class=line>            ans += <span class=built_in>max</span>(left[i],right[i]);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>无重叠区间</strong><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。<p><strong>注意</strong> 只在一点上接触的区间是 <strong>不重叠的</strong>。例如 <code>[1, 2]</code> 和 <code>[2, 3]</code> 是不重叠的<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>eraseOverlapIntervals</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& intervals)</span> </span>{</span><br><span class=line>        <span class=built_in>sort</span>(intervals.<span class=built_in>begin</span>(), intervals.<span class=built_in>end</span>());</span><br><span class=line>        <span class=comment>// [1,2] [1,3] [2,3] [3,4]</span></span><br><span class=line>        <span class=keyword>int</span> lastTime = intervals[<span class=number>0</span>][<span class=number>1</span>];</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < intervals.<span class=built_in>size</span>() - <span class=number>1</span>; i++) {</span><br><span class=line>            <span class=keyword>if</span> (lastTime <= intervals[i + <span class=number>1</span>][<span class=number>0</span>]) {</span><br><span class=line>                lastTime = intervals[i + <span class=number>1</span>][<span class=number>1</span>];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 重叠</span></span><br><span class=line>                lastTime = <span class=built_in>min</span>(lastTime, intervals[i + <span class=number>1</span>][<span class=number>1</span>]);</span><br><span class=line>                res++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>eraseOverlapIntervals</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& intervals)</span> </span>{</span><br><span class=line>        <span class=keyword>auto</span> comp = [](vector<<span class=keyword>int</span>>& a,vector<<span class=keyword>int</span>>& b){</span><br><span class=line>            <span class=keyword>return</span> a[<span class=number>1</span>]&LTb[<span class=number>1</span>];</span><br><span class=line>        };</span><br><span class=line>        <span class=built_in>sort</span>(intervals.<span class=built_in>begin</span>(),intervals.<span class=built_in>end</span>(),comp);</span><br><span class=line>        <span class=keyword>int</span> lastTime = intervals[<span class=number>0</span>][<span class=number>1</span>];</span><br><span class=line>        <span class=keyword>int</span> cnt{<span class=number>1</span>};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>;i&LTintervals.<span class=built_in>size</span>();i++) {</span><br><span class=line>            <span class=keyword>if</span>(lastTime<=intervals[i][<span class=number>0</span>]) {</span><br><span class=line>                <span class=comment>// 不需要移除</span></span><br><span class=line>                cnt++;</span><br><span class=line>                lastTime = intervals[i][<span class=number>1</span>];</span><br><span class=line>            }<span class=keyword>else</span>{</span><br><span class=line>                <span class=comment>// 大于开始时间 需要移除</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> intervals.<span class=built_in>size</span>()-cnt;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>跳跃游戏II</strong><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置在下标 0。<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在索引 <code>i</code> 处，你可以跳转到任意 <code>(i + j)</code> 处：<ul><li><code>0 <= j <= nums[i]</code> 且<li><code>i + j < n</code></ul><p>返回到达 <code>n - 1</code> 的最小跳跃次数。测试用例保证可以到达 <code>n - 1</code>。<p>目标是：<strong>在当前跳跃能达到的范围内，寻找下一跳能跳得最远的位置</strong><p>当你从索引 <code>i</code> 遍历到 <code>end</code> 之间时，你会不断更新 <code>farthest</code>（即 <code>max(farthest, i + nums[i])</code>）。当你真正走到 <code>end</code> 这个边界时，说明你<strong>不得不</strong>再跳一次了。此时，你把跳跃次数 <code>jumps</code> 加 1，并将新的边界 <code>end</code> 设置为刚才探测到的 <code>farthest</code>。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>jump</span><span class=params>(vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>if</span> (n <= <span class=number>1</span>) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> jumps = <span class=number>0</span>;      <span class=comment>// 跳跃次数</span></span><br><span class=line>        <span class=keyword>int</span> farthest = <span class=number>0</span>;   <span class=comment>// 目前能跳到的最远位置</span></span><br><span class=line>        <span class=keyword>int</span> end = <span class=number>0</span>;        <span class=comment>// 当前跳跃步数能覆盖的边界</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 注意：我们不需要遍历最后一个元素，因为题目保证能到达</span></span><br><span class=line>        <span class=comment>// 如果遍历到最后一个元素，可能会多算一次跳跃</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < n - <span class=number>1</span>; i++) {</span><br><span class=line>            <span class=comment>// 1. 在当前范围内，探测下一跳最远能到哪</span></span><br><span class=line>            farthest = <span class=built_in>max</span>(farthest, i + nums[i]);</span><br><span class=line></span><br><span class=line>            <span class=comment>// 2. 到达当前跳跃的边界了</span></span><br><span class=line>            <span class=keyword>if</span> (i == end) {</span><br><span class=line>                jumps++;</span><br><span class=line>                end = farthest; <span class=comment>// 开启下一段势力范围</span></span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 如果已经能覆盖终点，可以提前结束</span></span><br><span class=line>                <span class=keyword>if</span> (end >= n - <span class=number>1</span>) <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> jumps;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>移掉k位数字</strong><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。<p><strong>让越小的数字尽可能排在越左边（高位）</strong>。这本质上是一个贪心问题，而实现这个贪心策略的最佳工具是 <strong>单调栈 (Monotonic Stack)</strong>。想象一个数字序列，如果左边的数字比右边的大（例如 <code>...43...</code>），那么删掉左边的这个“大数”，整个数字就会立刻变小。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>removeKdigits</span><span class=params>(string num, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (num.<span class=built_in>length</span>() == k) <span class=keyword>return</span> <span class=string>"0"</span>;</span><br><span class=line></span><br><span class=line>        string res = <span class=string>""</span>; <span class=comment>// 这里的 string 可以直接当做栈来用</span></span><br><span class=line>        </span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>char</span> d : num) {</span><br><span class=line>            <span class=comment>// 当当前数字比“栈”顶小，且还有删除名额时，弹出末尾数字</span></span><br><span class=line>            <span class=keyword>while</span> (k > <span class=number>0</span> && !res.<span class=built_in>empty</span>() && res.<span class=built_in>back</span>() > d) {</span><br><span class=line>                res.<span class=built_in>pop_back</span>();</span><br><span class=line>                k--;</span><br><span class=line>            }</span><br><span class=line>            res.<span class=built_in>push_back</span>(d);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 如果 k 还没用完，从末尾截断（因为此时 res 已经是升序的了）</span></span><br><span class=line>        <span class=keyword>while</span> (k > <span class=number>0</span>) {</span><br><span class=line>            res.<span class=built_in>pop_back</span>();</span><br><span class=line>            k--;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 处理前导零</span></span><br><span class=line>        <span class=keyword>int</span> start = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>while</span> (start < res.<span class=built_in>size</span>() && res[start] == <span class=string>'0'</span>) {</span><br><span class=line>            start++;</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        string ans = res.<span class=built_in>substr</span>(start);</span><br><span class=line>        <span class=keyword>return</span> ans.<span class=built_in>empty</span>() ? <span class=string>"0"</span> : ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>根据身高重建队列</strong><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。<p><strong>先安置“高个子”，再让“矮个子”插队</strong>。因为高个子的相对位置只受比他更高或一样高的人影响，而矮个子对他来说是“隐形”的。<p>我们可以通过两个步骤来搞定：<p>第一步：排序<p>我们要对数组进行排序：<ol><li><strong>身高 $h$ 降序</strong>：高个子排在前面。<li><strong>人数 $k$ 升序</strong>：如果身高一样，要求前面人少的排在前面。</ol><p>第二步：插入<p>遍历排序后的数组，直接将每个人插入到他对应的 $k$ 位置。<ul><li><strong>逻辑保证</strong>：当我们处理第 $i$ 个人时，已经在队列里的所有人身高都 $\ge$ 他的身高。<li>此时，他要求前面有 $k$ 个比他高或相等的人，我们就直接把他放在索引 $k$ 的位置。哪怕后面有更矮的人插到他前面，也不会影响他的 $k$ 值。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>reconstructQueue</span>(vector&LTvector<<span class=keyword>int</span>>>& people) {</span><br><span class=line>        <span class=comment>// 先排序身高</span></span><br><span class=line>        <span class=keyword>auto</span> comp = [](vector<<span class=keyword>int</span>>& a,vector<<span class=keyword>int</span>>& b) {</span><br><span class=line>            <span class=keyword>if</span>(a[<span class=number>0</span>] == b[<span class=number>0</span>]) {</span><br><span class=line>                <span class=comment>// 身高相等 排序低的在前面</span></span><br><span class=line>                <span class=keyword>return</span> a[<span class=number>1</span>]&LTb[<span class=number>1</span>];</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> a[<span class=number>0</span>]>b[<span class=number>0</span>];</span><br><span class=line>        };</span><br><span class=line>        <span class=built_in>sort</span>(people.<span class=built_in>begin</span>(),people.<span class=built_in>end</span>(),comp);</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        <span class=comment>//</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>auto</span>& p:people) {</span><br><span class=line>           res.<span class=built_in>insert</span>(res.<span class=built_in>begin</span>()+p[<span class=number>1</span>],p);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>用最少数量的箭引爆气球</strong><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足 <code>xstart ≤ x ≤ xend</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。<p><strong>按照气球的结束坐标 ($x_{end}$) 进行升序排序。</strong><p><strong>为什么选结束坐标？</strong>如果我们按照结束坐标排序，第一支箭的最优射出位置一定是<strong>第一个气球的结束位置</strong>。因为这样射出的箭，在引爆当前气球的同时，最有机会引爆后面那些“开始得很早”的气球。<p>算法步骤：<ol><li><strong>排序</strong>：将气球按 $x_{end}$ 从小到大排序。<li><strong>初始化</strong>：至少需要 1 支箭（假设数组不为空），初始射箭位置设为第一个气球的结束坐标。<li><strong>遍历</strong>：从第二个气球开始遍历：<ul><li>如果当前气球的开始坐标 $x_{start}$ <strong>大于</strong> 上一次射箭的位置：说明这支箭射不到这个气球。<li><strong>更新</strong>：我们需要一支新箭，增加箭的计数，并将射箭位置更新为当前气球的结束坐标。<li>否则：这支箭可以顺便引爆当前气球，位置保持不变。</ul></ol><p><strong>按区间的开始位置（Start）进行升序排序。</strong><p>核心思路：贪心加排序为什么要按开始位置排序？ 因为排序后，<strong>可以合并的区间一定是连续出现的</strong>。我们只需要比较当前区间的“开始”和上一个合并区间的“结束”即可。<p>算法步骤：<ol><li><strong>排序</strong>：按照每个区间的 <code>start</code> 从小到大排序。<li><strong>初始化</strong>：创建一个空的结果数组 <code>res</code>，先把第一个区间放进去。<li><strong>遍历</strong>：从第二个区间开始遍历：<ul><li>取 <code>res</code> 中最后一个区间的末尾 <code>last_end</code>。<li>取当前遍历区间的开头 <code>curr_start</code> 和末尾 <code>curr_end</code>。<li><strong>判断重叠</strong>：如果 <code>curr_start <= last_end</code>，说明重叠了！<ul><li><strong>合并</strong>：将 <code>res</code> 中最后一个区间的末尾更新为 <code>max(last_end, curr_end)</code>。</ul><li><strong>不重叠</strong>：如果 <code>curr_start > last_end</code>，说明这两个区间接不上。<ul><li><strong>直接添加</strong>：把当前区间整个塞进 <code>res</code>。</ul></ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>findMinArrowShots</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& points)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (points.<span class=built_in>empty</span>()) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 1. 按结束坐标升序排序</span></span><br><span class=line>        <span class=comment>// 注意：使用 lambda 表达式时，直接相减可能会导致溢出，建议使用 < 判断</span></span><br><span class=line>        <span class=built_in>sort</span>(points.<span class=built_in>begin</span>(), points.<span class=built_in>end</span>(), [](<span class=keyword>const</span> vector<<span class=keyword>int</span>>& a, <span class=keyword>const</span> vector<<span class=keyword>int</span>>& b) {</span><br><span class=line>            <span class=keyword>return</span> a[<span class=number>1</span>] < b[<span class=number>1</span>];</span><br><span class=line>        });</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> arrows = <span class=number>1</span>; <span class=comment>// 至少需要一支箭</span></span><br><span class=line>        <span class=keyword>int</span> last_end = points[<span class=number>0</span>][<span class=number>1</span>]; <span class=comment>// 第一支箭射在第一个气球的末尾</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < points.<span class=built_in>size</span>(); ++i) {</span><br><span class=line>            <span class=comment>// 2. 如果当前气球的开始位置在箭的射程之外</span></span><br><span class=line>            <span class=keyword>if</span> (points[i][<span class=number>0</span>] > last_end) {</span><br><span class=line>                arrows++; <span class=comment>// 必须再射一支</span></span><br><span class=line>                last_end = points[i][<span class=number>1</span>]; <span class=comment>// 更新这支箭的位置到当前气球末尾</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> arrows;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>合并区间</strong><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>merge</span>(vector&LTvector<<span class=keyword>int</span>>>& intervals) {</span><br><span class=line>        <span class=keyword>auto</span> comp = [](vector<<span class=keyword>int</span>>& a,vector<<span class=keyword>int</span>>&b) {</span><br><span class=line>            <span class=keyword>if</span>(a[<span class=number>0</span>] == b[<span class=number>0</span>]) {</span><br><span class=line>                <span class=keyword>return</span> a[<span class=number>1</span>]&LTb[<span class=number>1</span>];</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span> a[<span class=number>0</span>]&LTb[<span class=number>0</span>];</span><br><span class=line>        };</span><br><span class=line>        <span class=built_in>sort</span>(intervals.<span class=built_in>begin</span>(),intervals.<span class=built_in>end</span>(),comp);</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        res.<span class=built_in>push_back</span>(intervals[<span class=number>0</span>]);</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>;i&LTintervals.<span class=built_in>size</span>();i++) {</span><br><span class=line>            <span class=keyword>auto</span>& lastInterval = res.<span class=built_in>back</span>();</span><br><span class=line>            <span class=keyword>if</span>(lastInterval[<span class=number>1</span>]>=intervals[i][<span class=number>0</span>]) {</span><br><span class=line>                <span class=comment>// 重叠区间 合并</span></span><br><span class=line>                lastInterval[<span class=number>1</span>] = <span class=built_in>max</span>(lastInterval[<span class=number>1</span>],intervals[i][<span class=number>1</span>]);</span><br><span class=line>            }<span class=keyword>else</span>{</span><br><span class=line>                <span class=comment>// 不重叠区间</span></span><br><span class=line>                res.<span class=built_in>push_back</span>(intervals[i]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>合并区间（本题）</strong>：我们需要知道谁先开始，因为合并是向前推进的。如果按 End 排序，一个跨度极大的区间（如 <code>[1, 100]</code>）可能会排在最后，导致你之前合并好的所有小片段都要重新去和它比对，逻辑会变复杂。<p><strong>射气球/不重叠区间</strong>：我们需要尽早结束当前区间，好给后面的区间留位置。所以“谁先结束”是最重要的贪心标准。<p><strong>插入区间</strong><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 按照 <code>starti</code> 升序排列。同样给定一个区间 <code>newInterval = [start, end]</code> 表示另一个区间的开始和结束。<p>在 <code>intervals</code> 中插入区间 <code>newInterval</code>，使得 <code>intervals</code> 依然按照 <code>starti</code> 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。<p>返回插入之后的 <code>intervals</code>。<strong>注意</strong> 你不需要原地修改 <code>intervals</code>。你可以创建一个新数组然后返回它。<p>可以把处理过程想象成在一条时间轴上排队，把 <code>newInterval</code> 插入进去，并把受到波及的人“融合”掉：<ul><li><p><strong>阶段一：左侧无重叠</strong></p> <p>直接把所有<strong>结束时间</strong>早于 <code>newInterval</code> <strong>开始时间</strong>的区间丢进结果集。它们完全在左边，互不干扰。</p><li><p><strong>阶段二：中间重叠区（融合）</strong></p> <p>只要当前的区间<strong>没有完全在 <code>newInterval</code> 的右边</strong>（即当前区间的开始时间 $\le$ <code>newInterval</code> 的结束时间），就说明有重叠。</p> <ul><li><strong>融合策略</strong>：更新 <code>newInterval</code> 的起点为 <code>min(起点)</code>，终点为 <code>max(终点)</code>。</ul><li><p><strong>阶段三：右侧无重叠</strong></p> <p>把合并后的 <code>newInterval</code> 放进结果集，然后把剩下的还没处理的区间（它们都在右边，开始时间晚于 <code>newInterval</code> 的结束时间）全部接在后面。</p></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>insert</span>(vector&LTvector<<span class=keyword>int</span>>>& intervals,</span><br><span class=line>                               vector<<span class=keyword>int</span>>& newInterval) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        <span class=keyword>int</span> i{};</span><br><span class=line>        <span class=keyword>while</span> (i < intervals.<span class=built_in>size</span>() && intervals[i][<span class=number>1</span>] < newInterval[<span class=number>0</span>]) {</span><br><span class=line>            <span class=comment>// 不重叠 添加</span></span><br><span class=line>            res.<span class=built_in>push_back</span>(intervals[i]);</span><br><span class=line>            i++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (i < intervals.<span class=built_in>size</span>() && intervals[i][<span class=number>0</span>] <= newInterval[<span class=number>1</span>]) {</span><br><span class=line>            <span class=comment>// 重叠 合并</span></span><br><span class=line>            newInterval[<span class=number>0</span>] = <span class=built_in>min</span>(newInterval[<span class=number>0</span>], intervals[i][<span class=number>0</span>]);</span><br><span class=line>            newInterval[<span class=number>1</span>] = <span class=built_in>max</span>(newInterval[<span class=number>1</span>], intervals[i][<span class=number>1</span>]);</span><br><span class=line>            i++;</span><br><span class=line>        }</span><br><span class=line>        res.<span class=built_in>push_back</span>(newInterval);</span><br><span class=line>        <span class=keyword>while</span> (i < intervals.<span class=built_in>size</span>()) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(intervals[i]);</span><br><span class=line>            i++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>灌溉花园的最少水龙头数目</strong><p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i - ranges[i], i + ranges[i]]</code> 。<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>minTaps</span><span class=params>(<span class=keyword>int</span> n, vector<<span class=keyword>int</span>>& ranges)</span> </span>{</span><br><span class=line>        <span class=comment>// 1. 预处理：将区间转换为类似于“跳跃游戏”的数组</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>max_reach</span><span class=params>(n + <span class=number>1</span>, <span class=number>0</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>int</span> left = <span class=built_in>max</span>(<span class=number>0</span>, i - ranges[i]);</span><br><span class=line>            <span class=keyword>int</span> right = <span class=built_in>min</span>(n, i + ranges[i]);</span><br><span class=line>            <span class=comment>// 在 left 这个位置，最远能覆盖到 right</span></span><br><span class=line>            max_reach[left] = <span class=built_in>max</span>(max_reach[left], right);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 2. 执行“跳跃游戏 II”的贪心逻辑</span></span><br><span class=line>        <span class=keyword>int</span> taps = <span class=number>0</span>;       <span class=comment>// 使用的水龙头数量</span></span><br><span class=line>        <span class=keyword>int</span> cur_end = <span class=number>0</span>;    <span class=comment>// 当前已覆盖范围的右边界</span></span><br><span class=line>        <span class=keyword>int</span> farthest = <span class=number>0</span>;   <span class=comment>// 下一步能达到的最远位置</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &LTn; i++) {</span><br><span class=line>            <span class=comment>// 更新当前能探测到的最远位置</span></span><br><span class=line>            farthest = <span class=built_in>max</span>(farthest, max_reach[i]);</span><br><span class=line></span><br><span class=line>            <span class=comment>// 如果连当前的 i 都覆盖不到，说明中间有断层</span></span><br><span class=line>            <span class=keyword>if</span> (i >= farthest) <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line></span><br><span class=line>            <span class=comment>// 到达当前水龙头的覆盖极限，必须开启下一个</span></span><br><span class=line>            <span class=keyword>if</span> (i == cur_end) {</span><br><span class=line>                taps++;</span><br><span class=line>                cur_end = farthest;</span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 如果已经覆盖到 n，可以提前退出</span></span><br><span class=line>                <span class=keyword>if</span> (cur_end >= n) <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> cur_end >= n ? taps : <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>总体而言贪心类型的题目难度级别大部分只有中等，对应的解题技巧主要包括3个步骤。<p>●　掌握常见的贪心策略，例如本章的内容或其他人总结的经典贪心思想。<p>●　不断练习，积累题目经验，补充贪心策略，开拓自己的眼界和认知。<p>●　面对一道新颖的贪心类型的题目，要敢于设想一个局部最优策略。寻找局部最优策略的过程就是试错的过程，可以基于自己的生活经验或解题经验，并对策略的可行性进行简单的推理论证。<h1 id=回溯><a class=headerlink href=#回溯 title=回溯></a>回溯</h1><p>回溯法是一种复杂度很高的暴力搜索算法，实现简单且有固定模板，常被用于搜索排列组合问题的所有可行性解。不同于普通的暴力搜索，回溯法会在每一步判断状态是否合法，而不是等到状态全部生成后再进行确认。当某一步状态非法时，它将回退到上一步中正确的位置，然后继续搜索其他不同的状态。前进和后退是回溯法的关键动作，因此可以使用递归去模拟整个过程，即使用递归实现回溯法。<p><strong>组合总和</strong><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。<p>回溯法的本质是深度优先遍历，具体的实现方法是递归，因此需要定义一个递归函数来模拟整个搜索过程，即dfs()。不断向下递归的过程，也就是搜索前进的过程，那么在这个过程中需要注意哪些问题呢？这些问题与递归函数的内容及参数息息相关，值得我们关注理解。<p>（i）如何区别不同的递归？或者如何知道现在搜索到哪里了？每一层递归的函数内容是固定的，有所区别的只有参数信息，因此可以将参数信息作为区分的标记。通过获取当前递归的参数信息，也就能够认识到搜索的位置了。也可以称这些参数信息为递归携带的状态，模板中定义了3个状态，分别是idx、cur和path。其中，idx标记位置信息，例如idx=1可以表示搜索到数组的第1个数字，idx=2可以表示搜索到数组的第2个数字；cur和path实际上都是从出发点到当前位置的路径上的某个信息，需要根据题目的要求灵活定义。<p>（ii）递归如何结束？有几个结束出口？搜索的目标就是找到可行性解。通常情况下找到可行性解就应该结束搜索，但在一些特殊场景下，不同的解可能会重叠，例如找到解后继续搜索可能会得到新的解，此时就不能结束搜索。此外，当无法继续搜索时也应该结束搜索，例如依次遍历数组元素，如果递归过程中idx等于数组末尾的下标，则不能继续往下搜索，否则会发生程序错误。<p>（iii）递归过程中状态可能会互相影响，如何解决？这个问题可能不是很好理解。举个例子来说，假设当前可以向左前进，也可以向右前进，并且需要保存走过的路径。基于上述第一个问题，应该在递归中携带状态path来保存当前路径，并在进入下一层递归之前改变状态：向左前进则path.append(left)，向右前进则path.append(right)。如果先选择向左前进，path已经发生变化，包括向左的一些路径信息，再选择向右前进就会存在问题。一种简单的解决方案是：每次进入下一层递归时重新复制path，但复制path的时间复杂度为O(n)，时间开销太大，无法充分利用path。可以考虑另外一种解决方案：在递归结束的地方恢复原来path的状态，即在下一层递归前通过path.append(num)改变状态，并在递归结束时通过path.pop()恢复状态。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, vector<<span class=keyword>int</span>>& r, vector<<span class=keyword>int</span>>& nums,</span></span></span><br><span class=line><span class=params><span class=function>                   <span class=keyword>int</span> idx, <span class=keyword>int</span> sum_val, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (idx == nums.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (sum_val == target) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(r);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = idx; i < nums.<span class=built_in>size</span>() && (nums[i] + sum_val <= target); i++) {</span><br><span class=line>            r.<span class=built_in>push_back</span>(nums[i]);</span><br><span class=line>            <span class=built_in>backtrace</span>(res, r, nums, i, sum_val + nums[i], target);</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>combinationSum</span>(vector<<span class=keyword>int</span>>& candidates, <span class=keyword>int</span> target) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=built_in>sort</span>(candidates.<span class=built_in>begin</span>(), candidates.<span class=built_in>end</span>());</span><br><span class=line>        <span class=built_in>backtrace</span>(res, r, candidates, <span class=number>0</span>, <span class=number>0</span>, target);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>组合总和II</strong><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。<p><strong>注意：</strong>解集不能包含重复的组合。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> result;</span><br><span class=line>    vector<<span class=keyword>int</span>> path;</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtracking</span><span class=params>(vector<<span class=keyword>int</span>>& candidates, <span class=keyword>int</span> target, <span class=keyword>int</span> sum, <span class=keyword>int</span> startIndex, vector<<span class=keyword>bool</span>>& used)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (sum == target) {</span><br><span class=line>            result.<span class=built_in>push_back</span>(path);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = startIndex; i < candidates.<span class=built_in>size</span>() && sum + candidates[i] <= target; i++) {</span><br><span class=line>            <span class=comment>// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class=line>            <span class=comment>// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class=line>            <span class=comment>// 要对同一树层使用过的元素进行跳过</span></span><br><span class=line>            <span class=keyword>if</span> (i > <span class=number>0</span> && candidates[i] == candidates[i - <span class=number>1</span>] && used[i - <span class=number>1</span>] == <span class=literal>false</span>) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            sum += candidates[i];</span><br><span class=line>            path.<span class=built_in>push_back</span>(candidates[i]);</span><br><span class=line>            used[i] = <span class=literal>true</span>;</span><br><span class=line>            <span class=built_in>backtracking</span>(candidates, target, sum, i + <span class=number>1</span>, used); <span class=comment>// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class=line>            used[i] = <span class=literal>false</span>;</span><br><span class=line>            sum -= candidates[i];</span><br><span class=line>            path.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>combinationSum2</span>(vector<<span class=keyword>int</span>>& candidates, <span class=keyword>int</span> target) {</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>used</span><span class=params>(candidates.size(), <span class=literal>false</span>)</span></span>;</span><br><span class=line>        path.<span class=built_in>clear</span>();</span><br><span class=line>        result.<span class=built_in>clear</span>();</span><br><span class=line>        <span class=comment>// 首先把给candidates排序，让其相同的元素都挨在一起。</span></span><br><span class=line>        <span class=built_in>sort</span>(candidates.<span class=built_in>begin</span>(), candidates.<span class=built_in>end</span>());</span><br><span class=line>        <span class=built_in>backtracking</span>(candidates, target, <span class=number>0</span>, <span class=number>0</span>, used);</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><p>组合总和<strong>III</strong><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：<ul><li>只使用数字1到9<li>每个数字 <strong>最多使用一次</strong></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, <span class=keyword>int</span> sum_val, <span class=keyword>int</span> idx,</span></span></span><br><span class=line><span class=params><span class=function>                   vector<<span class=keyword>int</span>>& r, <span class=keyword>int</span> k, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (r.<span class=built_in>size</span>() == k) {</span><br><span class=line>            <span class=keyword>if</span> (sum_val == n) {</span><br><span class=line>                res.<span class=built_in>push_back</span>(r);</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = idx; i <= <span class=number>9</span> && i + sum_val <= n; i++) {</span><br><span class=line>            r.<span class=built_in>push_back</span>(i);</span><br><span class=line>            <span class=built_in>backtrace</span>(res, sum_val + i, i + <span class=number>1</span>, r, k, n);</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>combinationSum3</span>(<span class=keyword>int</span> k, <span class=keyword>int</span> n) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=built_in>backtrace</span>(res, <span class=number>0</span>, <span class=number>1</span>, r, k, n);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>子集</strong><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res,vector<<span class=keyword>int</span>>& r,vector<<span class=keyword>int</span>>& nums,<span class=keyword>int</span> idx)</span> </span>{</span><br><span class=line>        <span class=comment>// 添加所有节点</span></span><br><span class=line>        res.<span class=built_in>push_back</span>(r);</span><br><span class=line>        <span class=comment>// 截至条件</span></span><br><span class=line>        <span class=comment>// if(idx == nums.size()) {</span></span><br><span class=line>        <span class=comment>//     return;</span></span><br><span class=line>        <span class=comment>// }</span></span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = idx;i&LTnums.<span class=built_in>size</span>();i++) {</span><br><span class=line>            r.<span class=built_in>push_back</span>(nums[i]);</span><br><span class=line>            <span class=built_in>backtrace</span>(res,r,nums,i+<span class=number>1</span>);</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>subsets</span>(vector<<span class=keyword>int</span>>& nums) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=built_in>backtrace</span>(res,r,nums,<span class=number>0</span>);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>全排列</strong><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, vector<<span class=keyword>int</span>>& r, vector<<span class=keyword>int</span>>& nums,</span></span></span><br><span class=line><span class=params><span class=function>                   <span class=keyword>int</span> idx, vector<<span class=keyword>bool</span>>& used)</span> </span>{</span><br><span class=line>        <span class=comment>// 截至条件</span></span><br><span class=line>        <span class=keyword>if</span> (r.<span class=built_in>size</span>() == nums.<span class=built_in>size</span>()) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(r);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=comment>// 如果使用过</span></span><br><span class=line>            <span class=keyword>if</span> (used[i]) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            r.<span class=built_in>push_back</span>(nums[i]);</span><br><span class=line>            used[i] = <span class=literal>true</span>;</span><br><span class=line>            <span class=built_in>backtrace</span>(res, r, nums, i + <span class=number>1</span>, used);</span><br><span class=line>            used[i] = <span class=literal>false</span>;</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>permute</span>(vector<<span class=keyword>int</span>>& nums) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>used</span><span class=params>(sz)</span></span>;</span><br><span class=line>        <span class=built_in>backtrace</span>(res, r, nums, <span class=number>0</span>, used);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrack</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, vector<<span class=keyword>int</span>>& output, <span class=keyword>int</span> first, <span class=keyword>int</span> len)</span></span>{</span><br><span class=line>        <span class=comment>// 所有数都填完了</span></span><br><span class=line>        <span class=keyword>if</span> (first == len) {</span><br><span class=line>            res.<span class=built_in>emplace_back</span>(output);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = first; i < len; ++i) {</span><br><span class=line>            <span class=comment>// 动态维护数组</span></span><br><span class=line>            <span class=built_in>swap</span>(output[i], output[first]);</span><br><span class=line>            <span class=comment>// 继续递归填下一个数</span></span><br><span class=line>            <span class=built_in>backtrack</span>(res, output, first + <span class=number>1</span>, len);</span><br><span class=line>            <span class=comment>// 撤销操作</span></span><br><span class=line>            <span class=built_in>swap</span>(output[i], output[first]);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>permute</span>(vector<<span class=keyword>int</span>>& nums) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>> > res;</span><br><span class=line>        <span class=built_in>backtrack</span>(res, nums, <span class=number>0</span>, (<span class=keyword>int</span>)nums.<span class=built_in>size</span>());</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><p><strong>解数独</strong><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。<p>编写一个程序，通过填充空格来解决数独问题。<p>数独的解法需 <strong>遵循如下规则</strong>：<ol><li>数字 <code>1-9</code> 在每一行只能出现一次。<li>数字 <code>1-9</code> 在每一列只能出现一次。<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector&LTvector<<span class=keyword>char</span>>>& grid, <span class=keyword>int</span> row, <span class=keyword>int</span> col, <span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=comment>// 每行</span></span><br><span class=line>        <span class=keyword>int</span> m = grid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = grid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>            <span class=keyword>if</span> (grid[row][j] == <span class=string>'0'</span> + num) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 每列</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>if</span> (grid[i][col] == <span class=string>'0'</span> + num) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 格子内部</span></span><br><span class=line>        <span class=keyword>int</span> start_i = row / <span class=number>3</span> * <span class=number>3</span>;</span><br><span class=line>        <span class=keyword>int</span> start_j = col / <span class=number>3</span> * <span class=number>3</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = start_i; i < start_i + <span class=number>3</span>; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = start_j; j < start_j + <span class=number>3</span>; j++) {</span><br><span class=line>                <span class=keyword>if</span> (grid[i][j] == <span class=string>'0'</span> + num) {</span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>char</span>>>& board)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = board.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = board[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 截至条件</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>                <span class=keyword>if</span> (board[i][j] != <span class=string>'.'</span>) {</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>int</span> num = <span class=number>1</span>; num <= <span class=number>9</span>; num++) {</span><br><span class=line>                    <span class=keyword>if</span> (<span class=built_in>isValid</span>(board, i, j, num)) {</span><br><span class=line>                        board[i][j] = <span class=string>'0'</span> + num;</span><br><span class=line>                        <span class=keyword>if</span> (<span class=built_in>backtrace</span>(board)) {</span><br><span class=line>                            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>                        }</span><br><span class=line>                        board[i][j] = <span class=string>'.'</span>;</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>solveSudoku</span><span class=params>(vector&LTvector<<span class=keyword>char</span>>>& board)</span> </span>{</span><br><span class=line>        <span class=comment>// 回溯进行选择 然后判断是否合规</span></span><br><span class=line>        <span class=keyword>int</span> m = board.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = board[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=built_in>backtrace</span>(board);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>全排列II</strong><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, vector<<span class=keyword>int</span>>& r, vector<<span class=keyword>bool</span>>& used,</span></span></span><br><span class=line><span class=params><span class=function>                   vector<<span class=keyword>int</span>>& nums)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (r.<span class=built_in>size</span>() == nums.<span class=built_in>size</span>()) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(r);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < nums.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=comment>// 同一层如果使用过</span></span><br><span class=line>            <span class=keyword>if</span>(i><span class=number>0</span> && (nums[i] == nums[i<span class=number>-1</span>]) && !used[i<span class=number>-1</span>]) {</span><br><span class=line>                <span class=comment>// </span></span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=comment>// 同一树枝使用过</span></span><br><span class=line>            <span class=keyword>if</span> (used[i]) {</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            used[i] = <span class=literal>true</span>;</span><br><span class=line>            r.<span class=built_in>push_back</span>(nums[i]);</span><br><span class=line>            <span class=built_in>backtrace</span>(res, r, used, nums);</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>            used[i] = <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>permuteUnique</span>(vector<<span class=keyword>int</span>>& nums) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>used</span><span class=params>(nums.size())</span></span>;</span><br><span class=line>        <span class=built_in>sort</span>(nums.<span class=built_in>begin</span>(),nums.<span class=built_in>end</span>());</span><br><span class=line>        <span class=built_in>backtrace</span>(res, r, used, nums);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>N皇后</strong><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isValid</span><span class=params>(vector&LTstring>& board, <span class=keyword>int</span> i, <span class=keyword>int</span> j)</span> </span>{</span><br><span class=line>        <span class=comment>// 判断该位置能否放置</span></span><br><span class=line>        <span class=comment>// 同一行</span></span><br><span class=line>        <span class=keyword>int</span> n = board.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> col = <span class=number>0</span>; col < n; col++) {</span><br><span class=line>            <span class=keyword>if</span> (board[i][col] == <span class=string>'Q'</span>) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 同一列</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> row = <span class=number>0</span>; row < n; row++) {</span><br><span class=line>            <span class=keyword>if</span> (board[row][j] == <span class=string>'Q'</span>) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 斜线</span></span><br><span class=line>        <span class=comment>// 从右下到左上</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> row = i, col = j; row >= <span class=number>0</span> && col >= <span class=number>0</span>; col--, row--) {</span><br><span class=line>            <span class=keyword>if</span> (board[row][col] == <span class=string>'Q'</span>) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 从左下到右上</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> row = i, col = j; row >= <span class=number>0</span> && col < n; col++, row--) {</span><br><span class=line>            <span class=keyword>if</span> (board[row][col] == <span class=string>'Q'</span>) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector&LTstring>>& res, vector&LTstring>& board,</span></span></span><br><span class=line><span class=params><span class=function>                   <span class=keyword>int</span> row)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> n = board.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 结束条件 最后一行</span></span><br><span class=line>        <span class=keyword>if</span> (n == row) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(board);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 对于每一行</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>isValid</span>(board, row, j)) {</span><br><span class=line>                board[row][j] = <span class=string>'Q'</span>;</span><br><span class=line>                <span class=built_in>backtrace</span>(res, board, row + <span class=number>1</span>);</span><br><span class=line>                board[row][j] = <span class=string>'.'</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector&LTstring>> <span class=built_in>solveNQueens</span>(<span class=keyword>int</span> n) {</span><br><span class=line>        vector&LTvector&LTstring>> res;</span><br><span class=line>        <span class=function>string <span class=title>tmp</span><span class=params>(n, <span class=string>'.'</span>)</span></span>;</span><br><span class=line>        <span class=function>vector&LTstring> <span class=title>board</span><span class=params>(n, tmp)</span></span>;</span><br><span class=line>        <span class=built_in>backtrace</span>(res, board, <span class=number>0</span>);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>组合</strong><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。<p>你可以按 <strong>任何顺序</strong> 返回答案。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, <span class=keyword>int</span> n, vector<<span class=keyword>int</span>>& r, <span class=keyword>int</span> idx,</span></span></span><br><span class=line><span class=params><span class=function>                   <span class=keyword>int</span> cnt, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (cnt == k) {</span><br><span class=line>            res.<span class=built_in>push_back</span>(r);</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 剪枝</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = idx; cnt+n-i+<span class=number>1</span>>=k; i++) {</span><br><span class=line>            r.<span class=built_in>push_back</span>(i);</span><br><span class=line>            <span class=built_in>backtrace</span>(res, n, r, i + <span class=number>1</span>, cnt + <span class=number>1</span>, k);</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>combine</span>(<span class=keyword>int</span> n, <span class=keyword>int</span> k) {</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=built_in>backtrace</span>(res, n, r, <span class=number>1</span>, <span class=number>0</span>, k);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>子集II</strong><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。<p>在递归时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& res, vector<<span class=keyword>int</span>>& r, vector<<span class=keyword>int</span>>& nums,</span></span></span><br><span class=line><span class=params><span class=function>                   <span class=keyword>int</span> idx, vector<<span class=keyword>bool</span>>& used)</span> </span>{</span><br><span class=line>        <span class=comment>// 添加每个节点</span></span><br><span class=line>        res.<span class=built_in>push_back</span>(r);</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = idx; i < sz; i++) {</span><br><span class=line>            <span class=keyword>if</span> (i > <span class=number>0</span> && nums[i] == nums[i - <span class=number>1</span>] && used[i - <span class=number>1</span>] == <span class=literal>false</span>) {</span><br><span class=line>                <span class=comment>// 同一层选择相同值</span></span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            used[i] = <span class=literal>true</span>;</span><br><span class=line>            r.<span class=built_in>push_back</span>(nums[i]);</span><br><span class=line>            <span class=built_in>backtrace</span>(res, r, nums, i + <span class=number>1</span>, used);</span><br><span class=line>            r.<span class=built_in>pop_back</span>();</span><br><span class=line>            used[i] = <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>subsetsWithDup</span>(vector<<span class=keyword>int</span>>& nums) {</span><br><span class=line>        <span class=keyword>int</span> sz = nums.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>bool</span>> <span class=title>used</span><span class=params>(sz)</span></span>;</span><br><span class=line>        vector&LTvector<<span class=keyword>int</span>>> res;</span><br><span class=line>        vector<<span class=keyword>int</span>> r;</span><br><span class=line>        <span class=built_in>sort</span>(nums.<span class=built_in>begin</span>(),nums.<span class=built_in>end</span>());</span><br><span class=line>        <span class=built_in>backtrace</span>(res, r, nums, <span class=number>0</span>, used);</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>黄金矿工</strong><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 <code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。<p>为了使收益最大化，矿工需要按以下规则来开采黄金：<ul><li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<li>矿工每次可以从当前位置向上下左右四个方向走。<li>每个单元格只能被开采（进入）一次。<li><strong>不得开采</strong>（进入）黄金数目为 <code>0</code> 的单元格。<li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=keyword>int</span> res{};</span><br><span class=line>    vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>> dirs = {{<span class=number>0</span>, <span class=number>1</span>}, {<span class=number>0</span>, <span class=number>-1</span>}, {<span class=number>1</span>, <span class=number>0</span>}, {<span class=number>-1</span>, <span class=number>0</span>}};</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>backtrace</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& grid, <span class=keyword>int</span> x, <span class=keyword>int</span> y, <span class=keyword>int</span> val)</span> </span>{</span><br><span class=line>        res = <span class=built_in>max</span>(res, val);</span><br><span class=line>        <span class=comment>// 选择四个方向</span></span><br><span class=line>        <span class=keyword>int</span> m = grid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = grid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& dir : dirs) {</span><br><span class=line>            <span class=keyword>int</span> nx = x + dir.first;</span><br><span class=line>            <span class=keyword>int</span> ny = y + dir.second;</span><br><span class=line>            <span class=keyword>if</span> (nx < <span class=number>0</span> || nx >= m || ny < <span class=number>0</span> || ny >= n) {</span><br><span class=line>                <span class=comment>// 无法到达</span></span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (grid[nx][ny] == <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// 无法到达</span></span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>int</span> tmp = grid[nx][ny];</span><br><span class=line>            grid[nx][ny] = <span class=number>0</span>;</span><br><span class=line>            <span class=built_in>backtrace</span>(grid, nx, ny, val + tmp);</span><br><span class=line>            grid[nx][ny] = tmp;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getMaximumGold</span><span class=params>(vector&LTvector<<span class=keyword>int</span>>>& grid)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> m = grid.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>int</span> n = grid[<span class=number>0</span>].<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < n; j++) {</span><br><span class=line>                <span class=keyword>if</span> (grid[i][j] != <span class=number>0</span>) {</span><br><span class=line>                    <span class=keyword>int</span> val = grid[i][j];</span><br><span class=line>                    grid[i][j] = <span class=number>0</span>;</span><br><span class=line>                    <span class=built_in>backtrace</span>(grid, i, j, val);</span><br><span class=line>                    grid[i][j] = val;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>组合总和<strong>IV</strong><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素排列的个数。题目数据保证答案符合 32 位整数范围。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>combinationSum4</span><span class=params>(vector<<span class=keyword>int</span>>& nums, <span class=keyword>int</span> target)</span> </span>{</span><br><span class=line>        <span class=comment>// dp[i]表示总和为i的组合个数0</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>long</span> <span class=keyword>long</span>> <span class=title>dp</span><span class=params>(target + <span class=number>1</span>,<span class=number>0</span>)</span></span>;</span><br><span class=line>        <span class=built_in>sort</span>(nums.<span class=built_in>begin</span>(), nums.<span class=built_in>end</span>());</span><br><span class=line>        dp[<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= target; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>auto</span> n : nums) {</span><br><span class=line>                <span class=keyword>if</span> (n <= i && dp[i]+dp[i-n]<=INT_MAX) {</span><br><span class=line>                    <span class=comment>// 状态转移方程</span></span><br><span class=line>                    <span class=comment>// dp[i] += dp[i-n]</span></span><br><span class=line>                    dp[i] += dp[i - n];</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[target];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>回溯算法能解决如下问题：<ul><li>组合问题：N个数里面按一定规则找出k个数的集合<li>排列问题：N个数按一定规则全排列，有几种排列方式<li>切割问题：一个字符串按一定规则有几种切割方式<li>子集问题：一个N个数的集合里有多少符合条件的子集<li>棋盘问题：N皇后，解数独等等</ul><h1 id=有趣的题目><a class=headerlink href=#有趣的题目 title=有趣的题目></a>有趣的题目</h1><p><strong>求众数II</strong><p>给定一个大小为n的数组，找出其中所有出现次数超过n/3 次的元素。说明：要求算法的时间复杂度为O(n)，空间复杂度为O(1)。<h1 id=字符串模拟><a class=headerlink href=#字符串模拟 title=字符串模拟></a>字符串模拟</h1><p><strong>字符串模拟</strong>。要攻克它们，我建议你按这个<strong>分级练习路径</strong>来：<p>第一关：入门级（固定映射）<ul><li><strong>LC 13. 罗马数字转整数</strong>：练习基本的哈希映射。<li><strong>LC 12. 整数转罗马数字</strong>：练习贪心凑数思想。</ul><p>第二关：进阶级（带有进制逻辑）<ul><li><strong>LC 168. Excel表列名称</strong>：理解 26 进制与偏移量的关系（这是你之前刚看过的）。<li><strong>LC 171. Excel表列序号</strong>：反向模拟。</ul><p>第三关：大模拟级（细节控）<ul><li><strong>LC 8. 字符串转换整数 (atoi)</strong>：练习处理空格、正负号、边界溢出（面试高频）。<li><strong>LC 43. 字符串相乘</strong>：练习手写竖式计算，理解大数处理逻辑。</ul><p>第四关：终极 Boss<ul><li><strong>LC 273. 整数转换英文表示</strong>：这就是你现在的目标。<li><strong>LC 68. 文本左右对齐</strong>：字符串模拟题的“噩梦”</ul><p><strong>整数转换英文表示</strong><p>将非负整数 <code>num</code> 转换为其对应的英文表示。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    vector&LTstring> tens = {<span class=string>""</span>,      <span class=string>"Ten"</span>,   <span class=string>"Twenty"</span>,  <span class=string>"Thirty"</span>, <span class=string>"Forty"</span>,</span><br><span class=line>                           <span class=string>"Fifty"</span>, <span class=string>"Sixty"</span>, <span class=string>"Seventy"</span>, <span class=string>"Eighty"</span>, <span class=string>"Ninety"</span>};</span><br><span class=line>    vector&LTstring> singles = {<span class=string>""</span>,        <span class=string>"One"</span>,       <span class=string>"Two"</span>,      <span class=string>"Three"</span>,</span><br><span class=line>                              <span class=string>"Four"</span>,    <span class=string>"Five"</span>,      <span class=string>"Six"</span>,      <span class=string>"Seven"</span>,</span><br><span class=line>                              <span class=string>"Eight"</span>,   <span class=string>"Nine"</span>,      <span class=string>"Ten"</span>,      <span class=string>"Eleven"</span>,</span><br><span class=line>                              <span class=string>"Twelve"</span>,  <span class=string>"Thirteen"</span>,  <span class=string>"Fourteen"</span>, <span class=string>"Fifteen"</span>,</span><br><span class=line>                              <span class=string>"Sixteen"</span>, <span class=string>"Seventeen"</span>, <span class=string>"Eighteen"</span>, <span class=string>"Nineteen"</span>};</span><br><span class=line>    vector&LTstring> units = {<span class=string>""</span>, <span class=string>"Thousand"</span>, <span class=string>"Million"</span>, <span class=string>"Billion"</span>};</span><br><span class=line>    <span class=function>string <span class=title>helper</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=comment>// 小于1000</span></span><br><span class=line>        <span class=keyword>if</span> (num == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=string>""</span>;</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (num < <span class=number>20</span>) {</span><br><span class=line>            <span class=keyword>return</span> singles[num] + <span class=string>" "</span>;</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (num < <span class=number>100</span>) {</span><br><span class=line>            <span class=keyword>return</span> tens[num / <span class=number>10</span>] + <span class=string>" "</span> + <span class=built_in>helper</span>(num % <span class=number>10</span>);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>return</span> singles[num / <span class=number>100</span>] + <span class=string>" Hundred "</span> + <span class=built_in>helper</span>(num % <span class=number>100</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function>string <span class=title>numberToWords</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=comment>// 每个三个一份</span></span><br><span class=line>        <span class=keyword>if</span> (num == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=string>"Zero"</span>;</span><br><span class=line>        }</span><br><span class=line>        string res;</span><br><span class=line>        <span class=keyword>int</span> i{};</span><br><span class=line>        <span class=keyword>while</span> (num) {</span><br><span class=line>            <span class=keyword>if</span> (num % <span class=number>1000</span>) {</span><br><span class=line>                <span class=comment>// 处理当前这三位，并在后面加上单位</span></span><br><span class=line>                res = <span class=built_in>helper</span>(num % <span class=number>1000</span>) + units[i] + <span class=string>" "</span> + res;</span><br><span class=line>            }</span><br><span class=line>            num /= <span class=number>1000</span>;</span><br><span class=line>            i++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (!res.<span class=built_in>empty</span>() && res.<span class=built_in>back</span>() == <span class=string>' '</span>) {</span><br><span class=line>            res.<span class=built_in>pop_back</span>();</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>汉字数字转阿拉伯数字</strong><p>处理它的核心思路是：<strong>分权累加，遇“大单位”结算</strong>。<p><strong>核心逻辑：</strong><ol><li><p><strong>映射表</strong>：准备好数字（一:1）和单位（十:10, 百:100, 万:10000）。</p><li><p><strong>状态变量</strong>：</p> <ul><li><code>section_sum</code>: 当前小节（万以下）的累加和。<li><code>total_sum</code>: 最终的总和。<li><code>temp_val</code>: 当前读到的数字。</ul><li><p><strong>遍历规则</strong>：</p> <ul><li>读到<strong>数字</strong>：存入 <code>temp_val</code>。<li>读到<strong>小单位</strong>（十、百、千）：用 <code>temp_val</code> 乘以单位，加进 <code>section_sum</code>。<li>读到<strong>大单位</strong>（万、亿）：将 <code>section_sum</code> 加上 <code>temp_val</code> 后，整体乘以大单位，并入 <code>total_sum</code>，然后清空 <code>section_sum</code>。</ul> <p>汉字数字的逻辑是<strong>“权重累加”</strong>。核心在于区分：</p> <ul><li><strong>小单位</strong>（十、百、千）：仅修饰前一个数字。<li><strong>大单位</strong>（万、亿）：修饰前面整整一截数字。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunordered_map></span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>cnToAr</span><span class=params>(std::u16string s)</span> </span>{</span><br><span class=line>    std::unordered_map<<span class=keyword>char16_t</span>, <span class=keyword>int</span>> digits = {</span><br><span class=line>        {<span class=string>u'零'</span>, <span class=number>0</span>}, {<span class=string>u'一'</span>, <span class=number>1</span>}, {<span class=string>u'二'</span>, <span class=number>2</span>}, {<span class=string>u'三'</span>, <span class=number>3</span>}, {<span class=string>u'四'</span>, <span class=number>4</span>},</span><br><span class=line>        {<span class=string>u'五'</span>, <span class=number>5</span>}, {<span class=string>u'六'</span>, <span class=number>6</span>}, {<span class=string>u'七'</span>, <span class=number>7</span>}, {<span class=string>u'八'</span>, <span class=number>8</span>}, {<span class=string>u'九'</span>, <span class=number>9</span>}</span><br><span class=line>    };</span><br><span class=line>    std::unordered_map<<span class=keyword>char16_t</span>, <span class=keyword>long</span> <span class=keyword>long</span>> units = {</span><br><span class=line>        {<span class=string>u'十'</span>, <span class=number>10</span>}, {<span class=string>u'百'</span>, <span class=number>100</span>}, {<span class=string>u'千'</span>, <span class=number>1000</span>}, </span><br><span class=line>        {<span class=string>u'万'</span>, <span class=number>10000</span>}, {<span class=string>u'亿'</span>, <span class=number>100000000</span>}</span><br><span class=line>    };</span><br><span class=line></span><br><span class=line>    <span class=keyword>long</span> <span class=keyword>long</span> total = <span class=number>0</span>;   <span class=comment>// 总结果</span></span><br><span class=line>    <span class=keyword>long</span> <span class=keyword>long</span> section = <span class=number>0</span>; <span class=comment>// 当前“万”或“亿”之内的累加和</span></span><br><span class=line>    <span class=keyword>long</span> <span class=keyword>long</span> num = <span class=number>0</span>;     <span class=comment>// 暂存当前读到的数字</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>char16_t</span> ch : s) {</span><br><span class=line>        <span class=keyword>if</span> (digits.<span class=built_in>count</span>(ch)) {</span><br><span class=line>            num = digits[ch];</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (units.<span class=built_in>count</span>(ch)) {</span><br><span class=line>            <span class=keyword>long</span> <span class=keyword>long</span> unit = units[ch];</span><br><span class=line>            <span class=keyword>if</span> (unit == <span class=number>10000</span> || unit == <span class=number>100000000</span>) {</span><br><span class=line>                <span class=comment>// 遇到大单位，结算当前 section 并乘以权重</span></span><br><span class=line>                section = (section + num) * unit;</span><br><span class=line>                total += section;</span><br><span class=line>                section = <span class=number>0</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 遇到小单位（十百千）</span></span><br><span class=line>                <span class=keyword>if</span> (num == <span class=number>0</span> && unit == <span class=number>10</span>) num = <span class=number>1</span>; <span class=comment>// 处理“十二”开头的“十”</span></span><br><span class=line>                section += num * unit;</span><br><span class=line>            }</span><br><span class=line>            num = <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> total + section + num;</span><br><span class=line>}</span><br></pre></table></figure><p>处理亿万级别<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTunordered_map></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line>    <span class=comment>// 使用 static 成员，避免重复创建 map</span></span><br><span class=line>    <span class=keyword>inline</span> <span class=keyword>static</span> <span class=keyword>const</span> unordered_map<<span class=keyword>char16_t</span>, <span class=keyword>long</span> <span class=keyword>long</span>> vals = {</span><br><span class=line>        {<span class=string>u'零'</span>, <span class=number>0</span>}, {<span class=string>u'一'</span>, <span class=number>1</span>}, {<span class=string>u'二'</span>, <span class=number>2</span>}, {<span class=string>u'三'</span>, <span class=number>3</span>}, {<span class=string>u'四'</span>, <span class=number>4</span>},</span><br><span class=line>        {<span class=string>u'五'</span>, <span class=number>5</span>}, {<span class=string>u'六'</span>, <span class=number>6</span>}, {<span class=string>u'七'</span>, <span class=number>7</span>}, {<span class=string>u'八'</span>, <span class=number>8</span>}, {<span class=string>u'九'</span>, <span class=number>9</span>} <span class=comment>// 修正了“九”</span></span><br><span class=line>    };</span><br><span class=line>    <span class=keyword>inline</span> <span class=keyword>static</span> <span class=keyword>const</span> unordered_map<<span class=keyword>char16_t</span>, <span class=keyword>long</span> <span class=keyword>long</span>> units = {</span><br><span class=line>        {<span class=string>u'十'</span>, <span class=number>10</span>}, {<span class=string>u'百'</span>, <span class=number>100</span>}, {<span class=string>u'千'</span>, <span class=number>1000</span>}</span><br><span class=line>    };</span><br><span class=line>    <span class=keyword>inline</span> <span class=keyword>static</span> <span class=keyword>const</span> unordered_map<<span class=keyword>char16_t</span>, <span class=keyword>long</span> <span class=keyword>long</span>> segments = {</span><br><span class=line>        {<span class=string>u'万'</span>, <span class=number>10000</span>}, {<span class=string>u'亿'</span>, <span class=number>100000000</span>}</span><br><span class=line>    };</span><br><span class=line></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>chineseNumsToArabicNums</span><span class=params>(u16string s)</span> </span>{</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> res = <span class=number>0</span>;      <span class=comment>// 最终结果</span></span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> section = <span class=number>0</span>;  <span class=comment>// “万”或“亿”之内的段内和</span></span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> val = <span class=number>0</span>;      <span class=comment>// 当前数字</span></span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>char16_t</span> ch : s) {</span><br><span class=line>            <span class=keyword>if</span> (vals.<span class=built_in>count</span>(ch)) {</span><br><span class=line>                val = vals.<span class=built_in>at</span>(ch);</span><br><span class=line>            } </span><br><span class=line>            <span class=keyword>else</span> <span class=keyword>if</span> (units.<span class=built_in>count</span>(ch)) {</span><br><span class=line>                <span class=keyword>long</span> <span class=keyword>long</span> unit = units.<span class=built_in>at</span>(ch);</span><br><span class=line>                <span class=keyword>if</span> (val == <span class=number>0</span> && unit == <span class=number>10</span>) val = <span class=number>1</span>; <span class=comment>// 处理“十二”</span></span><br><span class=line>                section += val * unit;</span><br><span class=line>                val = <span class=number>0</span>;</span><br><span class=line>            } </span><br><span class=line>            <span class=keyword>else</span> <span class=keyword>if</span> (segments.<span class=built_in>count</span>(ch)) {</span><br><span class=line>                <span class=keyword>long</span> <span class=keyword>long</span> segUnit = segments.<span class=built_in>at</span>(ch);</span><br><span class=line>                <span class=comment>// 核心修正：section 加上当前的 val，再乘以万或亿</span></span><br><span class=line>                section = (section + val) * segUnit;</span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 处理“亿”和“万”的嵌套（如一亿万，虽然少见但逻辑要通）</span></span><br><span class=line>                <span class=keyword>if</span> (segUnit == <span class=number>100000000</span>) { </span><br><span class=line>                    res += section;</span><br><span class=line>                    section = <span class=number>0</span>;</span><br><span class=line>                } <span class=keyword>else</span> {</span><br><span class=line>                    <span class=comment>// 如果是万，先存在 section 里，可能后面还有亿</span></span><br><span class=line>                }</span><br><span class=line>                val = <span class=number>0</span>;</span><br><span class=line>            } </span><br><span class=line>            <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 处理零，通常不需要操作，只需重置 val 为 0 即可</span></span><br><span class=line>                val = <span class=number>0</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res + section + val;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>阿拉伯数字转汉字数字</strong><p>反过来的核心逻辑是<strong>“四位一组”</strong>。中国数字是每 4 位（一个“万”）进一级，而不是英文的每 3 位。<p><strong>处理重点：</strong><ul><li><strong>零的处理</strong>：中间连续的 0 只读一个“零”（如 1005 $\rightarrow$ 一千零五）。<li><strong>末尾的零</strong>：每组末尾的 0 不读（如 120 $\rightarrow$ 一百二十）。</ul><p><strong>整数转罗马数字</strong><p>罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：<ul><li>如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。<li>如果该值以 4 或 9 开头，使用 <strong>减法形式</strong>，表示从以下符号中减去一个符号，例如 4 是 5 (<code>V</code>) 减 1 (<code>I</code>): <code>IV</code> ，9 是 10 (<code>X</code>) 减 1 (<code>I</code>)：<code>IX</code>。仅使用以下减法形式：4 (<code>IV</code>)，9 (<code>IX</code>)，40 (<code>XL</code>)，90 (<code>XC</code>)，400 (<code>CD</code>) 和 900 (<code>CM</code>)。<li>只有 10 的次方（<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (<code>V</code>)，50 (<code>L</code>) 或 500 (<code>D</code>)。如果需要将符号附加4次，请使用 <strong>减法形式</strong>。</ul><p>给定一个整数，将其转换为罗马数字。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>intToRoman</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        vector&LTpair<<span class=keyword>int</span>, string>> vecs = {</span><br><span class=line>            {<span class=number>1000</span>, <span class=string>"M"</span>}, {<span class=number>900</span>, <span class=string>"CM"</span>}, {<span class=number>500</span>, <span class=string>"D"</span>}, {<span class=number>400</span>, <span class=string>"CD"</span>}, {<span class=number>100</span>, <span class=string>"C"</span>},</span><br><span class=line>            {<span class=number>90</span>, <span class=string>"XC"</span>},  {<span class=number>50</span>, <span class=string>"L"</span>},   {<span class=number>40</span>, <span class=string>"XL"</span>}, {<span class=number>10</span>, <span class=string>"X"</span>},   {<span class=number>9</span>, <span class=string>"IX"</span>},</span><br><span class=line>            {<span class=number>5</span>, <span class=string>"V"</span>},    {<span class=number>4</span>, <span class=string>"IV"</span>},   {<span class=number>1</span>, <span class=string>"I"</span>}};</span><br><span class=line>        string res;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& p : vecs) {</span><br><span class=line>            <span class=keyword>while</span> (num >= p.first) {</span><br><span class=line>                num -= p.first;</span><br><span class=line>                res += p.second;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (num == <span class=number>0</span>)</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>罗马字转整数</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>romanToInt</span><span class=params>(string s)</span> </span>{</span><br><span class=line>        unordered_map<<span class=keyword>char</span>, <span class=keyword>int</span>> umap = {</span><br><span class=line>            {<span class=string>'I'</span>, <span class=number>1</span>},   {<span class=string>'V'</span>, <span class=number>5</span>},   {<span class=string>'X'</span>, <span class=number>10</span>},  {<span class=string>'L'</span>, <span class=number>50</span>},</span><br><span class=line>            {<span class=string>'C'</span>, <span class=number>100</span>}, {<span class=string>'D'</span>, <span class=number>500</span>}, {<span class=string>'M'</span>, <span class=number>1000</span>},</span><br><span class=line>        };</span><br><span class=line>        <span class=comment>// 字符右边比左边大就是减否则+</span></span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (i < s.<span class=built_in>size</span>() - <span class=number>1</span> && umap[s[i]] < umap[s[i + <span class=number>1</span>]]) {</span><br><span class=line>                res -= umap[s[i]];</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                res += umap[s[i]];</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>Excel表列名称</strong><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。<p>例如：<figure class="highlight clean"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>A -> <span class=number>1</span></span><br><span class=line>B -> <span class=number>2</span></span><br><span class=line>C -> <span class=number>3</span></span><br><span class=line>...</span><br><span class=line>Z -> <span class=number>26</span></span><br><span class=line>AA -> <span class=number>27</span></span><br><span class=line>AB -> <span class=number>28</span> </span><br><span class=line>...</span><br></pre></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>convertToTitle</span><span class=params>(<span class=keyword>int</span> columnNumber)</span> </span>{</span><br><span class=line>        string res{};</span><br><span class=line>        <span class=keyword>while</span> (columnNumber) {</span><br><span class=line>            columnNumber--;</span><br><span class=line>            <span class=keyword>char</span> ch = (<span class=string>'A'</span> + (columnNumber % <span class=number>26</span>));</span><br><span class=line>            res = ch + res;</span><br><span class=line>            columnNumber /= <span class=number>26</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>表列序号</strong><p>给你一个字符串 <code>columnTitle</code> ，表示 Excel 表格中的列名称。返回 <em>该列名称对应的列序号</em> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>titleToNumber</span><span class=params>(string columnTitle)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>auto</span>& ch : columnTitle) {</span><br><span class=line>            res = res * <span class=number>26</span> + (ch - <span class=string>'A'</span> + <span class=number>1</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>字符串转换整数</strong><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数。<p>函数 <code>myAtoi(string s)</code> 的算法如下：<ol><li><strong>空格：</strong>读入字符串并丢弃无用的前导空格（<code>" "</code>）<li><strong>符号：</strong>检查下一个字符（假设还未到字符末尾）为 <code>'-'</code> 还是 <code>'+'</code>。如果两者都不存在，则假定结果为正。<li><strong>转换：</strong>通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。<li><strong>舍入：</strong>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被舍入为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被舍入为 <code>231 − 1</code> 。</ol><p>返回整数作为最终结果<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>myAtoi</span><span class=params>(string s)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> idx{};</span><br><span class=line>        <span class=keyword>while</span> (idx < s.<span class=built_in>size</span>()) {</span><br><span class=line>            <span class=keyword>if</span> (s[idx] == <span class=string>' '</span>) {</span><br><span class=line>                idx++;</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>bool</span> neg{};</span><br><span class=line>        <span class=keyword>if</span> (s[idx] == <span class=string>'-'</span>) {</span><br><span class=line>            idx++;</span><br><span class=line>            neg = <span class=literal>true</span>;</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (s[idx] == <span class=string>'+'</span>) {</span><br><span class=line>            idx++;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> num{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = idx; i < s.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=keyword>if</span> (s[i] < <span class=string>'0'</span> || s[i] > <span class=string>'9'</span>) {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (num > INT_MAX / <span class=number>10</span> ||</span><br><span class=line>                ((num == INT_MAX / <span class=number>10</span> )&&  (s[i]-<span class=string>'0'</span>) > INT_MAX % <span class=number>10</span>)) {</span><br><span class=line>                <span class=keyword>return</span> neg ? INT_MIN : INT_MAX;</span><br><span class=line>            }</span><br><span class=line>            num = num * <span class=number>10</span> + (s[i] - <span class=string>'0'</span>);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> neg ? -num : num;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>为什么溢出判断是 <code>INT_MAX / 10</code>？<p>这是这道题最容易写错的地方。<ul><li><code>INT_MAX</code> 是 <strong>2147483647</strong>。<li>假设当前 <code>res</code> 是 <strong>214748364</strong>：<ul><li>如果你下一位 <code>digit</code> 是 <strong>8</strong>，那么 <code>214748364 * 10 + 8</code> 就会变成 <strong>2147483648</strong>，这已经超过了 <code>INT_MAX</code>。<li>所以，如果 <code>res > 214748364</code>，或者 <code>res == 214748364</code> 且 <code>digit > 7</code>，我们就直接根据正负号返回最大值或最小值。</ul></ul><p><strong>字符串相乘</strong><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。<strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。<p>我们可以把乘法拆解为每一位的乘积。假设 <code>num1</code> 长度为 $m$，<code>num2</code> 长度为 $n$：<ol><li><p><strong>结果长度</strong>：$num1 \times num2$ 的积，其位数最多为 $m + n$（例如 $99 \times 99 = 9801$，$2+2=4$ 位）。</p><li><p><strong>下标映射（关键）</strong>：</p> <p>如果我们从右往左遍历：</p> <ul><li><code>num1[i]</code> 与 <code>num2[j]</code> 相乘的结果 <code>mul</code>。<li><code>mul</code> 的<strong>低位</strong>会累加到结果数组的下标 <code>i + j + 1</code>。<li><code>mul</code> 的<strong>高位（进位）</strong>会累加到结果数组的下标 <code>i + j</code>。</ul> <p><img alt=image-20260211173106800 data-src=https://cdn.sekyoro.top/imgs/image-20260211173106800.png></p></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTiostream></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTvector></span></span></span><br><span class=line><span class=meta>#<span class=meta-keyword>include</span> <span class=meta-string>&LTstring></span></span></span><br><span class=line></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>multiply</span><span class=params>(string num1, string num2)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (num1 == <span class=string>"0"</span> || num2 == <span class=string>"0"</span>) <span class=keyword>return</span> <span class=string>"0"</span>;</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> m = num1.<span class=built_in>size</span>(), n = num2.<span class=built_in>size</span>();</span><br><span class=line>        <span class=comment>// 结果最多有 m + n 位</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>res</span><span class=params>(m + n, <span class=number>0</span>)</span></span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 从后往前遍历进行乘法</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = m - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = n - <span class=number>1</span>; j >= <span class=number>0</span>; j--) {</span><br><span class=line>                <span class=comment>// 计算当前两位数字的乘积</span></span><br><span class=line>                <span class=keyword>int</span> mul = (num1[i] - <span class=string>'0'</span>) * (num2[j] - <span class=string>'0'</span>);</span><br><span class=line>                <span class=comment>// 加上原本由于之前的计算留在该位置上的进位</span></span><br><span class=line>                <span class=keyword>int</span> sum = mul + res[i + j + <span class=number>1</span>];</span><br><span class=line></span><br><span class=line>                <span class=comment>// 更新当前位和进位</span></span><br><span class=line>                res[i + j + <span class=number>1</span>] = sum % <span class=number>10</span>; <span class=comment>// 低位</span></span><br><span class=line>                res[i + j] += sum / <span class=number>10</span>;     <span class=comment>// 进位直接累加到前一位</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 转为字符串</span></span><br><span class=line>        string ans = <span class=string>""</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < res.<span class=built_in>size</span>(); i++) {</span><br><span class=line>            <span class=comment>// 跳过前导零</span></span><br><span class=line>            <span class=keyword>if</span> (ans.<span class=built_in>empty</span>() && res[i] == <span class=number>0</span>) <span class=keyword>continue</span>;</span><br><span class=line>            ans += <span class=built_in>to_string</span>(res[i]);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> ans.<span class=built_in>empty</span>() ? <span class=string>"0"</span> : ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>模拟竖式乘法<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>add</span><span class=params>(string num1, string num2)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> i = num1.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>int</span> j = num2.<span class=built_in>size</span>() - <span class=number>1</span>;</span><br><span class=line>        string r;</span><br><span class=line>        <span class=keyword>int</span> car{};</span><br><span class=line>        <span class=keyword>while</span> (i >= <span class=number>0</span> || j >= <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>int</span> val = ((i >= <span class=number>0</span>) ? (num1[i] - <span class=string>'0'</span>) : <span class=number>0</span>) +</span><br><span class=line>                      ((j >= <span class=number>0</span>) ? (num2[j] - <span class=string>'0'</span>) : <span class=number>0</span>) + car;</span><br><span class=line>            car = val / <span class=number>10</span>;</span><br><span class=line>            r = <span class=built_in>to_string</span>(val % <span class=number>10</span>) + r;</span><br><span class=line>            i--;</span><br><span class=line>            j--;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (car) {</span><br><span class=line>            r = <span class=string>"1"</span> + r;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> r;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>string <span class=title>multiply</span><span class=params>(string num1, string num2)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (num1 == <span class=string>"0"</span>|| num2 == <span class=string>"0"</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=string>"0"</span>;</span><br><span class=line>        }</span><br><span class=line>        string res = <span class=string>"0"</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = num1.<span class=built_in>size</span>() - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>char</span>& ch1 = num1[i];</span><br><span class=line>            string r{};</span><br><span class=line>            <span class=keyword>int</span> car{};</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = num2.<span class=built_in>size</span>() - <span class=number>1</span>; j >= <span class=number>0</span>; j--) {</span><br><span class=line>                <span class=keyword>char</span>& ch2 = num2[j];</span><br><span class=line>                <span class=keyword>int</span> val = car + (ch1 - <span class=string>'0'</span>) * (ch2 - <span class=string>'0'</span>);</span><br><span class=line>                car = val / <span class=number>10</span>;</span><br><span class=line>                val = val % <span class=number>10</span>;</span><br><span class=line>                r = <span class=built_in>to_string</span>(val) + r;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (car) {</span><br><span class=line>                r = <span class=built_in>to_string</span>(car) + r;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>int</span> offset = num1.<span class=built_in>size</span>() - <span class=number>1</span> - i;</span><br><span class=line>            r += <span class=built_in>string</span>(offset, <span class=string>'0'</span>);</span><br><span class=line>            res = <span class=built_in>add</span>(r, res);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>KMP</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>getNext</span><span class=params>(<span class=keyword>int</span>* next, <span class=keyword>const</span> string& s)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> j = <span class=number>-1</span>;</span><br><span class=line>        next[<span class=number>0</span>] = j;</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>1</span>; i < s.<span class=built_in>size</span>(); i++) { <span class=comment>// 注意i从1开始</span></span><br><span class=line>            <span class=keyword>while</span> (j >= <span class=number>0</span> && s[i] != s[j + <span class=number>1</span>]) { <span class=comment>// 前后缀不相同了</span></span><br><span class=line>                j = next[j]; <span class=comment>// 向前回退</span></span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (s[i] == s[j + <span class=number>1</span>]) { <span class=comment>// 找到相同的前后缀</span></span><br><span class=line>                j++;</span><br><span class=line>            }</span><br><span class=line>            next[i] = j; <span class=comment>// 将j（前缀的长度）赋给next[i]</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>strStr</span><span class=params>(string haystack, string needle)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (needle.<span class=built_in>size</span>() == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>        }</span><br><span class=line>		<span class=function>vector<<span class=keyword>int</span>> <span class=title>next</span><span class=params>(needle.size())</span></span>;</span><br><span class=line>		<span class=built_in>getNext</span>(&next[<span class=number>0</span>], needle);</span><br><span class=line>        <span class=keyword>int</span> j = <span class=number>-1</span>; <span class=comment>// // 因为next数组里记录的起始位置为-1</span></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < haystack.<span class=built_in>size</span>(); i++) { <span class=comment>// 注意i就从0开始</span></span><br><span class=line>            <span class=keyword>while</span>(j >= <span class=number>0</span> && haystack[i] != needle[j + <span class=number>1</span>]) { <span class=comment>// 不匹配</span></span><br><span class=line>                j = next[j]; <span class=comment>// j 寻找之前匹配的位置</span></span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (haystack[i] == needle[j + <span class=number>1</span>]) { <span class=comment>// 匹配，j和i同时向后移动</span></span><br><span class=line>                j++; <span class=comment>// i的增加在for循环里</span></span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (j == (needle.<span class=built_in>size</span>() - <span class=number>1</span>) ) { <span class=comment>// 文本串s里出现了模式串t</span></span><br><span class=line>                <span class=keyword>return</span> (i - needle.<span class=built_in>size</span>() + <span class=number>1</span>);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=number>-1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br></pre></table></figure><h1 id=链表><a class=headerlink href=#链表 title=链表></a>链表</h1><p>合并有序链表<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>mergeTwoLists</span><span class=params>(ListNode* list1, ListNode* list2)</span> </span>{</span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        ListNode* cur = dummy;</span><br><span class=line>        <span class=keyword>while</span> (list1 && list2) {</span><br><span class=line>            <span class=keyword>if</span> (list1->val < list2->val) {</span><br><span class=line>                cur->next = list1;</span><br><span class=line>                list1 = list1->next;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                cur->next = list2;</span><br><span class=line>                list2 = list2->next;</span><br><span class=line>            }</span><br><span class=line>            cur = cur->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (list1) {</span><br><span class=line>            cur->next = list1;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (list2) {</span><br><span class=line>            cur->next = list2;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>排序链表</strong><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。<p>归并排序链表可以分为三个步骤：<ol><li><strong>切分（Split）</strong>：使用<strong>快慢指针</strong>找到链表的中点，将链表断开成左右两部分。<li><strong>递归（Recursive Sort）</strong>：递归地对左右两部分进行排序。<li><strong>合并（Merge）</strong>：将两个有序的小链表合并成一个大的有序链表（类似于“合并两个有序链表”）。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>sortList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=comment>// 基准情况：如果链表为空或只有一个节点，直接返回</span></span><br><span class=line>        <span class=keyword>if</span> (!head || !head->next) <span class=keyword>return</span> head;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 1. 找到中点并断开</span></span><br><span class=line>        ListNode* mid = <span class=built_in>getMid</span>(head);</span><br><span class=line>        ListNode* rightHead = mid->next;</span><br><span class=line>        mid->next = <span class=literal>nullptr</span>; <span class=comment>// 【关键】切断连接</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 2. 递归排序左右两半</span></span><br><span class=line>        ListNode* left = <span class=built_in>sortList</span>(head);</span><br><span class=line>        ListNode* right = <span class=built_in>sortList</span>(rightHead);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3. 合并有序链表</span></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>merge</span>(left, right);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=comment>// 快慢指针找中点（返回前半部分的最后一个节点）</span></span><br><span class=line>    <span class=function>ListNode* <span class=title>getMid</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        ListNode *slow = head, *fast = head->next;</span><br><span class=line>        <span class=keyword>while</span> (fast && fast->next) {</span><br><span class=line>            slow = slow->next;</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> slow;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 合并两个有序链表</span></span><br><span class=line>    <span class=function>ListNode* <span class=title>merge</span><span class=params>(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class=line>        <span class=function>ListNode <span class=title>dummy</span><span class=params>(<span class=number>0</span>)</span></span>;</span><br><span class=line>        ListNode* tail = &dummy;</span><br><span class=line>        <span class=keyword>while</span> (l1 && l2) {</span><br><span class=line>            <span class=keyword>if</span> (l1->val < l2->val) {</span><br><span class=line>                tail->next = l1;</span><br><span class=line>                l1 = l1->next;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                tail->next = l2;</span><br><span class=line>                l2 = l2->next;</span><br><span class=line>            }</span><br><span class=line>            tail = tail->next;</span><br><span class=line>        }</span><br><span class=line>        tail->next = l1 ? l1 : l2;</span><br><span class=line>        <span class=keyword>return</span> dummy.next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>反转链表</strong><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function>ListNode* <span class=title>reverseNode</span><span class=params>(ListNode* node, ListNode* prev = <span class=literal>nullptr</span>)</span> </span>{</span><br><span class=line>     <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>         <span class=keyword>return</span> prev;</span><br><span class=line>     }</span><br><span class=line>     ListNode* n = node->next;</span><br><span class=line>     node->next = prev;</span><br><span class=line>     <span class=keyword>return</span> <span class=built_in>reverseNode</span>(n, node);</span><br><span class=line> }</span><br></pre></table></figure><p>反转链表II<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left <= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>       <span class=function>ListNode* <span class=title>reverseNode</span><span class=params>(ListNode* node, ListNode* prev = <span class=literal>nullptr</span>)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (node == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>return</span> prev;</span><br><span class=line>        }</span><br><span class=line>        ListNode* n = node->next;</span><br><span class=line>        node->next = prev;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>reverseNode</span>(n, node);</span><br><span class=line>    }</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseBetween</span><span class=params>(ListNode* head, <span class=keyword>int</span> left, <span class=keyword>int</span> right)</span> </span>{</span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        ListNode* cur = dummy;</span><br><span class=line>        left--;</span><br><span class=line>        <span class=keyword>while</span>(left--) {</span><br><span class=line>            cur = cur->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 找到左边节点的前一个节点</span></span><br><span class=line>        <span class=comment>// 方便进行链表头反转</span></span><br><span class=line>        ListNode* pre = cur;</span><br><span class=line>        cur = dummy;</span><br><span class=line>        <span class=keyword>while</span>(right--) {</span><br><span class=line>            cur = cur->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 找到右边节点</span></span><br><span class=line>        <span class=comment>// 方便找到下一个节点并设置nullptr</span></span><br><span class=line>        ListNode* rightNode = cur;</span><br><span class=line>        ListNode* tail = rightNode->next;</span><br><span class=line>        rightNode->next = <span class=literal>nullptr</span>;</span><br><span class=line>        ListNode* start = pre->next;</span><br><span class=line>        pre->next = <span class=built_in>reverseNode</span>(pre->next);</span><br><span class=line>        start->next = tail;</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><img alt=image-20260222222516630 data-src=https://files.seeusercontent.com/2026/02/22/9fuG/image-20260222222516630.png><p><a href=https://leetcode.cn/problems/remove-nth-node-from-end-of-list/ rel=noopener target=_blank>删除链表的倒数第 N 个结点</a><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>removeNthFromEnd</span><span class=params>(ListNode* head, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 双指针</span></span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        ListNode *slow = dummy, *fast = dummy;</span><br><span class=line>        <span class=keyword>while</span> (n--) {</span><br><span class=line>            fast = fast->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (fast && fast->next) {</span><br><span class=line>            fast = fast->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        slow->next = slow->next->next;</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>回文链表</strong><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>getPreMidNode</span><span class=params>(ListNode* node)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        ListNode *slow = node, *fast = node;</span><br><span class=line>        <span class=keyword>while</span> (fast->next && fast->next->next) {</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> slow;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseNode</span><span class=params>(ListNode* node, ListNode* prev = <span class=literal>nullptr</span>)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!node) {</span><br><span class=line>            <span class=keyword>return</span> prev;</span><br><span class=line>        }</span><br><span class=line>        ListNode* next_node = node->next;</span><br><span class=line>        node->next = prev;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>reverseNode</span>(next_node, node);</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isPalindrome</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=comment>// 中点</span></span><br><span class=line>        ListNode* preNode = <span class=built_in>getPreMidNode</span>(head);</span><br><span class=line>        ListNode* mid = preNode->next;</span><br><span class=line>        preNode->next = <span class=literal>nullptr</span>;</span><br><span class=line>        <span class=comment>// 反转</span></span><br><span class=line>        mid = <span class=built_in>reverseNode</span>(mid);</span><br><span class=line>        <span class=comment>// 对比</span></span><br><span class=line>        ListNode* cur = head;</span><br><span class=line>        <span class=keyword>while</span> (cur && mid) {</span><br><span class=line>            <span class=keyword>if</span> (cur->val != mid->val) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>            }</span><br><span class=line>            cur = cur->next;</span><br><span class=line>            mid = mid->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>链表的中间节点</strong><p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>middleNode</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        ListNode* slow = head,*fast = head;</span><br><span class=line>        <span class=keyword>while</span>(fast && fast->next) {</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> slow;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>删除链表的中间节点</strong><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>deleteMiddle</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        ListNode *slow = dummy, *fast = head;</span><br><span class=line>        <span class=keyword>while</span> (fast && fast->next) {</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        slow->next = slow->next->next;</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>重排链表</strong><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>L0</span> → L<span class=number>1</span> → … → Ln - <span class=number>1</span> → Ln</span><br></pre></table></figure><p>请将其重新排列后变为：<figure class="highlight apache"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attribute>L0</span> → Ln → L<span class=number>1</span> → Ln - <span class=number>1</span> → L<span class=number>2</span> → Ln - <span class=number>2</span> → …</span><br></pre></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<p>寻找链表中点 + 链表逆序 + 合并链表<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>reorderList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!head || !head->next || !head->next->next) <span class=keyword>return</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 1. 使用快慢指针找到中点</span></span><br><span class=line>        ListNode *slow = head, *fast = head;</span><br><span class=line>        <span class=keyword>while</span> (fast->next && fast->next->next) {</span><br><span class=line>            slow = slow->next;</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 2. 翻转后半部分链表 (从 slow->next 开始)</span></span><br><span class=line>        ListNode* mid = slow;</span><br><span class=line>        ListNode* l2 = mid->next;</span><br><span class=line>        mid->next = <span class=literal>nullptr</span>; <span class=comment>// 断开前半部分和后半部分</span></span><br><span class=line>        l2 = <span class=built_in>reverseList</span>(l2);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3. 交错合并两个链表 l1 和 l2</span></span><br><span class=line>        ListNode* l1 = head;</span><br><span class=line>        <span class=keyword>while</span> (l1 && l2) {</span><br><span class=line>            ListNode* next1 = l1->next;</span><br><span class=line>            ListNode* next2 = l2->next;</span><br><span class=line></span><br><span class=line>            l1->next = l2;</span><br><span class=line>            l2->next = next1;</span><br><span class=line></span><br><span class=line>            l1 = next1;</span><br><span class=line>            l2 = next2;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        ListNode* prev = <span class=literal>nullptr</span>;</span><br><span class=line>        ListNode* curr = head;</span><br><span class=line>        <span class=keyword>while</span> (curr) {</span><br><span class=line>            ListNode* nextTemp = curr->next;</span><br><span class=line>            curr->next = prev;</span><br><span class=line>            prev = curr;</span><br><span class=line>            curr = nextTemp;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> prev;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>环形链表</strong><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>hasCycle</span><span class=params>(ListNode *head)</span> </span>{</span><br><span class=line>        ListNode* slow = head,*fast = head;</span><br><span class=line>        <span class=keyword>while</span>(fast && fast->next) {</span><br><span class=line>            slow = slow->next;</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            <span class=keyword>if</span>(slow == fast) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>环形链表<strong>II</strong> 给定一个链表，返回链表开始入环的第一个节点。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode *<span class=title>detectCycle</span><span class=params>(ListNode *head)</span> </span>{</span><br><span class=line>        <span class=comment>// 先使用 </span></span><br><span class=line>        ListNode* slow= head,*fast = head;</span><br><span class=line>        <span class=keyword>while</span>(fast && fast->next) {</span><br><span class=line>            slow = slow->next;</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            <span class=keyword>if</span>(slow == fast) {</span><br><span class=line>                <span class=comment>// 快慢指针相遇 快指针领先一圈</span></span><br><span class=line>                <span class=comment>// a+b+(b+c) = 2*(a+b)</span></span><br><span class=line>                <span class=comment>//    => a = c</span></span><br><span class=line>                ListNode* cur = head;</span><br><span class=line>                <span class=keyword>while</span>(cur!=slow) {</span><br><span class=line>                    cur = cur->next;</span><br><span class=line>                    slow = slow->next;</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> cur;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line></span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>相交链表</strong><p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode *<span class=title>getIntersectionNode</span><span class=params>(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class=line>        ListNode* cur1 = headA,*cur2 = headB;</span><br><span class=line>        <span class=keyword>while</span>(cur1!=cur2) {</span><br><span class=line>            cur1 = (cur1 == <span class=literal>nullptr</span>)? headB:cur1->next;</span><br><span class=line>            cur2 = (cur2 == <span class=literal>nullptr</span>)? headA:cur2->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cur1;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>链表最大孪生和</strong><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 <strong>偶数</strong> 的链表中，对于 <code>0 <= i <= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <strong>0</strong> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。<ul><li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</ul><p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。<p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>midNode</span><span class=params>(ListNode* node)</span> </span>{</span><br><span class=line>        ListNode *slow = node, *fast = node;</span><br><span class=line>        <span class=keyword>while</span> (fast && fast->next) {</span><br><span class=line>            fast = fast->next->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> slow;</span><br><span class=line>    }</span><br><span class=line>    <span class=function>ListNode* <span class=title>revereNode</span><span class=params>(ListNode* node)</span> </span>{</span><br><span class=line>        ListNode* prev{};</span><br><span class=line>        <span class=keyword>while</span> (node) {</span><br><span class=line>            ListNode* n = node->next;</span><br><span class=line>            node->next = prev;</span><br><span class=line>            prev = node;</span><br><span class=line>            node = n;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> prev;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>pairSum</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=comment>// 获取中间节点</span></span><br><span class=line>        ListNode* mid = <span class=built_in>midNode</span>(head);</span><br><span class=line>        ListNode* l=<span class=built_in>revereNode</span>(mid);</span><br><span class=line>        <span class=keyword>int</span> max_val{INT_MIN};</span><br><span class=line>        <span class=keyword>while</span>(head && l) {</span><br><span class=line>            max_val = <span class=built_in>max</span>(max_val,head->val+l->val);</span><br><span class=line>            head = head->next;</span><br><span class=line>            l = l->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> max_val;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><a href=https://leetcode.cn/problems/reverse-nodes-in-k-group/ rel=noopener target=_blank>K 个一组翻转链表</a><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseKGroup</span><span class=params>(ListNode* head, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建一个虚拟头节点，方便处理</span></span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> <span class=built_in>ListNode</span>(<span class=number>0</span>);</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        </span><br><span class=line>        ListNode* prev = dummy;   <span class=comment>// 上一组的尾节点</span></span><br><span class=line>        ListNode* end = dummy;    <span class=comment>// 当前组的尾节点</span></span><br><span class=line>        </span><br><span class=line>        <span class=keyword>while</span> (end->next != <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=comment>// 找到当前组的尾节点</span></span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < k && end != <span class=literal>nullptr</span>; i++) {</span><br><span class=line>                end = end->next;</span><br><span class=line>            }</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 如果不足 k 个，直接结束</span></span><br><span class=line>            <span class=keyword>if</span> (end == <span class=literal>nullptr</span>) {</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 记录当前组的头节点和下一组的头节点</span></span><br><span class=line>            ListNode* start = prev->next;</span><br><span class=line>            ListNode* nextGroup = end->next;</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 断开当前组与后面的连接</span></span><br><span class=line>            end->next = <span class=literal>nullptr</span>;</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 翻转当前组</span></span><br><span class=line>            prev->next = <span class=built_in>reverseList</span>(start);</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 连接翻转后的链表</span></span><br><span class=line>            start->next = nextGroup;</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 更新 prev 和 end 为下一组的前一个节点</span></span><br><span class=line>            prev = start;</span><br><span class=line>            end = prev;</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        ListNode* result = dummy->next;</span><br><span class=line>        <span class=keyword>delete</span> dummy;</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=comment>// 翻转整个链表</span></span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        ListNode* prev = <span class=literal>nullptr</span>;</span><br><span class=line>        ListNode* curr = head;</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>while</span> (curr != <span class=literal>nullptr</span>) {</span><br><span class=line>            ListNode* next = curr->next;</span><br><span class=line>            curr->next = prev;</span><br><span class=line>            prev = curr;</span><br><span class=line>            curr = next;</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>return</span> prev;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>两两交换链表中的节点</strong><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>swapPairs</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (!head) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>nullptr</span>;</span><br><span class=line>        }</span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        ListNode* pre = dummy;</span><br><span class=line>        ListNode* next_node = head;</span><br><span class=line>        <span class=keyword>while</span> (next_node && next_node->next) {</span><br><span class=line>            <span class=comment>// 交换节点</span></span><br><span class=line>            ListNode* secondNode = next_node->next;</span><br><span class=line>            pre->next = secondNode;</span><br><span class=line>            next_node->next = secondNode->next;</span><br><span class=line>            secondNode->next = next_node;</span><br><span class=line></span><br><span class=line>            pre = next_node;</span><br><span class=line>            next_node = pre->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>递归,递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。<p><strong>递归过程</strong>：<ol><li>设当前头节点为 <code>head</code>，下一个节点为 <code>next</code>。<li><code>head</code> 的下一个节点应该是“后续所有节点两两交换后”的结果。<li><code>next</code> 的下一个节点指向当前的 <code>head</code>。<li>返回 <code>next</code> 作为这部分交换后的新头节点。</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>swapPairs</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (head == <span class=literal>nullptr</span> || head->next == <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>return</span> head;</span><br><span class=line>        }</span><br><span class=line>        ListNode* newHead = head->next;</span><br><span class=line>        head->next = <span class=built_in>swapPairs</span>(newHead->next);</span><br><span class=line>        newHead->next = head;</span><br><span class=line>        <span class=keyword>return</span> newHead;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>交换链表中的节点</strong><p>给你链表的头节点 <code>head</code> 和一个整数 <code>k</code> 。<p><strong>交换</strong> 链表正数第 <code>k</code> 个节点和倒数第 <code>k</code> 个节点的值后，返回链表的头节点（链表 <strong>从 1 开始索引</strong>）<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>swapNodes</span><span class=params>(ListNode* head, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=comment>// 快慢指针</span></span><br><span class=line>        ListNode *slow = head, *fast = head;</span><br><span class=line>        k--;</span><br><span class=line>        <span class=keyword>while</span> (k--) {</span><br><span class=line>            fast = fast->next;</span><br><span class=line>        }</span><br><span class=line>        ListNode* node1 = fast;</span><br><span class=line>        <span class=keyword>while</span>(fast && fast->next) {</span><br><span class=line>            fast = fast->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        ListNode* node2 = slow;</span><br><span class=line>        <span class=built_in>swap</span>(node1->val,node2->val);</span><br><span class=line>        <span class=keyword>return</span> head;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>翻转偶数长度组的节点</strong><p>给你一个链表的头节点 <code>head</code> 。<p>链表中的节点 <strong>按顺序</strong> 划分成若干 <strong>非空</strong> 组，这些非空组的长度构成一个自然数序列（<code>1, 2, 3, 4, ...</code>）。一个组的 <strong>长度</strong> 就是组中分配到的节点数目。换句话说：<ul><li>节点 <code>1</code> 分配给第一组<li>节点 <code>2</code> 和 <code>3</code> 分配给第二组<li>节点 <code>4</code>、<code>5</code> 和 <code>6</code> 分配给第三组，以此类推</ul><p>注意，最后一组的长度可能小于或者等于 <code>1 + 倒数第二组的长度</code> 。<p><strong>反转</strong> 每个 <strong>偶数</strong> 长度组中的节点，并返回修改后链表的头节点 <code>head</code><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseEvenLengthGroups</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=comment>// 创建虚拟头节点，简化边界处理</span></span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> <span class=built_in>ListNode</span>(<span class=number>0</span>);</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        </span><br><span class=line>        <span class=comment>// pre: 当前组的前一个节点（上一组的尾节点）</span></span><br><span class=line>        <span class=comment>// tail: 用于遍历找到当前组的尾节点</span></span><br><span class=line>        ListNode* pre = dummy;</span><br><span class=line>        ListNode* tail = dummy;</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>int</span> groupSize = <span class=number>1</span>;  <span class=comment>// 当前组期望的长度</span></span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 循环处理每一组</span></span><br><span class=line>        <span class=keyword>while</span> (tail->next != <span class=literal>nullptr</span>) {</span><br><span class=line>            <span class=keyword>int</span> actualCount = <span class=number>0</span>;  <span class=comment>// 当前组实际有多少个节点</span></span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 步骤1: 找到当前组的尾节点</span></span><br><span class=line>            <span class=comment>// 尝试走 groupSize 步，但可能走不完（最后一组）</span></span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < groupSize && tail->next != <span class=literal>nullptr</span>; i++) {</span><br><span class=line>                tail = tail->next;  <span class=comment>// 移动到当前组的下一个节点</span></span><br><span class=line>                actualCount++;      <span class=comment>// 统计实际节点数</span></span><br><span class=line>            }</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 步骤2: 判断是否需要反转</span></span><br><span class=line>            <span class=keyword>if</span> (actualCount % <span class=number>2</span> == <span class=number>0</span>) {</span><br><span class=line>                <span class=comment>// 情况A: 需要反转当前组（实际长度为偶数）</span></span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 记录当前组的起始节点和下一组的起始节点</span></span><br><span class=line>                ListNode* groupStart = pre->next;  <span class=comment>// 当前组的第一个节点</span></span><br><span class=line>                ListNode* nextGroupStart = tail->next;  <span class=comment>// 下一组的第一个节点</span></span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 断开当前组与下一组的连接，便于单独反转</span></span><br><span class=line>                tail->next = <span class=literal>nullptr</span>;</span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 反转当前组</span></span><br><span class=line>                ListNode* reversedGroupHead = <span class=built_in>reverseList</span>(groupStart);</span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 重新连接链表</span></span><br><span class=line>                pre->next = reversedGroupHead;  <span class=comment>// 上一组的尾连接反转后的组头</span></span><br><span class=line>                groupStart->next = nextGroupStart;  <span class=comment>// 反转前的组头（现在是组尾）连接下一组</span></span><br><span class=line>                </span><br><span class=line>                <span class=comment>// 更新 pre 和 tail 为当前组的尾节点（反转前的头节点）</span></span><br><span class=line>                pre = groupStart;</span><br><span class=line>                tail = groupStart;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 情况B: 不需要反转（实际长度为奇数）</span></span><br><span class=line>                <span class=comment>// 直接让 pre 指向当前组的尾节点，为下一组做准备</span></span><br><span class=line>                pre = tail;</span><br><span class=line>                <span class=comment>// tail 已经在正确位置，不需要移动</span></span><br><span class=line>            }</span><br><span class=line>            </span><br><span class=line>            <span class=comment>// 步骤3: 准备处理下一组，期望长度+1</span></span><br><span class=line>            groupSize++;</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        ListNode* result = dummy->next;</span><br><span class=line>        <span class=keyword>delete</span> dummy;  <span class=comment>// 清理虚拟头节点</span></span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=comment>// 反转链表的辅助函数</span></span><br><span class=line>    <span class=function>ListNode* <span class=title>reverseList</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        ListNode* prev = <span class=literal>nullptr</span>;  <span class=comment>// 前一个节点</span></span><br><span class=line>        ListNode* curr = head;     <span class=comment>// 当前节点</span></span><br><span class=line>        </span><br><span class=line>        <span class=keyword>while</span> (curr != <span class=literal>nullptr</span>) {</span><br><span class=line>            ListNode* nextNode = curr->next;  <span class=comment>// 保存下一个节点</span></span><br><span class=line>            curr->next = prev;                <span class=comment>// 反转指针方向</span></span><br><span class=line>            prev = curr;                      <span class=comment>// 前移prev</span></span><br><span class=line>            curr = nextNode;                  <span class=comment>// 前移curr</span></span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>return</span> prev;  <span class=comment>// 返回新的头节点</span></span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>删除链表的倒数第N个节点</strong><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>removeNthFromEnd</span><span class=params>(ListNode* head, <span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 双指针</span></span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> ListNode;</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        ListNode *slow = dummy, *fast = dummy;</span><br><span class=line>        <span class=keyword>while</span> (n--) {</span><br><span class=line>            fast = fast->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (fast && fast->next) {</span><br><span class=line>            fast = fast->next;</span><br><span class=line>            slow = slow->next;</span><br><span class=line>        }</span><br><span class=line>        slow->next = slow->next->next;</span><br><span class=line>        <span class=keyword>return</span> dummy->next;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><h1 id=数字-数论题目><a class=headerlink href=#数字-数论题目 title=数字/数论题目></a>数字/数论题目</h1><p>数根又称数字根（Digital root），是自然数的一种性质，每个自然数都有一个数根。<strong>对于给定的自然数，反复将各个位上的数字相加，直到结果为一位数，则该一位数即为原自然数的数根。</strong><p>计算数根的最直观的方法是模拟计算各位相加的过程，直到剩下的数字是一位数。利用自然数的性质，则能在 O(1) 的时间内计算数根。<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。<p>对 num 分类讨论：<p>num 不是 9 的倍数时，其数根即为 num 除以 9 的余数。<p>num 是 9 的倍数时：<p>如果 num=0，则其数根是 0；<p>如果 num>0，则各位相加的结果大于 0，其数根也大于 0，因此其数根是<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>addDigits</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> (num - <span class=number>1</span>) % <span class=number>9</span> + <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>丑数</strong><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和 <code>5</code> 的 <em>正</em> 整数。<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isUgly</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span>(n<=<span class=number>0</span>) <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        vector<<span class=keyword>int</span>> nums{<span class=number>2</span>,<span class=number>3</span>,<span class=number>5</span>};</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>auto</span>& num:nums) {</span><br><span class=line>            <span class=keyword>while</span>(n%num==<span class=number>0</span>) {</span><br><span class=line>                n/=num;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> n==<span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。<strong>丑数</strong> 就是质因子只包含 <code>2</code>、<code>3</code> 和 <code>5</code> 的正整数<p>我们要维护一个有序的丑数列表。假设我们已经有了前几个丑数，下一个丑数一定是：<ul><li>之前的某个丑数 $\times 2$<li>之前的某个丑数 $\times 3$<li>之前的某个丑数 $\times 5$</ul><p>为了保证列表的有序性，我们每次都选这三个乘积中<strong>最小</strong>的那一个。<p><strong>算法逻辑</strong>：<ol><li>定义数组 <code>dp</code>，<code>dp[i]</code> 表示第 $i+1$ 个丑数。初始化 <code>dp[0] = 1</code>。<li>定义三个指针 <code>p2, p3, p5</code>，初始都指向下标 <code>0</code>。<li>循环 $n-1$ 次：<ul><li>计算 <code>next2 = dp[p2] * 2</code>, <code>next3 = dp[p3] * 3</code>, <code>next5 = dp[p5] * 5</code>。<li>取三者最小值作为下一个丑数：<code>dp[i] = min(next2, next3, next5)</code>。<li><strong>关键点</strong>：哪个指针产生的最小值，就把哪个指针<strong>向后移一位</strong>。如果多个指针产生的乘积相同（比如 $2 \times 3 = 6$ 和 $3 \times 2 = 6$），则这些指针<strong>都要移动</strong>，以实现去重。</ul></ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=comment>// 生成最小质因数</span></span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>nthUglyNumber</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>dp</span><span class=params>(n)</span></span>;</span><br><span class=line>        dp[<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>int</span> n2{}, n3{}, n5{};</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < n; i++) {</span><br><span class=line>            <span class=keyword>int</span> p2 = dp[n2] * <span class=number>2</span>;</span><br><span class=line>            <span class=keyword>int</span> p3 = dp[n3] * <span class=number>3</span>;</span><br><span class=line>            <span class=keyword>int</span> p5 = dp[n5] * <span class=number>5</span>;</span><br><span class=line>            <span class=keyword>int</span> min_num = <span class=built_in>min</span>(<span class=built_in>min</span>(p2, p3), p5);</span><br><span class=line>            dp[i] = min_num;</span><br><span class=line>            <span class=keyword>if</span> (min_num == p2) {</span><br><span class=line>                n2++;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (min_num == p3) {</span><br><span class=line>                n3++;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (min_num == p5) {</span><br><span class=line>                n5++;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[n - <span class=number>1</span>];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>可以把寻找丑数的过程看作是<strong>合并三个有序链表</strong>：<ul><li>链表 1：$1\times2, 2\times2, 3\times2, 4\times2, 5\times2, \dots$<li>链表 2：$1\times3, 2\times3, 3\times3, 4\times3, 5\times3, \dots$<li>链表 3：$1\times5, 2\times5, 3\times5, 4\times5, 5\times5, \dots$</ul><p>由于我们每次都从这三个链表的“头部”取最小值，且“头部”的定义是由 <code>p2, p3, p5</code> 指向的 <code>dp</code> 元素决定的，因此我们能保证生成的 <code>dp</code> 数组是严格递增且不遗漏任何丑数的。<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong> 。<p>给你四个整数：<code>n</code> 、<code>a</code> 、<code>b</code> 、<code>c</code> ，请你设计一个算法来找出第 <code>n</code> 个丑数。 二分+容斥原理<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>gcd</span><span class=params>(<span class=keyword>int</span> a, <span class=keyword>int</span> b)</span> </span>{ <span class=keyword>return</span> b == <span class=number>0</span> ? a : <span class=built_in>gcd</span>(b, a % b); }</span><br><span class=line>    <span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>lcm</span><span class=params>(<span class=keyword>int</span> a, <span class=keyword>int</span> b)</span> </span>{ <span class=keyword>return</span> (<span class=keyword>long</span> <span class=keyword>long</span>)a / <span class=built_in>gcd</span>(a, b) * b; }</span><br><span class=line>    <span class=comment>// 计算[1, x]范围内丑数的个数（容斥原理）</span></span><br><span class=line>    <span class=function><span class=keyword>long</span> <span class=keyword>long</span> <span class=title>count</span><span class=params>(<span class=keyword>long</span> <span class=keyword>long</span> x, <span class=keyword>long</span> <span class=keyword>long</span> a, <span class=keyword>long</span> <span class=keyword>long</span> b, <span class=keyword>long</span> <span class=keyword>long</span> c, <span class=keyword>long</span> <span class=keyword>long</span> lcm_ab,</span></span></span><br><span class=line><span class=params><span class=function>                    <span class=keyword>long</span> <span class=keyword>long</span> lcm_ac, <span class=keyword>long</span> <span class=keyword>long</span> lcm_bc, <span class=keyword>long</span> <span class=keyword>long</span> lcm_abc)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> (x / a + x / b + x / c - x / lcm_ab - x / lcm_ac - x / lcm_bc +</span><br><span class=line>                x / lcm_abc);</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>nthUglyNumber</span><span class=params>(<span class=keyword>int</span> n, <span class=keyword>int</span> a, <span class=keyword>int</span> b, <span class=keyword>int</span> c)</span> </span>{</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> lcm_ab = <span class=built_in>lcm</span>(a, b);</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> lcm_ac = <span class=built_in>lcm</span>(a, c);</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> lcm_bc = <span class=built_in>lcm</span>(c, b);</span><br><span class=line>        <span class=keyword>long</span> <span class=keyword>long</span> lcm_abc = <span class=built_in>lcm</span>(lcm_ab, c);</span><br><span class=line>        <span class=keyword>int</span> left = <span class=number>1</span>, right = <span class=number>2e9</span>;</span><br><span class=line>        <span class=keyword>while</span> (left < right) {</span><br><span class=line>            <span class=keyword>int</span> mid = (right - left) / <span class=number>2</span> + left;</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>count</span>(mid, a, b, c, lcm_ab, lcm_ac, lcm_bc, lcm_abc) < n) {</span><br><span class=line>                left = mid + <span class=number>1</span>;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                right = mid;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> left;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code> ，返回第 <code>n</code> 个 <strong>超级丑数</strong> 。题目数据保证第 <code>n</code> 个 <strong>超级丑数</strong> 在 <strong>32-bit</strong> 带符号整数范围内。<p>定义数组 dp，其中 dp[i] 表示第 i 个超级丑数，第 n 个超级丑数即为 dp[n]。<p>由于最小的超级丑数是 1，因此 dp[1]=1。<p>如何得到其余的超级丑数呢？创建与数组 primes 相同长度的数组 pointers，表示下一个超级丑数是当前指针指向的超级丑数乘以对应的质因数。初始时，数组 pointers 的元素值都是 1。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>nthSuperUglyNumber</span><span class=params>(<span class=keyword>int</span> n, vector<<span class=keyword>int</span>>& primes)</span> </span>{</span><br><span class=line>        <span class=function>vector<<span class=keyword>long</span>> <span class=title>dp</span><span class=params>(n + <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>int</span> m = primes.<span class=built_in>size</span>();</span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>pointers</span><span class=params>(m, <span class=number>0</span>)</span></span>;</span><br><span class=line>        <span class=function>vector<<span class=keyword>long</span>> <span class=title>nums</span><span class=params>(m, <span class=number>1</span>)</span></span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>long</span> minNum = INT_MAX;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < m; j++) {</span><br><span class=line>                minNum = <span class=built_in>min</span>(minNum, nums[j]);</span><br><span class=line>            }</span><br><span class=line>            dp[i] = minNum;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j < m; j++) {</span><br><span class=line>                <span class=keyword>if</span> (nums[j] == minNum) {</span><br><span class=line>                    pointers[j]++;</span><br><span class=line>                    nums[j] = dp[pointers[j]] * primes[j];</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> dp[n];</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>快乐数</strong><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。<p><strong>「快乐数」</strong> 定义为：<ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code><p>快慢指针,通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。意识到实际有个链表，那么这个问题就<strong>可以转换为检测一个链表是否有环</strong>。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>getNext</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> res{};</span><br><span class=line>        <span class=keyword>while</span>(num) {</span><br><span class=line>            res += (num%<span class=number>10</span>)*(num%<span class=number>10</span>);</span><br><span class=line>            num/=<span class=number>10</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> res;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>isHappy</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> slowNum = n,fastNum = <span class=built_in>getNext</span>(n);</span><br><span class=line>        <span class=keyword>while</span>(fastNum!= <span class=number>1</span> && fastNum!=slowNum) {</span><br><span class=line>            slowNum = <span class=built_in>getNext</span>(slowNum);</span><br><span class=line>            fastNum = <span class=built_in>getNext</span>(<span class=built_in>getNext</span>(fastNum));</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> fastNum == <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>加一</strong><p>给定一个表示 <strong>大整数</strong> 的整数数组 <code>digits</code>，其中 <code>digits[i]</code> 是整数的第 <code>i</code> 位数字。这些数字按从左到右，从最高位到最低位排列。这个大整数不包含任何前导 <code>0</code>。将大整数加 1，并返回结果的数字数组。<p>只需要对数组 digits 进行一次逆序遍历，找出第一个不为 9 的元素，将其加一并将后续所有元素置零即可。如果 digits 中所有的元素均为 9，那么对应着「思路」部分的第三种情况，我们需要返回一个新的数组。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>plusOne</span><span class=params>(vector<<span class=keyword>int</span>>& digits)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz =digits.<span class=built_in>size</span>();</span><br><span class=line>        <span class=keyword>for</span>(<span class=keyword>int</span> i = sz<span class=number>-1</span>;i>=<span class=number>0</span>;i--) {</span><br><span class=line>            <span class=keyword>if</span>(digits[i]!=<span class=number>9</span>) {</span><br><span class=line>                digits[i] +=<span class=number>1</span>;</span><br><span class=line>                <span class=keyword>for</span>(<span class=keyword>int</span> j = i+<span class=number>1</span>;j&LTsz;j++) {</span><br><span class=line>                    digits[j] = <span class=number>0</span>;</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> digits;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>//全为9</span></span><br><span class=line>        <span class=function>vector<<span class=keyword>int</span>> <span class=title>ans</span><span class=params>(<span class=number>1</span>+sz)</span></span>;</span><br><span class=line>        ans[<span class=number>0</span>] = <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>给单链表加一</strong><p>给定一个用<strong>链表</strong>表示的非负整数， 然后将这个整数 <em>再加上 1</em> 。<p>这些数字的存储是这样的：最高位有效的数字位于链表的首位 <code>head</code> 。<p><strong>算法步骤</strong><ul><li><p>初始化哨兵节点为 ListNode(0) 并将其设置为新的头节点：sentinel.next = head。</p><li><p>找到最右边的不等于九的数字。</p><li>将该数字加一。<li>将所有后面的九都设为零。<li>如果哨兵节点被设置为1，则返回哨兵节点， 否则返回头 sentinel.next。</ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>ListNode* <span class=title>plusOne</span><span class=params>(ListNode* head)</span> </span>{</span><br><span class=line>        <span class=comment>// 找到最右边的非9数字</span></span><br><span class=line>        ListNode* dummy = <span class=keyword>new</span> <span class=built_in>ListNode</span>(<span class=number>0</span>);</span><br><span class=line>        dummy->next = head;</span><br><span class=line>        ListNode* flag = dummy;</span><br><span class=line>        <span class=keyword>while</span> (head) {</span><br><span class=line>            <span class=keyword>if</span> (head->val != <span class=number>9</span>) {</span><br><span class=line>                flag = head;</span><br><span class=line>            }</span><br><span class=line>            head = head->next;</span><br><span class=line>        }</span><br><span class=line>        flag->val += <span class=number>1</span>;</span><br><span class=line>        flag = flag->next;</span><br><span class=line>        <span class=comment>// 将后面的值置为0</span></span><br><span class=line>        <span class=keyword>while</span> (flag) {</span><br><span class=line>            flag->val = <span class=number>0</span>;</span><br><span class=line>            flag = flag->next;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> (dummy->val == <span class=number>0</span>)?dummy->next:dummy;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>数组形式整数加法</strong><p>整数的 <strong>数组形式</strong> <code>num</code> 是按照从左到右的顺序表示其数字的数组。<ul><li>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</ul><p>给定 <code>num</code> ，整数的 <strong>数组形式</strong> ，和整数 <code>k</code> ，返回 <em>整数 <code>num + k</code> 的 <strong>数组形式</strong></em> 。<p>任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>addToArrayForm</span><span class=params>(vector<<span class=keyword>int</span>>& num, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>int</span> sz = num.<span class=built_in>size</span>();</span><br><span class=line>        vector<<span class=keyword>int</span>> ans;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = sz - <span class=number>1</span>; i >= <span class=number>0</span>; i--) {</span><br><span class=line>            <span class=keyword>int</span> val = num[i] + k % <span class=number>10</span>;</span><br><span class=line>            k /= <span class=number>10</span>;</span><br><span class=line>            k += val / <span class=number>10</span>;</span><br><span class=line>            ans.<span class=built_in>push_back</span>(val % <span class=number>10</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>while</span> (k><span class=number>0</span>) {</span><br><span class=line>            ans.<span class=built_in>push_back</span>(k % <span class=number>10</span>);</span><br><span class=line>            k /= <span class=number>10</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>reverse</span>(ans.<span class=built_in>begin</span>(),ans.<span class=built_in>end</span>());</span><br><span class=line>        <span class=keyword>return</span> ans;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>将整数减少到零需要的最少操作数</strong><p>给你一个正整数 <code>n</code> ，你可以执行下述操作 <strong>任意</strong> 次：<ul><li><code>n</code> 加上或减去 <code>2</code> 的某个 <strong>幂</strong></ul><p>返回使 <code>n</code> 等于 <code>0</code> 需要执行的 <strong>最少</strong> 操作数。<p>如果 <code>x == 2i</code> 且其中 <code>i >= 0</code> ，则数字 <code>x</code> 是 <code>2</code> 的幂。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> memo;</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>dfs</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(num)) {</span><br><span class=line>            <span class=keyword>return</span> memo[num];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> ((num & <span class=number>1</span>) == <span class=number>0</span>) {</span><br><span class=line>            <span class=comment>// 00 10</span></span><br><span class=line>            memo[num] = <span class=built_in>dfs</span>(num >> <span class=number>1</span>);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 如果是奇数</span></span><br><span class=line>            <span class=comment>//  01 11</span></span><br><span class=line>            <span class=keyword>if</span> ((num & <span class=number>3</span>) == <span class=number>3</span>) {</span><br><span class=line>                memo[num] = <span class=number>1</span> + <span class=built_in>dfs</span>(num + <span class=number>1</span>);</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                memo[num] = <span class=number>1</span> + <span class=built_in>dfs</span>(num - <span class=number>1</span>);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> memo[num];</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>minOperations</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 如果是偶数 00 10 直接减去</span></span><br><span class=line>        memo[<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(n);</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    unordered_map<<span class=keyword>int</span>, <span class=keyword>int</span>> memo;</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>dfs</span><span class=params>(<span class=keyword>int</span> num)</span> </span>{</span><br><span class=line>        <span class=keyword>if</span> (memo.<span class=built_in>count</span>(num)) {</span><br><span class=line>            <span class=keyword>return</span> memo[num];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>int</span> r{};</span><br><span class=line>        <span class=keyword>if</span> ((num & (num - <span class=number>1</span>)) == <span class=number>0</span>) {</span><br><span class=line>            r = <span class=number>1</span>;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>int</span> lb = num & (-num);</span><br><span class=line>            r = <span class=number>1</span> + <span class=built_in>min</span>(<span class=built_in>dfs</span>(num + lb), <span class=built_in>dfs</span>(num - lb));</span><br><span class=line>        }</span><br><span class=line>        memo[num] = r;</span><br><span class=line>        <span class=keyword>return</span> r;</span><br><span class=line>    }</span><br><span class=line>    <span class=function><span class=keyword>int</span> <span class=title>minOperations</span><span class=params>(<span class=keyword>int</span> n)</span> </span>{</span><br><span class=line>        <span class=comment>// 如果是偶数 00 10 直接减去</span></span><br><span class=line>        memo[<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>dfs</span>(n);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><strong>计算字符串的数字和</strong><p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。<p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：<ol><li>将 <code>s</code> <strong>拆分</strong> 成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。<li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>"346"</code> 会替换为 <code>"13"</code> ，因为 <code>3 + 4 + 6 = 13</code> 。<li><strong>合并</strong> 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</ol><p>返回在完成所有轮操作后的 <code>s</code> 。<p>以模拟题目中的操作过程更新字符串 s，具体在每一轮操作中：<p>我们用字符串（或数组，视不同语言字符串的实现方式而确定）tmp 来维护该轮操作的结果。随后，我们遍历字符串 s，以每 k 个字符为一组，计算该组的数字和 val，并转化为字符串添加至 tmp 尾部。最终，我们将 s 更新为 tmp 所表示的字符串。<p>我们执行上述操作直到 s 的长度小于等于 k 为止，并最终返回 s 作为答案。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function>string <span class=title>digitSum</span><span class=params>(string s, <span class=keyword>int</span> k)</span> </span>{</span><br><span class=line>        <span class=keyword>while</span> (s.<span class=built_in>size</span>() > k) {</span><br><span class=line>            string ns;</span><br><span class=line>            <span class=keyword>int</span> sz = s.<span class=built_in>size</span>();</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i < s.<span class=built_in>size</span>(); i += k) {</span><br><span class=line>                <span class=keyword>int</span> num{};</span><br><span class=line>                <span class=keyword>for</span> (<span class=keyword>int</span> j = i; j < i + k && j < sz; j++) {</span><br><span class=line>                    num += (s[j] - <span class=string>'0'</span>);</span><br><span class=line>                }</span><br><span class=line>                ns += <span class=built_in>to_string</span>(num);</span><br><span class=line>            }</span><br><span class=line>            s = ns;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> s;</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p><img alt=image-20260221213221536 data-src=https://files.seeusercontent.com/2026/02/21/Sr6n/image-20260221213221536.png><h1 id=图算法><a class=headerlink href=#图算法 title=图算法></a>图算法</h1><h2 id=最短路径><a class=headerlink href=#最短路径 title=最短路径></a>最短路径</h2><p>最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。<h4 id=dijkstra><a class=headerlink href=#dijkstra title=dijkstra></a>dijkstra</h4><p>dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。<p>需要注意两点：<ul><li>dijkstra 算法可以同时求 起点到所有节点的最短路径<li>权值不能为负数</ul><p>dijkstra 算法是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。<strong>minDist数组 用来记录每一个节点距离源点的最小距离</strong>。<p><strong>dijkstra三部曲</strong>：<ol><li>第一步，选源点到哪个节点近且该节点未被访问过<li>第二步，该最近节点被标记访问过<li>第三步，更新非访问节点到源点的距离（即更新minDist数组）</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, m, p1, p2, val;</span><br><span class=line>    cin >> n >> m;</span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>grid</span>(n + <span class=number>1</span>, vector<<span class=keyword>int</span>>(n + <span class=number>1</span>, INT_MAX));</span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++){</span><br><span class=line>        cin >> p1 >> p2 >> val;</span><br><span class=line>        grid[p1][p2] = val;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>int</span> start = <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>int</span> end = n;</span><br><span class=line></span><br><span class=line>    <span class=function>std::vector<<span class=keyword>int</span>> <span class=title>minDist</span><span class=params>(n + <span class=number>1</span>, INT_MAX)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=function>std::vector<<span class=keyword>bool</span>> <span class=title>visited</span><span class=params>(n + <span class=number>1</span>, <span class=literal>false</span>)</span></span>;</span><br><span class=line></span><br><span class=line>    minDist[start] = <span class=number>0</span>; </span><br><span class=line></span><br><span class=line>    <span class=comment>//加上初始化</span></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>parent</span><span class=params>(n + <span class=number>1</span>, <span class=number>-1</span>)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> minVal = INT_MAX;</span><br><span class=line>        <span class=keyword>int</span> cur = <span class=number>1</span>;</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> v = <span class=number>1</span>; v <= n; ++v) {</span><br><span class=line>            <span class=keyword>if</span> (!visited[v] && minDist[v] < minVal) {</span><br><span class=line>                minVal = minDist[v];</span><br><span class=line>                cur = v;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        visited[cur] = <span class=literal>true</span>;</span><br><span class=line></span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> v = <span class=number>1</span>; v <= n; v++) {</span><br><span class=line>            <span class=keyword>if</span> (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {</span><br><span class=line>                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class=line>                parent[v] = cur; <span class=comment>// 记录边</span></span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 输出最短情况</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>        cout << parent[i] << <span class=string>"->"</span> << i << endl;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>邻接表存储+堆优化版本,其实思路依然是 dijkstra 三部曲：<ol><li>第一步，选源点到哪个节点近且该节点未被访问过<li>第二步，该最近节点被标记访问过<li>第三步，更新非访问节点到源点的距离（即更新minDist数组）</ol><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br></pre><td class=code><pre><span class=line><span class=comment>// 小顶堆</span></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>mycomparison</span> {</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=keyword>bool</span> <span class=title>operator</span><span class=params>()</span><span class=params>(<span class=keyword>const</span> pair<<span class=keyword>int</span>, <span class=keyword>int</span>>& lhs, <span class=keyword>const</span> pair<<span class=keyword>int</span>, <span class=keyword>int</span>>& rhs)</span> </span>{</span><br><span class=line>        <span class=keyword>return</span> lhs.second > rhs.second;</span><br><span class=line>    }</span><br><span class=line>};</span><br><span class=line><span class=comment>// 定义一个结构体来表示带权重的边</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Edge</span> {</span></span><br><span class=line>    <span class=keyword>int</span> to;  <span class=comment>// 邻接顶点</span></span><br><span class=line>    <span class=keyword>int</span> val; <span class=comment>// 边的权重</span></span><br><span class=line></span><br><span class=line>    <span class=built_in>Edge</span>(<span class=keyword>int</span> t, <span class=keyword>int</span> w): <span class=built_in>to</span>(t), <span class=built_in>val</span>(w) {}  <span class=comment>// 构造函数</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, m, p1, p2, val;</span><br><span class=line>    cin >> n >> m;</span><br><span class=line></span><br><span class=line>    vector&LTlist&LTEdge>> <span class=built_in>grid</span>(n + <span class=number>1</span>);</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++){</span><br><span class=line>        cin >> p1 >> p2 >> val; </span><br><span class=line>        <span class=comment>// p1 指向 p2，权值为 val</span></span><br><span class=line>        grid[p1].<span class=built_in>push_back</span>(<span class=built_in>Edge</span>(p2, val));</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>int</span> start = <span class=number>1</span>;  <span class=comment>// 起点</span></span><br><span class=line>    <span class=keyword>int</span> end = n;    <span class=comment>// 终点</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 存储从源点到每个节点的最短距离</span></span><br><span class=line>    <span class=function>std::vector<<span class=keyword>int</span>> <span class=title>minDist</span><span class=params>(n + <span class=number>1</span>, INT_MAX)</span></span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 记录顶点是否被访问过</span></span><br><span class=line>    <span class=function>std::vector<<span class=keyword>bool</span>> <span class=title>visited</span><span class=params>(n + <span class=number>1</span>, <span class=literal>false</span>)</span></span>; </span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 优先队列中存放 pair<节点，源点到该节点的权值></span></span><br><span class=line>    priority_queue&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>, vector&LTpair<<span class=keyword>int</span>, <span class=keyword>int</span>>>, mycomparison> pq;</span><br><span class=line></span><br><span class=line></span><br><span class=line>    <span class=comment>// 初始化队列，源点到源点的距离为0，所以初始为0</span></span><br><span class=line>    pq.<span class=built_in>push</span>(pair<<span class=keyword>int</span>, <span class=keyword>int</span>>(start, <span class=number>0</span>)); </span><br><span class=line>    </span><br><span class=line>    minDist[start] = <span class=number>0</span>;  <span class=comment>// 起始点到自身的距离为0</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (!pq.<span class=built_in>empty</span>()) {</span><br><span class=line>        <span class=comment>// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span></span><br><span class=line>        <span class=comment>// <节点， 源点到该节点的距离></span></span><br><span class=line>        pair<<span class=keyword>int</span>, <span class=keyword>int</span>> cur = pq.<span class=built_in>top</span>(); pq.<span class=built_in>pop</span>();</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (visited[cur.first]) <span class=keyword>continue</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 2. 第二步，该最近节点被标记访问过</span></span><br><span class=line>        visited[cur.first] = <span class=literal>true</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class=line>        <span class=keyword>for</span> (Edge edge : grid[cur.first]) { <span class=comment>// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class=line>            <span class=comment>// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class=line>            <span class=keyword>if</span> (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { <span class=comment>// 更新minDist</span></span><br><span class=line>                minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class=line>                pq.<span class=built_in>push</span>(pair<<span class=keyword>int</span>, <span class=keyword>int</span>>(edge.to, minDist[edge.to]));</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (minDist[end] == INT_MAX) cout << <span class=number>-1</span> << endl; <span class=comment>// 不能到达终点</span></span><br><span class=line>    <span class=keyword>else</span> cout << minDist[end] << endl; <span class=comment>// 到达终点最短路径</span></span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h4 id=Bellman-ford><a class=headerlink href=#Bellman-ford title=Bellman_ford></a>Bellman_ford</h4><p><strong>带负权值的单源最短路问题</strong>，Bellman_ford算法的核心思想是 对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路。<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, m, p1, p2, val;</span><br><span class=line>    cin >> n >> m;</span><br><span class=line></span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> grid;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 将所有边保存起来</span></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++){</span><br><span class=line>        cin >> p1 >> p2 >> val;</span><br><span class=line>        <span class=comment>// p1 指向 p2，权值为 val</span></span><br><span class=line>        grid.<span class=built_in>push_back</span>({p1, p2, val});</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>int</span> start = <span class=number>1</span>;  <span class=comment>// 起点</span></span><br><span class=line>    <span class=keyword>int</span> end = n;    <span class=comment>// 终点</span></span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>minDist</span><span class=params>(n + <span class=number>1</span> , INT_MAX)</span></span>;</span><br><span class=line>    minDist[start] = <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i < n; i++) { <span class=comment>// 对所有边 松弛 n-1 次</span></span><br><span class=line>        <span class=keyword>for</span> (vector<<span class=keyword>int</span>> &side : grid) { <span class=comment>// 每一次松弛，都是对所有边进行松弛</span></span><br><span class=line>            <span class=keyword>int</span> from = side[<span class=number>0</span>]; <span class=comment>// 边的出发点</span></span><br><span class=line>            <span class=keyword>int</span> to = side[<span class=number>1</span>]; <span class=comment>// 边的到达点</span></span><br><span class=line>            <span class=keyword>int</span> price = side[<span class=number>2</span>]; <span class=comment>// 边的权值</span></span><br><span class=line>            <span class=comment>// 松弛操作 </span></span><br><span class=line>            <span class=comment>// minDist[from] != INT_MAX 防止从未计算过的节点出发</span></span><br><span class=line>            <span class=keyword>if</span> (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) { </span><br><span class=line>                minDist[to] = minDist[from] + price;  </span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (minDist[end] == INT_MAX) cout << <span class=string>"unconnected"</span> << endl; <span class=comment>// 不能到达终点</span></span><br><span class=line>    <span class=keyword>else</span> cout << minDist[end] << endl; <span class=comment>// 到达终点最短路径</span></span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>队列优化版本(SPFA)<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>Edge</span> {</span> <span class=comment>//邻接表</span></span><br><span class=line>    <span class=keyword>int</span> to;  <span class=comment>// 链接的节点</span></span><br><span class=line>    <span class=keyword>int</span> val; <span class=comment>// 边的权重</span></span><br><span class=line></span><br><span class=line>    <span class=built_in>Edge</span>(<span class=keyword>int</span> t, <span class=keyword>int</span> w): <span class=built_in>to</span>(t), <span class=built_in>val</span>(w) {}  <span class=comment>// 构造函数</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, m, p1, p2, val;</span><br><span class=line>    cin >> n >> m;</span><br><span class=line></span><br><span class=line>    vector&LTlist&LTEdge>> <span class=built_in>grid</span>(n + <span class=number>1</span>); </span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>bool</span>> <span class=title>isInQueue</span><span class=params>(n + <span class=number>1</span>)</span></span>; <span class=comment>// 加入优化，已经在队里里的元素不用重复添加</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 将所有边保存起来</span></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++){</span><br><span class=line>        cin >> p1 >> p2 >> val;</span><br><span class=line>        <span class=comment>// p1 指向 p2，权值为 val</span></span><br><span class=line>        grid[p1].<span class=built_in>push_back</span>(<span class=built_in>Edge</span>(p2, val));</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>int</span> start = <span class=number>1</span>;  <span class=comment>// 起点</span></span><br><span class=line>    <span class=keyword>int</span> end = n;    <span class=comment>// 终点</span></span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>minDist</span><span class=params>(n + <span class=number>1</span> , INT_MAX)</span></span>;</span><br><span class=line>    minDist[start] = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    queue<<span class=keyword>int</span>> que;</span><br><span class=line>    que.<span class=built_in>push</span>(start); </span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (!que.<span class=built_in>empty</span>()) {</span><br><span class=line></span><br><span class=line>        <span class=keyword>int</span> node = que.<span class=built_in>front</span>(); que.<span class=built_in>pop</span>();</span><br><span class=line>        isInQueue[node] = <span class=literal>false</span>; <span class=comment>// 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入</span></span><br><span class=line>        <span class=keyword>for</span> (Edge edge : grid[node]) {</span><br><span class=line>            <span class=keyword>int</span> from = node;</span><br><span class=line>            <span class=keyword>int</span> to = edge.to;</span><br><span class=line>            <span class=keyword>int</span> value = edge.val;</span><br><span class=line>            <span class=keyword>if</span> (minDist[to] > minDist[from] + value) { <span class=comment>// 开始松弛</span></span><br><span class=line>                minDist[to] = minDist[from] + value; </span><br><span class=line>                <span class=keyword>if</span> (isInQueue[to] == <span class=literal>false</span>) { <span class=comment>// 已经在队列里的元素不用重复添加</span></span><br><span class=line>                    que.<span class=built_in>push</span>(to);</span><br><span class=line>                    isInQueue[to] = <span class=literal>true</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (minDist[end] == INT_MAX) cout << <span class=string>"unconnected"</span> << endl; <span class=comment>// 不能到达终点</span></span><br><span class=line>    <span class=keyword>else</span> cout << minDist[end] << endl; <span class=comment>// 到达终点最短路径</span></span><br><span class=line>}</span><br></pre></table></figure><p>判断负权回路：有负权回路的情况下，一直都会有更短的最短路，所以 松弛 第n次，minDist数组 也会发生改变再多松弛一次，看minDist数组 是否发生变化. 如果是SPFA，节点加入队列的次数超过了 n-1次 ，那么该图就一定有负权回路。<p>单源有限最短路径<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> src, dst,k ,p1, p2, val ,m , n;</span><br><span class=line>    </span><br><span class=line>    cin >> n >> m;</span><br><span class=line></span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> grid;</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++){</span><br><span class=line>        cin >> p1 >> p2 >> val;</span><br><span class=line>        grid.<span class=built_in>push_back</span>({p1, p2, val});</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    cin >> src >> dst >> k;</span><br><span class=line></span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>minDist</span><span class=params>(n + <span class=number>1</span> , INT_MAX)</span></span>;</span><br><span class=line>    minDist[src] = <span class=number>0</span>;</span><br><span class=line>    <span class=function>vector<<span class=keyword>int</span>> <span class=title>minDist_copy</span><span class=params>(n + <span class=number>1</span>)</span></span>; <span class=comment>// 用来记录上一次遍历的结果</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= k + <span class=number>1</span>; i++) {</span><br><span class=line>        minDist_copy = minDist; <span class=comment>// 获取上一次计算的结果</span></span><br><span class=line>        <span class=keyword>for</span> (vector<<span class=keyword>int</span>> &side : grid) {</span><br><span class=line>            <span class=keyword>int</span> from = side[<span class=number>0</span>];</span><br><span class=line>            <span class=keyword>int</span> to = side[<span class=number>1</span>];</span><br><span class=line>            <span class=keyword>int</span> price = side[<span class=number>2</span>];</span><br><span class=line>            <span class=comment>// 注意使用 minDist_copy 来计算 minDist </span></span><br><span class=line>            <span class=keyword>if</span> (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  </span><br><span class=line>                <span class=comment>//在每次计算 minDist 时候，要基于 对所有边上一次松弛的 minDist 数值才行，所以我们要记录上一次松弛的minDist</span></span><br><span class=line>                minDist[to] = minDist_copy[from] + price;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (minDist[dst] == INT_MAX) cout << <span class=string>"unreachable"</span> << endl; <span class=comment>// 不能到达终点</span></span><br><span class=line>    <span class=keyword>else</span> cout << minDist[dst] << endl; <span class=comment>// 到达终点最短路径</span></span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=Floyd算法><a class=headerlink href=#Floyd算法 title=Floyd算法></a>Floyd算法</h4><p>多源最短路算法<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=function><span class=keyword>int</span> <span class=title>main</span><span class=params>()</span> </span>{</span><br><span class=line>    <span class=keyword>int</span> n, m, p1, p2, val;</span><br><span class=line>    cin >> n >> m;</span><br><span class=line></span><br><span class=line>    vector&LTvector<<span class=keyword>int</span>>> <span class=built_in>grid</span>(n + <span class=number>1</span>, vector<<span class=keyword>int</span>>(n + <span class=number>1</span>, <span class=number>10005</span>));  <span class=comment>// 因为边的最大距离是10^4</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span>(<span class=keyword>int</span> i = <span class=number>0</span>; i < m; i++){</span><br><span class=line>        cin >> p1 >> p2 >> val;</span><br><span class=line>        grid[p1][p2] = val;</span><br><span class=line>        grid[p2][p1] = val; <span class=comment>// 注意这里是双向图</span></span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 开始 floyd</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> k = <span class=number>1</span>; k <= n; k++) {</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>1</span>; i <= n; i++) {</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>1</span>; j <= n; j++) {</span><br><span class=line>                grid[i][j] = <span class=built_in>min</span>(grid[i][j], grid[i][k] + grid[k][j]);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 输出结果</span></span><br><span class=line>    <span class=keyword>int</span> z, start, end;</span><br><span class=line>    cin >> z;</span><br><span class=line>    <span class=keyword>while</span> (z--) {</span><br><span class=line>        cin >> start >> end;</span><br><span class=line>        <span class=keyword>if</span> (grid[start][end] == <span class=number>10005</span>) cout << <span class=number>-1</span> << endl;</span><br><span class=line>        <span class=keyword>else</span> cout << grid[start][end] << endl;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p><strong>如果遇到单源且边为正数，直接Dijkstra</strong>。至于 <strong>使用朴素版还是 堆优化版 还是取决于图的稠密度</strong>.一般情况下，可以直接用堆优化版本。<p><strong>如果遇到单源边可为负数，直接 Bellman-Ford</strong>，同样 SPFA 还是 Bellman-Ford 取决于图的稠密度。一般情况下，直接用 SPFA。<p><strong>如果有负权回路，优先 Bellman-Ford</strong>， 如果是有限节点最短路 也优先 Bellman-Ford，理由是写代码比较方便。<p><strong>如果是遇到多源点求最短路，直接 Floyd</strong><h2 id=最小生成树><a class=headerlink href=#最小生成树 title=最小生成树></a>最小生成树</h2><p>最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。<h4 id=Prim><a class=headerlink href=#Prim title=Prim></a>Prim</h4><ol><li>第一步，选距离生成树最近节点<li>第二步，最近节点加入生成树<li>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</ol><h4 id=Kruskal><a class=headerlink href=#Kruskal title=Kruskal></a>Kruskal</h4><h2 id=拓扑排序><a class=headerlink href=#拓扑排序 title=拓扑排序></a>拓扑排序</h2><p>拓扑排序 是在图上的一种排序。概括来说，<strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序</strong>。<p>同样，拓扑排序也可以检测这个有向图 是否有环，即存在循环依赖的情况。拓扑排序的一些应用场景，例如：大学排课，文件下载依赖 等等。<p>只要记住如下两步拓扑排序的过程，代码就容易写了：<ol><li>找到入度为0 的节点，加入结果集<li>将该节点从图中移除</ol><h2 id=并查集><a class=headerlink href=#并查集 title=并查集></a>并查集</h2><p>并查集常用来解决连通性问题。<p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。<p>并查集主要有两个功能：<ul><li>将两个元素添加到一个集合中。<li>判断两个元素在不在同一个集合</ul><h1 id=融会贯通><a class=headerlink href=#融会贯通 title=融会贯通></a>融会贯通</h1><h2 id=循环位移问题><a class=headerlink href=#循环位移问题 title=循环位移问题></a>循环位移问题</h2><p>循环移位是一类非常经典的问题，通常涉及数组、字符串和链表等线性数据结构，包括移动问题、查找问题和包含问题等类型。虽然表现形式有很多，但其问题本质是相似的，只要理解其背后的算法思想，你便能掌握不同数据结构下的实现。<h1 id=通用解题模板><a class=headerlink href=#通用解题模板 title=通用解题模板></a>通用解题模板</h1><h1 id=解题技巧><a class=headerlink href=#解题技巧 title=解题技巧></a>解题技巧</h1><h1 id=常考题><a class=headerlink href=#常考题 title=常考题></a>常考题</h1><ol><li>数据结构之王：LRU 缓存 (Least Recently Used)</ol><p>这道题是<strong>大厂出镜率最高</strong>的题目，没有之一。它考察的不仅是算法，更是你对<strong>复合数据结构</strong>的理解。<ul><li><strong>题目内容</strong>：实现 <code>LRU缓存</code> 机制，要求 <code>get</code> 和 <code>put</code> 都是 $O(1)$ 时间复杂度。<li><strong>考察核心</strong>：<strong>哈希表 + 双向链表</strong>。<li><strong>面试官想看什么</strong>：你是否能手写双向链表的节点删除和插入，是否考虑了线程安全（如果是 Java 面试），以及对空间复杂度的权衡。</ul><ol><li>数组与指针：接雨水 (Trapping Rain Water)</ol><p>如果说 LRU 是数据结构的必考，那么接雨水就是<strong>双指针和单调栈</strong>的巅峰。<ul><li><strong>题目内容</strong>：给定 $n$ 个非负整数表示每个柱子的高度，计算按此排列的柱子，下雨能接多少雨水。<li><strong>考察核心</strong>：<strong>双指针</strong>、<strong>单调栈</strong>或<strong>动态规划</strong>。<li><strong>面试官想看什么</strong>：你能不能从 $O(n^2)$ 的暴力解法优化到 $O(n)$。这道题能一眼看出一个候选人的算法上限。</ul><ol><li>树论基础：二叉树的最近公共祖先 (LCA)</ol><p>二叉树题目中，LCA 是区分度最高的一道。<ul><li><strong>题目内容</strong>：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<li><strong>考察核心</strong>：<strong>递归</strong>、<strong>回溯</strong>。<li><strong>面试官想看什么</strong>：你对递归边界的控制能力。很多候选人能写出代码，但说不清为什么当 <code>left</code> 和 <code>right</code> 都不为空时，当前节点就是祖先。</ul><ol><li>排序与选择：前 K 个高频元素 / 第 K 大的数</ol><p>这类题目直接对应业务场景（如：排行榜、热门搜索）。<ul><li><strong>考察核心</strong>：<strong>堆排序 (Heap)</strong> 或 <strong>快速选择 (Quick Select)</strong>。<li><strong>面试官想看什么</strong>：如果你用 <code>sort</code> 函数，面试直接结束。他想看你能不能用 $O(n \log k)$ 甚至 $O(n)$ 的时间复杂度解决问题，并让你手写一个大顶堆或小顶堆。</ul><ol><li>动态规划入门与进阶：最长递增子序列 (LIS)</ol><p>大厂面试必有一道 DP（动态规划）。<ul><li><strong>考察核心</strong>：<strong>状态转移方程的推导</strong>。<li><strong>面试官想看什么</strong>：你能写出 $O(n^2)$ 的 DP 是及格，如果你能写出 $O(n \log n)$ 的“贪心 + 二分查找”解法，那就是优秀。</ul><p><strong>大厂面试高频分类表</strong><div class=table-container><table><thead><tr><th><strong>类别</strong><th><strong>必刷经典题</strong><th><strong>核心技巧</strong><tbody><tr><td><strong>链表</strong><td>反转链表、环形链表 II<td>快慢指针、虚拟头节点<tr><td><strong>二叉树</strong><td>层次遍历、锯齿形遍历<td>BFS、队列应用<tr><td><strong>字符串</strong><td>无重复字符的最长子串<td>滑动窗口、哈希表<tr><td><strong>排序</strong><td>手写快排、归并排序<td>分治法、递归<tr><td><strong>场景题</strong><td>100亿个URL去重、大文件排序<td>布隆过滤器、外部排序</table></div><h2 id=参考资料><a class=headerlink href=#参考资料 title=参考资料></a>参考资料</h2><ol><li><a href=https://noworneverev.github.io/leetcode_101 rel=noopener target=_blank>https://noworneverev.github.io/leetcode_101</a><li><a href=https://github.com/krahets/LeetCode-Book rel=noopener target=_blank>krahets/LeetCode-Book: 《剑指 Offer》《图解算法数据结构》《Krahets 笔面试精选 88 题》Python, Java, C++ 解题代码</a><li><a href=https://zhuanlan.zhihu.com/p/666207645 rel=noopener target=_blank> 一个标星25.5k⭐开源的编程题解仓库:leetcode - 知乎</a><li><a href=https://github.com/doocs/leetcode rel=noopener target=_blank>doocs/leetcode: 🔥LeetCode solutions in any programming language | 多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解</a><li><a href=https://docs.qq.com/doc/DUGxZZnNjVm53S2NF?no_promotion=1 rel=noopener target=_blank>算法</a><li><a href=https://github.com/krahets/hello-algo rel=noopener target=_blank>krahets/hello-algo</a><li><a href=https://github.com/halfrost/LeetCode-Go rel=noopener target=_blank>https://github.com/halfrost/LeetCode-Go</a><li><a href=https://labuladong.online/zh/ rel=noopener target=_blank>labuladong.online</a><li><a href=https://www.programmercarl.com/ rel=noopener target=_blank>代码随想录</a><li><a href=https://codetop.cc/ rel=noopener target=_blank>CodeTop 面试题目总结</a><li><a href=https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md rel=noopener target=_blank>codeforces-go/leetcode/SOLUTIONS.md at master · EndlessCheng/codeforces-go</a><li><a href=https://leetcode.cn/discuss/post/RvFUtj/ rel=noopener target=_blank>分享｜如何科学刷题？ - 讨论 - 力扣（LeetCode）</a></ol><link href=/css/spoiler.css rel=stylesheet><script async src=/js/spoiler.js></script></div><div><div><div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div class=popular-posts-header>相关文章</div><ul class=popular-posts><li class=popular-posts-item><div class=popular-posts-title><a href=\2026\01\25\线段树问题\ rel=bookmark>线段树问题</a></div></ul><div class=reward-container><div>感谢阅读.</div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Sekyoro 微信支付" src=/images/wechatpay.png><p>微信支付</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Sekyoro<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://www.sekyoro.top/2026/01/27/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/ title=经典算法题解析>https://www.sekyoro.top/2026/01/27/经典算法题解析/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=followme><p>欢迎关注我的其它发布渠道<div class=social-list><div class=social-item><a class=social-link href=/images/wxqrcode.png target=_blank> <span class=icon> <i class="fab fa-weixin"></i> </span> <span class=label>WeChat</span> </a></div><div class=social-item><a class=social-link href=/images/website.png target=_blank> <span class=icon> <i class="fa fa-user"></i> </span> <span class=label>PersonalWebsite</span> </a></div><div class=social-item><a class=social-link href=https://my-astro-git-main-drowning-in-codes.vercel.app target=_blank> <span class=icon> <i class="fas fa-share"></i> </span> <span class=label>杂鱼分享</span> </a></div><div class=social-item><a class=social-link href=/atom.xml target=_blank> <span class=icon> <i class="fa fa-rss"></i> </span> <span class=label>RSS</span> </a></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/%E7%AE%97%E6%B3%95/ rel=tag><i class="fa fa-tag"></i> 算法</a></div><div class=post-nav><div class=post-nav-item><a href=/2026/01/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E9%97%AE%E9%A2%98/ rel=prev title=线段树问题> <i class="fa fa-chevron-left"></i> 线段树问题 </a></div><div class=post-nav-item><a href=/2026/02/02/Java%E3%80%81JVM%E3%80%81%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6/ rel=next title=Java、JVM、并发进阶> Java、JVM、并发进阶 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><!-- 评论区 --><div class=comments><div data-id=city data-uid=MTAyMC81MzE5Ny8yOTY3Mg== id=lv-container></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><!-- canvas粒子时钟 --><div><canvas id=canvas style=width:60%;>当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();</script><!-- require APlayer --><link href=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css rel=stylesheet><script src=https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js></script><!-- require MetingJS --><script src=/js/meting-js.js></script><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90><span class=nav-number>1.</span> <span class=nav-text>复杂度分析</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90><span class=nav-number>1.1.</span> <span class=nav-text>递归算法的复杂度分析</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3><span class=nav-number>2.</span> <span class=nav-text>数学相关</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%8E%E5%85%AC%E5%9B%A0%E6%95%B0><span class=nav-number>2.1.</span> <span class=nav-text>公倍数与公因数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8E%A8%E5%AF%BC><span class=nav-number>2.1.1.</span> <span class=nav-text>推导</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%B4%A8%E6%95%B0><span class=nav-number>2.2.</span> <span class=nav-text>质数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%B4%A8%E6%95%B0><span class=nav-number>2.2.1.</span> <span class=nav-text>判断是否是质数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%A1%E7%AE%97-1-%E5%88%B0-n-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0><span class=nav-number>2.2.2.</span> <span class=nav-text>计算 $1$ 到 $n$ 之间的质数个数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E5%9B%A0%E6%95%B0%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E8%B4%A8%E5%9B%A0%E6%95%B0><span class=nav-number>2.2.3.</span> <span class=nav-text>一个数的因数与一个数的质因数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-%E5%88%B0-N-%E8%8C%83%E5%9B%B4%E5%86%85%E6%89%80%E6%9C%89%E6%95%B0%E7%9A%84%E8%B4%A8%E5%9B%A0%E6%95%B0><span class=nav-number>2.2.4.</span> <span class=nav-text>$1$ 到 $N$ 范围内所有数的质因数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-%E5%88%B0-N-%E8%8C%83%E5%9B%B4%E5%86%85%E6%89%80%E6%9C%89%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B4%A8%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0><span class=nav-number>2.2.5.</span> <span class=nav-text>$1$ 到 $N$ 范围内所有数的不同的质因数个数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-n%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B0%E7%9A%84%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0><span class=nav-number>2.2.6.</span> <span class=nav-text>1-n中所有数的因数个数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86><span class=nav-number>2.2.6.1.</span> <span class=nav-text>约数个数定理</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%9B%A0%E6%95%B0%E4%B9%8B%E5%92%8C><span class=nav-number>2.2.7.</span> <span class=nav-text>因数之和</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B8%B8%E8%A7%81%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%B1%9E%E6%80%A7%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F><span class=nav-number>2.2.7.1.</span> <span class=nav-text>常见质因数属性的递推公式</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2><span class=nav-number>2.3.</span> <span class=nav-text>进制转换</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%B8%83%E8%BF%9B%E5%88%B6><span class=nav-number>2.3.1.</span> <span class=nav-text>十进制转七进制</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9A%8F%E6%9C%BA%E5%8F%96%E6%A0%B7><span class=nav-number>2.4.</span> <span class=nav-text>随机取样</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%8D%E8%BF%90%E7%AE%97><span class=nav-number>2.4.1.</span> <span class=nav-text>位运算</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E6%80%A7><span class=nav-number>2.4.2.</span> <span class=nav-text>二进制特性</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%9B%9E%E6%96%87><span class=nav-number>3.</span> <span class=nav-text>回文</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2><span class=nav-number>3.0.1.</span> <span class=nav-text>验证回文串</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98><span class=nav-number>3.0.2.</span> <span class=nav-text>游戏问题</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86><span class=nav-number>3.1.</span> <span class=nav-text>广度优先和深度优先遍历</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98><span class=nav-number>3.1.1.</span> <span class=nav-text>岛屿问题</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8D%9A%E5%BC%88%E8%AE%BA%E9%A2%98%E7%9B%AE><span class=nav-number>3.1.1.1.</span> <span class=nav-text>博弈论题目</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8C%E5%88%86%E6%B3%95><span class=nav-number>3.2.</span> <span class=nav-text>二分法</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BD%8D%E8%BF%90%E7%AE%97-1><span class=nav-number>4.</span> <span class=nav-text>位运算</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%AE%BE%E8%AE%A1><span class=nav-number>5.</span> <span class=nav-text>设计</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8F%8C%E6%8C%87%E9%92%88><span class=nav-number>6.</span> <span class=nav-text>双指针</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92><span class=nav-number>7.</span> <span class=nav-text>动态规划</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#01%E8%83%8C%E5%8C%85%EF%BC%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%8C%E7%BB%84%E5%90%88%E6%8E%92%E5%88%97%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84><span class=nav-number>7.1.</span> <span class=nav-text>01背包，完全背包，组合排列与滚动数组</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%9A><span class=nav-number>7.1.0.1.</span> <span class=nav-text>回溯算法：</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98><span class=nav-number>8.</span> <span class=nav-text>博弈问题</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%88%86%E6%B2%BB%E6%B3%95><span class=nav-number>9.</span> <span class=nav-text>分治法</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%B4%AA%E5%BF%83><span class=nav-number>10.</span> <span class=nav-text>贪心</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%9B%9E%E6%BA%AF><span class=nav-number>11.</span> <span class=nav-text>回溯</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE><span class=nav-number>12.</span> <span class=nav-text>有趣的题目</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%8B%9F><span class=nav-number>13.</span> <span class=nav-text>字符串模拟</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%93%BE%E8%A1%A8><span class=nav-number>14.</span> <span class=nav-text>链表</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%95%B0%E5%AD%97-%E6%95%B0%E8%AE%BA%E9%A2%98%E7%9B%AE><span class=nav-number>15.</span> <span class=nav-text>数字/数论题目</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%9B%BE%E7%AE%97%E6%B3%95><span class=nav-number>16.</span> <span class=nav-text>图算法</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84><span class=nav-number>16.1.</span> <span class=nav-text>最短路径</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#dijkstra><span class=nav-number>16.1.0.1.</span> <span class=nav-text>dijkstra</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Bellman-ford><span class=nav-number>16.1.0.2.</span> <span class=nav-text>Bellman_ford</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Floyd%E7%AE%97%E6%B3%95><span class=nav-number>16.1.0.3.</span> <span class=nav-text>Floyd算法</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91><span class=nav-number>16.2.</span> <span class=nav-text>最小生成树</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#Prim><span class=nav-number>16.2.0.1.</span> <span class=nav-text>Prim</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Kruskal><span class=nav-number>16.2.0.2.</span> <span class=nav-text>Kruskal</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F><span class=nav-number>16.3.</span> <span class=nav-text>拓扑排序</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B9%B6%E6%9F%A5%E9%9B%86><span class=nav-number>16.4.</span> <span class=nav-text>并查集</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A><span class=nav-number>17.</span> <span class=nav-text>融会贯通</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BE%AA%E7%8E%AF%E4%BD%8D%E7%A7%BB%E9%97%AE%E9%A2%98><span class=nav-number>17.1.</span> <span class=nav-text>循环位移问题</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%80%9A%E7%94%A8%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF><span class=nav-number>18.</span> <span class=nav-text>通用解题模板</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7><span class=nav-number>19.</span> <span class=nav-text>解题技巧</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%B8%B8%E8%80%83%E9%A2%98><span class=nav-number>20.</span> <span class=nav-text>常考题</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99><span class=nav-number>20.1.</span> <span class=nav-text>参考资料</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Sekyoro class=site-author-image itemprop=image src=https://i.loli.net/2021/05/17/YqoavnXdGTpPO9R.jpg><p class=site-author-name itemprop=name>Sekyoro<div class=site-description itemprop=description>什么也无法舍弃的人，什么也做不了.</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>267</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>229</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="Personal Website → http://proanimer.com" href=http://proanimer.com/ rel=noopener target=_blank><i class="fab fa-internet-explorer fa-fw"></i>Personal Website</a> </span><span class=links-of-author-item> <a title="GitHub → https://github.com/drowning-in-codes" href=https://github.com/drowning-in-codes rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:bukalala174@gmail.com" href=mailto:bukalala174@gmail.com rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="wxPublicAccount → https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd" href=https://mp.weixin.qq.com/s?__biz=Mzg3ODY1MDkzMg==&mid=2247483770&idx=1&sn=fdf88faab01d5c219ac609570a21c9d6&chksm=cf113221f866bb373938cfca03cf095ff4fe1e4dc37d68ef5de4cd4876ee1260fca0c015a4d6&token=1096259873&lang=zh_CN#rd rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>wxPublicAccount</a> </span><span class=links-of-author-item> <a title="RSS → /atom.xml" href=/atom.xml><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class=links-of-author-item> <a title="CSDN → https://blog.csdn.net/aqwca" href=https://blog.csdn.net/aqwca rel=noopener target=_blank><i class="fa fa-handshake fa-fw"></i>CSDN</a> </span><span class=links-of-author-item> <a title="杂鱼分享 → https://my-astro-git-main-drowning-in-codes.vercel.app" href=https://my-astro-git-main-drowning-in-codes.vercel.app/ rel=noopener target=_blank><i class="fas fa-share fa-fw"></i>杂鱼分享</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=http://myqhs.top/ rel=noopener target=_blank title=http://myqhs.top/>myqhs</a><li class=links-of-blogroll-item><a href=https://www.lllomh.com/ rel=noopener target=_blank title=https://www.lllomh.com/>芈渡</a><li class=links-of-blogroll-item><a href=https://protool-ten.vercel.app/ rel=noopener target=_blank title=https://protool-ten.vercel.app/>protools</a></ul></div><div class="motion-element announcement"><div class=title></div><p class=content><p class=date></div></div><meting-js id=6856787487 order=random server=netease type=playlist> </meting-js><div class=widget-wrap><h3 class=widget-title style=margin:0>文章词云</h3><div class="widget tagcloud" id=myCanvasContainer><canvas height=250 id=resCanvas style=width:100% width=250><ul class=tag-list itemprop=keywords><li class=tag-list-item><a class=tag-list-link href=/tags/%E7%AE%97%E6%B3%95/ rel=tag>算法</a><span class=tag-list-count>2</span></ul></canvas></div></div><script id=clustrmaps src=https://clustrmaps.com/map_v2.js?d=xQdGTxqARTBiNIwX2aUban-ixkj2s6VaZQWo-aVCgY8&cl=ffffff&w=a></script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div><!-- 边栏 --></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© Wed Apr 08 2020 08:00:00 GMT+0800 (中国标准时间) – <span itemprop=copyrightYear>2026</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Sekyoro</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>4.7m</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>71:48</span></div><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>document.addEventListener("DOMContentLoaded", function() {
    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {
        var pvContainer = document.getElementById("busuanzi_container_site_pv");
        if (pvContainer && pvContainer.style.display !== "none") {
            var pvElement = document.getElementById("busuanzi_value_site_pv");
            if (pvElement) {
                pvElement.innerHTML = parseInt(pvElement.innerHTML) + countOffset;
                clearInterval(int);
            }
        }
        
        var uvContainer = document.getElementById("busuanzi_container_site_uv");
        if (uvContainer && window.getComputedStyle(uvContainer).display !== "none")
        {
            var uvElement = document.getElementById("busuanzi_value_site_uv");
            if (uvElement) {
                uvElement.innerHTML = parseInt(uvElement.innerHTML) + countOffset; // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    }
});</script><div><span id=timeDate>载入天数...</span><span id=times>载入时分秒...</span><script>var now = new Date();
    function createtime() {
        var grt= new Date("04/08/2021 20:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);</script></div><div class=busuanzi-count><script async data-pjax src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=https://cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js></script><script src=https://cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax',
	 '.widget-wrap'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
 
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
  
  // Reinitialize TagCanvas for tag cloud
  if (typeof TagCanvas !== 'undefined' && document.getElementById('resCanvas')) {
    try {
      TagCanvas.textFont = 'Trebuchet MS, Helvetica';
      TagCanvas.textColour = '#333';
      TagCanvas.textHeight = 20;
      TagCanvas.outlineColour = '#E2E1D1';
      TagCanvas.maxSpeed = 0.3;
      TagCanvas.freezeActive = true;
      TagCanvas.outlineMethod = 'block';
      TagCanvas.minBrightness = 0.2;
      TagCanvas.depth = 0.92;
      TagCanvas.pulsateTo = 0.6;
      TagCanvas.initial = [0.1,-0.1];
      TagCanvas.decel = 0.98;
      TagCanvas.reverse = true;
      TagCanvas.hideTags = false;
      TagCanvas.shadow = '#ccf';
      TagCanvas.shadowBlur = 3;
      TagCanvas.weight = false;
      TagCanvas.imageScale = null;
      TagCanvas.fadeIn = 1000;
      TagCanvas.clickToFront = 600;
      TagCanvas.lock = false;
      TagCanvas.Start('resCanvas');
      TagCanvas.tc['resCanvas'].Wheel(true);
    } catch(e) {
      console.log('TagCanvas initialization failed:', e);
    }
  }
});</script><script data-pjax>(function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();</script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js></script><script src=/js/algolia-search.js></script><script data-pjax>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script><div id=pjax><script charset=utf-8 defer src=/js/outdate.js></script></div><script charset=utf-8 defer src=/js/tagcanvas.js></script><script charset=utf-8 defer src=/js/tagcloud.js></script><script>NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});</script><script>var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });</script><script src=/js/src/activate-power-mode.min.js></script><script>POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);</script>